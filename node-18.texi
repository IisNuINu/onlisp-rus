@node 18 Destructuring, 19 A Query Compiler, 17 Read-Macros, Top
@comment  node-name,  next,  previous,  up
@chapter 18 Деконструкция
@cindex 18 Destructuring

Деконструкция это обобщение присваивания. Операторы setq и setf выполняют
присванивание для отдельных переменных. Деконструкция сочетает в себе присванивание
с доступом: вместо того, чтобы давать единственную переменную в качестве первого
аргумента, мы дает образец переменных, каждому из которых присваивается значение,
встречающееся в соответствующей позиции в некоторой структуре.

@menu
* 18-1 Destructuring on Lists::  
* 18-2 Other Structures::       
* 18-3 Reference::              
* 18-4 Matching::               
@end menu

@node 18-1 Destructuring on Lists, 18-2 Other Structures, 18 Destructuring, 18 Destructuring
@comment  node-name,  next,  previous,  up
@section 18-1 Деконструкция Списков.
@cindex 18-1 Destructuring on Lists

Начиная с CLTL2, Common Lisp включает новый макроса называемый destructuring-bind.
Этот макроса был кратко представлен в главе 7. Здесь мы рассмотрим его более подробно.
Предположим, что lst является списком из трех элементов, и мы хотим связать x с первым
элементом, y со вторым, и z с третьим. В незрелом CLTL1 Common Lisp, мы бы должны были
сказать:

@lisp
(let ((x (first lst))
        (y (second lst))
        (z (third lst)))
  ...)
@end lisp

С новым макросом весто этого мы можем сказать:

@lisp
(destructuring-bind (x y z) lst
  ...)
@end lisp

что не только короче, но и понятнее. Читатели понимают визуальные подсказки быстрее,
чем текстовые. В последнем примере нам сразу показывают связь между x, y и z; а в первом
случае, мы должны делать вывод об этом.

Если такой простой случай проясняется с помощью деконструкции, представьте себе
улучшение ясности более сложных. Первый аргумент в destructuring-bind
может быть произвольно сложным деревом. Представьте

@lisp
(destructuring-bind ((first last) (month day year) . notes)
                            birthday
  ...)
@end lisp

будет записано с использованием let и функций доступа к списку. Что поднимает еще
один аргумент: деконструкция облегчает написание программ, а также облегчает их
чтение.

Деконструкция существовала и в CLTL1 Common Lisp. Если шаблоны в примерах выше
выглядят знакомо, это потому, что они имеют ту же форму, что и списки парамемтров
макросов. Фактически, destructuring-bind это код, используемый для разбора списка
аргументов макроса, теперь предоставляемый отдельно. Вы можете положить что нибудь в
шабон, который вы бы представили в виде списка параметров макроса, за одним 
незначительным исключением(ключевого слова &environment).

Установление массовых привязок является привлекательной идеей. Следующие разделы
описывают несколько вариаций на эту тему.

@node 18-2 Other Structures, 18-3 Reference, 18-1 Destructuring on Lists, 18 Destructuring
@comment  node-name,  next,  previous,  up
@section 18-2 Другие Структуры
@cindex 18-2 Other Structures

Нет причин ограничивать деконструкцию списками. Любой сложный объект является
кандидатом для этого. В этом разделе показано, как писать макросы подобные
destructuring-bind для других видов объектов.

Следующим естественным шагом является обработка в целом последовательностей. Рисунок 18-1
содержит макрос называемый dbind, который напоминает destructuring-bind, но обрабатывающий
любой вид последовательностей. Второй аргумент может быть списком, вектором, или любой их
комбинацией:

@example
> (dbind (a b c) #(1 2 3)
        (list a b c))
(123)
> (dbind (a (b c) d) '( 1 #(2 3) 4)
        (list abcd))
(1234)
> (dbind (a (b . c) &rest d) '(1 "fribble" 2 3 4)
        (list abcd))
(1 #\f "ribble" (2 3 4))
@end example

@cartouche
@lisp
 (defmacro dbind (pat seq &body body)
       (let ((gseq (gensym)))
        `(let ((,gseq ,seq))
           ,(dbind-ex (destruc pat gseq #'atom) body))))

 (defun destruc (pat seq &optional (atom? #'atom) (n 0))
       (if (null pat)
          nil
          (let ((rest (cond ((funcall atom? pat) pat)
                                ((eq (car pat) '&rest) (cadr pat))
                                ((eq (car pat) '&body) (cadr pat))
                                (t nil))))
           (if rest
                 `((,rest (subseq ,seq ,n)))
                 (let ((p (car pat))
                         (rec (destruc (cdr pat) seq atom? (1+ n))))
                  (if (funcall atom? p)
                         (cons `(,p (elt ,seq ,n))
                               rec)
                         (let ((var (gensym)))
                           (cons (cons `(,var (elt ,seq ,n))
                                         (destruc p var atom?))
                                 rec))))))))

 (defun dbind-ex (binds body)
       (if (null binds)
          `(progn ,@@body)
          `(let ,(mapcar #'(lambda (b)
                                 (if (consp (car b))
                                       (car b)
                                       b))
                            binds)
            ,(dbind-ex (mapcan #'(lambda (b)
                                         (if (consp (car b))
                                              (cdr b)))
                                    binds)
                           body))))
@end lisp

             Рисунок 18-1: Операции деконструкции обобщенной последовательности.
@end cartouche

Макрос чтения #( для представления векторов, и #\ для представления символьных знаков.
Поскольку "abc" = #(#\a #\b #\c), первым элементом "fribble" является знак #\f. Для
простоты, dbind поддерживает только ключевые слова &rest и &body
keywords.

По сравнению с большинством макросов, dbind большой. Стоит поучиться реализации
данного макроса, не только для того чтобы понять как он работает, но и потому
что он воплощает главный урок о Lisp программировании. Как уже упоминалось в
разделе 3-4, программы Lisp могут быть написаны так, чтобы их легко было проверять.
В большинстве кода, мы должны сбалансировать это желание с необходимостью достижения
высокой скорости. К счастью, как объяснил Раздел 7-8, скорость не так важна в
коде расширителя. При написании кода, который генерирует расширение макроса, мы
можем облегчить себе жизнь. Расширение dbind создает две функции, destruc и dbind-ex.
Возможно, их обе объединить в одну функцию, которая сделала бы все за один проход.
Но зачем? А две раздельные функции, легче тестировать. Зачем обменивать это преимущество
на скорость, которая нам не нужна?

Первая функция destruc, обходит шаблон и связывает каждую переменную с расположением
соответствующего объекта во время выполнения:

@example
> (destruc '(a b c) 'seq #'atom)
((A (ELT SEQ 0)) (B (ELT SEQ 1)) (C (ELT SEQ 2)))
@end example

Необязательный третий аргумент - это предикат используемый для отделения струкутры
шаблона от содержимого шаблона.

Чтобы сделать доступ более эффективным, к каждой подпоследовательности будет привязана
новая (gensym) переменная:

@example
> (destruc '(a (b . c) &rest d) 'seq)
((A (ELT SEQ 0))
 ((#:G2 (ELT SEQ 1)) (B (ELT #:G2 0)) (C (SUBSEQ #:G2 1)))
 (D (SUBSEQ SEQ 2)))
@end example

Вывод destruc передается в dbind-ex, который генерирует большую часть расширения
макроса. Он переводит дерево созданное destruc в ряд вложенных let:

@example
> (dbind-ex (destruc '(a (b . c) &rest d) 'seq) '(body))
(LET ((A (ELT SEQ 0))
          (#:G4 (ELT SEQ 1))
          (D (SUBSEQ SEQ 2)))
  (LET ((B (ELT #:G4 0))
             (C (SUBSEQ #:G4 1)))
        (PROGN BODY)))
@end example

@cartouche
@lisp
 (defmacro with-matrix (pats ar &body body)
       (let ((gar (gensym)))
         `(let ((,gar ,ar))
             (let ,(let ((row -1))
                        (mapcan
                           #'(lambda (pat)
                                (incf row)
                                (setq col -1)
                                (mapcar #'(lambda (p)
                                                `(,p (aref ,gar
                                                                 ,row
                                                                 ,(incf col))))
                                            pat))
                           pats))
                ,@@body))))

 (defmacro with-array (pat ar &body body)
       (let ((gar (gensym)))
         `(let ((,gar ,ar))
             (let ,(mapcar #'(lambda (p)
                                      `(,(car p) (aref ,gar ,@@(cdr p))))
                                pat)
                ,@@body))))
@end lisp

                        Рисунок 18-2: Деконструкция массивов.
@end cartouche

Обратите внимание, что dbind, как и destructuring-bind, предполагает, что он найдет
всю структуру списка, которую он просматирвает. Оставшиеся переменные не просто
связываются с nil, а с использованием multiple-value-bind. Если последовательность,
заданная во время выполнения, не имеет всех ожидаемых элементов,  операторы
деконструкции выдают ошибку:

@example
> (dbind (a b c) (list 1 2))
>>Error: 2 is not a valid index for the sequence (1 2)
@end example

Какие еще объекты имеют внутреннюю структуру? Обычно есть массивы, которые отличаются
от векторов, наличием более чем одной размерности. Если мы определеим макрос деконструкции
для массивов, как мы представим шаблон? Для двумерных массивов, все еще будет практичным
использовать список. Рисунок 18-2 содержит макрос with-matrix для деконструкции двумерных
массивов.

@cartouche
@lisp
  (defmacro with-struct ((name . fields) struct &body body)
         (let ((gs (gensym)))
            `(let ((,gs ,struct))
                (let ,(mapcar #'(lambda (f)
                                        `(,f (,(symb name f) ,gs)))
                                  fields)
                  ,@@body))))
@end lisp

                         Рисунок 18-3: Деконструкция структур.
@end cartouche

@example
> (setq ar (make-array '(3 3)))
#<Simple-Array T (3 3) C2D39E>
> (for (r 0 2)
          (for (c 0 2)
             (setf (aref ar r c) (+ (* r 10) c))))
NIL
> (with-matrix ((a b c)
                          (def)
                          (g h i)) ar
          (list abcdefghi))
(012101112202122)
@end example

Для больших массивов или массивов размероностью 3 и выше, нам надо использовать
другой подход. Мы вряд ли захотим связывать переменные с каждым элементом большого
массива. Будет более практичным сделать шаблон с разреженным представлением массива,
содержащим переменные только для нескольких элементов, а также координаты для их
их идентификации. Второй макрос на Рисунке 18-2 создан по этому принципу. Здесь мы
используем его, для того чтобы получить диагональ предыдущего массива:

@example
> (with-array ((a 0 0) (d 1 1) (i 2 2)) ar
          (values a d i))
01122
@end example

С этим новым макросом мы начали отходить от шаблонов, элементы которых должны появляться
в фиксированном порядке. Мы можем создать подобный макрос для привязки переменных к полякм
в структурах созданных с помощью defstruct. Такой макрос определен на Рисунке 18-3. Первым
аргументов в шаблоне будет префик, связанный со стуктурой, а остальные - имена полей.
Для построения вызовов доступа этот макрос использует symb (стр. 58).

@example
> (defstruct visitor name title firm)
VISITOR
> (setq theo (make-visitor :name "Theodebert"
                                      :title 'king
                                      :firm 'franks))
#S(VISITOR NAME "Theodebert" TITLE KING FIRM FRANKS)
> (with-struct (visitor- name firm title) theo
        (list name firm title))
("Theodebert" FRANKS KING)
@end example

@node 18-3 Reference, 18-4 Matching, 18-2 Other Structures, 18 Destructuring
@comment  node-name,  next,  previous,  up
@section 18-3 Ссылки
@cindex 18-3 Reference

CLOS приносит с собой макрос для деконструкции экземпляров. Предположим, что tree
(дерево) это клас с тремя слотами: порода(species), возраст(age), и высота(height),
и my-tree это экземпляр tree. В

@lisp
(with-slots (species age height) my-tree
  ...)
@end lisp

@noindent
мы можем ссылаться на слоты my-tree, как если бы они были обычными переменными. В
пределах тела with-slots, символ height ссылается на слот height. Он не просто
связан со значением хранящимся в нем, но он ссылается на этот слот, так что если
мы напишем:

@lisp
(setq height 72)
@end lisp

тогда слоту height в my-tree будет присвоено значение 72. Этот макрос работает
как определение height как макрос-символ (Раздел 7-11) который расширяется до
ссылки на слот. На самом деле, он был должен поддерживать макросы, такие как with-slots,
symbol-macrolet был добавлен в Common Lisp.

Является или нет на самом деле with-slots макросом деконструкции, он играет ту же
прагматичну роль, что и destructuring-bind. Так как обычная деконструкция это
вызов по значению, это новый вид  - вызов по имени. Как бы мы его не называли,
он выглядит очень полезным. Какие еще макросы мы можем определить по этому
принципу?

Мы можем создать вызов по имени для любого макроса деконструкции, расширяя его
до symbol-macrolet, а не до let. На рисунке 18-4 показана версия dbind модифицированная
для поведения, аналогичного with-slots. Мы можем использовать with-places также как
dbind:

@example
> (with-places (a b c) #(1 2 3)
        (list a b c))
(1 2 3)
@end example

@cartouche
@lisp
 (defmacro with-places (pat seq &body body)
    (let ((gseq (gensym)))
         `(let ((,gseq ,seq))
                ,(wplac-ex (destruc pat gseq #'atom) body))))

 (defun wplac-ex (binds body)
    (if (null binds)
           `(progn ,@@body)
           `(symbol-macrolet ,(mapcar #'(lambda (b)
                                                     (if (consp (car b))
                                                         (car b)
                                                         b))
                                               binds)
                 ,(wplac-ex (mapcan #'(lambda (b)
                                            (if (consp (car b))
                                                   (cdr b)))
                                       binds)
                             body))))
@end lisp

                  Рисунок 18-4: Ссылочная деконструкция последовательностей.
@end cartouche

Но новый макрос также дает нам возможность присваивать позиции в последовательностях 
с помощью setf, как мы это делали с помощью with-slots:

@example
> (let ((lst '(1 (2 3) 4)))
        (with-places (a (b . c) d) lst
          (setf a 'uno)
          (setf c '(tre)))
        lst)
(UNO (2 TRE) 4)
@end example

Как и в случае с with-slots, переменные теперь ссылаются на соответствующие места
в структуре. Однако есть одно важное отличие: вы должны использовать setf, а не
setq, чтобы установить эти псевдо-переменные. Макрос with-slots должен вызывать
code-walker (стр 273), чтобы преобразовать setq в setf внутри своего тела. Здесь,
написание code-walker потребует много кода для небольшого уточнения.

Если with-places является более общим чем dbind, почему бы просто не использовать его
постоянно? В то время как dbind связывает переменную со значением, with-places связвает
ее с набором инструкций для поиска значения. Каждая ссылка требует поиска. Где dbind 
будет связвать символ c со значением (elt x 2), with-places сделает символ c символом
макросом, который расширяется в (elt x 2). Таким образом, если c вычисляется n раз в 
теле, это повлечет за собой n вызвов elt. Если вы на самом деле не хотите присваивать(setf)
переменные созданные деконструкцией,  dbind будет работать быстрее.

Определение with-places немного отличается от определения dbind
(Рисунок 18-1). Вn wplac-ex (ранее dbind-ex)  let стала symbol-macrolet. 
С помощью аналогичных изменений, мы можем сделать версию вызова по имени
для любого обычного деконструирующего макроса.

@node  18-4 Matching,  , 18-3 Reference, 18 Destructuring
@comment  node-name,  next,  previous,  up
@section 18-4 Сопоставления

Как деконструкция является обобщением присваивания, сопоставление с образцом является
обобщением деконструкции. Термин "сопоставление с образцом" имеет много смыслов. В
данном конетексте, он означает сравнение двух структур, возможно содержащих переменные,
чтобы выяснить, существует ли какой либо спосбо присвоения значений переменным, который
сделает их равным. Например, если ?x и ?y являются переменными, то два списка

@lisp
   (p ?x ?y  c ?x)
   (p a   b  c  a)
@end lisp

соответсвуют, когда ?x = a и ?y = b. И списки

@lisp
   (p ?x b ?y a)
   (p ?y b c a)
@end lisp

соответствуют, когда ?x = ?y = c.

Предположим, что программа работает путем обмена сообщениями с внешним источником.
Чтобы ответить на сообщение, программе надо сообщить, какой тип имеет это сообщение,
а также извлечь конкретное содержание. С оператором сопоставления мы можем объединить
эти два шага.

Чтобы написать такой оператор, мы должны придумать способ различения переменных. 
Мы не можем просто сказать, что все символы являются переменными, потому что мы
хотим, чтобы символы появлялись как аргументы в образцах. Здесь мы скажем, что
переменная образца это символ начинающийся со знака вопроса. Если это станет
не удобным, это соглашение можно изменить, просто определив предикат var?.

Рисунок 18-5 содержит функцию сопоставления с образцом, аналогичную той, которая
приводилась во введении в Lisp. Мы даем  match два списка, и если они могут
быть сопоставлены, мы получаем назад список показывающий как это сделать:

@example
   > (match '(pabca)'(p?x?yc?x))
   ((?Y . B) (?X . A))
   T
@end example

@cartouche
@lisp
     (defun match (x y &optional binds)
       (acond2
        ((or (eql x y) (eql x '_) (eql y '_)) (values binds t))
        ((binding x binds) (match it y binds))
        ((binding y binds) (match x it binds))
        ((varsym? x) (values (cons (cons x y) binds) t))
        ((varsym? y) (values (cons (cons y x) binds) t))
        ((and (consp x) (consp y) (match (car x) (car y) binds))
          (match (cdr x) (cdr y) it))
        (t (values nil nil))))

     (defun varsym? (x)
       (and (symbolp x) (eq (char (symbol-name x) 0) #\?)))

     (defun binding (x binds)
       (labels ((recbind (x binds)
                  (aif (assoc x binds)
                         (or (recbind (cdr it) binds)
                              it))))
        (let ((b (recbind x binds)))
          (values (cdr b) b))))
@end lisp

                        Рисунок 18-5: Функции Сопоставления.
@end cartouche

@example
> (match '(p ?x b ?y a) '(p ?y b c a))
((?Y . C) (?X . ?Y))
T> (match '(a b c) '(a a a))
NIL
NIL
@end example

Когда match сравнивает свои аргументы элемент за элементом, она создает
присваивания значений переменным, называемые привязками, в в параметре binds. Если
сопоставление проходит успешно, match возвращает сгенерированные привязки, в
противном случае возвращается nil. Поскольку не все успешные совпадения генерируют
какие-либо привязки, match как и gethash, возвращает второе значение, чтобы указать,
был ли вызов match успешными или неудачным:

@example
> (match '(p ?x) '(p ?x))
NIL
T
@end example

@cartouche
@lisp
     (defmacro if-match (pat seq then &optional else)
       `(aif2 (match ',pat ,seq)
                (let ,(mapcar #'(lambda (v)
                                        `(,v (binding ',v it)))
                                  (vars-in then #'atom))
                    ,then)
                ,else))

     (defun vars-in (expr &optional (atom? #'atom))
       (if (funcall atom? expr)
            (if (var? expr) (list expr))
            (union (vars-in (car expr) atom?)
                     (vars-in (cdr expr) atom?))))

     (defun var? (x)
       (and (symbolp x) (eq (char (symbol-name x) 0) #\?)))
@end lisp

                        Рисунок 18-6: Медленные операторы сопоставления.
@end cartouche

Когда match возвращает nil и t, как указано выше, это указывает на успешное 
совпадение, которое не дало никаких  привязок.

Как и в Prolog, match рассматривает (подчеркивание) как произвольный знак. Он
может соответствовать чему угодно, и не влияет на привязки:

@example
> (match '(a ?x b) '(_ 1 _))
((?X . 1))
T
@end example

Учитывая match, легко написать версию dbind для сопоставления с образцом. На
Рисунке 18-6 содержиться макрос с именем if-match. Как и dbind, его первые два
аргуемнта это образец и последовательность, и он устанавливает привязки сравнивая
образец с последовательностью. Однако, вместо тело у него есть еще два аргумента:
предложение then вычисляемое с новыми привязками, если совпадение найдено; и
предложение else вычисляемое в случае сбоя сопоставления. Вот простая функция,
которая использует if-match:

@lisp
(defun abab (seq)
     (if-match (?x ?y ?x ?y) seq
           (values ?x ?y)
           nil))
@end lisp

Если match выполняется успешно, оно устанавливает значения для ?x и ?y, которые будут возвращены:

@example
> (abab '(hi ho hi ho))
HI
HO
@end example

Функция vars-in возвращает все переменные образца в выражении. Он вызывает  var? 
чтобы проверить, является что-либо переменной. На данный момент var? является 
идентичным varsym? (Рисунок 18-5), который используется для обнаружения переменных в
списках привязок. У нас есть две разные функции на случай если мы захотим использовать
разные представления для двух типов переменых.

Определеное на Рисунке 18-6 if-match является коротки, но не очень эффективным. Оно
делает слишком много работы во время выполнения. Мы  проходим по двум последовательностям
во время выполнения, хотя первая уже известна  во время копиляции. Что еще хуже, в 
процессе сопоставления, мы создаем списки для хранения привязок переменных. Если 
мы воспользуемся информацией известной во время коомпиляции, мы сможем написать
версию if-match, которая не будет выполнять не нужных сравнений и не имеет 
недостатков использования cons.

Если одна из последовательностей известна во время компиляции, и это та которая
содержит переменные, тогда мы можем действовать по другому. В вызове match любой
аргуемнт может содержать переменные. Ограничивая переменные только первым аргументом
if-match, мы позволяем указать во время компиляции, какие переменные будут учавствовать
в сопоставлении. Тогда вместо создания списков привязок переменных, мы могли бы хранить
значения переменных в самих переменных.

Новая версия if-match показана на рисунках 18-7 и 18-8. Когда мы можем предсказать,
какой код будет вычисляться во время выполнения, мы можем просто сгенерировать его
во время компиляции. Здесь, вместо расширения в вызов match, мы генерируе код
который выполняет только правильныеп сравнения.

Если мы собираемся использовать переменную ?x, чтобы содержать привязку ?x, как
нам представить переменную, для которой совпадение еще не было установлено match?
Здесь мы укажем, что переменная образца не связана, связывая её с gensym.
Поэтому if-match начинается с генерации генерации кода, который будет связывать
все переменные образца с gensyms. В этом случае, вместо того чтобы расширятсья в
with-gensyms, безопасно создавать gensyms один раз во время компиляции и вставлять
их непросредственно в расширение.

Остальная часть расширения генерируется с помощью pat-match. Этот макрос принимает
те же аргументы что и if-match; единственное отличие состоит в том, что он не 
устанавливает новых привязок для переменных образца. В некоторых ситуациях это
является преимуществом, и глава 19 будет использовать pat-match в качестве 
самостоятельного оператора.

В новом операторе сопоставления различие между содержимым и структурой
образца будет определяться функцией simple?. Если мы хотим иметь возможность 
использовать квотированные литералы в образце, коду деконструкции (и vars-in) нужно
запретить входить внутрь списков, первым элементом которых является quote. С новым
оперетором сопоставления, мы можем использовать списки в качестве элементов образца,
просто заключая их в символ квотирования.

@cartouche
@lisp
 (defmacro if-match (pat seq then &optional else)
       `(let ,(mapcar #'(lambda (v) `(,v ',(gensym)))
                          (vars-in pat #'simple?))
           (pat-match ,pat ,seq ,then ,else)))

 (defmacro pat-match (pat seq then else)
       (if (simple? pat)
            (match1 `((,pat ,seq)) then else)
            (with-gensyms (gseq gelse)
              `(labels ((,gelse () ,else))
                    ,(gen-match (cons (list gseq seq)
                                          (destruc pat gseq #'simple?))
                                 then
                                 `(,gelse))))))

 (defun simple? (x) (or (atom x) (eq (car x) 'quote)))

 (defun gen-match (refs then else)
       (if (null refs)
            then
            (let ((then (gen-match (cdr refs) then else)))
              (if (simple? (caar refs))
                     (match1 refs then else)
                     (gen-match (car refs) then else)))))
@end lisp

                        Рисунок 18-7: Опертор быстрого сопоставления.
@end cartouche

Как и dbind, pat-match вызывает destruc чтобы получить список вызвов, которые 
будут испольовать часть его аргументов во время выполнения. Этот список передается
в gen-match, который рекурсивно генерирует код сопоставления для вложенных образцов,
а затем в match1, который генерирует код сопоставления для каждого листа дерева
образца.

Большая часть кода, который появитсья в расширении if-match, происходит из  match1, 
что показано на рисунке 18-8. Эта функция рассматривает четыре случая. Если аргумент
образца является gensym, то это одна из невидимых переменных, созданных destruc для
хранения подсписков и все, что нам нужно сделать во время выполнения, это проверить,
что он имеет правильную длину. Если элемент образца является произвольным знаком
(_), генерировать код не нужно. Если элемент образца является переменной, match1
генерирует код, чтобы сопоставить его снова, или установить его соответствие с
соответствующей частью последовательности, заданной во время выполнения. В проитвном
случае элемент образца считается буквенным значением и match1 генерирует код для
сравнения его с соответствующей частью последовательности.

@cartouche
@lisp
 (defun match1 (refs then else)
    (dbind ((pat expr) . rest) refs
         (cond ((gensym? pat)
                  `(let ((,pat ,expr))
                       (if (and (typep ,pat 'sequence)
                                 ,(length-test pat rest))
                           ,then
                           ,else)))
                 ((eq pat '_) then)
                 ((var? pat)
                  (let ((ge (gensym)))
                      `(let ((,ge ,expr))
                        (if (or (gensym? ,pat) (equal ,pat ,ge))
                              (let ((,pat ,ge)) ,then)
                              ,else))))
                 (t `(if (equal ,pat ,expr) ,then ,else)))))

 (defun gensym? (s)
    (and (symbolp s) (not (symbol-package s))))

 (defun length-test (pat rest)
    (let ((fin (caadar (last rest))))
         (if (or (consp fin) (eq fin 'elt))
                `(= (length ,pat) ,(length rest))
                `(> (length ,pat) ,(- (length rest) 2)))))
@end lisp

                  Рисунок 18-8: Быстрый оператор сопоставления (продолжение).
@end cartouche

Давайте посмотрим на примеры того, как генерируются некоторые части расширения.
Предположим, мы начали с

@lisp
(if-match (?x 'a) seq
        (print ?x)
        nil)
@end lisp

Образец будет передан в destruc, с некоторымe gensym (назовем его g для разборчивости)
в представленную последовательность:

@lisp
(destruc '(?x 'a) 'g #'simple?)
@end lisp

@noindent
получаем:

@lisp
   ((?x (elt g 0)) ((quote a) (elt g 1)))
@end lisp

В начало этого списка мы подставляем (g seq):

@lisp
   ((g seq) (?x (elt g 0)) ((quote a) (elt g 1)))
@end lisp

и отправляем его в gen-match. Как и в наивной реализации length (стр 22), gen-match
сначала рекурсивно проходит до конца списка, а затем строит свое возвращаемое 
значение на обратном пути. Когда у него заканчиваются элементы, gen-match возвращает
его аргумент then, который будет ?x. На обратном пути рекурсии это возвращаемое 
значение будет передано в качестве аргумент в  match1.Теперь мы можем вызвать
как:

@lisp
   (match1 '(((quote a) (elt g 1))) '(print ?x) ' else function )
@end lisp

@noindent
получая:

@lisp
   (if (equal (quote a) (elt g 1))
           (print ?x)
            else function )
@end lisp

Это в свою очередь, станет аргументом then для друго вызова match1, значение которого
станет then аргументом для последнего вызова match1. Полное расширение этого if-match 
показано на рисунке 18-9.

В этом расширении gensyms используются двумя совершенно не связанными способами.
Переменные, используемые для хранения частей дерева во время выполнения имеют
сгенерированные gensym имена, чтобы избежать захвата. И переменные ?x изначально
связвается с  gensym, чтобы указать, что ей не было присвоено значение путем
сопоставления.

В новом if-match, элементы образца теперь вычисляются, а не заключются неявно
в кавычки. Это означает, что Lisp переменные могут использоваться в образцах,
а также в выражениях в кавычках:

@example
   > (let ((n 3))
           (if-match (?x n 'n '(a b)) '(13n(ab))
              ?x))
   1
@end example

Два новых улучшения появляютс потому, что новая версися вызывает destruc (Рисунок
18-1). Теперь образец может содержать ключевые слова &rest или &body (match не
беспокоит их). И поскольку destruc использует опрераторы общей последовательности
elt и subseq, новый  if-match будет работать для любого типа последовательностей. 
Если abab определен  с новой версией, он может быть испольозван также для
векторов и строк:

@cartouche
@lisp
      (if-match (?x 'a) seq
           (print ?x))
@end lisp

      расширяется в:

@lisp
      (let ((?x '#:g1))
        (labels ((#:g3 nil nil))
           (let ((#:g2 seq))
             (if (and (typep #:g2 'sequence)
                          (= (length #:g2) 2))
                  (let ((#:g5 (elt #:g2 0)))
                       (if (or (gensym? x) (equal ?x #:g5))
                          (let ((?x #:g5))
                              (if (equal 'a (elt #:g2 1))
                                   (print ?x)
                                   (#:g3)))
                          (#:g3)))
                  (#:g3)))))
@end lisp

                        Рисунок 18-9: Расширение if-match.
@end cartouche

@example
> (abab "abab")
#\a
#\b
> (abab #(1 2 1 2))
12
@end example
На самом деле, образцы могут быть сложными, как образцы для dbind:

@example
> (if-match (?x (1 . ?y) . ?x) '((a b) #(1 2 3) a b)
            (values ?x ?y))
(A B)
#(2 3)
@end example

Обратите внимание, что во втором возвращаемом значении, отображаются элементы вектора.
Чтобы векторы печатались таким образом, установите *print-array* в t.

В этой главе мы начали переходить грань в новый вид программирования. Мы начали
с простых макросв для деконструкции. И в финальной версии из if-match у нас
получилось что то больше похожее на собственный язык. Остальные главы описывают 
целый класс программ, которые работают на той же философии.