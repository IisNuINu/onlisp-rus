@node 12 Generalized Variables, 13 Computation at Compile-Time, 11 Classic Macros, Top
@comment  node-name,  next,  previous,  up
@chapter 12 Обобщенные переменные
@cindex 12 Generalized Variables

В главе 8 упоминалось, что одним из преимуществ макросов является их способность
преобразовывать свои аргументы. Одним из макросов такого рода является setf. Эта
глава рассматривает смысл(подтекст) setf, и затем показывает некотоыре примеры
макросов, которые могут быть построены на подобном принципе.

Написание правильных макросов на setf удивительно сложно. Чтобы вникнуть в тему,
в первом разделе приведен простой пример, который немного неверен. В следующем
разделе объясняется, что не так с этим макросом, и показывается как исправить это.
В третьем и четвертом разделах представлены примеры утилит, основанных на setf, и
в последнем разделе объясняется как определить ваши собственные инверсии setf.
@menu
* 12-1 The Concept::            
* 12-2 The Multiple Evaluation Problem::  
* 12-3 New Utilities::          
* 12-4 More Complex Utilities::  
* 12-5 Defining Inversions::    
@end menu

@node 12-1 The Concept, 12-2 The Multiple Evaluation Problem, 12 Generalized Variables, 12 Generalized Variables
@comment  node-name,  next,  previous,  up
@section 12-1 Концепция(Идея)
@cindex 12-1 The Concept

Встроенный макрос setf является обобщением setq. Первый аргумент для setf может
быть вызовом, представляющим собой запрос на определение значения переменной в 
некоторой структуре данных(например в списке), а не простой переменной:

@example
> (setq lst '(a b c))
(A B C)
> (setf (car lst) 480)
480
> lst
(480 B C)
@end example

В общем (setf x y) можно понимать как высказывание "смотри чтобы этот x имел значение
равное y." Как макрос, setf может заглянуть внутрь своих аргументов, чтобы увидеть,
что нужно сделать, чтобы сделать это утверждение правдой. Если первый аргумент
(после расширения макроса) является символом, setf просто расширяется в setq. Но если
аргумент является запросом, setf расширяется в соответствующее утверждение.  Поскольку
второй аргумент это константа, предыдущий пример может расшириться до:

@lisp
(progn (rplaca lst 480) 480)
@end lisp

Это преобразование из запроса в утверждение называется инверсией. Все самые
часто используемые функции доступа Common Lisp имеют предопределенные инверсии,
включаяя car, cdr, nth, aref, get, gethash, и функции доступа, созданные 
defstruct. (Полный список приведен в CLTL2, стр. 125.)

Выражение, которое может служить первым аргументом для setf называется
обобщенной переменной. Обобщенные переменные оказались мощной абстракцией. 
Вызов макроса напоминает обобщенную переменную тем, что любой вызов макроса,
который расширяется в обратимую ссылку, сам будет обратимым.

Когда мы также пишем наши собственные макросы поверх setf, эта комбинация приводит к
заметному улучшению ясности программы. Одним из макросов, которые мы можем определить
поверх setf является toggle(переключатель),@footnote{Это определение не является
правильным, почему объясняется в следующем разделе.}

@lisp
(defmacro toggle (obj)                                                       ; wrong
  `(setf ,obj (not ,obj)))
@end lisp

@noindent
который переключает (логическое) значение обобщенной переменной:

@example
> (let ((lst '(a b c)))
        (toggle (car lst))
        lst)
(NIL B C)
@end example

Теперь рассмотрим следующий пример приложения. Предположим, кто-то - писатель мыльных
опер, энергичный занятый человек, или партийный чиновник - хочет вести базу данных
из всех отношений между жителями небольшого города. В числе требуемых таблиц, необходима
та, в которой записываются друзья людей:

@lisp
(defvar *friends* (make-hash-table))
@end lisp

Записи в этой хеш-таблице сами являются хеш-таблицами, в которых имена потенциальных
друзей отображаются в  t или nil:

@lisp
(setf (gethash 'mary *friends*) (make-hash-table))
@end lisp

@noindent
Чтобы записать John другом Mary, мы могли бы сказать:

@lisp
(setf (gethash 'john (gethash 'mary *friends*)) t)
@end lisp

Город разделен между двумя фракциями. Как обычно делают фракции, каждая говорит
"кто не с нами, тот против нас", поэтому все в городе вынуждены присоединиться
к той или иной стороне. Таким образом, когда кто то переходит на другую сторону,
все его друзья становяться врагами, а все его враги становяться друзьями.

Чтобы переключить(toggle), что x является другом y используя только встроенные операторы,
мы можем сказать:

@lisp
(setf (gethash x (gethash y *friends*))
           (not (gethash x (gethash y *friends*))))
@end lisp

это довольно сложное выражение, хотя гораздо проще, чем без использования setf. 
Если мы определим макрос доступа к базе данных следующим образом:

@lisp
(defmacro friend-of (p q)
  `(gethash ,p (gethash ,q *friends*)))
@end lisp

тогда с этим макросом и toggle, мы были бы лучше подготовлены к изменениям в базе
данных. Предыдущее обновление могло бы быть выражено просто как:

@lisp
(toggle (friend-of x y))
@end lisp

Обобщенные переменные похожи на здоровую пищу, которая имеет приятный вкус. Они
дают программам виртуозную модульность, и все же элегантно красивы. Если вы
предоставляете доступ к вашим структурам данных с помощью макросов или обратимых
функций, другие модули могут использовать setf для изменения ваших струкутр
данных, без необходимости знать подробности их представления.

@node 12-2 The Multiple Evaluation Problem, 12-3 New Utilities, 12-1 The Concept, 12 Generalized Variables
@comment  node-name,  next,  previous,  up
@section 12-2 Проблема Многократнрых Вычислений
@cindex 12-2 The Multiple Evaluation Problem

Предыдущий раздел предупреждал, что наше первоначальное определение toggle было
неверным:

@lisp
(defmacro toggle (obj)                                                   ; wrong
  `(setf ,obj (not ,obj)))
@end lisp

Он подвержен проблеме, описанной в разделе 10-1, множественное вычисление. Проблема
возникает когда его аргумент имеет побочные эффекты. Наример, если lst это список
объектов мы пишем:

@lisp
(toggle (nth (incf i) lst))
@end lisp

тогда мы ожидаем переключения(toggling) (i+1)-го элемента. Однако, с текущим
определением toggle этот вызов расширяется в:

@lisp
(setf (nth (incf i) lst)
           (not (nth (incf i) lst)))
@end lisp

Здесь i увеличивается дважды, и устанавливается (i+1)й элемент противоположностью
от (i+2)го элемента. Так что в этом примере

@example
> (let ((lst '(t nil t))
             (i -1))
        (toggle (nth (incf i) lst))
        lst)
(T NIL T)
@end example

@noindent
вызов toggle, кажеться, не имеет никакого эффекта.

Не достаточно просто взять выражение, передаваемое в качестве аргумента toggle
и вставить его как первый аргумент для setf. Мы должны заглянуть внутрь выражения
и посмотреть, что оно делает: если оно содержит подчиненные формы, мы должны
разбить их на части и вычислить их отдельно, в случае если они имеют побочные
эффекты. В общем, это сложное дело.

Чтобы сделать это проще, Common Lisp предоставлялет макрос, который автоматически
определяет ограниченный класс макросов для setf. Этот марос называется 
define-modify-macro и он принимает три аргумента: имя макроса, его дополнительные
параметры(после обобщенной переменной),и имя функции@footnote{Имя функции в
общем смысле: или 1+ или (lambda (x) (+ x 1)).} которая дает новое значение
для обобщенной переменной.

Используя define-modify-macro, мы можем определить toggle следующим образом:

@lisp
(define-modify-macro toggle () not)
@end lisp

Перефразируя, тут говориться "чтобы вычислить выражение формы (toggle place),
найдите место, указанное в place, и если в нем храниться значение val, замените
его на значение (not val)." Здесь новый макрос используется в том же самом 
примере:

@example
> (let ((lst '(t nil t))
             (i -1))
        (toggle (nth (incf i) lst))
        lst)
(NIL NIL T)
@end example

Эта версия дает правильный результат, но его можно сделать более общим. Поскольку
setf и setq могут принимать произвольное количество аргументов, то же можно делать
и toggle. Мы можем добавить эту возможность, определив другой макрос поверх
modify-macro, как на рисунке 12-1.

@cartouche
@lisp
 (defmacro allf (val &rest args)
        (with-gensyms (gval)
         `(let ((,gval ,val))
            (setf ,@@(mapcan #'(lambda (a) (list a gval))
                                  args)))))

 (defmacro nilf (&rest args) `(allf nil ,@@args))

 (defmacro tf (&rest args) `(allf t ,@@args))

 (defmacro toggle (&rest args)
        `(progn
          ,@@(mapcar #'(lambda (a) `(toggle2 ,a))
                       args)))

 (define-modify-macro toggle2 () not)
@end lisp

            Рисунок 12-1: Макросы которые оперируют обобщенными переменными.
@end cartouche

@node 12-3 New Utilities, 12-4 More Complex Utilities, 12-2 The Multiple Evaluation Problem, 12 Generalized Variables
@comment  node-name,  next,  previous,  up
@section 12-3 Новые Утилиты
@cindex 12-3 New Utilities

В этом разделе приведены некоторые примеры новых утилит, которые работают с
обобщенными переменными. Они должны быть макросами, чтобы передать свои
аргументы без изменений в setf.

На рисунке 12-1 показаны четыре новых макроса построенных на основе setf. Первый
allf, предназначен для устновки нескольких обобщенных переменных в одно и тоже
значение. На нем построены nilf и tf, которые устанавливают свои аргументы в nil
и t, соответственно. Эти макросы просты, но они имеют значение.

Как и setq, setf может принимать несколько аргументов - перемежающиеся переменные
и значения:

@lisp
(setf x 1 y 2)
@end lisp

Как и эти новые утилиты, но вы можете пропустить половину этих аргументов. Если вы хотите,
инициализировать несколько переменых в nil, вместо

@lisp
(setf x nil y nil z nil)
@end lisp

вы можете просто сказать

@lisp
(nilf x y z)
@end lisp

@cartouche
@lisp
 (define-modify-macro concf (obj) nconc)

 (define-modify-macro conc1f (obj)
       (lambda (place obj)
          (nconc place (list obj))))

 (define-modify-macro concnew (obj &rest args)
       (lambda (place obj &rest args)
          (unless (apply #'member obj place args)
            (nconc place (list obj)))))
@end lisp

                 Рисунок 12-2: Списковые операции с обобщенными перменными.
@end cartouche

Последний макрос, toggle, описанный в предыдущем разделе: он похож на  nilf,
но придает каждому из своих аргументов противоположное логическое значение.

Эти четыре макроса иллюстрируют важный момент о операторах присваивания.
Даже если мы намереваемся использовать оператор только для обычных переменных,
стоит написать его расширяющимся в setf, а не в setq. Если первый аргумент 
является символом setf будет расширяться в setq в любом случае. Так мы
сможем получить обобщение в setf без дополнительных затрат, и очень редко
необходимо использвать setq в расширениях макроса.

Рисунок 12-2 содержит три макроса для деструктивного изменения концов списков.
В разделе 3-1 упоминается, что не безопасно полагаться на побочные эффекты

@lisp
(nconc x y)
@end lisp

и что вместо этого, нужно писать

@lisp
(setq x (nconc x y))
@end lisp

Эта идиома воплощена в concf. Более специализированные conc1f и concnew
похожи на push и pushnew для другого конца списка: conc1f добавляет один
элемент в конец списка, и concnew делает тоже самое, но только если элемент
не является членом списка.

В разделе 2-2 упоминается, что имя функции может быть лямбда-выражением,
а также символом. Таким образом, можно передать целое лямбда-выражение в
качестве третьего аргумента для define-modify-macro, как в определении 
conc1f. С помощью conc1 со страницы 45, этот макрос мог быть написан так:

@lisp
(define-modify-macro conc1f (obj) conc1)
@end lisp

Макросы на Рисунке 12-2 должны использоваться с одной оговоркой. Если вы планируете
построить список путем добавления элементов в конец, может быть предпочтительнее
использовать push, и затем развернуть с помощью nreverse список. Дешевле сделать 
чтото с началом списка, чем с его концом, потому что прежде чем чтото делать в конце
списка, вначале вы должны до него добраться. Вероятно, для поощрения эффективного
программирования в Common Lisp есть много операторов для первого и лишь немного для
второго.

@node 12-4 More Complex Utilities, 12-5 Defining Inversions, 12-3 New Utilities, 12 Generalized Variables
@comment  node-name,  next,  previous,  up
@section 12-4 Более Сложные Утилиты
@cindex 12-4 More Complex Utilities

Не все макросы в setf могут быть определены с помощью define-modify-macro. Например
предположим, что мы хотим определить макрос _f для применения деструктивной функции
к обобщенной переменной. Встроенный макрос incf это сокращенная аббревиатура для setf 
для +. Вместо

@lisp
(setf x (+ x y))
@end lisp

@noindent
мы просто скажем

@lisp
(incf x y)
@end lisp

Новый _f должен быть обобщением этой идеи: в то время как incf расширяется в вызов
+, _f рассширяется в вызов оператора указанного в качестве первого аргумента. Например,
в определении scale-objs на странице 115, нам пришлось написать

@lisp
(setf (obj-dx o) (* (obj-dx o) factor))
@end lisp

С _f эта запись станет:

@lisp
(_f * (obj-dx o) factor)
@end lisp

Неправильным способом написать f будет:

@lisp
(defmacro _f (op place &rest args)            ; wrong
  `(setf ,place (,op ,place ,@@args)))
@end lisp

К сожалению, мы не можем определить правильный _f с помощьюw define-modify-macro,
поскольку оператор, который будет применен к обобщенной переменной, задан в 
качестве аргумента.

Более сложные макросы, подобные этому, должны быть написаны в ручную. Чтобы
такие макросы было легче писать, Common Lisp предоставляет функци get-setf-method,
которая принимает обобщенную переменную и возвращает всю информацию, необходимую для
получения или установки её значения. Мы увидим, как использовать эту информацию
генерируя в ручную расширение для:

@lisp
(incf (aref a (incf i)))
@end lisp

Когда мы вызываем get-setf-method для обобщенной переменной, мы получаем
пять значений предназначенных для использования в качестве ингредиентов
в расширении макроса:

@example
> (get-setf-method '(aref a (incf i)))
;;в sbcl используется (get-setf-expansion '(aref a (incf i)))
(#:G4 #:G5)
(A (INCF I))
(#:G6)
(SYSTEM:SET-AREF #:G6 #:G4 #:G5)
(AREF #:G4 #:G5)
@end example

Первые два значения это списки временных переменных и значений, которые должны им
присвоены. Итак мы можем начать расширение с:

@lisp
(let* ((#:g4 a)
       (#:g5 (incf i)))
   ...)
@end lisp

Эти привязки должны быть созданы в let*, потому что в общем случае значения форм могут 
ссылаться на более ранние переменные. Третье@footnote{Третье значение в настоящее время
является списком из одного элемента. Оно возвращается в виде списка, чтобы предоставить
(таким образом это еще далеко не всё) возможность для хранения нескольких значений в
обобщенных переменных.} и пятое значения являются еще одними временными переменными и
формой, которая будет возвращать исходное значение обобщенной переменной. Поскольку мы
хотим добавить 1 к этому значению, мы заключаем последнюю в вызов 1+:

@lisp
(let* ((#:g4   a)
       (#:g5   (incf i))
       (#:g6   (1+ (aref #:g4 #:g5))))
   ...)
@end lisp

Наконец, четвертое значение, возвращаемое get-setf-method это присваивание,
которое мы должны сделать в рамках новых привязок:

@lisp
(let* ((#:g4  a)
       (#:g5  (incf i))
       (#:g6  (1+ (aref #:g4 #:g5))))
   (system:set-aref #:g6 #:g4 #:g5))
@end lisp

Чаще всего эта форма будет ссылаться на внутренние функции, которые  не являются 
частью Common Lisp. Обычно setf прячет наличие этих функций, но они должны где-то
существовать. Все они зависят от реализации, поэтому переносимый код должен
использовать формы возвращаемые get-setf-method, а не ссылаться на такие функции,
например как system:set-aref, на прямую.

Теперь для реализации _f мы пишем макрос, которые делает почти то же, что делали мы,
когда расширяли incf в ручную. Разница лишь в том, что вместо оборачивания последней
формы в let* в вызове 1+, мы оборачиваем ее выражение из аргументов передаваемых _f. 
Определение _f показано на Риснуке 12-3.

@cartouche
@lisp
 (defmacro _f (op place &rest args)
   (multiple-value-bind (vars forms var set access)
                             (get-setf-method place)
        `(let* (,@@(mapcar #'list vars forms)
               (,(car var) (,op ,access ,@@args)))
          ,set)))

 (defmacro pull (obj place &rest args)
   (multiple-value-bind (vars forms var set access)
                             (get-setf-method place)
        (let ((g (gensym)))
         `(let* ((,g ,obj)
                 ,@@(mapcar #'list vars forms)
                 (,(car var) (delete ,g ,access ,@@args)))
            ,set))))

 (defmacro pull-if (test place &rest args)
   (multiple-value-bind (vars forms var set access)
                             (get-setf-method place)
        (let ((g (gensym)))
         `(let* ((,g ,test)
                 ,@@(mapcar #'list vars forms)
                 (,(car var) (delete-if ,g ,access ,@@args)))
            ,set))))

 (defmacro popn (n place)
   (multiple-value-bind (vars forms var set access)
                             (get-setf-method place)
        (with-gensyms (gn glst)
         `(let* ((,gn ,n)
                 ,@@(mapcar #'list vars forms)
                 (,glst ,access)
                 (,(car var) (nthcdr ,gn ,glst)))
            (prog1 (subseq ,glst 0 ,gn)
                     ,set)))))
@end lisp

                Рисунок 12-3: Более сложный макрос setf.
@end cartouche

Эта утилита довольно полезна. Теперь когда у нас она есть, мы легко можем, например, заменить
любую именованную функцию на её эквивалент с запомнинанием(memoized) (Разел 5-3).@footnote{Встроенные 
функции не должны запоминаться таким образом. Common Lisp запрещает переопределение встроенных функций.}
для запоминания(memoize) foo мы бы сказали:

@lisp
(_f memoize (symbol-function 'foo))
@end lisp

Наличие _f также облегчает определение других макросов в setf. Нампример, теперь мы
можем определить conc1f (Рисунок 12-2) как:

@lisp
(defmacro conc1f (lst obj)
   `(_f nconc ,lst (list ,obj)))
@end lisp

Рисунок 12-3 cодержит другие полезные макросы для setf. Следующий, pull,
предназначен в качестве дополнения к встроенному pushnew. Эта пара более
различающая аргументы подобна паре push и pop; pushnew помещает новый элемент
в список, если он не являетися уже членом списка, и pull разрушающе удалят выделенный
элемент из списка. Параметр &rest в определении pull делает pull способным принимать
все те же параметры ключевый слова как и в delete:

@example
> (setq x '(1 2 (a b) 3))
(1 2 (A B) 3)
> (pull 2 x)
(1 (A B) 3)
> (pull '(a b) x :test #'equal)
(1 3)
>x
(1 3)
@end example

Вы могли бы думать об этом макросе как если был определен как:

@lisp
(defmacro pull (obj seq &rest args)                                           ; wrong
   `(setf ,seq (delete ,obj ,seq ,@@args)))
@end lisp

@noindent
хотя, если это действительно было бы определено таким образом, оно было бы связано с
проблемами как по порядку, так и по количеству вычилений. Мы могли бы определить версию
pull как простой modify-macro:

@lisp
(define-modify-macro pull (obj &rest args)
   (lambda (seq obj &rest args)
        (apply #'delete obj seq args)))
@end lisp

но так как modify-macros должен принимать обобщенную переменную, в качестве первого
аргумента, мы должны были бы передать первые два аргумента в обратном порядке, что
будет менее интуитивно понятно.

Более общий pull-if принимает начальный аргумент функции, и расширяется
в delete-if вместо delete:

@example
> (let ((lst '(1 2 3 4 5 6)))
        (pull-if #'oddp lst)
        lst)
(2 4 6)
@end example

Эти два макроса иллюстрируют еще один общий момент. Если основная функция принимает
необязательные аргументы, то и макрос должен основываться на них. Оба, и pull и pull-if
передают необзательные аргументы своим функциям удаления.

Последний макрос на рисунке 12-3, popn, является обобщением pop. Вместо простого
выталкивания по одному элементу из списка, он выталкивает и возвращает 
подпоследовательность произвольной длины:

@example
> (setq x '(a b c d e f))
(A B C D E F)
> (popn 3 x)
(ABC)
>x
(D E F)
@end example

Рисунок 12-4 содержит макрос, который сортирует свои аргументы. Если x и y являются
переменными и мы хотим убедиться, что x не является меньшим из двух значений, мы можем
написать:

@lisp
(if (> y x) (rotatef x y))
@end lisp

Но если мы хотим сделать это для трех и более переменных, требуемый код растет
очень быстро. Вместо, того, чтобы писать его в ручную, мы можем сделать так, чтобы
sortf писал его за нас. Этот макрос принимает оператор сравнения пюст любое количество
обобщенных переменных, и меняет их значения до тех пор, пока они не будут в порядке
определяемом оператором. В простейшем случае аргументы могут быть обычными переменными:

@example
> (setq x 1 y 2 z 3)
> (sortf > x y z)
> (list x y z)
(3 2 1)
@end example

@cartouche
@lisp
 (defmacro sortf (op &rest places)
       (let* ((meths (mapcar #'(lambda (p)
                                  (multiple-value-list
                                       (get-setf-method p)))
                                    places))
              (temps (apply #'append (mapcar #'third meths))))
          `(let* ,(mapcar #'list
                          (mapcan #'(lambda (m)
                                      (append (first m)
                                              (third m)))
                                  meths)
                          (mapcan #'(lambda (m)
                                      (append (second m)
                                              (list (fifth m))))
                                  meths))
             ,@@(mapcon #'(lambda (rest)
                            (mapcar
                               #'(lambda (arg)
                                   `(unless (,op ,(car rest) ,arg)
                                       (rotatef ,(car rest) ,arg)))
                               (cdr rest)))
                        temps)
             ,@@(mapcar #'fourth meths))))
@end lisp

                   Рисунок 12-4: Макрос который сортирует свои аргументы.
@end cartouche

В общем, это могут быть любые обратимые выражения. Предположим, что cake является 
обратимой функцией и которая возвращает чей либо кусочек пирога, а bigger функция
сравнения определенная на кусочках пирога. Если мы хотим применить правило, что
торт moe не меньше, чем торт larry, который не меньше чем торт curly, мы запишем:

@lisp
(sortf bigger (cake 'moe) (cake 'larry) (cake 'curly))
@end lisp

Определение sortf в общих чертах аналогично определению _f. Оно начинается с
let* в котором связываются временные переменные возвращаемые get-setf-method 
и связваются начальные значения обобщенных переменных. Ядром sortf является
центральное выражение mapcon, которое генерирует код сортирующий эти временные
переменные. Код, сгенерированный этой частью макроса, растет экспотенциально 
вместе с числом аргументов. После сортировки, обобщенные переменные переприсваиваются
с помощью

@cartouche
@lisp
 (sortf > x (aref ar (incf i)) (car lst))
@end lisp

@noindent
расширяется (в одной из возможных реализаций) в:

@lisp
 (let* ((#:g1 x)
        (#:g4 ar)
        (#:g3 (incf i))
        (#:g2 (aref #:g4 #:g3))
        (#:g6 lst)
        (#:g5 (car #:g6)))
    (unless (> #:g1 #:g2)
        (rotatef #:g1 #:g2))
    (unless (> #:g1 #:g5)
        (rotatef #:g1 #:g5))
    (unless (> #:g2 #:g5)
        (rotatef #:g2 #:g5))
    (setq x #:g1)
    (system:set-aref #:g2 #:g4 #:g3)
    (system:set-car #:g6 #:g5))
@end lisp

                    Рисунок 12-5: Расширение вызова sortf.
@end cartouche

форм, возвращаемых get-setf-method. Используемый алгоритм представляет собой
сортировку пузыкрьком O(n2), но этот макрос не предназначен для вызова с большим
количеством аргументов.

На Рисунке 12-5 показано расширение вызова sortf. В начальномl let*, аргументы и
их подформы тщательно вычисляются в порядке слева на право. Затем появляются три
выражения, которые сравнивают, и возможно заменяют значения временных переменных: 
первый сравниватся со вторым, затем первый с третьим, затем второй с третьим. Наконец,
обобщенные переменные переприсваиваются в порядке с лева на право. Хотя проблема
возникает редко, аргументы макроса должны присваиваться слева на право, а также 
вычисляться в том же порядке.

Операторы типа _f и sortf имеют определенное сходство с функциями, которые принимают
функциональные аргументы. Следует понимать, что они имеют воплне очевидное различие.
Функция подобная find-if получает функцию и вызывает её; а макрос подобный _f
получает имя, и делает его началом(car) выражения. Оба и _f и sortf могут быть
написаны , чтобы принимать функциональные аргументы. Например, _f может быть
написан:

@lisp
(defmacro _f (op place &rest args)
     (let ((g (gensym)))
        (multiple-value-bind (vars forms var set access)
                                   (get-setf-method place)
        `(let* ((,g ,op)
                  ,@@(mapcar #'list vars forms)
                  (,(car var) (funcall ,g ,access ,@@args)))
              ,set))))
@end lisp

@noindent
и вызываться ( f #'+ x 1). Но оригинальная версия _f может сделать, что угодно, и 
так как она имеет дело с именами, она также может принять имя макроса или 
специальной формы. Например, кроме +, вы можете вызвать nif (стр. 150):

@example
> (let ((x 2))
        (_f nif x 'p 'z 'n)
        x)
P
@end example

@node 12-5 Defining Inversions,  , 12-4 More Complex Utilities, 12 Generalized Variables
@comment  node-name,  next,  previous,  up
@section 12-5 Определение Инверсий
@cindex 12-5 Defining Inversions

Раздел 12-1 объяснил, что любой вызов макроса, который расширяется в обратимую
ссылку, сам по себе, будет обратимым. Вам не нужно определять операторы как макросы,
только для того чтобы сделать их обратимыми. Используя defsetf вы можете указать
Lisp, как инвертировать любую функцию или вызов макроса.

Этот макрос можно использовать двумя способами. В простейшем случае его аргументы
это два символа:

@lisp
(defsetf symbol-value set)
@end lisp

В более сложной форме, вызов defsetf подобен вызову defmacro, с дополнительным
параметром для обновления значения формы. Например, определим возможную инверсию
формы для car:

@lisp
(defun my-car (lst)
  (car lst))

(defsetf my-car (lst) (new-car)
     `(progn (rplaca ,lst ,new-car)
             ,new-car))

(let ((lst (list 1 2 3))
      (y   7))
  (setf (my-car lst) y)
  (my-car lst)
  );;7


@end lisp

Между defmacro и defsetf есть одно очень важное отличие: последнее автоматически создает
идентификаторы gensyms для своих аргументов. С определением данным выше,

@lisp
(setf (my-car x) y) расшириться до:
(let* ((#:g2 x)
       (#:g1 y))
     (progn (rplaca #:g2 #:g1)
               #:g1))
@end lisp

@cartouche
@lisp
 (defvar *cache* (make-hash-table))

 (defun retrieve (key)
    (multiple-value-bind (x y) (gethash key *cache*)
        (if y
            (values x y)
            (cdr (assoc key *world*)))))

 (defsetf retrieve (key) (val)
    `(setf (gethash ,key *cache*) ,val))
@end lisp

                      Рисунок 12-6: Асиментричная инверсия.
@end cartouche

Таким образом, мы можем писать расширители  defsetf не беспокоясь о захвате
переменных, или числе и порядке вычислений.

В CLTL2 Common Lisp можно задавать инверсии setf непосредственно используя
defun, поэтому предыдущий пример также может быть записан, как:

@lisp
(defun (setf my-car) (new-car lst)
  (rplaca lst new-car)
  new-car)
@end lisp

Обновленное значение должно быть первым параметром в такой функции. Она также,
по соглашению, должна возвращать это значение как значение функции.

До сих пор примеры показывали, что обобщенные переменные предположительно
ссылаются на место в структуре данных. Злодей уносит свою заложницу в темницу,
а спасающий герой поднимает ее обратно; они оба следуют одному и тому же пути, но
в разных направлениях. Не удивительно, если у людей есть представление, что setf 
должен работать таким образом, поскольку все предопределенные инверсии, кажеться,
имеют эту форму; действительно, место - это условное название параметра, который 
должен быть перевернут(инвертирован).

В принципе, setf является более общим: форма доступа и её инверсия не должны работать
на той же структуре данных. Предположим, что в каком то, приложении мы хотим кешировать
обновления базы данных. Это может быть необходимо, например, если бы реальные обновления
на лету делать не эффективно, или если все обновления должны быть сверены для согласованности
перед их совершением(принятием/committing).

Предположим, что *world* является фактической базой данных. Для простоты, мы сделаем
её ассоциативным списком, элементы которого имеют форму (key . val). Рисунок 12-6 
показывает функцию поиска назваемую retrieve. Если *world* это

@lisp
((a . 2) (b . 16) (c . 50) (d . 20) (f . 12))
@end lisp

@noindent
тогда

@example
  > (retrieve 'c)
  50
@end example

В отличии от вызова car, вызов retrieve не ссылается к конкретному месту структуры данных.
Возвращаемое значение может придти от одного из двух мест. И инверсия retrieve, также
определенная на рисунке 12-6, относиться только к одному из них:

@example
> (setf (retrieve 'n) 77)
77
> (retrieve 'n)
77
T
@end example

Этот поиск возвращает вторым значением t, указывающим, что ответ был найден в кеше.

Как и сами макросы, обобщенные переменные являются абстракцией замечательной 
мощности. Здесь, вероятно, еще многое предстоит открыть. Конечно, отдельные
пользователи, вероятно, обнаружат способы, которыми использование обобщенных
переменных может привести к более элегантным и более мощным программам. Но также 
возможно использовать инверсии setf новыми способами, или открыть другие классы,
аналогичных полезных преобразований(трансформаций).