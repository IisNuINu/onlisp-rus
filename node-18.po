#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-18.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 12:04+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-18.texi:5
msgid ""
"@node 18 Destructuring, 19 A Query Compiler, 17 Read-Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 18 Destructuring\n"
"@cindex 18 Destructuring"
msgstr ""
"@node 18 Destructuring, 19 A Query Compiler, 17 Read-Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 18 Деконструкция\n"
"@cindex 18 Destructuring"

#: texi/node-18.texi:11
msgid ""
"Destructuring is a generalization of assignment. The operators setq and "
"setf\n"
"do assignments to individual variables. Destructuring combines assignment "
"with\n"
"access: instead of giving a single variable as the first argument, we give a "
"pattern\n"
"of variables, which are each assigned the value occurring in the "
"corresponding\n"
"position in some structure."
msgstr ""
"Деконструкция это обобщение присваивания. Операторы setq и setf выполняют\n"
"присванивание для отдельных переменных. Деконструкция сочетает в себе "
"присванивание\n"
"с доступом: вместо того, чтобы давать единственную переменную в качестве "
"первого\n"
"аргумента, мы дает образец переменных, каждому из которых присваивается "
"значение,\n"
"встречающееся в соответствующей позиции в некоторой структуре."

#: texi/node-18.texi:18
msgid ""
"@menu\n"
"* 18-1 Destructuring on Lists::  \n"
"* 18-2 Other Structures::       \n"
"* 18-3 Reference::              \n"
"* 18-4 Matching::               \n"
"@end menu"
msgstr ""

#: texi/node-18.texi:23
msgid ""
"@node 18-1 Destructuring on Lists, 18-2 Other Structures, 18 Destructuring, "
"18 Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-1 Destructuring on Lists\n"
"@cindex 18-1 Destructuring on Lists"
msgstr ""
"@node 18-1 Destructuring on Lists, 18-2 Other Structures, 18 Destructuring, "
"18 Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-1 Деконструкция Списков.\n"
"@cindex 18-1 Destructuring on Lists"

#: texi/node-18.texi:29
msgid ""
"As of CLTL2, Common Lisp includes a new macro called destructuring-bind.\n"
"This macro was briefly introduced in Chapter 7. Here we consider it in more\n"
"detail. Suppose that lst is a list of three elements, and we want to bind x "
"to the\n"
"first, y to the second, and z to the third. In raw CLTL1 Common Lisp, we "
"would\n"
"have had to say:"
msgstr ""
"Начиная с CLTL2, Common Lisp включает новый макроса называемый destructuring-"
"bind.\n"
"Этот макроса был кратко представлен в главе 7. Здесь мы рассмотрим его более "
"подробно.\n"
"Предположим, что lst является списком из трех элементов, и мы хотим связать "
"x с первым\n"
"элементом, y со вторым, и z с третьим. В незрелом CLTL1 Common Lisp, мы бы "
"должны были\n"
"сказать:"

#: texi/node-18.texi:36
msgid ""
"@lisp\n"
"(let ((x (first lst))\n"
"        (y (second lst))\n"
"        (z (third lst)))\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:38
msgid "With the new macro we can say instead"
msgstr "С новым макросом весто этого мы можем сказать:"

#: texi/node-18.texi:43
msgid ""
"@lisp\n"
"(destructuring-bind (x y z) lst\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:47
msgid ""
"which is not only shorter, but clearer as well. Readers grasp visual cues "
"much\n"
"faster than textual ones. In the latter form we are shown the relationship "
"between\n"
"x, y, and z; in the former, we have to infer it."
msgstr ""
"что не только короче, но и понятнее. Читатели понимают визуальные подсказки "
"быстрее,\n"
"чем текстовые. В последнем примере нам сразу показывают связь между x, y и "
"z; а в первом\n"
"случае, мы должны делать вывод об этом."

#: texi/node-18.texi:51
msgid ""
"If such a simple case is made clearer by the use of destructuring, imagine "
"the\n"
"improvement in more complex ones. The first argument to destructuring-bind\n"
"can be an arbitrarily complex tree. Imagine"
msgstr ""
"Если такой простой случай проясняется с помощью деконструкции, представьте "
"себе\n"
"улучшение ясности более сложных. Первый аргумент в destructuring-bind\n"
"может быть произвольно сложным деревом. Представьте"

#: texi/node-18.texi:57
msgid ""
"@lisp\n"
"(destructuring-bind ((first last) (month day year) . notes)\n"
"                            birthday\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:60
msgid ""
"written using let and the list access functions. Which raises another "
"point:\n"
"destructuring makes it easier to write programs as well as easier to read "
"them."
msgstr ""
"будет записано с использованием let и функций доступа к списку. Что "
"поднимает еще\n"
"один аргумент: деконструкция облегчает написание программ, а также облегчает "
"их\n"
"чтение."

#: texi/node-18.texi:67
msgid ""
"Destructuring did exist in CLTL1 Common Lisp. If the patterns in the "
"examples\n"
"above look familiar, it's because they have the same form as macro parameter "
"lists.\n"
"In fact, destructuring-bind is the code used to take apart macro argument\n"
"lists, now sold separately. You can put anything in the pattern that you "
"would put\n"
"in a macro parameter list, with one unimportant exception (the &environment\n"
"keyword)."
msgstr ""
"Деконструкция существовала и в CLTL1 Common Lisp. Если шаблоны в примерах "
"выше\n"
"выглядят знакомо, это потому, что они имеют ту же форму, что и списки "
"парамемтров\n"
"макросов. Фактически, destructuring-bind это код, используемый для разбора "
"списка\n"
"аргументов макроса, теперь предоставляемый отдельно. Вы можете положить что "
"нибудь в\n"
"шабон, который вы бы представили в виде списка параметров макроса, за "
"одним \n"
"незначительным исключением(ключевого слова &environment)."

#: texi/node-18.texi:70
msgid ""
"Establishing bindings en masse is an attractive idea. The following "
"sections\n"
"describe several variations upon this theme."
msgstr ""
"Установление массовых привязок является привлекательной идеей. Следующие "
"разделы\n"
"описывают несколько вариаций на эту тему."

#: texi/node-18.texi:75
msgid ""
"@node 18-2 Other Structures, 18-3 Reference, 18-1 Destructuring on Lists, 18 "
"Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-2 Other Structures\n"
"@cindex 18-2 Other Structures"
msgstr ""
"@node 18-2 Other Structures, 18-3 Reference, 18-1 Destructuring on Lists, 18 "
"Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-2 Другие Структуры\n"
"@cindex 18-2 Other Structures"

#: texi/node-18.texi:79
msgid ""
"There is no reason to limit destructuring to lists. Any complex object is a "
"candidate\n"
"for it. This section shows how to write macros like destructuring-bind for\n"
"other kinds of objects."
msgstr ""
"Нет причин ограничивать деконструкцию списками. Любой сложный объект "
"является\n"
"кандидатом для этого. В этом разделе показано, как писать макросы подобные\n"
"destructuring-bind для других видов объектов."

#: texi/node-18.texi:84
msgid ""
"The natural next step is to handle sequences generally. Figure 18-1 contains "
"a\n"
"macro called dbind, which resembles destructuring-bind, but works for any\n"
"kind of sequence. The second argument can be a list, a vector, or any "
"combination\n"
"thereof:"
msgstr ""
"Следующим естественным шагом является обработка в целом последовательностей. "
"Рисунок 18-1\n"
"содержит макрос называемый dbind, который напоминает destructuring-bind, но "
"обрабатывающий\n"
"любой вид последовательностей. Второй аргумент может быть списком, вектором, "
"или любой их\n"
"комбинацией:"

#: texi/node-18.texi:97
msgid ""
"@example\n"
"> (dbind (a b c) #(1 2 3)\n"
"        (list a b c))\n"
"(123)\n"
"> (dbind (a (b c) d) '( 1 #(2 3) 4)\n"
"        (list abcd))\n"
"(1234)\n"
"> (dbind (a (b . c) &rest d) '(1 \"fribble\" 2 3 4)\n"
"        (list abcd))\n"
"(1 #\\f \"ribble\" (2 3 4))\n"
"@end example"
msgstr ""

#: texi/node-18.texi:103
msgid ""
"@lisp\n"
" (defmacro dbind (pat seq &body body)\n"
"       (let ((gseq (gensym)))\n"
"        `(let ((,gseq ,seq))\n"
"           ,(dbind-ex (destruc pat gseq #'atom) body))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro dbind (pat seq &body body)\n"
"       (let ((gseq (gensym)))\n"
"        `(let ((,gseq ,seq))\n"
"           ,(dbind-ex (destruc pat gseq #'atom) body))))"

#: texi/node-18.texi:122
msgid ""
" (defun destruc (pat seq &optional (atom? #'atom) (n 0))\n"
"       (if (null pat)\n"
"          nil\n"
"          (let ((rest (cond ((funcall atom? pat) pat)\n"
"                                ((eq (car pat) '&rest) (cadr pat))\n"
"                                ((eq (car pat) '&body) (cadr pat))\n"
"                                (t nil))))\n"
"           (if rest\n"
"                 `((,rest (subseq ,seq ,n)))\n"
"                 (let ((p (car pat))\n"
"                         (rec (destruc (cdr pat) seq atom? (1+ n))))\n"
"                  (if (funcall atom? p)\n"
"                         (cons `(,p (elt ,seq ,n))\n"
"                               rec)\n"
"                         (let ((var (gensym)))\n"
"                           (cons (cons `(,var (elt ,seq ,n))\n"
"                                         (destruc p var atom?))\n"
"                                 rec))))))))"
msgstr ""

#: texi/node-18.texi:137
msgid ""
" (defun dbind-ex (binds body)\n"
"       (if (null binds)\n"
"          `(progn ,@@body)\n"
"          `(let ,(mapcar #'(lambda (b)\n"
"                                 (if (consp (car b))\n"
"                                       (car b)\n"
"                                       b))\n"
"                            binds)\n"
"            ,(dbind-ex (mapcan #'(lambda (b)\n"
"                                         (if (consp (car b))\n"
"                                              (cdr b)))\n"
"                                    binds)\n"
"                           body))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:139
msgid "             Figure 18-1: General sequence destructuring operator."
msgstr ""
"             Рисунок 18-1: Операции деконструкции обобщенной "
"последовательности.\n"
"@end cartouche"

#: texi/node-18.texi:146
msgid ""
"The #( read-macro is for representing vectors, and #\\ for representing "
"characters.\n"
"Since \"abc\" = #(#\\a #\\b #\\c), the first element of \"fribble\" is the "
"character\n"
"#\\f. For the sake of simplicity, dbind supports only the &rest and &body\n"
"keywords."
msgstr ""
"Макрос чтения #( для представления векторов, и #\\ для представления "
"символьных знаков.\n"
"Поскольку \"abc\" = #(#\\a #\\b #\\c), первым элементом \"fribble\" является "
"знак #\\f. Для\n"
"простоты, dbind поддерживает только ключевые слова &rest и &body\n"
"keywords."

#: texi/node-18.texi:159
msgid ""
"Compared to most of the macros seen so far, dbind is big. It's worth "
"studying\n"
"the implementation of this macro, not only to understand how it works, but "
"also\n"
"because it embodies a general lesson about Lisp programming. As section 3-4\n"
"mentioned, Lisp programs may intentionally be written in a way that will "
"make\n"
"them easy to test. In most code, we have to balance this desire against the "
"need\n"
"for speed. Fortunately, as Section 7-8 explained, speed is not so important "
"in\n"
"expander code. When writing code that generates macroexpansions, we can "
"make\n"
"life easier for ourselves. The expansion of dbind is generated by two "
"functions,\n"
"destruc and dbind-ex. Perhaps they both could be combined into one function\n"
"which would do everything in a single pass. But why bother? As two separate\n"
"functions, they will be easier to test. Why trade this advantage for speed "
"we don't\n"
"need?"
msgstr ""
"По сравнению с большинством макросов, dbind большой. Стоит поучиться "
"реализации\n"
"данного макроса, не только для того чтобы понять как он работает, но и "
"потому\n"
"что он воплощает главный урок о Lisp программировании. Как уже упоминалось "
"в\n"
"разделе 3-4, программы Lisp могут быть написаны так, чтобы их легко было "
"проверять.\n"
"В большинстве кода, мы должны сбалансировать это желание с необходимостью "
"достижения\n"
"высокой скорости. К счастью, как объяснил Раздел 7-8, скорость не так важна "
"в\n"
"коде расширителя. При написании кода, который генерирует расширение макроса, "
"мы\n"
"можем облегчить себе жизнь. Расширение dbind создает две функции, destruc и "
"dbind-ex.\n"
"Возможно, их обе объединить в одну функцию, которая сделала бы все за один "
"проход.\n"
"Но зачем? А две раздельные функции, легче тестировать. Зачем обменивать это "
"преимущество\n"
"на скорость, которая нам не нужна?"

#: texi/node-18.texi:162
msgid ""
"The first function, destruc, traverses the pattern and associates each "
"variable\n"
"with the location of the corresponding object at runtime:"
msgstr ""
"Первая функция destruc, обходит шаблон и связывает каждую переменную с "
"расположением\n"
"соответствующего объекта во время выполнения:"

#: texi/node-18.texi:167
msgid ""
"@example\n"
"> (destruc '(a b c) 'seq #'atom)\n"
"((A (ELT SEQ 0)) (B (ELT SEQ 1)) (C (ELT SEQ 2)))\n"
"@end example"
msgstr ""

#: texi/node-18.texi:170
msgid ""
"The optional third argument is the predicate used to distinguish pattern "
"structure\n"
"from pattern content."
msgstr ""
"Необязательный третий аргумент - это предикат используемый для отделения "
"струкутры\n"
"шаблона от содержимого шаблона."

#: texi/node-18.texi:173
msgid ""
"To make access more efficient, a new variable (a gensym) will be bound to\n"
"each subsequence:"
msgstr ""
"Чтобы сделать доступ более эффективным, к каждой подпоследовательности будет "
"привязана\n"
"новая (gensym) переменная:"

#: texi/node-18.texi:181
msgid ""
"@example\n"
"> (destruc '(a (b . c) &rest d) 'seq)\n"
"((A (ELT SEQ 0))\n"
" ((#:G2 (ELT SEQ 1)) (B (ELT #:G2 0)) (C (SUBSEQ #:G2 1)))\n"
" (D (SUBSEQ SEQ 2)))\n"
"@end example"
msgstr ""

#: texi/node-18.texi:185
msgid ""
"The output of destruc is sent to dbind-ex, which generates the bulk of the\n"
"macroexpansion. It translates the tree produced by destruc into a nested "
"series\n"
"of lets:"
msgstr ""
"Вывод destruc передается в dbind-ex, который генерирует большую часть "
"расширения\n"
"макроса. Он переводит дерево созданное destruc в ряд вложенных let:"

#: texi/node-18.texi:196
msgid ""
"@example\n"
"> (dbind-ex (destruc '(a (b . c) &rest d) 'seq) '(body))\n"
"(LET ((A (ELT SEQ 0))\n"
"          (#:G4 (ELT SEQ 1))\n"
"          (D (SUBSEQ SEQ 2)))\n"
"  (LET ((B (ELT #:G4 0))\n"
"             (C (SUBSEQ #:G4 1)))\n"
"        (PROGN BODY)))\n"
"@end example"
msgstr ""

#: texi/node-18.texi:213
msgid ""
"@lisp\n"
" (defmacro with-matrix (pats ar &body body)\n"
"       (let ((gar (gensym)))\n"
"         `(let ((,gar ,ar))\n"
"             (let ,(let ((row -1))\n"
"                        (mapcan\n"
"                           #'(lambda (pat)\n"
"                                (incf row)\n"
"                                (setq col -1)\n"
"                                (mapcar #'(lambda (p)\n"
"                                                `(,p (aref ,gar\n"
"                                                                 ,row\n"
"                                                                 ,(incf "
"col))))\n"
"                                            pat))\n"
"                           pats))\n"
"                ,@@body))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-matrix (pats ar &body body)\n"
"       (let ((gar (gensym)))\n"
"         `(let ((,gar ,ar))\n"
"             (let ,(let ((row -1))\n"
"                        (mapcan\n"
"                           #'(lambda (pat)\n"
"                                (incf row)\n"
"                                (setq col -1)\n"
"                                (mapcar #'(lambda (p)\n"
"                                                `(,p (aref ,gar\n"
"                                                                 ,row\n"
"                                                                 ,(incf "
"col))))\n"
"                                            pat))\n"
"                           pats))\n"
"                ,@@body))))"

#: texi/node-18.texi:222
msgid ""
" (defmacro with-array (pat ar &body body)\n"
"       (let ((gar (gensym)))\n"
"         `(let ((,gar ,ar))\n"
"             (let ,(mapcar #'(lambda (p)\n"
"                                      `(,(car p) (aref ,gar ,@@(cdr p))))\n"
"                                pat)\n"
"                ,@@body))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:224
msgid "                        Figure 18-2: Destructuring on arrays."
msgstr ""
"                        Рисунок 18-2: Деконструкция массивов.\n"
"@end cartouche"

#: texi/node-18.texi:229
msgid ""
"Note that dbind, like destructuring-bind, assumes that it will find all the\n"
"list structure it is looking for. Left-over variables are not simply bound "
"to nil,as\n"
"with multiple-value-bind. If the sequence given at runtime does not have "
"all\n"
"the expected elements, destructuring operators generate an error:"
msgstr ""
"Обратите внимание, что dbind, как и destructuring-bind, предполагает, что он "
"найдет\n"
"всю структуру списка, которую он просматирвает. Оставшиеся переменные не "
"просто\n"
"связываются с nil, а с использованием multiple-value-bind. Если "
"последовательность,\n"
"заданная во время выполнения, не имеет всех ожидаемых элементов,  операторы\n"
"деконструкции выдают ошибку:"

#: texi/node-18.texi:235
msgid ""
"@example\n"
"> (dbind (a b c) (list 1 2))\n"
">>Error: 2 is not a valid index for the sequence (1 2)\n"
"@end example"
msgstr ""

#: texi/node-18.texi:241
msgid ""
"What other objects have internal structure? There are arrays generally, "
"which\n"
"differ from vectors in having more than one dimension. If we define a "
"destructuring\n"
"macro for arrays, how do we represent the pattern? For two-dimensional "
"arrays,\n"
"it is still practical to use a list. Figure 18-2 contains a macro, with-"
"matrix, for\n"
"destructuring on two-dimensional arrays."
msgstr ""
"Какие еще объекты имеют внутреннюю структуру? Обычно есть массивы, которые "
"отличаются\n"
"от векторов, наличием более чем одной размерности. Если мы определеим макрос "
"деконструкции\n"
"для массивов, как мы представим шаблон? Для двумерных массивов, все еще "
"будет практичным\n"
"использовать список. Рисунок 18-2 содержит макрос with-matrix для "
"деконструкции двумерных\n"
"массивов."

#: texi/node-18.texi:251
msgid ""
"@lisp\n"
"  (defmacro with-struct ((name . fields) struct &body body)\n"
"         (let ((gs (gensym)))\n"
"            `(let ((,gs ,struct))\n"
"                (let ,(mapcar #'(lambda (f)\n"
"                                        `(,f (,(symb name f) ,gs)))\n"
"                                  fields)\n"
"                  ,@@body))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"  (defmacro with-struct ((name . fields) struct &body body)\n"
"         (let ((gs (gensym)))\n"
"            `(let ((,gs ,struct))\n"
"                (let ,(mapcar #'(lambda (f)\n"
"                                        `(,f (,(symb name f) ,gs)))\n"
"                                  fields)\n"
"                  ,@@body))))\n"
"@end lisp"

#: texi/node-18.texi:253
msgid "                         Figure 18-3: Destructuring on structures."
msgstr ""
"                         Рисунок 18-3: Деконструкция структур.\n"
"@end cartouche"

#: texi/node-18.texi:267
msgid ""
"@example\n"
"> (setq ar (make-array '(3 3)))\n"
"#<Simple-Array T (3 3) C2D39E>\n"
"> (for (r 0 2)\n"
"          (for (c 0 2)\n"
"             (setf (aref ar r c) (+ (* r 10) c))))\n"
"NIL\n"
"> (with-matrix ((a b c)\n"
"                          (def)\n"
"                          (g h i)) ar\n"
"          (list abcdefghi))\n"
"(012101112202122)\n"
"@end example"
msgstr ""

#: texi/node-18.texi:274
msgid ""
"For large arrays or those with dimension 3 or higher, we want a different "
"kind\n"
"of approach. We are not likely to want to bind variables to each element of "
"a large\n"
"array. It will be more practical to make the pattern a sparse representation "
"of the\n"
"array-containing variables for only a few elements, plus coordinates to "
"identify\n"
"them. The second macro in Figure 18-2 is built on this principle. Here we "
"use it\n"
"to get the diagonal of our previous array:"
msgstr ""
"Для больших массивов или массивов размероностью 3 и выше, нам надо "
"использовать\n"
"другой подход. Мы вряд ли захотим связывать переменные с каждым элементом "
"большого\n"
"массива. Будет более практичным сделать шаблон с разреженным представлением "
"массива,\n"
"содержащим переменные только для нескольких элементов, а также координаты "
"для их\n"
"их идентификации. Второй макрос на Рисунке 18-2 создан по этому принципу. "
"Здесь мы\n"
"используем его, для того чтобы получить диагональ предыдущего массива:"

#: texi/node-18.texi:281
msgid ""
"@example\n"
"> (with-array ((a 0 0) (d 1 1) (i 2 2)) ar\n"
"          (values a d i))\n"
"01122\n"
"@end example"
msgstr ""

#: texi/node-18.texi:288
msgid ""
"With this new macro we have begun to move away from patterns whose\n"
"elements must occur in a fixed order. We can make a similar sort of macro to "
"bind\n"
"variables to fields in structures built by defstruct. Such a macro is "
"defined in\n"
"Figure 18-3. The first argument in the pattern is taken to be the prefix "
"associated\n"
"with the structure, and the rest are field names. To build access calls, "
"this macro\n"
"uses symb (page 58)."
msgstr ""
"С этим новым макросом мы начали отходить от шаблонов, элементы которых "
"должны появляться\n"
"в фиксированном порядке. Мы можем создать подобный макрос для привязки "
"переменных к полякм\n"
"в структурах созданных с помощью defstruct. Такой макрос определен на "
"Рисунке 18-3. Первым\n"
"аргументов в шаблоне будет префик, связанный со стуктурой, а остальные - "
"имена полей.\n"
"Для построения вызовов доступа этот макрос использует symb (стр. 58)."

#: texi/node-18.texi:300
msgid ""
"@example\n"
"> (defstruct visitor name title firm)\n"
"VISITOR\n"
"> (setq theo (make-visitor :name \"Theodebert\"\n"
"                                      :title 'king\n"
"                                      :firm 'franks))\n"
"#S(VISITOR NAME \"Theodebert\" TITLE KING FIRM FRANKS)\n"
"> (with-struct (visitor- name firm title) theo\n"
"        (list name firm title))\n"
"(\"Theodebert\" FRANKS KING)\n"
"@end example"
msgstr ""

#: texi/node-18.texi:305
msgid ""
"@node 18-3 Reference, 18-4 Matching, 18-2 Other Structures, 18 "
"Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-3 Reference\n"
"@cindex 18-3 Reference"
msgstr ""
"@node 18-3 Reference, 18-4 Matching, 18-2 Other Structures, 18 "
"Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-3 Ссылки\n"
"@cindex 18-3 Reference"

#: texi/node-18.texi:309
msgid ""
"CLOS brings with it a macro for destructuring on instances. Suppose tree is "
"a\n"
"class with three slots, species, age, and height, and that my-tree is an "
"instance\n"
"of tree. Within"
msgstr ""
"CLOS приносит с собой макрос для деконструкции экземпляров. Предположим, что "
"tree\n"
"(дерево) это клас с тремя слотами: порода(species), возраст(age), и "
"высота(height),\n"
"и my-tree это экземпляр tree. В"

#: texi/node-18.texi:314
msgid ""
"@lisp\n"
"(with-slots (species age height) my-tree\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:319
msgid ""
"@noindent\n"
"we can refer to the slots of my-tree as if they were ordinary variables. "
"Within the\n"
"body of the with-slots, the symbol height refers to the height slot. It is "
"not\n"
"simply bound to the value stored there, but refers to the slot, so that if "
"we write:"
msgstr ""
"@noindent\n"
"мы можем ссылаться на слоты my-tree, как если бы они были обычными "
"переменными. В\n"
"пределах тела with-slots, символ height ссылается на слот height. Он не "
"просто\n"
"связан со значением хранящимся в нем, но он ссылается на этот слот, так что "
"если\n"
"мы напишем:"

#: texi/node-18.texi:323
msgid ""
"@lisp\n"
"(setq height 72)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:328
msgid ""
"then the height slot of my-tree will be given the value 72. This macro works "
"by\n"
"defining height as a symbol-macro (Section 7-11) which expands into a slot "
"refer-\n"
"ence. In fact, it was to support macros like with-slots that symbol-"
"macrolet\n"
"was added to Common Lisp."
msgstr ""
"тогда слоту height в my-tree будет присвоено значение 72. Этот макрос "
"работает\n"
"как определение height как макрос-символ (Раздел 7-11) который расширяется "
"до\n"
"ссылки на слот. На самом деле, он был должен поддерживать макросы, такие как "
"with-slots,\n"
"symbol-macrolet был добавлен в Common Lisp."

#: texi/node-18.texi:333
msgid ""
"Whether or not with-slots is really a destructuring macro, it has the same\n"
"role pragmatically as destructuring-bind. As conventional destructuring is\n"
"to call-by-value, this new kind is to call-by-name. Whatever we call it, it "
"looks to\n"
"be useful. What other macros can we define on the same principle?"
msgstr ""
"Является или нет на самом деле with-slots макросом деконструкции, он играет "
"ту же\n"
"прагматичну роль, что и destructuring-bind. Так как обычная деконструкция "
"это\n"
"вызов по значению, это новый вид  - вызов по имени. Как бы мы его не "
"называли,\n"
"он выглядит очень полезным. Какие еще макросы мы можем определить по этому\n"
"принципу?"

#: texi/node-18.texi:338
msgid ""
"We can create a call-by-name version of any destructuring macro by making "
"it\n"
"expand into a symbol-macrolet rather than a let. Figure 18-4 shows a "
"version\n"
"of dbind modified to behave like with-slots. We can use with-places as we\n"
"do dbind:"
msgstr ""
"Мы можем создать вызов по имени для любого макроса деконструкции, расширяя "
"его\n"
"до symbol-macrolet, а не до let. На рисунке 18-4 показана версия dbind "
"модифицированная\n"
"для поведения, аналогичного with-slots. Мы можем использовать with-places "
"также как\n"
"dbind:"

#: texi/node-18.texi:345
msgid ""
"@example\n"
"> (with-places (a b c) #(1 2 3)\n"
"        (list a b c))\n"
"(123)\n"
"@end example"
msgstr ""
"@example\n"
"> (with-places (a b c) #(1 2 3)\n"
"        (list a b c))\n"
"(1 2 3)\n"
"@end example"

#: texi/node-18.texi:351
msgid ""
"@lisp\n"
" (defmacro with-places (pat seq &body body)\n"
"    (let ((gseq (gensym)))\n"
"         `(let ((,gseq ,seq))\n"
"                ,(wplac-ex (destruc pat gseq #'atom) body))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-places (pat seq &body body)\n"
"    (let ((gseq (gensym)))\n"
"         `(let ((,gseq ,seq))\n"
"                ,(wplac-ex (destruc pat gseq #'atom) body))))"

#: texi/node-18.texi:366
msgid ""
" (defun wplac-ex (binds body)\n"
"    (if (null binds)\n"
"           `(progn ,@@body)\n"
"           `(symbol-macrolet ,(mapcar #'(lambda (b)\n"
"                                                     (if (consp (car b))\n"
"                                                         (car b)\n"
"                                                         b))\n"
"                                               binds)\n"
"                 ,(wplac-ex (mapcan #'(lambda (b)\n"
"                                            (if (consp (car b))\n"
"                                                   (cdr b)))\n"
"                                       binds)\n"
"                             body))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:368
msgid "                  Figure 18-4: Reference destructuring on sequences."
msgstr ""
"                  Рисунок 18-4: Ссылочная деконструкция "
"последовательностей.\n"
"@end cartouche"

#: texi/node-18.texi:372
msgid ""
"But the new macro also gives us the option to setf positions in sequences, "
"as we\n"
"do slots in with-slots:"
msgstr ""
"Но новый макрос также дает нам возможность присваивать позиции в "
"последовательностях \n"
"с помощью setf, как мы это делали с помощью with-slots:"

#: texi/node-18.texi:381
msgid ""
"@example\n"
"> (let ((lst '(1 (2 3) 4)))\n"
"        (with-places (a (b . c) d) lst\n"
"          (setf a 'uno)\n"
"          (setf c '(tre)))\n"
"        lst)\n"
"(UNO (2 TRE) 4)\n"
"@end example"
msgstr ""

#: texi/node-18.texi:387
msgid ""
"As in a with-slots, the variables now refer to the corresponding locations "
"in the\n"
"structure. There is one important difference, however: you must use setf "
"rather\n"
"than setq to set these pseudo-variables. The with-slots macro must invoke\n"
"a code-walker (page 273) to transform setqs into setfs within its body. "
"Here,\n"
"writing a code-walker would be a lot of code for a small refinement."
msgstr ""
"Как и в случае с with-slots, переменные теперь ссылаются на соответствующие "
"места\n"
"в структуре. Однако есть одно важное отличие: вы должны использовать setf, а "
"не\n"
"setq, чтобы установить эти псевдо-переменные. Макрос with-slots должен "
"вызывать\n"
"code-walker (стр 273), чтобы преобразовать setq в setf внутри своего тела. "
"Здесь,\n"
"написание code-walker потребует много кода для небольшого уточнения."

#: texi/node-18.texi:395
msgid ""
"If with-places is more general than dbind, why not just use it all the "
"time?\n"
"While dbind associates a variable with a value, with-places associates it "
"with\n"
"a set of instructions for finding a value. Every reference requires a "
"lookup. Where\n"
"dbind would bind c to the value of (elt x 2), with-places will make c a\n"
"symbol-macro that expands into (elt x 2).Soifc is evaluated n times in the\n"
"body, that will entail n calls to elt. Unless you actually want to setf the "
"variables\n"
"created by destructuring, dbind will be faster."
msgstr ""
"Если with-places является более общим чем dbind, почему бы просто не "
"использовать его\n"
"постоянно? В то время как dbind связывает переменную со значением, with-"
"places связвает\n"
"ее с набором инструкций для поиска значения. Каждая ссылка требует поиска. "
"Где dbind \n"
"будет связвать символ c со значением (elt x 2), with-places сделает символ c "
"символом\n"
"макросом, который расширяется в (elt x 2). Таким образом, если c вычисляется "
"n раз в \n"
"теле, это повлечет за собой n вызвов elt. Если вы на самом деле не хотите "
"присваивать(setf)\n"
"переменные созданные деконструкцией,  dbind будет работать быстрее."

#: texi/node-18.texi:400
msgid ""
"The definition of with-places is only slightly changed from that of dbind\n"
"(Figure 18-1). Within wplac-ex (formerly dbind-ex) the let has become\n"
"a symbol-macrolet. By similar alterations, we could make a call-by-name\n"
"version of any normal destructuring macro."
msgstr ""
"Определение with-places немного отличается от определения dbind\n"
"(Рисунок 18-1). Вn wplac-ex (ранее dbind-ex)  let стала symbol-macrolet. \n"
"С помощью аналогичных изменений, мы можем сделать версию вызова по имени\n"
"для любого обычного деконструирующего макроса."

#: texi/node-18.texi:404
msgid ""
"@node  18-4 Matching,  , 18-3 Reference, 18 Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-4 Matching"
msgstr ""
"@node  18-4 Matching,  , 18-3 Reference, 18 Destructuring\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 18-4 Сопоставления"

#: texi/node-18.texi:410
msgid ""
"As destructuring is a generalization of assignment, pattern-matching is a "
"gener-\n"
"alization of destructuring. The term \"pattern-matching\" has many senses. "
"In this\n"
"context, it means comparing two structures, possibly containing variables, "
"to see\n"
"if there is some way of assigning values to the variables which makes the "
"two\n"
"equal. For example, if ?x and ?y are variables, then the two lists"
msgstr ""
"Как деконструкция является обобщением присваивания, сопоставление с образцом "
"является\n"
"обобщением деконструкции. Термин \"сопоставление с образцом\" имеет много "
"смыслов. В\n"
"данном конетексте, он означает сравнение двух структур, возможно содержащих "
"переменные,\n"
"чтобы выяснить, существует ли какой либо спосбо присвоения значений "
"переменным, который\n"
"сделает их равным. Например, если ?x и ?y являются переменными, то два списка"

#: texi/node-18.texi:417
msgid ""
"@lisp\n"
"   (p ?x ?y c ?x)\n"
"   (\n"
"        pabca\n"
"                       )\n"
"@end lisp"
msgstr ""
"@lisp\n"
"   (p ?x ?y  c ?x)\n"
"   (p a   b  c  a)\n"
"@end lisp"

#: texi/node-18.texi:419
msgid "match when ?x = a and ?y = b. And the lists"
msgstr "соответсвуют, когда ?x = a и ?y = b. И списки"

#: texi/node-18.texi:424
msgid ""
"@lisp\n"
"   (p ?x b ?y a)\n"
"   (p ?y b c a)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:426
msgid "match when ?x = ?y = c."
msgstr "соответствуют, когда ?x = ?y = c."

#: texi/node-18.texi:431
msgid ""
"Suppose a program works by exchanging messages with some outside source.\n"
"To respond to a message, the program has to tell what kind of message it is, "
"and\n"
" also to extract its specific content. With a matching operator we can "
"combine the\n"
" two steps."
msgstr ""
"Предположим, что программа работает путем обмена сообщениями с внешним "
"источником.\n"
"Чтобы ответить на сообщение, программе надо сообщить, какой тип имеет это "
"сообщение,\n"
"а также извлечь конкретное содержание. С оператором сопоставления мы можем "
"объединить\n"
"эти два шага."

#: texi/node-18.texi:438
msgid ""
"To be able to write such an operator we have to invent some way of distin-\n"
"guishing variables. We can't just say that all symbols are variables, "
"because we\n"
"will want symbols to occur as arguments within patterns. Here we will say "
"that\n"
"a pattern variable is a symbol beginning with a question mark. If it becomes "
"in-\n"
"convenient, this convention could be changed simply by redefining the "
"predicate\n"
"var?."
msgstr ""
"Чтобы написать такой оператор, мы должны придумать способ различения "
"переменных. \n"
"Мы не можем просто сказать, что все символы являются переменными, потому что "
"мы\n"
"хотим, чтобы символы появлялись как аргументы в образцах. Здесь мы скажем, "
"что\n"
"переменная образца это символ начинающийся со знака вопроса. Если это "
"станет\n"
"не удобным, это соглашение можно изменить, просто определив предикат var?."

#: texi/node-18.texi:442
msgid ""
"Figure 18-5 contains a pattern-matching function similar to ones that "
"appear\n"
"in several introductions to Lisp. We give match two lists, and if they can "
"be made\n"
"to match, we will get back a list showing how:"
msgstr ""
"Рисунок 18-5 содержит функцию сопоставления с образцом, аналогичную той, "
"которая\n"
"приводилась во введении в Lisp. Мы даем  match два списка, и если они могут\n"
"быть сопоставлены, мы получаем назад список показывающий как это сделать:"

#: texi/node-18.texi:448
msgid ""
"@example\n"
"   > (match '(pabca)'(p?x?yc?x))\n"
"   ((?Y . B) (?X . A))\n"
"   T\n"
"@end example"
msgstr ""

#: texi/node-18.texi:460
msgid ""
"@lisp\n"
"     (defun match (x y &optional binds)\n"
"       (acond2\n"
"        ((or (eql x y) (eql x '_) (eql y '_)) (values binds t))\n"
"        ((binding x binds) (match it y binds))\n"
"        ((binding y binds) (match x it binds))\n"
"        ((varsym? x) (values (cons (cons x y) binds) t))\n"
"        ((varsym? y) (values (cons (cons y x) binds) t))\n"
"        ((and (consp x) (consp y) (match (car x) (car y) binds))\n"
"          (match (cdr x) (cdr y) it))\n"
"        (t (values nil nil))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun match (x y &optional binds)\n"
"       (acond2\n"
"        ((or (eql x y) (eql x '_) (eql y '_)) (values binds t))\n"
"        ((binding x binds) (match it y binds))\n"
"        ((binding y binds) (match x it binds))\n"
"        ((varsym? x) (values (cons (cons x y) binds) t))\n"
"        ((varsym? y) (values (cons (cons y x) binds) t))\n"
"        ((and (consp x) (consp y) (match (car x) (car y) binds))\n"
"          (match (cdr x) (cdr y) it))\n"
"        (t (values nil nil))))"

#: texi/node-18.texi:463
msgid ""
"     (defun varsym? (x)\n"
"       (and (symbolp x) (eq (char (symbol-name x) 0) #\\?)))"
msgstr ""

#: texi/node-18.texi:472
msgid ""
"     (defun binding (x binds)\n"
"       (labels ((recbind (x binds)\n"
"                  (aif (assoc x binds)\n"
"                         (or (recbind (cdr it) binds)\n"
"                              it))))\n"
"        (let ((b (recbind x binds)))\n"
"          (values (cdr b) b))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:474
msgid "                        Figure 18-5: Matching function."
msgstr ""
"                        Рисунок 18-5: Функции Сопоставления.\n"
"@end cartouche"

#: texi/node-18.texi:482
msgid ""
"@example\n"
"> (match '(p ?x b ?y a) '(p ?y b c a))\n"
"((?Y . C) (?X . ?Y))\n"
"T> (match '(a b c) '(a a a))\n"
"NIL\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-18.texi:488
msgid ""
"As match compares its arguments element by element, it builds up "
"assignments\n"
"of values to variables, called bindings, in the parameter binds. If the "
"match is\n"
"successful, match returns the bindings generated, otherwise it returns nil. "
"Since\n"
"not all successful matches generate any bindings, match, like gethash, "
"returns a\n"
"second value to indicate whether the match succeeded or failed:"
msgstr ""
"Когда match сравнивает свои аргументы элемент за элементом, она создает\n"
"присваивания значений переменным, называемые привязками, в в параметре "
"binds. Если\n"
"сопоставление проходит успешно, match возвращает сгенерированные привязки, "
"в\n"
"противном случае возвращается nil. Поскольку не все успешные совпадения "
"генерируют\n"
"какие-либо привязки, match как и gethash, возвращает второе значение, чтобы "
"указать,\n"
"был ли вызов match успешными или неудачным:"

#: texi/node-18.texi:494
msgid ""
"@example\n"
"> (match '(p ?x) '(p ?x))\n"
"NIL\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-18.texi:503
msgid ""
"@lisp\n"
"     (defmacro if-match (pat seq then &optional else)\n"
"       `(aif2 (match ',pat ,seq)\n"
"                (let ,(mapcar #'(lambda (v)\n"
"                                        `(,v (binding ',v it)))\n"
"                                  (vars-in then #'atom))\n"
"                    ,then)\n"
"                ,else))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defmacro if-match (pat seq then &optional else)\n"
"       `(aif2 (match ',pat ,seq)\n"
"                (let ,(mapcar #'(lambda (v)\n"
"                                        `(,v (binding ',v it)))\n"
"                                  (vars-in then #'atom))\n"
"                    ,then)\n"
"                ,else))"

#: texi/node-18.texi:509
msgid ""
"     (defun vars-in (expr &optional (atom? #'atom))\n"
"       (if (funcall atom? expr)\n"
"            (if (var? expr) (list expr))\n"
"            (union (vars-in (car expr) atom?)\n"
"                     (vars-in (cdr expr) atom?))))"
msgstr ""

#: texi/node-18.texi:513
msgid ""
"     (defun var? (x)\n"
"       (and (symbolp x) (eq (char (symbol-name x) 0) #\\?)))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:515
msgid "                        Figure 18-6: Slow matching operator."
msgstr ""
"                        Рисунок 18-6: Медленные операторы сопоставления.\n"
"@end cartouche"

#: texi/node-18.texi:519
msgid ""
"When match returns nil and t as above, it indicates a successful match "
"which\n"
"yielded no bindings."
msgstr ""
"Когда match возвращает nil и t, как указано выше, это указывает на "
"успешное \n"
"совпадение, которое не дало никаких  привязок."

#: texi/node-18.texi:522
msgid ""
"Like Prolog, match treats (underscore) as a wild-card. It matches "
"everything,\n"
"and has no effect on the bindings:"
msgstr ""
"Как и в Prolog, match рассматривает (подчеркивание) как произвольный знак. "
"Он\n"
"может соответствовать чему угодно, и не влияет на привязки:"

#: texi/node-18.texi:529
msgid ""
"@example\n"
"> (match '(a ?x b) '(_ 1 _))\n"
"((?X . 1))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-18.texi:537
msgid ""
"Given match, it is easy to write a pattern-matching version of dbind. Fig-\n"
"ure 18-6 contains a macro called if-match. Like dbind, its first two "
"arguments\n"
"are a pattern and a sequence, and it establishes bindings by comparing the "
"pattern\n"
"with the sequence. However, instead of a body it has two more arguments: a "
"then\n"
"clause to be evaluated, with new bindings, if the match succeeds; and an "
"else\n"
"clause to be evaluated if the match fails. Here is a simple function which "
"uses\n"
"if-match:"
msgstr ""
"Учитывая match, легко написать версию dbind для сопоставления с образцом. "
"На\n"
"Рисунке 18-6 содержиться макрос с именем if-match. Как и dbind, его первые "
"два\n"
"аргуемнта это образец и последовательность, и он устанавливает привязки "
"сравнивая\n"
"образец с последовательностью. Однако, вместо тело у него есть еще два "
"аргумента:\n"
"предложение then вычисляемое с новыми привязками, если совпадение найдено; "
"и\n"
"предложение else вычисляемое в случае сбоя сопоставления. Вот простая "
"функция,\n"
"которая использует if-match:"

#: texi/node-18.texi:544
msgid ""
"@lisp\n"
"(defun abab (seq)\n"
"     (if-match (?x ?y ?x ?y) seq\n"
"           (values ?x ?y)\n"
"           nil))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:546
msgid ""
"If the match succeeds, it will establish values for ?x and ?y, which will be "
"returned:"
msgstr ""
"Если match выполняется успешно, оно устанавливает значения для ?x и ?y, "
"которые будут возвращены:"

#: texi/node-18.texi:552
msgid ""
"@example\n"
"> (abab '(hi ho hi ho))\n"
"HI\n"
"HO\n"
"@end example"
msgstr ""

#: texi/node-18.texi:558
msgid ""
"The function vars-in returns all the pattern variables in an expression. It\n"
"calls var? to test if something is a variable. At the moment, var? is "
"identical to\n"
"varsym? (Figure 18-5), which is used to detect variables in binding lists. "
"We have\n"
"two distinct functions in case we want to use different representations for "
"the two\n"
"kinds of variables."
msgstr ""
"Функция vars-in возвращает все переменные образца в выражении. Он вызывает  "
"var? \n"
"чтобы проверить, является что-либо переменной. На данный момент var? "
"является \n"
"идентичным varsym? (Рисунок 18-5), который используется для обнаружения "
"переменных в\n"
"списках привязок. У нас есть две разные функции на случай если мы захотим "
"использовать\n"
"разные представления для двух типов переменых."

#: texi/node-18.texi:565
msgid ""
"As defined in Figure 18-6, if-match is short, but not very efficient. It "
"does\n"
"too much work at runtime. We traverse both sequences at runtime, even "
"though\n"
"the first is known at compile-time. Worse still, during the process of "
"matching, we\n"
"cons up lists to hold the variable bindings. If we take advantage of "
"information\n"
"known at compile-time, we can write a version of if-match which performs no\n"
"unnecessary comparisons, and doesn't cons at all."
msgstr ""
"Определеное на Рисунке 18-6 if-match является коротки, но не очень "
"эффективным. Оно\n"
"делает слишком много работы во время выполнения. Мы  проходим по двум "
"последовательностям\n"
"во время выполнения, хотя первая уже известна  во время копиляции. Что еще "
"хуже, в \n"
"процессе сопоставления, мы создаем списки для хранения привязок переменных. "
"Если \n"
"мы воспользуемся информацией известной во время коомпиляции, мы сможем "
"написать\n"
"версию if-match, которая не будет выполнять не нужных сравнений и не имеет \n"
"недостатков использования cons."

#: texi/node-18.texi:572
msgid ""
"If one of the sequences is known at compile-time, and only that one "
"contains\n"
"variables, then we can go about things differently. In a call to match, "
"either\n"
"argument could contain variables. By restricting variables to the first "
"argument\n"
"of if-match, we make it possible to tell at compile-time which variables "
"will\n"
"be involved in the match. Then instead of creating lists of variable "
"bindings, we\n"
"could keep the values of variables in the variables themselves."
msgstr ""
"Если одна из последовательностей известна во время компиляции, и это та "
"которая\n"
"содержит переменные, тогда мы можем действовать по другому. В вызове match "
"любой\n"
"аргуемнт может содержать переменные. Ограничивая переменные только первым "
"аргументом\n"
"if-match, мы позволяем указать во время компиляции, какие переменные будут "
"учавствовать\n"
"в сопоставлении. Тогда вместо создания списков привязок переменных, мы могли "
"бы хранить\n"
"значения переменных в самих переменных."

#: texi/node-18.texi:577
msgid ""
"The new version of if-match appears in Figure 18-7 and 18-8. When we can\n"
"predict what code would be evaluated at runtime, we can simply generate it "
"at\n"
"compile-time. Here, instead of expanding into a call to match, we generate "
"code\n"
"which performs just the right comparisons."
msgstr ""
"Новая версия if-match показана на рисунках 18-7 и 18-8. Когда мы можем "
"предсказать,\n"
"какой код будет вычисляться во время выполнения, мы можем просто "
"сгенерировать его\n"
"во время компиляции. Здесь, вместо расширения в вызов match, мы генерируе "
"код\n"
"который выполняет только правильныеп сравнения."

#: texi/node-18.texi:585
msgid ""
"If we are going to use the variable ?x to contain the binding of ?x, how do "
"we\n"
"represent a variable for which no binding has yet been established by the "
"match?\n"
"Here we will indicate that a pattern variable is unbound by binding it to a "
"gensym.\n"
"So if-match begins by generating code which will bind all the variables in "
"the\n"
"pattern to gensyms. In this case, instead of expanding into a with-gensyms, "
"it's\n"
"safe to make the gensyms once at compile-time and insert them directly into "
"the\n"
"expansion."
msgstr ""
"Если мы собираемся использовать переменную ?x, чтобы содержать привязку ?x, "
"как\n"
"нам представить переменную, для которой совпадение еще не было установлено "
"match?\n"
"Здесь мы укажем, что переменная образца не связана, связывая её с gensym.\n"
"Поэтому if-match начинается с генерации генерации кода, который будет "
"связывать\n"
"все переменные образца с gensyms. В этом случае, вместо того чтобы "
"расширятсья в\n"
"with-gensyms, безопасно создавать gensyms один раз во время компиляции и "
"вставлять\n"
"их непросредственно в расширение."

#: texi/node-18.texi:590
msgid ""
"The rest of the expansion is generated by pat-match. This macro takes\n"
"the same arguments as if-match; the only difference is that it establishes "
"no\n"
"new bindings for pattern variables. In some situations this is an advantage, "
"and\n"
"Chapter 19 will use pat-match as an operator in its own right."
msgstr ""
"Остальная часть расширения генерируется с помощью pat-match. Этот макрос "
"принимает\n"
"те же аргументы что и if-match; единственное отличие состоит в том, что он "
"не \n"
"устанавливает новых привязок для переменных образца. В некоторых ситуациях "
"это\n"
"является преимуществом, и глава 19 будет использовать pat-match в качестве \n"
"самостоятельного оператора."

#: texi/node-18.texi:596
msgid ""
"In the new matching operator, the distinction between pattern content and\n"
"pattern structure will be defined by the function simple?. If we want to be "
"able\n"
"to use quoted literals in patterns, the destructuring code (and vars-"
"in)havetobe\n"
"told not to go inside lists whose first element is quote. With the new "
"matching\n"
"operator, we will be able to use lists as pattern elements, simply by "
"quoting them."
msgstr ""
"В новом операторе сопоставления различие между содержимым и структурой\n"
"образца будет определяться функцией simple?. Если мы хотим иметь "
"возможность \n"
"использовать квотированные литералы в образце, коду деконструкции (и vars-"
"in) нужно\n"
"запретить входить внутрь списков, первым элементом которых является quote. С "
"новым\n"
"оперетором сопоставления, мы можем использовать списки в качестве элементов "
"образца,\n"
"просто заключая их в символ квотирования."

#: texi/node-18.texi:602
msgid ""
"@lisp\n"
" (defmacro if-match (pat seq then &optional else)\n"
"       `(let ,(mapcar #'(lambda (v) `(,v ',(gensym)))\n"
"                          (vars-in pat #'simple?))\n"
"           (pat-match ,pat ,seq ,then ,else)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro if-match (pat seq then &optional else)\n"
"       `(let ,(mapcar #'(lambda (v) `(,v ',(gensym)))\n"
"                          (vars-in pat #'simple?))\n"
"           (pat-match ,pat ,seq ,then ,else)))"

#: texi/node-18.texi:612
msgid ""
" (defmacro pat-match (pat seq then else)\n"
"       (if (simple? pat)\n"
"            (match1 `((,pat ,seq)) then else)\n"
"            (with-gensyms (gseq gelse)\n"
"              `(labels ((,gelse () ,else))\n"
"                    ,(gen-match (cons (list gseq seq)\n"
"                                          (destruc pat gseq #'simple?))\n"
"                                 then\n"
"                                 `(,gelse))))))"
msgstr ""

#: texi/node-18.texi:614
msgid " (defun simple? (x) (or (atom x) (eq (car x) 'quote)))"
msgstr ""

#: texi/node-18.texi:623
msgid ""
" (defun gen-match (refs then else)\n"
"       (if (null refs)\n"
"            then\n"
"            (let ((then (gen-match (cdr refs) then else)))\n"
"              (if (simple? (caar refs))\n"
"                     (match1 refs then else)\n"
"                     (gen-match (car refs) then else)))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:625
msgid "                        Figure 18-7: Fast matching operator."
msgstr ""
"                        Рисунок 18-7: Опертор быстрого сопоставления.\n"
"@end cartouche"

#: texi/node-18.texi:631
msgid ""
"Like dbind, pat-match calls destruc to get a list of the calls that will\n"
"take apart its argument at runtime. This list is passed on to gen-match, "
"which\n"
"recursively generates matching code for nested patterns, and thence to "
"match1,\n"
"which generates match code for each leaf of the pattern tree."
msgstr ""
"Как и dbind, pat-match вызывает destruc чтобы получить список вызвов, "
"которые \n"
"будут испольовать часть его аргументов во время выполнения. Этот список "
"передается\n"
"в gen-match, который рекурсивно генерирует код сопоставления для вложенных "
"образцов,\n"
"а затем в match1, который генерирует код сопоставления для каждого листа "
"дерева\n"
"образца."

#: texi/node-18.texi:641
msgid ""
"Most of the code which will appear in the expansion of an if-match comes\n"
"from match1, which is shown in Figure 18-8. This function considers four "
"cases.\n"
"If the pattern argument is a gensym, then it is one of the invisible "
"variables created\n"
"by destruc to hold sublists, and all we need to do at runtime is test that "
"it has the\n"
"right length. If the pattern element is a wildcard ( ), no code need be "
"generated.\n"
"If the pattern element is a variable, match1 generates code to match it "
"against,\n"
"or set it to, the corresponding part of the sequence given at runtime. "
"Otherwise,\n"
"the pattern element is taken to be a literal value, and match1 generates "
"code to\n"
"compare it with the corresponding part of the sequence."
msgstr ""
"Большая часть кода, который появитсья в расширении if-match, происходит из  "
"match1, \n"
"что показано на рисунке 18-8. Эта функция рассматривает четыре случая. Если "
"аргумент\n"
"образца является gensym, то это одна из невидимых переменных, созданных "
"destruc для\n"
"хранения подсписков и все, что нам нужно сделать во время выполнения, это "
"проверить,\n"
"что он имеет правильную длину. Если элемент образца является произвольным "
"знаком\n"
"(_), генерировать код не нужно. Если элемент образца является переменной, "
"match1\n"
"генерирует код, чтобы сопоставить его снова, или установить его соответствие "
"с\n"
"соответствующей частью последовательности, заданной во время выполнения. В "
"проитвном\n"
"случае элемент образца считается буквенным значением и match1 генерирует код "
"для\n"
"сравнения его с соответствующей частью последовательности."

#: texi/node-18.texi:659
msgid ""
"@lisp\n"
" (defun match1 (refs then else)\n"
"    (dbind ((pat expr) . rest) refs\n"
"         (cond ((gensym? pat)\n"
"                  `(let ((,pat ,expr))\n"
"                       (if (and (typep ,pat 'sequence)\n"
"                                 ,(length-test pat rest))\n"
"                           ,then\n"
"                           ,else)))\n"
"                 ((eq pat '_) then)\n"
"                 ((var? pat)\n"
"                  (let ((ge (gensym)))\n"
"                      `(let ((,ge ,expr))\n"
"                        (if (or (gensym? ,pat) (equal ,pat ,ge))\n"
"                              (let ((,pat ,ge)) ,then)\n"
"                              ,else))))\n"
"                 (t `(if (equal ,pat ,expr) ,then ,else)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun match1 (refs then else)\n"
"    (dbind ((pat expr) . rest) refs\n"
"         (cond ((gensym? pat)\n"
"                  `(let ((,pat ,expr))\n"
"                       (if (and (typep ,pat 'sequence)\n"
"                                 ,(length-test pat rest))\n"
"                           ,then\n"
"                           ,else)))\n"
"                 ((eq pat '_) then)\n"
"                 ((var? pat)\n"
"                  (let ((ge (gensym)))\n"
"                      `(let ((,ge ,expr))\n"
"                        (if (or (gensym? ,pat) (equal ,pat ,ge))\n"
"                              (let ((,pat ,ge)) ,then)\n"
"                              ,else))))\n"
"                 (t `(if (equal ,pat ,expr) ,then ,else)))))"

#: texi/node-18.texi:662
msgid ""
" (defun gensym? (s)\n"
"    (and (symbolp s) (not (symbol-package s))))"
msgstr ""

#: texi/node-18.texi:669
msgid ""
" (defun length-test (pat rest)\n"
"    (let ((fin (caadar (last rest))))\n"
"         (if (or (consp fin) (eq fin 'elt))\n"
"                `(= (length ,pat) ,(length rest))\n"
"                `(> (length ,pat) ,(- (length rest) 2)))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:671
msgid "                  Figure 18-8: Fast matching operator (continued)."
msgstr ""
"                  Рисунок 18-8: Быстрый оператор сопоставления "
"(продолжение).\n"
"@end cartouche"

#: texi/node-18.texi:675
msgid ""
"Let's look at examples of how some parts of the expansion are generated.\n"
"Suppose we begin with"
msgstr ""
"Давайте посмотрим на примеры того, как генерируются некоторые части "
"расширения.\n"
"Предположим, мы начали с"

#: texi/node-18.texi:681
msgid ""
"@lisp\n"
"(if-match (?x 'a) seq\n"
"        (print ?x)\n"
"        nil)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:684
msgid ""
"The pattern will be passed to destruc, with some gensym (call it g for "
"legibility)\n"
"to represent the sequence:"
msgstr ""
"Образец будет передан в destruc, с некоторымe gensym (назовем его g для "
"разборчивости)\n"
"в представленную последовательность:"

#: texi/node-18.texi:688
msgid ""
"@lisp\n"
"(destruc '(?x 'a) 'g #'simple?)\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:691
msgctxt "texi/node-18.texi:691"
msgid ""
"@noindent\n"
"yielding:"
msgstr ""
"@noindent\n"
"получаем:"

#: texi/node-18.texi:695
msgid ""
"@lisp\n"
"   ((?x (elt g 0)) ((quote a) (elt g 1)))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:697
msgid "On the front of this list we cons (g seq):"
msgstr "В начало этого списка мы подставляем (g seq):"

#: texi/node-18.texi:701
msgid ""
"@lisp\n"
"   ((g seq) (?x (elt g 0)) ((quote a) (elt g 1)))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:708
msgid ""
"and send the whole thing to gen-match. Like the naive implementation of "
"length\n"
"(page 22), gen-match first recurses all the way to the end of the list, and "
"then\n"
"builds its return value on the way back up. When it has run out of "
"elements,\n"
"gen-match returns its then argument, which will be ?x. On the way back up "
"the\n"
"recursion, this return value will be passed as the then argument to match1."
"Now\n"
"we will have a call like:"
msgstr ""
"и отправляем его в gen-match. Как и в наивной реализации length (стр 22), "
"gen-match\n"
"сначала рекурсивно проходит до конца списка, а затем строит свое "
"возвращаемое \n"
"значение на обратном пути. Когда у него заканчиваются элементы, gen-match "
"возвращает\n"
"его аргумент then, который будет ?x. На обратном пути рекурсии это "
"возвращаемое \n"
"значение будет передано в качестве аргумент в  match1.Теперь мы можем "
"вызвать\n"
"как:"

#: texi/node-18.texi:712
msgid ""
"@lisp\n"
"   (match1 '(((quote a) (elt g 1))) '(print ?x) ' else function )\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:715
msgctxt "texi/node-18.texi:715"
msgid ""
"@noindent\n"
"yielding:"
msgstr ""
"@noindent\n"
"получая:"

#: texi/node-18.texi:721
msgid ""
"@lisp\n"
"   (if (equal (quote a) (elt g 1))\n"
"           (print ?x)\n"
"            else function )\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:725
msgid ""
"This will in turn become the then argument to another call to match1, the "
"value\n"
"of which will become the then argument of the last call to match1. The full\n"
"expansion of this if-match is shown in Figure 18-9."
msgstr ""
"Это в свою очередь, станет аргументом then для друго вызова match1, значение "
"которого\n"
"станет then аргументом для последнего вызова match1. Полное расширение этого "
"if-match \n"
"показано на рисунке 18-9."

#: texi/node-18.texi:730
msgid ""
"In this expansion gensyms are used in two completely unrelated ways. The\n"
"variables used to hold parts of the tree at runtime have gensymed names, in "
"order\n"
"to avoid capture. And the variable ?x is initially bound to a gensym, to "
"indicate\n"
"that it hasn't yet been assigned a value by matching."
msgstr ""
"В этом расширении gensyms используются двумя совершенно не связанными "
"способами.\n"
"Переменные, используемые для хранения частей дерева во время выполнения "
"имеют\n"
"сгенерированные gensym имена, чтобы избежать захвата. И переменные ?x "
"изначально\n"
"связвается с  gensym, чтобы указать, что ей не было присвоено значение "
"путем\n"
"сопоставления."

#: texi/node-18.texi:734
msgid ""
"In the new if-match, the pattern elements are now evaluated instead of "
"being\n"
"implicitly quoted. This means that Lisp variables can be used in patterns, "
"as well\n"
"as quoted expressions:"
msgstr ""
"В новом if-match, элементы образца теперь вычисляются, а не заключются "
"неявно\n"
"в кавычки. Это означает, что Lisp переменные могут использоваться в "
"образцах,\n"
"а также в выражениях в кавычках:"

#: texi/node-18.texi:741
msgid ""
"@example\n"
"   > (let ((n 3))\n"
"           (if-match (?x n 'n '(a b)) '(13n(ab))\n"
"              ?x))\n"
"   1\n"
"@end example"
msgstr ""

#: texi/node-18.texi:747
msgid ""
"Two further improvements appear because the new version calls destruc "
"(Figure\n"
"18-1). The pattern can now contain &rest or &body keywords (match doesn't "
"bother\n"
"with those). And because destruc uses the generic sequence operators elt "
"and\n"
"subseq, the new if-match will work for any kind of sequence. If abab is "
"defined\n"
"with the new version, it can be used also on vectors and strings:"
msgstr ""
"Два новых улучшения появляютс потому, что новая версися вызывает destruc "
"(Рисунок\n"
"18-1). Теперь образец может содержать ключевые слова &rest или &body (match "
"не\n"
"беспокоит их). И поскольку destruc использует опрераторы общей "
"последовательности\n"
"elt и subseq, новый  if-match будет работать для любого типа "
"последовательностей. \n"
"Если abab определен  с новой версией, он может быть испольозван также для\n"
"векторов и строк:"

#: texi/node-18.texi:752
msgid ""
"@lisp\n"
"      (if-match (?x 'a) seq\n"
"           (print ?x))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"      (if-match (?x 'a) seq\n"
"           (print ?x))\n"
"@end lisp"

#: texi/node-18.texi:754
msgid "      expands into:"
msgstr "      расширяется в:"

#: texi/node-18.texi:770
msgid ""
"@lisp\n"
"      (let ((?x '#:g1))\n"
"        (labels ((#:g3 nil nil))\n"
"           (let ((#:g2 seq))\n"
"             (if (and (typep #:g2 'sequence)\n"
"                          (= (length #:g2) 2))\n"
"                  (let ((#:g5 (elt #:g2 0)))\n"
"                       (if (or (gensym? x) (equal ?x #:g5))\n"
"                          (let ((?x #:g5))\n"
"                              (if (equal 'a (elt #:g2 1))\n"
"                                   (print ?x)\n"
"                                   (#:g3)))\n"
"                          (#:g3)))\n"
"                  (#:g3)))))\n"
"@end lisp"
msgstr ""

#: texi/node-18.texi:772
msgid "                        Figure 18-9: Expansion of an if-match."
msgstr ""
"                        Рисунок 18-9: Расширение if-match.\n"
"@end cartouche"

#: texi/node-18.texi:783
msgid ""
"@example\n"
"> (abab \"abab\")\n"
"#\\a\n"
"#\\b\n"
"> (abab #(1 2 1 2))\n"
"12\n"
"@end example\n"
"In fact, patterns can be as complex as patterns to dbind:"
msgstr ""
"@example\n"
"> (abab \"abab\")\n"
"#\\a\n"
"#\\b\n"
"> (abab #(1 2 1 2))\n"
"12\n"
"@end example\n"
"На самом деле, образцы могут быть сложными, как образцы для dbind:"

#: texi/node-18.texi:791
msgid ""
"@example\n"
"> (if-match (?x (1 . ?y) . ?x) '((a b) #(1 2 3) a b)\n"
"            (values ?x ?y))\n"
"(A B)\n"
"#(2 3)\n"
"@end example"
msgstr ""

#: texi/node-18.texi:794
msgid ""
"Notice that, in the second return value, the elements of the vector are "
"displayed.\n"
"To have vectors printed this way, set *print-array* to t."
msgstr ""
"Обратите внимание, что во втором возвращаемом значении, отображаются "
"элементы вектора.\n"
"Чтобы векторы печатались таким образом, установите *print-array* в t."

#: texi/node-18.texi:800
msgid ""
"In this chapter we are beginning to cross the line into a new kind of pro-\n"
"gramming. We began with simple macros for destructuring. In the final "
"version\n"
"of if-match we have something that looks more like its own language. The\n"
"remaining chapters describe a whole class of programs which operate on the "
"same\n"
"philosophy."
msgstr ""
"В этой главе мы начали переходить грань в новый вид программирования. Мы "
"начали\n"
"с простых макросв для деконструкции. И в финальной версии из if-match у нас\n"
"получилось что то больше похожее на собственный язык. Остальные главы "
"описывают \n"
"целый класс программ, которые работают на той же философии."
