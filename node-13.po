#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-13.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 11:42+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-13.texi:5
msgid ""
"@node 13 Computation at Compile-Time, 14 Anaphoric Macros, 12 Generalized "
"Variables, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 13 Computation at Compile-Time\n"
"@cindex 13 Computation at Compile-Time"
msgstr ""
"@node 13 Computation at Compile-Time, 14 Anaphoric Macros, 12 Generalized "
"Variables, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 13 Вычисления во время компиляции\n"
"@cindex 13 Computation at Compile-Time"

#: texi/node-13.texi:18
msgid ""
"The preceding chapters described several types of operators which have to "
"be\n"
"implemented by macros. This one describes a class of problems which could\n"
"be solved by functions, but where macros are more efficient. Section 8-2 "
"listed\n"
"the pros and cons of using macros in a given situation. Among the pros was\n"
"\"computation at compile-time.\" By defining an operator as a macro, you "
"can\n"
"sometimes make it do some of its work when it is expanded. This chapter "
"looks\n"
"at macros which take advantage of this possibility.\n"
"@menu\n"
"* 13-1 New Utilities::          \n"
"* 13-2 Example Bezier Curves::  \n"
"* 13-3 Applications::           \n"
"@end menu"
msgstr ""
"В предыдущих главах описано несколько типов операторов, которые должны быть\n"
"реализованы макросами. Они описывают класс проблем, которые должны решаться\n"
"функциями, но где макросы более эффективны. Раздел 8-2 перечисляет плюсы и\n"
"минусы использования макросов в данной ситуации. Среди плюсов был пункт\n"
"\"вычисление во время компиляции.\" Определив оператор как макрос, вы "
"можете\n"
"иногда заставить выполнить часть своей работы, во время его расширения. Эта\n"
"глава рассматривает макросы, которые используют эту возможность.\n"
"@menu\n"
"* 13-1 New Utilities::          \n"
"* 13-2 Example Bezier Curves::  \n"
"* 13-3 Applications::           \n"
"@end menu"

#: texi/node-13.texi:23
msgid ""
"@node 13-1 New Utilities, 13-2 Example Bezier Curves, 13 Computation at "
"Compile-Time, 13 Computation at Compile-Time\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 13-1 New Utilities\n"
"@cindex 13-1 New Utilities"
msgstr ""
"@node 13-1 New Utilities, 13-2 Example Bezier Curves, 13 Computation at "
"Compile-Time, 13 Computation at Compile-Time\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 13-1 Новые Утилиты\n"
"@cindex 13-1 New Utilities"

#: texi/node-13.texi:27
msgid ""
"Section 8-2 raised the possibility of using macros to shift computation to "
"compile-\n"
"time. There we had as an example the macro avg, which returns the average "
"of\n"
"its arguments:"
msgstr ""
"В разделе 8-2 упоминается возможность при использовании макросов перенести "
"вычисления\n"
"на время компиляции программы. Там, в качестве примера, у нас был макрос "
"avg, который\n"
"возвращал среднее значение своих аргументов:"

#: texi/node-13.texi:32
msgid ""
"@example\n"
"> (avg pi 4 5)\n"
"4.047...\n"
"@end example"
msgstr ""

#: texi/node-13.texi:37
msgid ""
"Figure 13-1 shows avg defined first as a function and then as a macro. When "
"avg\n"
"is defined as a macro, the call to length can be made at compile-time. In "
"the\n"
"macro version we also avoid the expense of manipulating the &rest parameter "
"at\n"
"runtime. In many implementations, avg will be faster written as a macro."
msgstr ""
"На рисунке 13-1 показано определение avg, сначала как функции и затем как "
"макроса.\n"
"Когда он определяется как макрос, вызов length может быть сделан во время "
"компиляции.\n"
"В версии макроса, мы также избегаем затрат на разбор параметров &rest во "
"время выполнения.\n"
"Во многих реализациях, avg будет скорее всего написан как макрос."

#: texi/node-13.texi:42
msgid ""
"The kind of savings which comes from knowing the number of arguments at\n"
"expansion-time can be combined with the kind we get from in (page 152), "
"where\n"
"it was possible to avoid even evaluating some of the arguments. Figure 13-2\n"
"contains two versions of most-of, which returns true if most of its "
"arguments do:"
msgstr ""
"Тип экономии, который достигается за счет знания количества аргументов во "
"время\n"
"расширения макроса может быть объединен, с типом, который мы получаем из "
"in \n"
"(стр. 152), где удалось избежать даже вычисления некоторых аргументов. "
"Рисунок 13-2\n"
"содержит две версии most-of, который возвращает истину если большинство его\n"
"аргументов истина:"

#: texi/node-13.texi:46
msgid ""
"@lisp\n"
"     (defun avg (&rest args)\n"
"       (/ (apply #'+ args) (length args)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun avg (&rest args)\n"
"       (/ (apply #'+ args) (length args)))"

#: texi/node-13.texi:50
msgid ""
"     (defmacro avg (&rest args)\n"
"       `(/ (+ ,@@args) ,(length args)))\n"
"@end lisp"
msgstr ""

#: texi/node-13.texi:52
msgid "            Figure 13-1: Shifting computation when finding averages."
msgstr ""
"            Рисунок 13-1: Перемещение вычислений при поиске среднего "
"значения.\n"
"@end cartouche"

#: texi/node-13.texi:62
msgid ""
"@lisp\n"
"     (defun most-of (&rest args)\n"
"       (let ((all 0)\n"
"             (hits 0))\n"
"        (dolist (a args)\n"
"          (incf all)\n"
"          (if a (incf hits)))\n"
"        (> hits (/ all 2))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun most-of (&rest args)\n"
"       (let ((all 0)\n"
"             (hits 0))\n"
"        (dolist (a args)\n"
"          (incf all)\n"
"          (if a (incf hits)))\n"
"        (> hits (/ all 2))))"

#: texi/node-13.texi:71
msgid ""
"     (defmacro most-of (&rest args)\n"
"       (let ((need (floor (/ (length args) 2)))\n"
"             (hits (gensym)))\n"
"        `(let ((,hits 0))\n"
"           (or ,@@(mapcar #'(lambda (a)\n"
"                                   `(and ,a (> (incf ,hits) ,need)))\n"
"                              args)))))\n"
"@end lisp"
msgstr ""

#: texi/node-13.texi:73
msgid "                Figure 13-2: Shifting and avoiding computation."
msgstr ""
"                Рисунок 13-2: Перемещение и избегание вычислений.\n"
"@end cartouche"

#: texi/node-13.texi:79
msgid ""
"@example\n"
"> (most-of t t t nil)\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-13.texi:83
msgid ""
"The macro version expands into code which, like in, only evaluates as many "
"of\n"
"the arguments as it needs to. For example, (most-of (a) (b) (c)) expands\n"
"into the equivalent of:"
msgstr ""
"Весрсия макроса расширяется в код, подобный in, вычисляет только столько "
"аргументов,\n"
"сколько надо. Например, (most-of (a) (b) (c)) расширяется в эквивалент:"

#: texi/node-13.texi:90
msgid ""
"@lisp\n"
"(let ((count 0))\n"
"     (or (and (a) (> (incf count) 1))\n"
"         (and (b) (> (incf count) 1))\n"
"         (and (c) (> (incf count) 1))))\n"
"@end lisp"
msgstr ""

#: texi/node-13.texi:92
msgid "In the best case, just over half the arguments will be evaluated."
msgstr "В лучшем случае, вычисляется чуть больше половины аргументов."

#: texi/node-13.texi:96
msgid ""
"@lisp\n"
" (defun nthmost (n lst)\n"
"   (nth n (sort (copy-list lst) #'>)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun nthmost (n lst)\n"
"   (nth n (sort (copy-list lst) #'>)))"

#: texi/node-13.texi:108
msgid ""
" (defmacro nthmost (n lst)\n"
"   (if (and (integerp n) (< n 20))\n"
"         (with-gensyms (glst gi)\n"
"            (let ((syms (map0-n #'(lambda (x) (gensym)) n)))\n"
"                `(let ((,glst ,lst))\n"
"                  (unless (< (length ,glst) ,(1+ n))\n"
"                    ,@@(gen-start glst syms)\n"
"                    (dolist (,gi ,glst)\n"
"                      ,(nthmost-gen gi syms t))\n"
"                    ,(car (last syms))))))\n"
"         `(nth ,n (sort (copy-list ,lst) #'>))))"
msgstr ""

#: texi/node-13.texi:116
msgid ""
" (defun gen-start (glst syms)\n"
"   (reverse\n"
"        (maplist #'(lambda (syms)\n"
"                      (let ((var (gensym)))\n"
"                        `(let ((,var (pop ,glst)))\n"
"                            ,(nthmost-gen var (reverse syms)))))\n"
"                  (reverse syms))))"
msgstr ""

#: texi/node-13.texi:130
msgid ""
" (defun nthmost-gen (var vars &optional long?)\n"
"   (if (null vars)\n"
"         nil\n"
"         (let ((else (nthmost-gen var (cdr vars) long?)))\n"
"            (if (and (not long?) (null else))\n"
"                 `(setq ,(car vars) ,var)\n"
"                 `(if (> ,var ,(car vars))\n"
"                      (setq ,@@(mapcan #'list\n"
"                                          (reverse vars)\n"
"                                          (cdr (reverse vars)))\n"
"                             ,(car vars) ,var)\n"
"                      ,else)))))\n"
"@end lisp"
msgstr ""

#: texi/node-13.texi:132
msgid "            Figure 13-3: Use of arguments known at compile-time."
msgstr ""
"            Рисунок 13-3: Использование аргументов, известных во время "
"компиляциии.\n"
"@end cartouche"

#: texi/node-13.texi:140
msgid ""
"A macro may also be able to shift computation to compile-time if the values\n"
"of particular arguments are known. Figure 13-3 contains an example of such "
"a\n"
"macro. The function nthmost takes a number n and a list of numbers, and "
"returns\n"
"the nth largest among them; like other sequence functions, it is zero-"
"indexed:"
msgstr ""
"Макрос также может быть в состоянии перенести вычисления на время "
"компиляции,\n"
"есил значения конкретных аргументов известны. На рисунке 13-3 приведен "
"пример\n"
"такого макроса. Функцияn nthmost принимает чисмло n и список чисел и "
"возвращает\n"
"n-й по величине из них; как и другие функции работающие с "
"последовательноостями \n"
"индекс начинается с нуля:"

#: texi/node-13.texi:145
msgid ""
"@example\n"
"> (nthmost 2 '(2 61534))\n"
"4\n"
"@end example"
msgstr ""
"@example\n"
"> (nthmost 2 '(2 6 1 5 3 4))\n"
"4\n"
"@end example"

#: texi/node-13.texi:150
msgid ""
"The function version is written very simply. It sorts the list and calls nth "
"on\n"
"the result. Since sort is destructive, nthmost copies the list before "
"sorting it.\n"
"Written thus, nthmost is inefficient is two respects: it conses, and it "
"sorts the\n"
"entire list of arguments, though all we care about are the top n."
msgstr ""
"Функциональная версия написана очень просто. Она сортирует список и вызывает "
"nth\n"
"для результата. Поскольку сортировка деструктивна, nthmost копирует список "
"перед\n"
"его сортировкой. Такое написание nthmost не эффективно в двум причинам: оно "
"выполняет\n"
"создание списка и оно сортирует весь список аргументов, хотя все, что нас "
"волнует это\n"
"старшие  n элементов."

#: texi/node-13.texi:161
msgid ""
"If we know n at compile-time, we can approach the problem differently. The\n"
"rest of the code in Figure 13-3 defines a macro version of nthmost. The "
"first\n"
"thing this macro does is look at its first argument. If the first argument "
"is not a\n"
"literal number, it expands into the same code we saw above. If the first "
"argument\n"
"is a number, we can follow a different course. If you wanted to find, say, "
"the third\n"
"biggest cookie on a plate, you could do it by looking at each cookie in "
"turn, always\n"
"keeping in your hand the three biggest found so far. When you have looked at "
"all\n"
"the cookies, the smallest cookie in your hand is the one you are looking "
"for. If n\n"
"is a small constant, not proportional to the number of cookies, then this "
"technique\n"
"gets you a given cookie with less effort that it would take to sort all of "
"them first."
msgstr ""
"Если мы знаем n во время компиляции, мы можем по другому подойти к проблеме. "
"Оставшаяся\n"
"часть кода на Рисунке 13-3 определяет версию nthmost в виде макроса. Первая "
"вещь,\n"
"которую делает этот макрос, это посмотреть на свой первый аргумент. Если "
"первый аргумент\n"
"не является буквальным числом(т.е записанным не переменной, а цифрами), "
"макрос расширяется\n"
"в тот же код, что приведен выше. Если первый аргумент это число, мы можем "
"пойти по другому\n"
"пути. Скажем, если вы хотели найти третье по величине самое большое печенье "
"на тарелке, вы\n"
"могли бы это сделать посмотрев на каждое печенье по очереди, всегда держа в "
"своих руках три \n"
"самых больших печенины найденных до сих пор. Когда бы вы осмотрели все "
"печенье, самое маленькое\n"
"печенье в ваших руках - это то, что вы ищите. Если n это небольшая "
"константа, не пропорциональная\n"
"количеству печенин, то этот метод даст вам необходимую печенину с меньшими "
"усилиями, чем та\n"
"которая требует предварительной сортировки всех печенин."

#: texi/node-13.texi:169
msgid ""
"This is the strategy followed when n is known at expansion-time. In its\n"
"expansion, the macro creates n variables, then calls nthmost-gen to generate "
"the\n"
"code which has to be evaluated upon looking at each cookie. Figure 13-4 "
"shows\n"
"a sample macroexpansion. The macro nthmost behaves just like the original\n"
"function, except that it can't be passed as an argument to apply. The "
"justification\n"
"for using a macro is purely one of efficiency: the macro version does not "
"cons at\n"
"runtime, and if n is a small constant, performs fewer comparisons."
msgstr ""
"Это стратегия, которой можно придерживатсья когда  n известно во время "
"расширения\n"
"макроса. После своего расширения, макрос создает n переменных, а затем "
"вызовав \n"
"nthmost-gen генерирует код который должен вычисляться при просмотре каждой "
"печенины.\n"
"Рисунок 13-4 показывает пример расширения макроса. Макрос nthmost ведет себя "
"так же,\n"
"как оригинальная функция, за исключением того, что он не может быть передан "
"в качестве\n"
"аргумента для применения(apply). Обоснование для применения макроса это "
"обычная \n"
"эффективность: версия макроса не выполняет конструирования списка, и если  n "
"небольшая\n"
"константа, выполняет меньше сравнений."

#: texi/node-13.texi:179
msgid ""
"To have efficient programs, must one then take the trouble to write such "
"huge\n"
"macros? In this case, probably not. The two versions of nthmost are intended "
"as\n"
"an example of a general principle: when some arguments are known at "
"compile-\n"
"time, you can use a macro to generate more efficient code. Whether or not "
"you\n"
"take advantage of this possibility will depend on how much you stand to "
"gain,\n"
"and how much more effort it will take to write an efficient macro version. "
"Since\n"
"the macro version of nthmost is long and complicated, it would only be "
"worth\n"
"writing in extreme cases. However, information known at compile-time is "
"always\n"
"a factor worth considering, even if you choose not to take advantage of it."
msgstr ""
"Чтобы иметь эффективные программы, нужно потрудиться чтобы написать такоие\n"
"огромные макросы? В этом случае, вероятно нет. Две версии nthmost приведены\n"
"как пример общего принципа: когда некоторые аргументы известны во время\n"
"компиляции, вы можете использовать марос для генерации более эффективного "
"кода.\n"
"Будете вы пользоваться этой возможностью или нет, будет зависеть от того, "
"сколько\n"
"вы выиграете, и сколько еще усилий потербуется, чтобы написать эффективную "
"версию\n"
"макроса. Версия nthmost реализованная в виде макроса, длинная и сложная, ее "
"стоит\n"
"писать только в крайних случаях. Однако информация, известная во время "
"компиляции,\n"
"всегда является фактором, который стоит учитывать, даже если вы решите не "
"использовать\n"
"её в своих интересах."

#: texi/node-13.texi:183
msgid ""
"@lisp\n"
" (nthmost 2 nums)\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (nthmost 2 nums)\n"
"@end lisp"

#: texi/node-13.texi:186
msgid ""
"@noindent\n"
"expands into:"
msgstr ""

#: texi/node-13.texi:212
msgid ""
"@lisp\n"
" (let ((#:g7 nums))\n"
"    (unless (< (length #:g7) 3)\n"
"        (let ((#:g6 (pop #:g7)))\n"
"         (setq #:g1 #:g6))\n"
"        (let ((#:g5 (pop #:g7)))\n"
"         (if (> #:g5 #:g1)\n"
"              (setq #:g2 #:g1 #:g1 #:g5)\n"
"              (setq #:g2 #:g5)))\n"
"        (let ((#:g4 (pop #:g7)))\n"
"         (if (> #:g4 #:g1)\n"
"              (setq #:g3 #:g2 #:g2 #:g1 #:g1 #:g4)\n"
"              (if (> #:g4 #:g2)\n"
"                   (setq #:g3 #:g2 #:g2 #:g4)\n"
"                   (setq #:g3 #:g4))))\n"
"        (dolist (#:g8 #:g7)\n"
"         (if (> #:g8 #:g1)\n"
"              (setq #:g3 #:g2 #:g2 #:g1 #:g1 #:g8)\n"
"              (if (> #:g8 #:g2)\n"
"                   (setq #:g3 #:g2 #:g2 #:g8)\n"
"                   (if (> #:g8 #:g3)\n"
"                          (setq #:g3 #:g8)\n"
"                          nil))))\n"
"        #:g3))\n"
"@end lisp"
msgstr ""

#: texi/node-13.texi:214
msgid "                        Figure 13-4: Expansion of nthmost."
msgstr ""
"                        Рисунок 13-4: Расширение nthmost.\n"
"@end cartouche"

#: texi/node-13.texi:219
msgid ""
"@node 13-2 Example Bezier Curves, 13-3 Applications, 13-1 New Utilities, 13 "
"Computation at Compile-Time\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 13-2 Example Bezier Curves\n"
"@cindex 13-2 Example Bezier Curves"
msgstr ""
"@node 13-2 Example Bezier Curves, 13-3 Applications, 13-1 New Utilities, 13 "
"Computation at Compile-Time\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 13-2 Example Кривые Безье(Bezier)\n"
"@cindex 13-2 Example Bezier Curves"

#: texi/node-13.texi:226
msgid ""
"Like the with- macro (Section 11-2), the macro for computation at compile-"
"time\n"
"is more likely to be written for a specific application than as a general-"
"purpose\n"
"utility. How much can a general-purpose utility know at compile-time? The\n"
"number of arguments it has been given, and perhaps some of their values. If\n"
"we want to use other constraints, they will probably have to be ones imposed "
"by\n"
"individual programs."
msgstr ""
"Как и макрос with- (Раздел 11-2), макрос для вычислений во время компиляции "
"вероятнее\n"
"всего, будет написан для конкретного приложения, чем как утилита общего "
"назначения.\n"
"Что может знать утилита общего назначения во время компиляции? Количество "
"переданных\n"
"ей аргументов , и возможно некоторые из их значений. Если мы хотим "
"использовать другие\n"
"ограничения, они, вероятно, должны быть индивидуальными программами."

#: texi/node-13.texi:234
msgid ""
"As an example, this section shows how macros can speed up the generation\n"
"of Bezier curves. Curves must be generated fast if they are being "
"manipulated\n"
"interactively. It turns out that if the number of segments in the curve is "
"known\n"
"beforehand, most of the computation can be done at compile-time. By writing "
"our\n"
"curve-generator as a macro, we can weave precomputed values right into "
"code.\n"
"This should be even faster than the more usual optimization of storing them "
"in an\n"
"array."
msgstr ""
"В качестве примера в этом разделе показано, как макросы могут ускорить "
"генерацию\n"
"кривых Безье. Кривые должны генерироваться быстро, если ими управляют в "
"интерактивном\n"
"режиме. Оказывается, что если количество сегментов в кривой известно "
"заранее, большая \n"
"часть вычислений может быть выполнена во время компиляции. Написав наш "
"генератор кривых\n"
"curve-generator в виде макроса, мы можем вшивать предварительно вычисленные "
"значения\n"
"прямо в код. Это должно быть даже более быстрым, чем обычная оптимизация с "
"их хранением\n"
"в массиве."

#: texi/node-13.texi:240
msgid ""
"A Bezier curve is defined in terms of four points-two endpoints and two\n"
"control points. When we are working in two dimensions, these points define\n"
"parametric equations for the x and y coordinates of points on the curve. If "
"the\n"
"two endpoints are (x0, y0) and (x3, y3) and the two control points are (x1, "
"y1) and\n"
"(x2, y2), then the equations defining points on the curve are:"
msgstr ""
"Кривая Безье определяется в терминах четырех точек - двух конечных точек и "
"двух\n"
"котнрольных(управляющих) точек. Когда мы работаем в двух измерениях, эти "
"точки\n"
"определяют параметрическоие уравнения для координат x и y точек на кривой. "
"Если\n"
"две конечные точки это (x0, y0) и (x3, y3) и две управляющие точки это (x1, "
"y1) и\n"
"(x2, y2), то уравнения определяющие точки на кривой будут:"

#: texi/node-13.texi:244
msgid ""
"@example\n"
"          x =(x                           3                      2\n"
"                   3 - 3x2 + 3x1 - x0)u +(3x2 - 6x1 + 3x0)u +(3x1 - 3x0)u + "
"x0"
msgstr ""
"@example\n"
"                                      3                         3\n"
"          x =(x3 - 3*x2 + 3*x1 - x0)*u  + (3*x2 - 6*x1 + 3*x0)*u + (3*x1 - "
"3*x0)*u + x0"

#: texi/node-13.texi:248
msgid ""
"          y =(y                      3                      2\n"
"                 3 - 3y2 + 3y1 - y0)u +(3y2 - 6y1 + 3y0)u +(3y1 - 3y0)u + "
"y0\n"
"@end example"
msgstr ""
"                                      3                        2\n"
"          y =(y3 - 3*y2 + 3*y1 - y0)*u + (3*y2 - 6*y1 + 3*y0)*u  + (3*y1 - "
"3*y0)*u + y0\n"
"@end example"

#: texi/node-13.texi:254
msgid ""
"If we evaluate these equations for n values of u between 0 and 1, we get n "
"points\n"
"on the curve. For example, if we want to draw the curve as 20 segments, then "
"we\n"
"would evaluate the equations for u = .05, .1,..., .95. There is no need to "
"evaluate\n"
"them for u of 0 or 1, because if u = 0 they will yield the first endpoint (x "
"0, y0), and\n"
"if u = 1 they will yield the second endpoint (x3, y3)."
msgstr ""
"Если мы вычислим эти уравнения для n значений u между 0 и 1, мы получим n "
"точек на\n"
"кривой. Например, если мы хотим нарисовать кривую как 20 сегментов, то мы бы "
"вычислили\n"
"уравнения для u = .05, .1,..., .95. Нет небходимости вычислять их для u "
"равных 0 или 1, \n"
"поскольку если u = 0 они дадут просто первую конечную точку (x 0, y0), и\n"
"если u = 1 они дадут вторую конечную точку (x3, y3)."

#: texi/node-13.texi:261
msgid ""
"An obvious optimization is to make n fixed, calculate the powers of u "
"before-\n"
"hand, and store them in an (n-1) × 3 array. By defining the curve-generator "
"as\n"
"a macro, we can do even better. If n is known at expansion-time, the "
"program\n"
"could simply expand into n line-drawing commands. The precomputed powers of\n"
"u, instead of being stored in an array, could be inserted as literal values "
"right into\n"
"the macro expansion."
msgstr ""
"Очевидная оптимизация состоит в том, чтобы сделать n фиксированным, "
"предварительно\n"
"расчитать степень u и сохранить их в массиве размером (n-1) × 3. Определив "
"генератор\n"
"кривой(curve-generator) как макрос, мы можем сделать еще лучше! Если n "
"изветсно во\n"
"время расширения, программа может просто расшириться до n команд рисующих "
"линии. \n"
"Предварительно вычисленные степени u, вместо того чтобы храниться в массиве, "
"могут\n"
"быть вставлены в виде буквальных значений прямо в код расширения макроса."

#: texi/node-13.texi:267
msgid ""
"Figure 13-5 contains a curve-generatingmacro which implements this "
"strategy.\n"
"Instead of drawing lines immediately, it dumps the generated points into an "
"array.\n"
"When a curve is moving interactively, each instance has to be drawn twice: "
"once\n"
"to show it, and again to erase it before drawing the next. In the meantime, "
"the\n"
"points have to be saved somewhere."
msgstr ""
"На рисунке 13-5 приведен макрос curve-generating,  который реализует эту "
"стратегию.\n"
"Вместо того, чтобы рисовать линии сразу, он создает массив сгенерированных "
"точек.\n"
"Когда кривая перемещается в интерактивном режиме, каждый экземпляр должен "
"быть нарисован\n"
"дважды: один раз чтобы показать её, и снова стереть её прежде чем нарисавать "
"ее ещё. Тем\n"
"временем точки должны где то храниться."

#: texi/node-13.texi:273
msgid ""
"With n = 20, genbez expands into 21 setfs. Since the powers of u appear\n"
"directly in the code, we save the cost of looking them up at runtime, and "
"the cost\n"
"of computing them at startup. Like the powers of u, the array indices appear "
"as\n"
"constants in the expansion, so the bounds-checking for the (setf aref)s "
"could\n"
"also be done at compile-time."
msgstr ""
"С n = 20, genbez расширяется до 21 setf. Так как степени u вшиваются "
"непосредственно\n"
"в код, мы экономим на затратах по их поиску во время выполнения, и на "
"стоимости \n"
"вычисления их при запуске. Подобно степеням u, индексы массива "
"представляются в виде\n"
"констант в расширении, поэтому проверка границ для (setf aref)  может быть\n"
"выполнена так же во время компиляции."

#: texi/node-13.texi:278
msgid ""
"@node 13-3 Applications,  , 13-2 Example Bezier Curves, 13 Computation at "
"Compile-Time\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 13-3 Applications\n"
"@cindex 13-3 Applications"
msgstr ""
"@node 13-3 Applications,  , 13-2 Example Bezier Curves, 13 Computation at "
"Compile-Time\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 13-3 Применения\n"
"@cindex 13-3 Applications"

#: texi/node-13.texi:283
msgid ""
"Later chapters contain several other macros which use information available "
"at\n"
"compile-time. A good example is if-match (page 242). Pattern-matchers com-\n"
"pare two sequences, possibly containing variables, to see if there is some "
"way of\n"
"assigning values to the variables which will make the two sequences equal. "
"The"
msgstr ""
"Последующие главы содержат несколько других макросов, которые используют "
"информацию,\n"
"доступную во время компиляции. Хорошим примером является if-match (стр. "
"242). \n"
"Сопоставитель-шаблонов сравнивающий две последовательности, возможно "
"содержащие\n"
"переменные, чтобы увидеть, есть ли какой-то способ присвоения значениий "
"переменным,\n"
"который сделает эти две последовательности равными."

#: texi/node-13.texi:288
msgid ""
"@lisp\n"
" (defconstant *segs* 20)\n"
" (defconstant *du*       (/ 1-0 *segs*))\n"
" (defconstant *pts* (make-array (list (1+ *segs*) 2)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defconstant *segs* 20)\n"
" (defconstant *du*       (/ 1-0 *segs*))\n"
" (defconstant *pts* (make-array (list (1+ *segs*) 2)))"

#: texi/node-13.texi:322
msgid ""
" (defmacro genbez (x0 y0 x1 y1 x2 y2 x3 y3)\n"
"   (with-gensyms (gx0 gx1 gy0 gy1 gx3 gy3)\n"
"        `(let ((,gx0 ,x0) (,gy0 ,y0)\n"
"              (,gx1 ,x1) (,gy1 ,y1)\n"
"              (,gx3 ,x3) (,gy3 ,y3))\n"
"           (let ((cx (* (- ,gx1 ,gx0) 3))\n"
"                (cy (* (- ,gy1 ,gy0) 3))\n"
"                (px (* (- ,x2 ,gx1) 3))\n"
"                (py (* (- ,y2 ,gy1) 3)))\n"
"            (let ((bx (- px cx))\n"
"                   (by (- py cy))\n"
"                   (ax (- ,gx3 px ,gx0))\n"
"                   (ay (- ,gy3 py ,gy0)))\n"
"              (setf (aref *pts* 0 0) ,gx0\n"
"                     (aref *pts* 0 1) ,gy0)\n"
"              ,@@(map1-n #'(lambda (n)\n"
"                                (let* ((u (* n *du*))\n"
"                                         (u^2 (* u u))\n"
"                                         (u^3 (expt u 3)))\n"
"                                  `(setf (aref *pts* ,n 0)\n"
"                                           (+ (* ax ,u^3)\n"
"                                                (* bx ,u^2)\n"
"                                                (* cx ,u)\n"
"                                                ,gx0)\n"
"                                           (aref *pts* ,n 1)\n"
"                                           (+ (* ay ,u^3)\n"
"                                                (* by ,u^2)\n"
"                                                (* cy ,u)\n"
"                                                ,gy0))))\n"
"                             (1- *segs*))\n"
"                (setf (aref *pts* *segs* 0) ,gx3\n"
"                        (aref *pts* *segs* 1) ,gy3))))))\n"
"@end lisp"
msgstr ""

#: texi/node-13.texi:324
msgid "              Figure 13-5: Macro for generating Bezier curves."
msgstr ""
"              Рисунок 13-5: Макрос для генерации кривых Безье.\n"
"@end cartouche"

#: texi/node-13.texi:331
msgid ""
"design of if-match shows that if one of the sequences is known at compile-"
"time,\n"
"and only that one contains variables, then matching can be done more "
"efficiently.\n"
"Instead of comparing the two sequences at runtime and consing up lists to "
"hold\n"
"the variable bindings established in the process, we can have a macro "
"generate\n"
"code to perform the exact comparisons dictated by the known sequence, and "
"can\n"
"store the bindings in real Lisp variables."
msgstr ""
"Конструкция if-match показывает, что если одна из последовательностей "
"известна\n"
"во время компиляции и только она содержит переменные, тогда сопоставление "
"может\n"
"быть сделано более эффективно. Весто сравнения двух последовательностей во "
"время\n"
"выполнения и создания списков для хранения привязок переменных, "
"установленных в\n"
"процессе сравнения, мы можем макросом сгенерировать код для выполнения "
"точных\n"
"сравнений, продиктованных известной последовательностью и можем хранить все "
"привязки\n"
"в реальных переменных Lisp-а."

#: texi/node-13.texi:338
msgid ""
"The embedded languages described in Chapters 19­24 also, for the most part,\n"
"take advantage of information available at compile-time. Since an embedded\n"
"language is a compiler of sorts, it's only natural that it should use such "
"information.\n"
"As a general rule, the more elaborate the macro, the more constraints it "
"imposes\n"
"on its arguments, and the better your chances of using these constraints to "
"generate\n"
"efficient code."
msgstr ""
"Встраиваемые языки описываемые в Главах 19-­24 также, по большей части, "
"используют\n"
"информацию, доступную во время компиляциии. Так как встроенный язык является "
"своего\n"
"рода компилятором, это вполне естественно, что он должен использовать такую "
"информацию.\n"
"Как правило, чем сложнее макрос, тем больше ограничений он накладывает на "
"аргументы,\n"
"и тем выше ваши шансы использовать эти ограничения для генерации "
"эффективного кода."
