@node 3 Functional Programming, 4 Utility Functions, 2 Functions, Top
@comment  node-name,  next,  previous,  up
@chapter 3 Функциональное программирование
@cindex 3 Functional Programming

В предыдущей главе рассказывалось о том, что Lisp и программы на нем
созданы из единственного материала: функций. Как и любому
строительному материалу, им присуще оказывать влияние как и на
свойства того, что мы создаем, так и на способ создания.


Эта глава описывает методы разработки, преобладающие в мире
Lisp. Изощренность этих методов позволит нам попытаться писать более
сложные программы. В следующей главе будет рассмотрен особенно важный
класс программ, который становится возможно реализовать в Лисп:
программы, которые эволюционируют вместо того, чтобы разрабатываться
старым способом "спланируй и реализуй".

@menu
* 3-1 Functional Design::       
* 3-2 Imperative Outside-In::   
* 3-3 Functional Interfaces::   
* 3-4 Interactive Programming::  
@end menu

@node 3-1 Functional Design, 3-2 Imperative Outside-In, 3 Functional Programming, 3 Functional Programming
@comment  node-name,  next,  previous,  up
@section 3-1 Функциональное проектирование
@cindex 3-1 Functional Design

На свойства объекта влияют элементы, из которых он создан. Например,
деревянное здание на вид отличается от каменного. Даже находясь от
него на далеком расстоянии и не имея возможности отличить на взгляд
камень от дерева, вы сможете определить материал, из которого оно
выстроено, исходя из общей формы этого здания. Особенности функций
Lisp оказывают аналогичное влияние на структуру Lisp программ.

Функциональное программирование означает написание программ, которые
работают за счет возврата значений, а не за счет побочных
действий. Побочные действия включают в себя деструктивные изменения
объектов (напр. rplaca) и присвоения переменным (напр. setq). Если
побочные действия немногочисленны и локализованы, то программы
становится легче читать, тестировать и отлаживать. Lisp-программисты
не всегда писали в таком стиле, но со временем Lisp и функциональное
программирование постепенно стали неразделимы.

Вот пример, который покажет, как функциональное программирование отличается от
того, что можно делать при помощи другого языка. Допустим, нам нужно с
какой-то целью 

@cartouche
@lisp
 (defun bad-reverse (lst)
       (let* ((len (length lst))
                (ilimit (truncate (/ len 2))))
          (do ((i 0 (1+ i))
                (j (1- len) (1- j)))
               ((>= i ilimit))
            (rotatef (nth i lst) (nth j lst)))))
@end lisp

                         Рисунок 3-1: Функция, инвертирующая списки.
@end cartouche

изменить порядок элементов списка. Вместо написания функции,
инвертирующей списки, мы напишем функцию, которая принимает список, а
возвращает список с теми же элементами в обратном порядке.

На рисунке 3.1 представлена функция, инвертирующая списки. Она
обрабатывает списки как массивы, сразу переворачивая их; ее
возвращаемое значение неважно:

@example
> (setq lst '(a b c))
(A B C)
> (bad-reverse lst)
NIL
> lst
(C B A)
@end example

Её имя подсказывает, что bad-reverse далека от хорошего Lisp-стиля. 
Кроме того, ее уродство заразно: так как она работает при
помощи побочных эффектов, то также уводит в сторону от функционального
идеала вызвавшие её функции.


Хотя, выступая в роли злодея, у bad-reverse есть одно достоинство: она
демонстрирует идиому Common Lisp для перестановки двух
значений. Макрос rotatef переворачивает значения любого числа
обобщенных переменных, то есть выражений, которые можно передать в setf
в качестве первого аргумента. Когда она примененяется просто к
двум аргументам, результатом будет их перестановка.

С другой стороны, на рисунке 3.2 показана функция, возвращающая
инвертированные списки. С помощью good-reverse мы получаем
инвертированный список в качестве возвращаемого значения; исходный
список остается прежним.

@example
> (setq lst '(a b c))
(A B C)
> (good-reverse lst)
(C B A)
> lst
(A B C)
@end example

@cartouche
@lisp
 (defun good-reverse (lst)
   (labels ((rev (lst acc)
      (if (null lst)
          acc
          (rev (cdr lst) (cons (car lst) acc)))))
     (rev lst nil)))
@end lisp

                        Рисунок 3-2: Функция, возвращающая инвертированные списки
@end cartouche

Раньше считалось, что можно судить о чьем-то характере, глядя на форму
его головы. Относится ли это в самом деле к людям или нет, неизвестно, 
но как правило, это применимо к Lisp-программам. Внешний вид функциональных
программ отличается от внешнего вида императивных. Структурно
функциональная программа -- это всегда композиция аргументов внутри
выражений, а так как аргументы можно размещать с отступом, то функциональный
код оказывается более разнообразным в плане наглядности. Функциональный
код выглядит гибким @footnote{Типичный пример приведен на странице 242.},
 а императивный код выглядит сплошным и блочным, как Basic.

Мы видим, не вдаваясь в детали, исходя из внешнего вида bad- и
good-reverse, какая из программ лучше. Несмотря на то, что
good-reverse короче, она также более эффективна: O(n) вместо O(n^2).


У нас нет проблем с написанием reverse, поскольку Common Lisp имеет
встроенную функцию. Имеет смысл ненадолго взглянуть на эту функцию, потому что
она часто выявляет неправильные представления о функциональном
программировании. Как и good-reverse, встроенная reverse возвращает
значение, не изменяя аргументов. Но изучающие Lisp могут подумать, что
она, как и bad-reverse, работает за счет побочных эффектов. Если в 
какой-либо части программы потребуется инвертировать список, можно написать

@lisp
(reverse lst)
@end lisp

но к удивлению это не сработает. В действительности, если нам нужны
действия от такой функции, то придется сделать это самим в вызывающем
коде. Вот, что вместо этого необходимо написать:


@lisp
(setq lst (reverse lst))
@end lisp

Такие операторы, как reverse, предназначены для вызова с целью
получения значений, а не побочных действий. Писать собственные
программы в таком стиле стоит не только из-за обязательно присущих ему
преимуществ, но и потому, что если этого не делать, вы будете работать
против языка.

Сравнивая bad- и good-reverse, мы не придали значения одной из
особенностей, заключающейся в том, что bad-reverse не создает
новый список. Вместо создания новой структуры списка, она работает
с исходным списком. Это может быть опасно: список может потребоваться
где-либо еще в программе, но это иногда бывает необходимо ради
производительности. Для таких случаев Common Lisp предоставляет O(n)
деструктивную инвертирующую функцию, которая называется nreverse.

Деструктивной является та функция, которая может изменять передаваемые
ей аргументы. Тем не менее даже деструктивные функции работают при
помощи возвращаемых значений: вы должны считать, что nreverse
переработает списки, переданные ей в качестве аргументов, но
по-прежнему нельзя полагаться на то, что она их инвертирует. Как и
раньше, инвертированный список будет содержаться в возвращаемом
значении. Вы не можете написать

@lisp
(nreverse lst)
@end lisp

в середине функции, полагая, что после этого lst будет инвертирован. Вот, что 
происходит в большинстве реализаций:

@example
> (setq lst '(a b c))
(A B C)
> (nreverse lst)
(C B A)
> lst
(A)
@end example

Для инвертирования lst можно было бы присвоить lst возвращаемое значение, как в 
случае с обычным reverse.

Если функция обозначена как деструктивная, то это вовсе не означает,
что ее предполагалось вызывать для побочных действий. Опасность
в том, что некоторые деструктивные функции создают впечатление
таковых. Например,

@lisp
(nconc x y)
@end lisp

почти всегда производит те же действия, что и

@lisp
(setq x (nconc x y))
@end lisp

Если вы написали код, зависящий от приведенной выше конструкции, то
он, вероятно, может работать некоторое время. Однако он не будет
делать то, что вы ожидали, когда x равно nil.

Лишь несколько операторов Lisp предназначены для вызова с целью
получения побочных эффектов. Вообще, встроенные операторы задумывались
для вызова ради возращаемых ими значений. Такие названия, как sort,
remove или substitute, не должны вводить в заблуждение. Если вам нужны
побочные эффекты, применяйте setq к возвращаемому значению.


Это самое правило предполагает, что побочные действия(эффекты) неизбежны. 
Придерживаться функционального программирования как идеала,
не означает того, что программы никогда не должны осуществлять
побочных эффектов. Это означает, что они должны быть, но не более, чем это
необходимо.

Чтобы развить такую привычку, возможно, потребуется время. Один из
способов состоит в том, чтобы использовать следующие операторы так,
как если бы был налог на их использование:

set setq setf psetf psetq incf decf push pop pushnew rplaca rplacd rotatef 
shiftf remf remprop remhash,  а также let* 

в которых нередко скрываются императивные программы. Применение этих 
операторов, как облагаемых налогом, лишь помогает приблизиться к хорошему 
Lisp-стилю, а не служит для него критерием. Тем не менее, лишь одно это 
позволит вам удивительно далеко зайти.

В других языках одной из наиболее частых причин возникновения побочных
эффектов является необходимость возврата функцией нескольких
значений. Если функции способны вернуть лишь одно значение, то они
должны "возвращать" оставшиеся путем изменения собственных
параметров. К счастью в Common Lisp в этом нет необходимости, так как любая
функция может вернуть несколько значений.

Встроенная функция truncate возвращает два значения, например,
округленное целое и то, что было отрезано с целью его
создания. Типичная реализация напечатает оба, когда truncate
вызывается из верхнего уровня:


@example
> (truncate 26.21875)
26
0.21875
@end example

Когда вызывающий код требует одно значение, будет использовано первое:

@example
> (= (truncate 26.21875) 26)
T
@end example

Вызывающий код может получить оба возвращаемых значения при помощи
multiple-value-bind. Этот оператор принимает список переменных, вызова,
а также тело программного кода. Код выполняется с привязкой переменных к
соответствующим значениям, возвращаемым вызовом:

@example
> (multiple-value-bind (int frac) (truncate 26.21875)
       (list int frac))
(26 0.21875)
@end example

Наконец, чтобы возвращать несколько значений, мы используем оператор
values:

@example
> (defun powers (x)
       (values x (sqrt x) (expt x 2)))
POWERS
> (multiple-value-bind (base root square) (powers 4)
       (list base root square))
(4 2.0 16)
@end example

Вообще, функциональное программирование -- хорошая идея. И особенно
хорошая в Lisp, так как Lisp развивался для того, чтобы её
поддерживать. Встроенные операторы, такие как reverse и nreverse, 
предполагается использовать в таком ключе. Другие операторы,
как values и multiple-value-bind, были разработаны как раз для того,
чтобы сделать функциональное программирование легче.

@menu
* 3-2 Imperative Outside-In::   
* 3-3 Functional Interfaces::   
* 3-4 Interactive Programming::  
@end menu

@node 3-2 Imperative Outside-In, 3-3 Functional Interfaces, 3-1 Functional Design, 3 Functional Programming
@comment  node-name,  next,  previous,  up
@section 3-2 Императивное программирование наизнанку
@cindex 3-2 Imperative Outside-In

Возможно, цели функционального программирования станут более понятными
в процессе сравнения с другим, более распространенным подходом --
императивным программированием. Функциональная программа говорит вам
то, что она хочет; императивная же говорит вам, что
делать. Функциональная программа говорит: <<Вернуть список, состоящий
из a и квадрата первого элемента x>>:

@lisp
(defun fun (x)
  (list 'a (expt (car x) 2)))
@end lisp

Императивная программа говорит: <<Взять первый элемент x, затем
возвести его в квадрат, затем вернуть список, состоящий из a и
квадрата>>:

@lisp
(defun imp (x)
  (let (y sqr)
        (setq y (car x))
        (setq sqr (expt y 2))
        (list 'a sqr)))
@end lisp

Пользователям Lisp повезло в том, что они могут написать эту программу
любым из двух способов. Некоторые языки приспособлены только для
императивного программирования, среди большинства языков
программирования особенно выделяется Basic. В действительности,
определение imp по внешнему виду напоминает машинный код, который
генерирует большинство компиляторов? Вероятно, ради забавы.


Зачем писать такой код, который может сделать за вас компилятор? Для
многих программистов этот вопрос даже никогда не встает. Язык
накладывает шаблон на наши мысли: кто-то, кто привык программировать
на императивном языке, скорее всего, начнет планировать программу в
императивных выражениях и наверняка обнаружит, что написание
императивных программ легче, чем функциональных. Имеет смысл
перешагнуть через этот стереотип, если у вас есть язык, позволяющий
это сделать.

Те, кто изучил другие языки, начав использовать лисп, будут походить
на ступивших в первый раз на каток. Вообще-то, если использовать
коньки, то намного легче выйти на лед, чем на землю. А до тех пор вам
останется лишь гадать о том, что люди находят в этом спорте.


Функциональное программирование означает для Lisp то же, что и коньки
для льда. Вместе они позволят передвигаться более изящно и с меньшими
усилиями. Но если вам привычен иной способ перемещения, то этот стиль 
не будет вашим первым опытом. Одно из препятствий к изучению Lisp в
качестве второго языка заключается в том, чтобы научиться
программировать в функциональном стиле.

К счастью, есть хитрость, позволяющая преобразовать императивные
программы в функциональные. Можно начать с применения этой хитрости к
законченному коду. Вскоре вы начнете себя предвосхищать и
преобразовывать код по мере его написания. Вслед за этим, вы начнете
думать о программах в функциональном плане с самого начала.

Хитрость заключается в том, чтобы понять, что императивная программа
представляет собой вывернутую на изнанку функциональную. Чтобы
отыскать запрятанную функциональную программу, мы просто вывернем ее
еще раз. Давайте попробуем этот метод на imp.

Первое, что мы замечаем -- это создание y и sqr в начальном let. Это
признак того, что плохие вещи впереди. Как eval во время выполнения,
неинициализированные переменные необходимы настолько редко, что они в
большинстве случаев должны рассматриваться как симптом некоторых
заболеваний программы. Такие переменные часто используются как
булавки, удерживающие программу от скручивания в естественную форму.

Несмотря на это, мы на время оставим их в покое и перейдем прямо в
конец функции. То, что в императивной программе происходит последним,
в функциональной происходит вначале. Таким образом, наш первый шаг -- 
взять последний вызов создания списка(list) и начать набивать туда оставшуюся часть
программы в точности, как выворачивают рубашку наизнанку. Мы
продолжим многократно применять такое же преобразование так же, как
поступили бы с рукавами рубашки, а затем и с манжетами.


Начиная с конца, мы переместим sqr вместе с (expt y 2):

@lisp
(list 'a (expt y 2)))
@end lisp

Затем заменим y на (car x):

@lisp
(list 'a (expt (car x) 2))
@end lisp

Теперь мы можем выкинуть оставшийся код, который полностью вошел в
последнее выражение. В ходе этого процесса мы убрали необходимость в
переменных y и sqr, так что мы можем также избавиться и от let.

Окончательный результат короче, чем тот, с которого мы начинали, и
легче для понимания. В первоначальном коде мы столкнулись с последним
выражением (list 'a sqr), но не сразу понятно, откуда берется значение
sqr. Теперь источник возвращаемого значения открыт нашему взору, как
дорожная карта.

Пример в этом разделе был коротким, но технология масштабируется. В
самом деле, она становится более ценной, если применяется к функциям
большего размера. Даже функции, осуществляющие побочные действия,
можно разобрать на части, которые не будут этого делать.


@node 3-3 Functional Interfaces, 3-4 Interactive Programming, 3-2 Imperative Outside-In, 3 Functional Programming
@comment  node-name,  next,  previous,  up
@section 3-3 Функциональные интерфейсы
@cindex 3-3 Functional Interfaces

Некоторые побочные действия хуже, чем другие. Например, хотя эта
функция вызывает nconc


@lisp
(defun qualify (expr)
  (nconc (copy-list expr) (list 'maybe)))
@end lisp

она оставляет ссылочную прозрачность.@footnote{ Определение ссылочной 
прозрачности приводится на странице 198} Если вы вызовете ее с 
заданным аргументом, то она всегда будет возвращать такое же (равное)
значение. С точки зрения вызывающего, qualify также может считаться
чисто функциональным кодом. Чего нельзя сказать того же о bad-reverse
(стр. 29), которая фактически модифицирует свои аргументы.

Вместо того, чтобы рассматривать побочные действия как одинаково
плохие, было бы полезно, если бы мы каким-то образом могли находить
различия между такими случаями. Неформально можно сказать, что для
функции безвредно модифицировать что-то, чем никто не
владеет. Например, nconc в qualify является безвредной потому, что
список, переданный в качестве первого аргумента, только что
создан (consed). Больше никто не может быть его владельцем.

В общем случае, следует говорить не о том, чем владеют сами функции, а
о том, чем владеют вызовы функций. Хотя здесь никто не владеет
переменной x:

@lisp
(let ((x 0))
  (defun total (y)
        (incf x y)))
@end lisp

эффекты одного вызова будут видны в последующих. Поэтому правило
должно быть таким: данный вызов может безопасно изменять лишь то, чем
владеет только он.

Кто владеет аргументами и возвращаемыми значениями? По соглашению в
Lisp считается, что вызов владеет объектами, полученными в качестве
возвращаемых значений, но не объектами, переданными ему в качестве
аргументов. Функции, изменяющие свои аргументы, определяются с помощью
метки "деструктивный", но нет никакого специального названия для
функций, изменяющих возвращенные им объекты.

Например, эта функция придерживается соглашения:

@lisp
(defun ok (x)
  (nconc (list 'a x) (list 'c)))
@end lisp

Она вызывает nconc, который не придерживается [соглашения], но
поскольку список, объединяемый с помощью nconc будет всегда создаваться заново, в отличие,
например, от списка, переданного ok в качестве аргумента, ok сам по
себе будет придеживаться функционального интерфейса.

Тем не менее, если она была бы написана несколько иначе, 

@lisp
(defun not-ok (x)
  (nconc (list 'a) x (list 'c)))
@end lisp

вызов nconc изменил бы аргумент, переданный not-ok.

Многие Lisp программисты нарушают это соглашение, по крайней мере
локально. Однако, как мы видели в ok, локальные нарушения не должны
делать негодной вызывающую функцию. И функции, действительно
отвечающие предыдущим условиям, будут содержать в себе множество
преимуществ чисто функционального кода.

Чтобы писать программы, действительно не отличимые от функционального
кода, мы должны добавить еще одно условие. Функции не могут совместно
использовать объекты с кодом, который не следует установленным нами правилам. 
Например, хотя эта функция и не имеет побочных эффектов,

@lisp
(defun anything (x)
      (+ x *anything*))
@end lisp

ее значение зависит от глобальной переменной *anything*. Так, если
любая другая функция может изменять значение этой переменной, то
anything может возвращать что угодно.

Код, написанный в стиле, когда каждый вызов изменяет лишь только
то, чем он владеет, почти так же хорош, как и чисто функциональный
код. Функция, удовлетворяющая всем приведенным выше условиям,
представляет миру функциональный интерфейс: если вызвать ее дважды с
теми же аргументами, то вы должны получить одинаковые результаты. И
это, как будет показано в следующем разделе, является важным
ингредиентом в программировании снизу-вверх.

Одна из проблем с деструктивными операциями заключается в том, что,
как и глобальные переменные, они могут разрушить локальность программы. 
Во время написания функционального кода, вы можете сузить свое поле 
зрения: необходимо рассмотреть лишь функции, которые вызывают ту или 
вызываются той, которую вы пишете. Данное преимущество исчезает, 
если вы хотите изменить что-то деструктивно. Это может быть
использовано где угодно.

Приведенные выше условия не гарантируют, что вы получите идеальную
локальность вместе с чисто функциональным кодом, хотя они несколько
улучшают положение вещей. Например, предположим, что f вызывает g, как
показано ниже:


@lisp
(defun f (x)
      (let ((val (g x)))
       ; safe to modify val here?
       ))
@end lisp

Безопасно ли для f присоединить что-нибудь к val с помощью nconc? Нет,
если g тождество(простое переименование переменных): тогда мы бы изменяли что-то,
изначально переданное самой f в качестве аргумента.

Поэтому, даже в программах, которые следуют соглашению, нам, возможно,
придется выйти за пределы f в том случае, если мы захотим там что-то
изменить. Тем не менее, не придется идти слишком далеко: вместо того,
чтобы беспокоиться о всей программе, теперь только лишь нужно
рассмотреть поддерево, начиная с f.

Следствием приведенного выше соглашения является то, что те функции не
должны возвращать ничего, что небезопасно изменять. Таким образом,
следует избегать написания функций, возвращаемые значения которых
включают в себя квотированные объекты. Если мы определим excalaim так,
что его возвращаемые значения включают в себя квотированный список, то

@anchor{page-037}
@lisp
(defun exclaim (expression)
  (append expression '(oh my)))
@end lisp

Тогда любое последующее деструктивное изменение возвращаемого значения

@example
> (exclaim '(lions and tigers and bears))
(LIONS AND TIGERS AND BEARS OH MY)
> (nconc * '(goodness))
(LIONS AND TIGERS AND BEARS OH MY GOODNESS)
@end example

может изменить список внутри функции!!!:

@example
> (exclaim '(fixnums and bignums and floats))
(FIXNUMS AND BIGNUMS AND FLOATS OH MY GOODNESS)
@end example

Для того чтобы сделать exclaim защищенной от такого рода проблем, ее
следовало написать так:

@lisp
(defun exclaim (expression)
  (append expression (list 'oh 'my)))
@end lisp

Существует одно важное исключение из того правила, что функции не
должны возвращать квотированные списки: это функции, которые генерируют
макрорасширения. Макрорасширители могут без проблем включать
квотированные списки в порождаемые ими расширения в том случае, если
макрорасширения прямо передаются компилятору.

С другой стороны, можно было бы также с подозрением относиться к
квотированным спискам в целом. Можно придумать им и множество других
применений, которые скорее всего будут выполнены с помощью макросов
наподобие in.

@node 3-4 Interactive Programming,  , 3-3 Functional Interfaces, 3 Functional Programming
@comment  node-name,  next,  previous,  up
@section 3-4 Интерактивное программирование
@cindex 3-4 Interactive Programming

Предыдущие разделы представляли функциональное программирование как
хороший способ организации программ. Но это нечто  большее. 
Lisp-программисты приняли функциональный стиль не только из
эстетических соображений. Они используют его потому, что он облегчает
им работу. В динамическом окружении Lisp функциональные программы
могут быть написаны с необыкновенной быстротой и в то же время
необычайно надёжны.

В Lisp относительно легко отлаживать программы. Очень много информации, 
помогающей найти причины возникновения ошибок, можно получить во время 
выполнения. Но еще более важным является легкость, с которой вы можете 
тестировать программы. Нет необходимости компилировать программу и 
тестировать все целиком за один раз. Вы  можете протестировать функции 
по отдельности, вызывая их из цикла верхнего уровня.

Инкрементное тестирование настолько значимо, что для того, чтобы получить выигрыш 
от его использоывания, Lisp стиль эволюционировал. Программы, написанные в 
функциональном стиле, можно воспринимать по одной функции за раз, и с точки зрения
читающего, это и есть его главное достоинство. Тем не менее, функциональный стиль
прекрасно приспособлен к инкрементному тестированию: программы, написанные в этом 
стиле, можно также протестировать по одной функции за раз. Когда функция не 
анализирует и не изменяет внешнего состояния, любые ошибки немедленно проявятся. 
Такая функция может влиять на внешний мир только через свои возвращаемые значения. 
В тех же пределах, в каких вы полагаетесь на эти значения, вы можете доверять
вернувшему их коду.

Опытные Lisp-программисты фактически делают свои программы удобными
для тестирования:

@enumerate
@item
Они пытаются отделить побочные действия в несколько функций, позволяющих 
большей части программы быть написанной в чисто функциональном стиле.
@item
Если функция должна осуществлять побочные действия, они по крайней
мере пытаются дать ей функциональный интерфейс.
@item
Они дают каждой функции единственную, четко определенную цель.
@end enumerate

Когда функция написана, они могут проверить ее на выборке из типичных случаев, а 
затем перейти к следующей. Если каждый кирпич делает то же, что и предполагалось 
делать, то стена будет стоять.

С таким же успехом в Lisp стену можно спроектировать лучшим образом. Представьте себе,
что если бы вы разговаривали с кем-то, находящимся настолько далеко, что задержки 
передачи составляли бы одну минуту. Теперь представьте разговор с кем-то, находящимся
в соседней комнате. Это бы не сделало прежний разговор быстрее, это был бы другой
вид разговора. В Lisp разработка программ похожа на разговор лицом к  лицу. 
Можно проверять код по мере его написания. И стоит вам отвернуться, и это возымеет
такие же резкие последствия на разработку, какие оказало бы на беседу. 
Вы не просто пишете ту же программу быстрее, вы пишете программу иного вида.

Как так? Когда тестирование быстрее, его можно делать чаще. В Lisp, как и в любом 
языке, разработка - это цикл написания и тестирования. Но в Lisp этот цикл очень
короткий: одиночная функция или части функций. А если проверять все по мере 
написания, то в случае возникновения ошибки, вы будете знать, где искать: в конце
написанного. Как бы просто это ни выглядело, но именно этот принцип, в
большей степени, позволяет программированию снизу-вверх быть возможным. 
Это приносит дополнительную степень уверенности, позволяющую Lisp-программистам 
свободно отдыхать, по крайней мере часть времени, от старого стиля разработки 
программного обеспечения "спланируй и реализуй".

В раздел 1.1 отмечено, что проектирование снизу-вверх -- эволюционный
процесс. Вы создаете язык по мере написания на нем программы. Такой
подход может работать, только если вы доверяете нижним слоям
кода. Если вы действительно хотите использовать этот слой как язык, то
вы должны уметь допускать, как и в случае с любым языком, что любые
обнаруженные ошибки -- это ошибки приложения, а не самого языка.


Итак, ваши новые абстракции должны нести это тяжелое бремя ответственности, 
и все же вы собираетесь создавать на их основе новые?
Именно так, в Lisp это возможно одновременно. Когда вы пишете
программы в функциональном стиле и инкрементно тестируете их, можно
получить гибкость создания вещей под влиянием момента вдобавок к
некоторой надежности, обычно ассоциируемой с тщательным планированием.