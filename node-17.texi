@node 17 Read-Macros, 18 Destructuring, 16 Macro-Defining Macros, Top
@comment  node-name,  next,  previous,  up
@chapter 17 Макросы Чтения
@cindex 17 Read-Macros

Различают три больших момента в жизни Lisp выражения: время чтения, время 
компиляции и время выполнения. Функции управлют во время выполнения. Макросы
дают нам возможность выполнять преобразования в программах во время компиляции.
В этой главе обсуждаются макросы чтения, которые выполняют свою работу во время
чтения.

@menu
* 17-1 Macro Characters::       
* 17-2 Dispatching Macro Characters::  
* 17-3 Delimiters::             
* 17-4 When What Happens::      
@end menu

@node 17-1 Macro Characters, 17-2 Dispatching Macro Characters, 17 Read-Macros, 17 Read-Macros
@comment  node-name,  next,  previous,  up
@section 17-1 Макросы Знаки
@cindex 17-1 Macro Characters

В соответствии с общей философией Lisp, у вас есть большой контроль над читателем
(reader). Его поведение управляется свойствами и переменными, которые все могут быть
изменены на лету. Читатель(reader) может быть запрограммирован на нескольких уровнях.
Самый простой способ изменить его поведение - определить новые Макросы-Знаки.

Макрос-Знак это знак(литерал, буква), который требует особого отношения от читателя
(reader) Lisp. Например, строчная буква a обычно обрабатывается так же как строчная
буква b, но левая скобка "(" - это нечто совсем иное: она говорит Lisp-у начать чтение
списка. Каждый такой знак имеет функцию связанную с ним, которая сообщает Lisp читателю
(reader), что делать когда встречается этот знак. Вы можете изменить функцию связанную
с существующим Макросом-Знаком или определить новые Макросы-Знаки самостоятельно.

Встроенная функция set-macro-character обеспечивает один из способов определения
Макросов Чтения. Она требует знак и функцию, а заем при чтении встречая указанный
знак возвращает результат вызова этой функции.

Один из старейших макросов чтения в Lisp является  ', цитата/кавычка. Вы можете
обойтись и без кавычки - ' , всегда записывая (quote a) вместо 'a, но это будет
очень утомительно, и сделает ваш код сложнее для чтения. Макрос чтения кавычка,
делает возможным использование 'a как аббревиатуру для (quote a). Мы могли бы
определить его как на Рисунке 17-1.

@cartouche
@lisp
 (set-macro-character #\'
       #'(lambda (stream char)
           (list 'quote (read stream t nil t))))
@end lisp

                      Рисунок 17-1: Возможное определение мароса знака - '.
@end cartouche

Когда читатель(read) встречается с экземпляром ' в обычном контексте (т.е не в "a'b" 
или |a'b|), он вернет результат вызова этой функции в текущий поток и знак. (Функция
игнорирует этот второй параметр, который всегда будет знаком кавычки.) Таким образом,
когда читатель(read) видит 'a, он вернет (quote a).

Последние три аргумента для read, соответственно, управляют должен ли конец файла
вызывать ошибку, какое значение вернуть в противном случае, и признак того что
вызов read происходит внутри другого вызова read. Почти во всех макросах чтения,
второй и четвертый аргументы должны быть t, и поэтому третий аргумент не имеет
значения.

Макросы чтения и обычные макросы, оба типа являются функциями нижнего уровня.
И как функции, которые генерируют расширения макросов, функци связанные с
Макросами-Знаками не должны иметь побочных эффектов, кроме как в  потоке(stream)
из которого они производят чтение. Common Lisp явно не дает никаких гарантий
относительно того, когда и как часто будет вызываться функция связанная с 
макросом чтения (См. CLTL2, стр. 543.)

Макросы и макросы чтения смотрят на нашу программу на разных этапах. Макросы
получают считанную программу, когда она уже была проанализирована и разобрана
в Lisp обекты читателем(reader), и макросы чтения работают с программой, когда
она еще является текстом. Тем не менее, вызывая read для этого текста, макрос
чтения может, если захочет, получить проанализированные объекты Lisp. Таким
образом, макросы чтения, по крайней мере так же мощны, как и обычные макросы.

В действительности, макросы чтения являются даже более мощными, по крайней мере,
в двух направлениях. Макрос чтения влияет на все, что читает Lisp, в то время
как обычный макрос расширяется только в код. И так как макаросы чтения обычно
вызывают read рекурсивно, выражения подобные

@lisp
''a
@end lisp

@noindent
превращаются в

@lisp
(quote (quote a))
@end lisp

@noindent
тогда как, если бы мы попытались определить сокращение для кавычки используя обычный
макрос,

@lisp
(defmacro q (obj)
  `(quote ,obj))
@end lisp

@cartouche
@lisp
     (set-dispatch-macro-character #\# #\?
       #'(lambda (stream char1 char2)
            `#'(lambda (&rest ,(gensym))
                  ,(read stream t nil t))))
@end lisp

                 Рисунок 17-2: Макросы чтения для постоянных функций.
@end cartouche

@noindent
он будет работать изолированно,

@example
> (eq 'a (q a))
T
@end example

@noindent
но не когда вложен. Например,

@lisp
(q (q a))
@end lisp

@noindent
будет расширяться в

@lisp
(quote (q a))
@end lisp

@node 17-2 Dispatching Macro Characters, 17-3 Delimiters, 17-1 Macro Characters, 17 Read-Macros
@comment  node-name,  next,  previous,  up
@section 17-2 Диспетчерские Макросы-Знаки
@cindex 17-2 Dispatching Macro Characters

Решетка с кавычкой #', подобно другим маросам чтения начинающимся с решетки #, 
является примером подвида, называемым диспетчерскими макросами чтения. Они 
появляются как два знака, первый из которых называется диспетчерским знаком. 
Цель таких макросов чтнения простая, чтобы можно было максимально использовать
набор ASCII знаков;  один знак позволяет иметь столько макросов чтения, сколько
всего одиночных знаков.

Вы можете (с помощью make-dispatch-macro-character) определить свой собственный
диспетчерский макрос-знак, но так как # уже определен как один из них, вы можете
использовать его. Некоторые комбинации начинающиеся с # явно зарезервированы для
использования вами; другие доступны, в том смысле, что они еще не имеют 
предопределенного значения в Common Lisp. Полный список приведен в CLTL2, стр. 531.

Новые комбинации диспетчерских макро знаков могут быть определены путем вызова
функции set-dispatch-macro-character, похожей на set-macro-character 
за исключением того, что она принимает два знаковых аргумента. Одной из 
зарезервированных комбинаций для программиста является  #?. На Рисунке 17-2 
показано, как определить эту комбинацию как макрос чтения для постоянных
функций.Теперь #?2 будет читаться как функция, которая принимает любое
количество аргументов и возвращает 2. Например:

@example
> (mapcar #?2 '(a b c))
(2 2 2)
@end example

@cartouche
@lisp
     (set-macro-character #\] (get-macro-character #\)))

     (set-dispatch-macro-character #\# #\[
      #'(lambda (stream char1 char2)
           (let ((accum nil)
                   (pair (read-delimited-list #\] stream t)))
              (do ((i (ceiling (car pair)) (1+ i)))
                   ((> i (floor (cadr pair)))
                     (list 'quote (nreverse accum)))
                 (push i accum)))))
@end lisp

                   Рисунок 17-3: Макрос чтения определяющий разделители.
@end cartouche

Этот пример создает новый оператор выглядящий довольно бессмысленным, но в программах
которые используют много функциональных аргументов, постоянные функции часто необходимы.
По факту, некоторые диалекты предоставляют встроенную функцию, которая вызывается
всегда для их определения.

Обратите внимание, что вполне нормально использовать макросы-Знаки в определении
этого макроса-знака: как и в любом Lisp выражении, они исчезают, когда определение
будет прочитано. Так же хорошо использовать Макросы-Знаки после #?. Определение #?
вызывает read, поэтому макросы-знаки, подобные ' и #' ведут себя как обычно:

@example
> (eq (funcall #?'a) 'a)
T> (eq (funcall #?#'oddp) (symbol-function 'oddp))
T
@end example

@node 17-3 Delimiters, 17-4 When What Happens, 17-2 Dispatching Macro Characters, 17 Read-Macros
@comment  node-name,  next,  previous,  up
@section 17-3 Разделители
@cindex 17-3 Delimiters

После простых макросов-знаков, наиболее часто определяемыми макросами-знаками
являются разелители списка. Другой комбинацией зарезервированной для пользователя,
является #[. На рисунке 17-3 приведен пример, как этот символ может быть определен
как более сложный вид левой скобки. Он определяет выражения вида #[x y] для
читателя(read) как список всех целых чисел заключенных между x и y, включительно:

@example
> #[2 7]
(2 3 4 5 6 7)
@end example

Единственно новая вещь в этом макросе чтения это вызов read-delimited-list, встроенной
функции предусмотренной, как раз для таких случаев. Её первый аргуентом является знак,
рассматриваемый как конец списка. Чтобы ] был распознан как разделитель, он должен быть
первым в этой роли, отсюда и предварительный вызов set-macro-character.

@cartouche
@lisp
     (defmacro defdelim (left right parms &body body)
       `(ddfn ,left ,right #'(lambda ,parms ,@@body)))

     (let ((rpar (get-macro-character #\) )))
       (defun ddfn (left right fn)
         (set-macro-character right rpar)
         (set-dispatch-macro-character #\# left
            #'(lambda (stream char1 char2)
                 (apply fn
                          (read-delimited-list right stream t))))))
@end lisp

              Рисунок 17-4: Макрос для определения макросов чтения разделителей.
@end cartouche

Большинство потенциальных определений макросов чтения разделителей будут дублировать
большую часть кода на рисунке 17-3. Макрос можно поместить в более абстрактный
интерфейс всего этого механизма. На Рисунке 17-4 показано, как мы можем определить 
утилитуs для определенения макросов чтения разделителя. Макрос defdelim принимает
два знака, списко параметров и тело кода. Список параметров и тело кода неявно
определяют функцию. Вызов defdelim определяет первый символ как диспетчерский
макрос чтения, который выполняет чтение до второго указанного знака, а затем
возвращает результат применения функции к тому, что он прочитал.
   Между прочим, тело функции на рисунке  17-3 также требует утилиты:  которую
мы уже определили, фактически: mapa-b, со страницы 54. Используя defdelim
и mapa-b, макрос чтения определенный на Рисунке 17-3 может быть записан:

@lisp
(defdelim #\[ #\] (x y)
     (list 'quote (mapa-b #'identity (ceiling x) (floor y))))
@end lisp

Другим полезным применением макроса чтения разделителей может быть функциональная 
композиция. Раздел 5-4 определяет оператор для функциональной композиции:

@example
> (let ((f1 (compose #'list #'1+))
             (f2 #'(lambda (x) (list (1+ x)))))
        (equal (funcall f1 7) (funcall f2 7)))
T
@end example

Когда мы составляем встроенные функции, такие как list и 1+, нет причин ждать
времени выполнения для того, чтобы выполнить вызов compose. Раздел 5-7 предлагал,
алльтернативу; добавив макрос чтения решетка с точкой #. к выражению compose,

@cartouche
@lisp
#.(compose #'list #'1+)
 (defdelim #\@{ #\@} (&rest args)
       `(fn (compose ,@@args)))
@end lisp

              Рисунок 17-5: Макрос чтения для функциональной композиции.
@end cartouche

@noindent
мы могли бы заставить его выполниться во время чтения.

Здесь мы показываем подробно, но более ясное решение. Макрос чтения на Рисунке 17-5
определяет выражение вида #@{f 1 f 2 ...fn@} как чтение композиции функций
f 1, f 2,...,fn. Таким образом:

@example
> (funcall #@{list 1+@} 7)
(8)
@end example

Он работает путем генерации вызова функций до fn (стр. 202), которая создает функцию
во время компиляции.

@menu
* 17-4 When What Happens::      
@end menu

@node 17-4 When What Happens,  , 17-3 Delimiters, 17 Read-Macros
@comment  node-name,  next,  previous,  up
@section 17-4 Когда Что Происходит
@cindex 17-4 When What Happens

В заключении, может быть полезно разобраться в возможной путанице. Если макросы чтения
вызываются до обычных макросов, как получается, что  эти макросы могут расширяться в
выражения, которые содержат макросы чтения? Например, макрос:

@lisp
(defmacro quotable ()
  '(list 'able))
@end lisp

генерирует расширение с кавычкой в нем. Или нет? На самом деле происходит следующее,
обе кавычки в определении этого макроса раскрываются когда выражение defmacro
читается, первращаясь в

@lisp
(defmacro quotable ()
  (quote (list (quote able))))
@end lisp

Обычно нет ничего плохого в том, что разложения макроса могут содержать
макросы чтения, потому что определение макроса чтения не (или не должно) 
измениться, между временем чтения и временем компиляции.