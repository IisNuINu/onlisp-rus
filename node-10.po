#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-10.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-07-04 11:37+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-10.texi:5
msgid ""
"@node 10 Other Macro Pitfalls, 11 Classic Macros, 9 Variable Capture, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 10 Other Macro Pitfalls\n"
"@cindex 10 Other Macro Pitfalls"
msgstr ""
"@node 10 Other Macro Pitfalls, 11 Classic Macros, 9 Variable Capture, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 10 Другие Ошибки в Макросах\n"
"@cindex 10 Other Macro Pitfalls"

#: texi/node-10.texi:17
msgid ""
"Writing macros requires an extra degree of caution. A function is isolated "
"in\n"
"its own lexical world, but a macro, because it is expanded into the calling "
"code,\n"
"can give the user an unpleasant surprise unless it is carefully written. "
"Chapter 9\n"
"explained variable capture, the biggest such surprise. This chapter "
"discusses four\n"
"more problems to avoid when defining macros.\n"
"@menu\n"
"* 10-1 Number of Evaluations::  \n"
"* 10-2 Order of Evaluation::    \n"
"* 10-3 Non-functional Expanders::  \n"
"* 10-4 Recursion::              \n"
"@end menu"
msgstr ""
"Написание макросов требует особой осторожности. Функция изолирована в своем "
"собственном\n"
"лексическом мире, но макрос. поскольку он расширяется в вызывающем его коде, "
"может\n"
"преподнести пользователю неприятный сюрприз, если он не будет написан очень "
"тщательно.\n"
"Глава 9 обяснила захват переменных, самый большой подобный сюрприз. В этой "
"главе\n"
"рассматриваются больше проблем, чтобы избежать их при определении макросов.\n"
"@menu\n"
"* 10-1 Number of Evaluations::  \n"
"* 10-2 Order of Evaluation::    \n"
"* 10-3 Non-functional Expanders::  \n"
"* 10-4 Recursion::              \n"
"@end menu"

#: texi/node-10.texi:22
msgid ""
"@node 10-1 Number of Evaluations, 10-2 Order of Evaluation, 10 Other Macro "
"Pitfalls, 10 Other Macro Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-1 Number of Evaluations\n"
"@cindex 10-1 Number of Evaluations"
msgstr ""
"@node 10-1 Number of Evaluations, 10-2 Order of Evaluation, 10 Other Macro "
"Pitfalls, 10 Other Macro Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-1 Количество Вычислений\n"
"@cindex 10-1 Number of Evaluations"

#: texi/node-10.texi:25
msgid ""
"Several incorrect versions of for appeared in the previous chapter. Figure "
"10-1\n"
"shows two more, accompanied by a correct version for comparison."
msgstr ""
"Несколько неправильных версий for появились в предыдущей главе. Рисунок "
"10-1\n"
"показывает еще две, в сопровождении правильной версии(для сравнения)."

#: texi/node-10.texi:32
msgid ""
"Though not vulnerable to capture, the second for contains a bug. It will\n"
"generate an expansion in which the form passed as stop will be evaluated on "
"each\n"
"iteration. In the best case, this kind of macro is inefficient, repeatedly "
"doing what\n"
"it could have done just once. If stop has side-effects, the macro could "
"actually\n"
"produce incorrect results. For example, this loop will never terminate, "
"because\n"
"the goal recedes on each iteration:"
msgstr ""
"Хотя он и не уязвим к захвату, второй for содержит ошибку. Он будет "
"создавать\n"
"расширение в котором, форма переданная в качестве условия остановки(stop) "
"будет\n"
"вычисляться на каждой итерации. В лучшем случае, этот вид макроса не "
"эффективен\n"
"(незачем многократно вычислять то, что можно вычислить один раз). Если stop "
"имеет \n"
"сторонние эффекты, макрос на самом деле может дать неправильные результаты. "
"Например, \n"
"этот цикл никогда не прекратиться, потому что цель отступает(отодвигается) "
"на каждой \n"
"итерации:"

#: texi/node-10.texi:39
msgid ""
"@example\n"
"> (let ((x 2))\n"
"     (for (i 1 (incf x))\n"
"        (princ i)))\n"
"12345678910111213...\n"
"@end example"
msgstr ""

#: texi/node-10.texi:42
msgid ""
"In writing macros like for, one must remember that the arguments to a macro\n"
"are forms, not values. Depending on where they appear in the expansion, they"
msgstr ""
"При написании макросов подобных for нужно помнить, что аргументы макроса "
"это\n"
"формы, а не значения. В зависимости от ого, где они появляются в "
"расширении,\n"
"они могут вычислятся более одного раза."

#: texi/node-10.texi:44
msgid "A correct version:"
msgstr ""
"@cartouche\n"
"Правильная версия:"

#: texi/node-10.texi:53
msgid ""
"@lisp\n"
" (defmacro for ((var start stop) &body body)\n"
"       (let ((gstop (gensym)))\n"
"         `(do ((,var ,start (1+ ,var))\n"
"                 (,gstop ,stop))\n"
"                ((> ,var ,gstop))\n"
"             ,@@body)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:55
msgid "Subject to multiple evaluations:"
msgstr "Подлежит многократному вычислению:"

#: texi/node-10.texi:62
msgid ""
"@lisp\n"
" (defmacro for ((var start stop) &body body)\n"
"       `(do ((,var ,start (1+ ,var)))\n"
"             ((> ,var ,stop))\n"
"           ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:64
msgid "Incorrect order of evaluation:"
msgstr "Неверный порядок вычилений:"

#: texi/node-10.texi:73
msgid ""
"@lisp\n"
" (defmacro for ((var start stop) &body body)\n"
"       (let ((gstop (gensym)))\n"
"         `(do ((,gstop ,stop)\n"
"                 (,var ,start (1+ ,var)))\n"
"                ((> ,var ,gstop))\n"
"             ,@@body)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:75
msgid "                    Figure 10-1: Controlling argument evaluation."
msgstr ""
"                    Рисунок 10-1: Управление вычислением аргументов\n"
"@end cartouche"

#: texi/node-10.texi:79
msgid ""
"could be evaluated more than once. In this case, the solution is to bind a "
"variable\n"
"to the value returned by the stop form, and refer to the variable during the "
"loop."
msgstr ""
"В этом случае решение состоит в том, чтобы привязать переменную к значению "
"возвращающему\n"
"формой stop, и обращаться к этой переменной во время цикла."

#: texi/node-10.texi:89
msgid ""
"Unless they are clearly intended for iteration, macros should ensure that "
"ex-\n"
"pressions are evaluated exactly as many times as they appear in the macro "
"call.\n"
"There are obvious cases in which this rule does not apply: the Common Lisp\n"
"or would be much less useful (it would become a Pascal or) if all its "
"arguments\n"
"were always evaluated. But in such cases the user knows how many "
"evaluations\n"
"to expect. This isn't so with the second version of for: the user has no "
"reason to\n"
"suppose that the stop form is evaluated more than once, and in fact there is "
"no\n"
"reason that it should be. A macro written like the second version of for is "
"most\n"
"likely written that way by mistake."
msgstr ""
"Если они явно не предназначены для итерации, макросы должны гарантировать, "
"что\n"
"выражения вычисляются ровно столько раз, сколько они появляются в вызове "
"макроса.\n"
"Существуют очевидные случаи, когда это правило не применяется: оператор or в "
"Common Lisp \n"
"будет менее полезным (он станет как Pascal or), если все его аргументы "
"будут\n"
"всегда вычисляться. Но в таких случаях пользователь точно знает сколько "
"вычислений\n"
"ожидать. Это не так для второй версии for: у пользователя нет причин "
"предполагать,\n"
"что форма stop вычисляется более одного раза и на самом деле нет причин, по "
"которым\n"
"это должно происходить. Макрос написанный подобно второй версии for "
"вероятнее всего\n"
"написан так по ошибке."

#: texi/node-10.texi:93
msgid ""
"Unintended multiple evaluation is a particularly difficult problem for "
"macros\n"
"built on setf. Common Lisp provides several utilities to make writing such\n"
"macros easier. The problem, and the solution, are discussed in Chapter 12."
msgstr ""
"Непреднамеренные множественные вычисления являются особенно сложной "
"проблемой для\n"
"макросов построенных на setf. Common Lisp предоставляет несколько утилит для "
"упрощения\n"
"написания таких макросов. Эта проблема и её решение обсуждаются в Главе 12."

#: texi/node-10.texi:98
msgid ""
"@node 10-2 Order of Evaluation, 10-3 Non-functional Expanders, 10-1 Number "
"of Evaluations, 10 Other Macro Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-2 Order of Evaluation\n"
"@cindex 10-2 Order of Evaluation"
msgstr ""
"@node 10-2 Order of Evaluation, 10-3 Non-functional Expanders, 10-1 Number "
"of Evaluations, 10 Other Macro Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-2 Порядок вычислений\n"
"@cindex 10-2 Order of Evaluation"

#: texi/node-10.texi:102
msgid ""
"The order in which expressions are evaluated, though not as important as "
"the\n"
"number of times they are evaluated, can sometimes become an issue. In "
"Common\n"
"Lisp function calls, arguments are evaluated left-to-right:"
msgstr ""
"Порядок в котором вычисления выражений, хотя и не так важен, как количество "
"их\n"
"вычислений, но иногда может стать проблемой. В Common Lisp при вызове "
"функции,\n"
"аргументы вычисляются слева на право:"

#: texi/node-10.texi:109
msgid ""
"@example\n"
"> (setq x 10)\n"
"10\n"
"> (+ (setq x 3) x)\n"
"6\n"
"@end example"
msgstr ""

#: texi/node-10.texi:112
msgid ""
"and it is good practice for macros to do the same. Macros should usually "
"ensure\n"
"that expressions are evaluated in the same order that they appear in the "
"macro call."
msgstr ""
"и хорошей практикой, будет, делать то же самое для макросов. Макросы обычно "
"должны обеспечивать\n"
"вычисление выражений в том же порядке, в котором они появляются в вызове "
"макроса."

#: texi/node-10.texi:116
msgid ""
"In Figure 10-1, the third version of for also contains a subtle bug. The\n"
"parameter stop will be evaluated before start, even though they appear in "
"the\n"
"opposite order in the macro call:"
msgstr ""
"На Рисунке 10-1, третья версия for также содержит хитрую ошибку. Параметр\n"
"stop будет вычисляться до параметра start, даже если они отображаются в "
"обратном\n"
"порядке при вызове макроса:"

#: texi/node-10.texi:124
msgid ""
"@example\n"
"> (let ((x 1))\n"
"        (for (i x (setq x 13))\n"
"         (princ i)))\n"
"13\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-10.texi:128
msgid ""
"This macro gives a disconcerting impression of going back in time. The "
"evaluation\n"
"of the stop form influences the value returned by the start form, even "
"though\n"
"the start form appears first textually."
msgstr ""
"Этот макрос дает приводящее в замешательство ощущение о возвращении во "
"времени. Вычисление\n"
"формы stop влияет на значение, возвращаемое формой start, даеж если форма "
"start появляется \n"
"в текстовом виде - первой."

#: texi/node-10.texi:131
msgid ""
"The correct version of for ensures that its arguments will be evaluated in "
"the\n"
"order in which they appear:"
msgstr ""
"Правильная весрия for гарантирует, что его аргументы будут вычисляться в том "
"порядке,\n"
"в котором они появляются:"

#: texi/node-10.texi:139
msgid ""
"@example\n"
"> (let ((x 1))\n"
"        (for (i x (setq x 13))\n"
"         (princ i)))\n"
"12345678910111213\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-10.texi:142
msgid ""
"Now setting x in the stop form has no effect on the value returned by the "
"previous\n"
"argument."
msgstr ""
"Теперь установка x в форме stop не повлияет на значение возвращаемое "
"предыдущими\n"
"аргументами."

#: texi/node-10.texi:151
msgid ""
"Although the preceding example is a contrived one, there are cases in which\n"
"this sort of problem might really happen, and such a bug would be extremely\n"
"difficult to find. Perhaps few people would write code in which the "
"evaluation of\n"
"one argument to a macro influenced the value returned by another, but people "
"may\n"
"do by accident things that they would never do on purpose. As well as having "
"to\n"
"work right when used as intended, a utility must not mask bugs. If anyone "
"wrote\n"
"code like the foregoing examples, it would probably be by mistake, but the "
"correct\n"
"version of for will make the mistake easier to detect."
msgstr ""
"Хотя предыдущий пример является надуманным, есть случаи, когда подобного "
"рода \n"
"проблемы действительно происходили, и такую ошибку чрезвычайно сложно "
"найти.\n"
"Возможно мало кто напишет код, в котором вычисление одного аргумента "
"макроса\n"
"влияет на значение возвращаемое другим, но люди могут случайно сделать то, "
"что\n"
"никогда бы не сделали нарочно. Утилита не должна маскировать ошибки, если \n"
"используется по назначению. Если кто нибудь написал код, как в предыдущих "
"примерах,\n"
"вероятно сделал он это по ошибке, но правильная версия for упростит "
"обнаружение\n"
"ошибки."

#: texi/node-10.texi:156
msgid ""
"@node 10-3 Non-functional Expanders, 10-4 Recursion, 10-2 Order of "
"Evaluation, 10 Other Macro Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-3 Non-functional Expanders\n"
"@cindex 10-3 Non-functional Expanders"
msgstr ""
"@node 10-3 Non-functional Expanders, 10-4 Recursion, 10-2 Order of "
"Evaluation, 10 Other Macro Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-3 Не функциональный код Расширителя(Функции создающей "
"расширение)\n"
"@cindex 10-3 Non-functional Expanders"

#: texi/node-10.texi:161
msgid ""
"Lisp expects code which generates macro expansions to be purely functional, "
"in\n"
"the sense described in Chapter 3. Expander code should depend on nothing "
"but\n"
"the forms passed to it as arguments, and should not try to have an effect on "
"the\n"
"world except by returning values."
msgstr ""
"Lisp ожидает, что код, который генерирует расширение макросов, будет чисто "
"функциональным,\n"
"в смысле описанным в Главе 3. Расширяющий код должен зависеть только от форм "
"передаваемых\n"
"ему в качестве аргументов, и не должен оказывать влияние на мир, кроме как "
"путем возвращения\n"
"значений."

#: texi/node-10.texi:170
msgid ""
"As of CLTL2 (p. 685), it is safe to assume that macro calls in compiled code "
"will\n"
"not be re-expanded at runtime. Otherwise, Common Lisp makes no guarantees\n"
"about when, or how often, a macro call will be expanded. It is considered an "
"error\n"
"for the expansion of a macro to vary depending on either. For example, "
"suppose\n"
"we wanted to count the number of times some macro is used. We can't simply\n"
"do a search through the source files, because the macro might be called in "
"code\n"
"which is generated by the program. We might therefore want to define the "
"macro\n"
"as follows:"
msgstr ""
"Начиная с CLTL2 (стр. 685), можно с уверенностью предположить, что вызовы "
"макросов\n"
"в скомпилированном коде не подлежит повторному расширению во время "
"выполнения.\n"
"В противном случае, Common Lisp не дает никаких гарантий о том, когда и как "
"часто\n"
"будет расширен вызов макроса. Считается ошибкой для расширения макроса "
"варьироваться\n"
"(изменяться) в зависимости от того или друго. Например, предположим,  мы "
"хотели посчитать, сколько раз используется какой либо макрос. Мы не можем "
"просто выполнить поиск по исходным\n"
"файлам, потому что макрос может быть вызван в коде, который генерируется "
"самой программой.\n"
"Поэтому мы моглибы захотеть определить макрос следующим образом:"

#: texi/node-10.texi:176
msgid ""
"@lisp\n"
"(defmacro nil! "
"(x)                                                           ; wrong\n"
"     (incf *nil!s*)\n"
"     `(setf ,x nil))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:183
msgid ""
"With this definition, the global *nil!s* will be incremented each time a "
"call\n"
"to nil! is expanded. However, we are mistaken if we expect the value of "
"this\n"
"variable to tell us how often nil! was called. A given call can be, and "
"often\n"
"is, expanded more than once. For example, a preprocessor which performed\n"
"transformations on your source code might have to expand the macro calls in "
"an\n"
"expression before it could decide whether or not to transform it."
msgstr ""
"С этим определением, глобальный *nil!s* будет увеличиваться при каждом "
"вызвове\n"
"расширения макроса nil!. Тем не менее, мы ошибаемся, если ожидаем, что "
"значение\n"
"этой переменной скажат нам, как часто вызвался nil!. Данный вызов может "
"быть\n"
"и частым, если он расширен более одного раза. Например, препроцессору, "
"который\n"
"выполняет преобразования в вашем исходном коде, возможно, придется "
"расширить\n"
"вызовы макросов в выражения, прежде чем он сможет определить, стоит ли его\n"
"преобразовывать."

#: texi/node-10.texi:188
msgid ""
"As a general rule, expander code shouldn't depend on anything except its\n"
"arguments. So any macro which builds its expansion out of strings, for "
"example,\n"
"should be careful not to assume anything about what the package will be at "
"the\n"
"time of expansion. This concise but rather pathological example,"
msgstr ""
"Основное правило, код расширителя не должен зависеть ни от чего. кроме его \n"
"аргументов. Так что любому макросу, например, который строит свое "
"расширение\n"
"из строк, следует быть осторожным, чтобы не предполагать, что пакет от "
"которого\n"
"зависит расширение макроса, будет загружен во время расширения. Это краткий, "
"но\n"
"довольно патологический пример,"

#: texi/node-10.texi:193
msgid ""
"@lisp\n"
"(defmacro string-call (opstring &rest "
"args)                                  ; wrong\n"
"     `(,(intern opstring) ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:197
msgid ""
"@noindent\n"
"defines a macro which takes the print name of an operator and expands into a "
"call\n"
"to it:"
msgstr ""
"@noindent\n"
"определяет макрос, который принимает печатное имя оператора и расширеят "
"вызов к нему:"

#: texi/node-10.texi:204
msgid ""
"@example\n"
"> (defun our+ (x y) (+ x y))\n"
"OUR+\n"
"> (string-call \"OUR+\" 2 3)\n"
"5\n"
"@end example"
msgstr ""

#: texi/node-10.texi:210
msgid ""
"The call to intern takes a string and returns the corresponding symbol. "
"However,\n"
"if we omit the optional package argument, it does so in the current package. "
"The\n"
"expansion will thus depend on the package at the time the expansion is "
"generated,\n"
"and unless our+ is visible in that package, the expansion will be a call to "
"an\n"
"unknown function."
msgstr ""
"Вызов intern принимает строку и возвращает соответствующий символ. Тем не "
"менее,\n"
"если мы опускаем необязательный аргумент package(пакет), он делает это в "
"текущем\n"
"пакете. Таким образом, расширение будет зависеть от текущего пакета во "
"время\n"
"создания расширения, и если our+ не виден в этом пакете, расширение будет с "
"вызовом\n"
"неизвестной функции."

#: texi/node-10.texi:217
msgid ""
"Miller and Benson's Lisp Style and Design mentions one particularly ugly  \n"
"example of problems arising from side-effects in expander code. In Common\n"
"Lisp, as of CLTL2 (p. 78), the lists bound to &rest parameters are not "
"guaranteed\n"
"to be freshly made. They may share structure with lists elsewhere in the "
"program.\n"
"In consequence, you shouldn't destructively modify &rest parameters, "
"because\n"
"you don't know what else you'll be modifying."
msgstr ""
"Миллер и Бенсон в книге \"Lisp Style and Design\"(Лисп Стиль и Дизайн) "
"упоминают\n"
"один особенно некрасивый прмер проблем, возникающих из-за побочных эффектов "
"в\n"
"коде расширителя. В Common Lisp, начиная с CLTL2 (стр. 78), списки связанные "
"с\n"
"параметром &rest не являются гарантированно новыми, свеже сформированными. "
"Они\n"
"могут разделять структуру со списками находящимися в другим местах "
"программы.\n"
"Следовательно, вы не должны разрушающе изменять параметр &rest,  потому что "
"вы\n"
"не знаете, что еще вы измените при этом."

#: texi/node-10.texi:222
msgid ""
"This possibility affects both functions and macros. With functions, "
"problems\n"
"would arise when using apply. In a valid implementation of Common Lisp the\n"
"following could happen. Suppose we define a function et-al, which returns a\n"
"list of its arguments with et al added to the end:"
msgstr ""
"Эта возможность влияет как на функции, так и на макросы. С функциями, "
"проблемы\n"
"возникают при использовании apply. В правильной реализаци Common Lisp может "
"произойти\n"
"следующее. Предположим, мы определили функцию et-al, которая возвращает "
"список\n"
"аргументов с добавлением  et al в конец:"

#: texi/node-10.texi:227
msgid ""
"@lisp\n"
"(defun et-al (&rest args)\n"
"  (nconc args (list 'et 'al)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:229
msgid "If we called this function normally, it would seem to work fine:"
msgstr ""
"Если бы мы вызвавали эту функцию обычным образом, она бы работала нормально:"

#: texi/node-10.texi:234
msgid ""
"@example\n"
"> (et-al 'smith 'jones)\n"
"(SMITH JONES ET AL)\n"
"@end example"
msgstr ""

#: texi/node-10.texi:236
msgid ""
"However, if we called it via apply, it could alter existing data structures:"
msgstr ""
"Однако, если мы вызываем ее через apply, она могла бы изменить существующие "
"структуры\n"
"данных:"

#: texi/node-10.texi:246
msgid ""
"@example\n"
"> (setq greats '(leonardo michelangelo))\n"
"(LEONARDO MICHELANGELO)\n"
"> (apply #'et-al greats)\n"
"(LEONARDO MICHELANGELO ET AL)\n"
"> greats\n"
"(LEONARDO MICHELANGELO ET AL)\n"
"@end example"
msgstr ""

#: texi/node-10.texi:249
msgid ""
"At least, a valid implementation of Common Lisp could do this, though so "
"far\n"
"none seems to."
msgstr ""
"По крайней мере, правильная реализация Common Lisp могла бы сделать это, "
"хотя,\n"
"кажется пока, так не делает никто."

#: texi/node-10.texi:255
msgid ""
"For macros, the danger is greater. A macro which altered an &rest parameter\n"
"could thereby alter the macro call. That is, you could end up with "
"inadvertently\n"
"self-rewriting programs. The danger is also more real-it actually happens "
"under\n"
"existing implementations. If we define a macro which nconcs something onto "
"its\n"
"&rest argument@footnote {`',(foo) is equivalent to `(quote ,(foo)).}"
msgstr ""
"Для макросов, опасность больше. Макрос который изменил параметр &rest тем "
"самым\n"
"может изменить вызов макроса. То есть, вы можете случайно создать само-"
"переписывающую\n"
"программу. Опасность этого также более реальна - это на самом деле "
"происходит при\n"
"использовании существующих реализаций лиспа. Если мы определим макрос, "
"который\n"
"соединяет(nconcs) нечто с его аргументом &rest @footnote {`',(foo) это "
"эквивалент `(quote ,(foo)).}"

#: texi/node-10.texi:260
msgid ""
"@lisp\n"
"(defmacro echo (&rest args)\n"
"  `',(nconc args (list 'amen)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:262
msgid "and then define a function that calls it:"
msgstr "и затем определим функцию, которая вызывает его:"

#: texi/node-10.texi:266
msgid ""
"@lisp\n"
"(defun foo () (echo x))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:268
msgid "in one widely used Common Lisp, the following will happen:"
msgstr "В одном широко используемом Common Lisp, произойдет следующее:"

#: texi/node-10.texi:275
msgid ""
"@example\n"
"> (foo)\n"
"(X AMEN AMEN)\n"
"> (foo)\n"
"(X AMEN AMEN AMEN)\n"
"@end example"
msgstr ""

#: texi/node-10.texi:278
msgid ""
"Not only does foo return the wrong result, it returns a different result "
"each time,\n"
"because each macroexpansion alters the definition of foo."
msgstr ""
"foo не только возвращает неправильный результат, он каждый раз возвращает "
"отличный от предыдущего\n"
"результат, потому что после каждого расширения макроса изменяется "
"определение foo."

#: texi/node-10.texi:283
msgid ""
"This example also illustrates the point made earlier about multiple "
"expansions\n"
"of a given macro call. In this particular implementation, the first call to "
"foo returns\n"
"a lists with two amens. For some reason this implementation expanded the "
"macro\n"
"call once when foo was defined, as well as once in each of the succeeding "
"calls."
msgstr ""
"Этот пример также иллюстрирует высказанную ранее мысль о множественных "
"расширениях\n"
"данного вызова макроса. В этой конкретной реализации, первый вызов foo "
"возвращает\n"
"списки с двумя amens. По какой то причине эта реализация расширила вызов "
"макроса\n"
"когда foo был определен, и также по одному разу в каждом из последующих его "
"вызовов."

#: texi/node-10.texi:285
msgid "It would be safer to have defined echo as:"
msgstr "Было бы более безопасно определить echo как:"

#: texi/node-10.texi:290
msgid ""
"@lisp\n"
"(defmacro echo (&rest args)\n"
"  `'(,@@args amen))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:294
msgid ""
"because a comma-at is equivalent to an append rather than an nconc. After\n"
"redefining this macro, foo will have to be redefined as well, even if it "
"wasn't\n"
"compiled, because the previous version of echo caused it to be rewritten."
msgstr ""
"потому что, запятая с \"собакой\"(comma-at) эквивалентны дополнению, а не "
"nconc. \n"
"После переопределения этого макроса, функцию foo тоже нужно будет "
"переопределить,\n"
"даже если она не скомпилирована, потому что предыдущая версия echo вызвала "
"его\n"
"перезапись."

#: texi/node-10.texi:298
msgid ""
"In macros, it's not only &rest parameters which are subject to this danger.\n"
"Any macro argument which is a list should be left alone. If we define a "
"macro\n"
"which modifies one of its arguments, and a function which calls it,"
msgstr ""
"В макросах этой опасности подвержены не только параметр &rest. Любой "
"аргумент\n"
"макроса, который является списком, должен быть оставлен в покое. Если мы "
"определим\n"
"макрос, который изменяет один из своих аргументов,  функцию которая его "
"вызывает,"

#: texi/node-10.texi:301
msgid ""
"@lisp\n"
"(defmacro crazy (expr) (nconc expr (list t)))"
msgstr ""

#: texi/node-10.texi:304
msgid ""
"(defun foo () (crazy (list)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:307
msgid ""
"then the source code of the calling function could get modified, as happens "
"in one\n"
"implementation the first time we call it:"
msgstr ""
"тогда исходный код вызывающей функции может быть изменен, как это происходит "
"в одной\n"
"реализации лиспа. В первый раз мы вызваем ее:"

#: texi/node-10.texi:312
msgid ""
"@example\n"
"> (foo)\n"
"(T T)\n"
"@end example"
msgstr ""

#: texi/node-10.texi:314
msgid "This happens in compiled as well as interpreted code."
msgstr "Это происходит как в скомпилированном, так и в интерпретиуемом коде."

#: texi/node-10.texi:318
msgid ""
"The upshot is, don't try to avoid consing by destructively modifying "
"parameter\n"
"list structure. The resulting programs won't be portable, if they run at "
"all. If you\n"
"want to avoid consing in a function which takes a variable number of "
"arguments,"
msgstr ""
"Заключение: не пытайтесь избежать конструирования списков путем "
"деструктивного изменения\n"
"параметра являющегося списковой структурой. Получающиеся программы будут не "
"переносимы,\n"
"если вообще будут работать. Если вам необходмо избежать конструирования "
"списка(cons) в функции\n"
"которая принимает переменное количество аргументов,"

#: texi/node-10.texi:322
msgid ""
"one solution is to use a macro, and thereby shift the consing forward to "
"compile-\n"
"time. For this application of macros, see Chapter 13."
msgstr ""
"одним из решений будет использование макроса, и таким образом, смещения "
"конструирования\n"
"списка(consing) вперед, с времени выполнения, на время работы компилятора. "
"Для такого\n"
"применения макросов, смотри Главу 13."

#: texi/node-10.texi:327
msgid ""
"One should also avoid performing destructive operations on the expressions\n"
"returned by macro expanders, if these expressions incorporate quoted lists. "
"This\n"
"is not a restriction on macros per se, but an instance of the principle "
"outlined in\n"
"Section 3-3."
msgstr ""
"Также следует избегать разрушающих операций над выражениями возвращаемых "
"расширителем\n"
"макроса, если эти выражения содержат заквотированные списки. Это не является "
"ограничением\n"
"для макросов как таковых, но является примером принципа, изложенного в "
"разделе 3-3."

#: texi/node-10.texi:332
msgid ""
"@node 10-4 Recursion,  , 10-3 Non-functional Expanders, 10 Other Macro "
"Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-4 Recursion\n"
"@cindex 10-4 Recursion"
msgstr ""
"@node 10-4 Recursion,  , 10-3 Non-functional Expanders, 10 Other Macro "
"Pitfalls\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 10-4 Рекурсия\n"
"@cindex 10-4 Recursion"

#: texi/node-10.texi:335
msgid ""
"Sometimes it's natural to define a function recursively. There's something "
"inher-\n"
"ently recursive about a function like this:"
msgstr ""
"Иногда естественно определять функцию рекурсивно. Имеется несколько по сути "
"рекурсивных\n"
"функций функций подобных этой:"

#: texi/node-10.texi:341
msgid ""
"@lisp\n"
"(defun our-length (x)\n"
"  (if (null x)\n"
"          0(1+ (our-length (cdr x)))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun our-length (x)\n"
"  (if (null x)\n"
"      0\n"
"      (1+ (our-length (cdr x)))))\n"
"@end lisp"

#: texi/node-10.texi:344
msgid ""
"This definition somehow seems more natural (though probably slower) than "
"the\n"
"iterative equivalent:"
msgstr ""
"Это определение, кажется более естественным(хотя вероятно более медленным), "
"чем\n"
"его итерационный эквивалент:"

#: texi/node-10.texi:351
msgid ""
"@lisp\n"
"(defun our-length (x)\n"
"  (do ((len 0 (1+ len))\n"
"           (y x (cdr y)))\n"
"          ((null y) len)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun our-length (x)\n"
"  (do ((len 0 (1+ len))\n"
"       (y   x (cdr y)))\n"
"      ((null y) len)))\n"
"@end lisp"

#: texi/node-10.texi:360
msgid ""
"A function which is neither recursive, nor part of some mutually recursive "
"set\n"
"of functions, can be transformed into a macro by the simple technique "
"described\n"
"in Section 7-10. However, just inserting backquotes and commas won't work "
"with\n"
"a recursive function. Let's take the built-in nth as an example. (For "
"simplicity,\n"
"our versions of nth will do no error-checking.) Figure 10-2 shows a "
"mistaken\n"
"attempt to define nth as a macro. Superficially, nthb appears to be "
"equivalent to\n"
"ntha, but a program containing a call to nthb would not compile, because "
"the\n"
"expansion of the call would never terminate."
msgstr ""
"Функция, которая не является ни рекурсивной, ни частью некоторого взаимно - "
"рекурсивного\n"
"набора функций, может быть преобразована в макрос, с помощью простого "
"метода, \n"
"описанного в разделе 7-10. Однако, простая вставка кавычек и запятых не "
"будет\n"
"работать с рекурсивной функцией. Давайте возьмем встроенный nth в качестве "
"примера.\n"
"(Для простоты, наша версия nth не будет проверять ошибки.) На рисуноке 10-2 "
"показана\n"
"ошибочная попытка определить nth как макрос. Внешне, nthb по видимому "
"эквивалентно\n"
"ntha, но программа, содержащая вызов nthb не будет компилироваться, "
"поскольку расширение\n"
"вызова никогда не прекратиться."

#: texi/node-10.texi:367
msgid ""
"In general, it's fine for macros to contain references to other macros, so "
"long as\n"
"expansion terminates somewhere. The trouble with nthb is that every "
"expansion\n"
"contains a reference to nthb itself. The function version,ntha, terminates "
"because\n"
"it recurses on the value of n, which is decremented on each recursion. But\n"
"macroexpansion only has access to forms, not to their values. When the "
"compiler\n"
"tries to macroexpand, say, (nthb x y), the first expansion will yield"
msgstr ""
"В целом, для макросов нормально содержать ссылки на другие макросы, если "
"расширение\n"
"шаблона где то заканчивается. Проблема с nthb в том, что каждое расширение "
"содержит\n"
"ссылку на сам nthb. Функциональная версия ntha завершается, потому что она "
"получает\n"
"значение n, которое уменьшается при каждом рекурсивном вызове. Но "
"расширитель макроса\n"
"имеет доступ только к формам, но не к их значениям. Когда компилятор "
"пытается разширить\n"
"макрос, скажем (nthb x y), первое расширение даст"

#: texi/node-10.texi:373
msgid ""
"@lisp\n"
"(if (= x 0)\n"
"        (car y)\n"
"        (nthb (- x 1) (cdr y)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:377
msgid " This will work:"
msgstr ""
"@cartouche\n"
" Это будет работать:"

#: texi/node-10.texi:384
msgid ""
"@lisp\n"
" (defun ntha (n lst)\n"
"       (if (= n 0)\n"
"            (car lst)\n"
"            (ntha (- n 1) (cdr lst))))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:386
msgid " This won't compile:"
msgstr " Это не компилируется:"

#: texi/node-10.texi:393
msgid ""
"@lisp\n"
" (defmacro nthb (n lst)\n"
"       `(if (= ,n 0)\n"
"              (car ,lst)\n"
"              (nthb (- ,n 1) (cdr ,lst))))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:395
msgid "                Figure 10-2: Mistaken analogy to a recursive function."
msgstr ""
"                Рисунок 10-2: Ошибочная аналогия с рекурсивной функцией.\n"
"@end cartouche"

#: texi/node-10.texi:398
msgid "which will in turn expand into:"
msgstr "который в свою очередь расшириться в:"

#: texi/node-10.texi:406
msgid ""
"@lisp\n"
"(if (= x 0)\n"
"        (car y)\n"
"        (if (= (- x 1) 0)\n"
"             (car (cdr y))\n"
"             (nthb (- (- x 1) 1) (cdr (cdr y)))))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:409
msgid ""
"and so on into an infinite loop. It's fine for a macro to expand into a call "
"to itself,\n"
"just so long as it doesn't always do so."
msgstr ""
"и так далее в бесконечный цикл. Это нормально для макроса расширении иметь "
"вызов самого себя,\n"
"если такое поведение рано или поздно заканчивается."

#: texi/node-10.texi:415
msgid ""
"The dangerous thing about recursive macros like nthb is that they usually "
"work\n"
"fine under the interpreter. Then when you finally have your program working "
"and\n"
"you try to compile it, it won't even compile. Not only that, but there will "
"usually\n"
"be no indication that the problem is due to a recursive macro; the compiler "
"will\n"
"simply go into an infinite loop and leave you to figure out what went wrong."
msgstr ""
"Опасная вещь в рекурсивных макросах, таких как nthb, в том, что они обычно "
"хорошо\n"
"работают под интерпретатором. Затем, когда у вас наконец-то рабочая "
"программа и\n"
"вы пытаетесь ее скомпилировать, она даже не компилируется. Хотя не только "
"это, но \n"
"обычно это указывает на то, что проблема связана с рекурсивным макросом; "
"компилятор\n"
"просто входит в бесконенчный цикл и оставляет вас в раздумьях, о том, что "
"что-то\n"
"пошло не так."

#: texi/node-10.texi:419
msgid ""
"In this case, ntha is tail-recursive. A tail-recursive function can easily "
"be\n"
"transformed into an iterative equivalent, and then used as a model for a "
"macro. A\n"
"macro like nthb could be written"
msgstr ""
"В этом случае, ntha является хвостовой(хорошей) рекурсией. Функция с "
"хвостовой рекурсией\n"
"может быть легко превращена в итерационный эквивалент, а затем использована "
"в качестве\n"
"модели для макроса. Макрос типа nthb может быть написан так:"

#: texi/node-10.texi:426
msgid ""
"@lisp\n"
"(defmacro nthc (n lst)\n"
"  `(do ((n2 ,n (1- n2))\n"
"             (lst2 ,lst (cdr lst2)))\n"
"            ((= n2 0) (car lst2))))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:430
msgid ""
"so it is not impossible in principle to duplicate a recursive function with "
"a macro.\n"
"However, transforming more complicated recursive functions could be "
"difficult,\n"
"or even impossible."
msgstr ""
"поэтому, в принципе, возможно продублировать рекурсивную функцию с помощью "
"макроса.\n"
"Однако, преобразование более сложных рекурсивных функций, может быть "
"затруднено или\n"
"даже невозможно."

#: texi/node-10.texi:435
msgid ""
"@lisp\n"
" (defmacro nthd (n lst)\n"
"    `(nth-fn ,n ,lst))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro nthd (n lst)\n"
"    `(nth-fn ,n ,lst))"

#: texi/node-10.texi:440
msgid ""
" (defun nth-fn (n lst)\n"
"    (if (= n 0)\n"
"         (car lst)\n"
"         (nth-fn (- n 1) (cdr lst))))"
msgstr ""

#: texi/node-10.texi:448
msgid ""
" (defmacro nthe (n lst)\n"
"    `(labels ((nth-fn (n lst)\n"
"                       (if (= n 0)\n"
"                          (car lst)\n"
"                          (nth-fn (- n 1) (cdr lst)))))\n"
"        (nth-fn ,n ,lst)))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:450
msgid "                    Figure 10-3: Two ways to fix the problem."
msgstr ""
"                    Рисунок 10-3: Два способа решения проблем.\n"
"@end cartouche"

#: texi/node-10.texi:458
msgid ""
"Depending on what you need a macro for, you may find it sufficient to use\n"
"instead a combination of macro and function. Figure 10-3 shows two ways to\n"
"make what appears to be a recursive macro. The first strategy, embodied by "
"nthd,\n"
"is simply to make the macro expand into a call to a recursive function. If, "
"for\n"
"example, you need a macro only to save users the trouble of quoting "
"arguments,\n"
"then this approach should suffice."
msgstr ""
"В зависимости от того, для чего вам нужен макрос, вы можете найти "
"достаточным\n"
"для использования сочетание макроса и функции. Рисунок 10-3 показывает два "
"способа\n"
"создать то, что кажется рекурсивным макросом. Первая стратегия, воплощенная "
"в nthd,\n"
"просто заставить расширяться макрос в вызов рекурсивной функции. Например, "
"если\n"
"вам нужен макрос для того, чтобы избавить пользвателей от необходимости "
"квотировать\n"
"аргументы, тогда такого подхода должно хватить."

#: texi/node-10.texi:465
msgid ""
"If you need a macro because you want its whole expansion to be inserted\n"
"into the lexical environment of the macro call, then you would more likely "
"want\n"
"to follow the example of nthe. The built-in labels special form (Section "
"2-7)\n"
"creates a local function definition. While each expansion of nthc will call "
"the\n"
"globally defined function nth-fn, each expansion of nthe will have its own\n"
"version of such a function within it."
msgstr ""
"Если вам нужен макрос, потому что вы хотите вставить всё его расширение в\n"
"лексическое окружение, где происходит вызов макроса, тогда вы, скорее "
"всего,\n"
"захотите последовать примеру определяющему nthe. Встроенная специальная\n"
"форма labels (Раздел 2-7) создает локальное определение функции. В то время "
"как, \n"
"каждое расширение nthc будет вызывать глобально определенную функцию nth-"
"fn, \n"
"каждое  расширение nthe будет иметь свою собственную версию такой функции "
"внутри себя."

#: texi/node-10.texi:471
msgid ""
"Although you can't translate a recursive function directly into a macro, you "
"can\n"
"write a macro whose expansion is recursively generated. The expansion "
"function\n"
"of a macro is a regular Lisp function, and can of course be recursive. For "
"example,\n"
"if we were to define a version of the built-in or, we would want to use a "
"recursive\n"
"expansion function."
msgstr ""
"Хотя вы не можете перевести рекурсивную функцию непосредственно в макрос, вы "
"можете\n"
"написать макрос, расширение которого генерируется рекурсивно. Функция "
"расширения\n"
"макроса это обычная функция Lisp и, конечно, она может быть рекурсивной. "
"Например,\n"
"если бы мы определяли версию встроенного or, мы могли бы использовать "
"рекурсивную\n"
"функцию расширения."

#: texi/node-10.texi:478
msgid ""
"Figure 10-4 shows two ways of defining recursive expansion functions for "
"or.\n"
"The macro ora calls the recursive function or-expand to generate its "
"expansion.\n"
"This macro will work, and so will the equivalent orb. Although orb recurses, "
"it\n"
"recurses on the arguments to the macro (which are available at "
"macroexpansion\n"
"time), not upon their values (which aren't). It might seem as if the "
"expansion\n"
"would contain a reference to orb itself, but the call to orb generated by one"
msgstr ""
"На рисунке 10-4 показаны два способа определить рекурсивную функцию "
"расширения\n"
"для or. Макрос or вызывает рекурсивную функцию or-expand для генерации "
"своего\n"
"расширения. Этот макрос будет работать, равно как и эквивалентный orb. Хотя\n"
"orb рекурсивный, он рекурсивен по аргументам макроса (которые доступны во\n"
"время расширения макроса), а не по их значениям (которые не доступны). "
"Может\n"
"показаться, что расширение будет содержать ссылку на само себя orb, но "
"вызов\n"
"orb генерируемый одним"

#: texi/node-10.texi:482
msgid ""
"@lisp\n"
" (defmacro ora (&rest args)\n"
"       (or-expand args))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro ora (&rest args)\n"
"       (or-expand args))"

#: texi/node-10.texi:491
msgid ""
" (defun or-expand (args)\n"
"       (if (null args)\n"
"               nil\n"
"          (let ((sym (gensym)))\n"
"                `(let ((,sym ,(car args)))\n"
"                      (if ,sym\n"
"                         ,sym\n"
"                         ,(or-expand (cdr args)))))))"
msgstr ""

#: texi/node-10.texi:501
msgid ""
" (defmacro orb (&rest args)\n"
"       (if (null args)\n"
"          nil\n"
"          (let ((sym (gensym)))\n"
"                `(let ((,sym ,(car args)))\n"
"                      (if ,sym\n"
"                         ,sym\n"
"                         (orb ,@@(cdr args)))))))\n"
"@end lisp"
msgstr ""

#: texi/node-10.texi:503
msgid "                       Figure 10-4: Recursive expansion functions."
msgstr ""
"                       Рисунок 10-4: Функции рекусрсивного расширения.\n"
"@end cartouche"

#: texi/node-10.texi:508
msgid ""
"macroexpansion step will be replaced by a let in the next one, yielding in "
"the\n"
"final expansion nothing more than a nested stack of lets; (orb x y) expands\n"
"into code equivalent to:"
msgstr ""
"шагом расширения макроса, будет заменен на let в следующем шаге, приводя "
"окончательное\n"
"расширение, в ничто иное как стек вложенных let; (orb x y) расширяется в "
"код\n"
"эквивалентный:"

#: texi/node-10.texi:516
msgid ""
"@lisp\n"
"(let ((g2 x))\n"
"  (if g2\n"
"         g2\n"
"         (let ((g3 y))\n"
"           (if g3 g3 nil))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(let ((g2 x))\n"
"  (if g2\n"
"      g2\n"
"      (let ((g3 y))\n"
"           (if g3 g3 nil))))\n"
"@end lisp"

#: texi/node-10.texi:519
msgid ""
"In fact, ora and orb are equivalent, and which style to use is just a matter "
"of\n"
"personal preference."
msgstr ""
"На самом деле ora и orb эквивалентны, и какой стиль использовать - это "
"вопрос\n"
"личного предпочтения."
