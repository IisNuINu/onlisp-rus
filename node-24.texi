@node 24 Prolog, 25 Object-Oriented Lisp, 23 Parsing with ATNs, Top
@comment  node-name,  next,  previous,  up
@chapter 24 Пролог
@cindex 24 Prolog

В этой главе описывается как написать  Prolog как встроенный язык. Глава 19
показала как написать программу, которая отвечала бы на сложные запросы в базах
данных. Здесь мы добавляем один новый инградиент: правила, которые позволяют выводить
факты из уже известных. Набор правил определяет дерево следствий. Чтобы использовать
правила, котоыре в противном случае подразумевали бы неограниченное количество
фактов, мы будем искать это дерево следствий недетерминированным образом.

Prolog дает отличный пример встроенного языка. Он объединяет три компонента:
сопоставление с образцом(pattern-matching), недетерминизм и правила. Главы 18
и 22 дают нам первые два независимо. Посторив Prolog поверх уже существующих
операторов сопоставления с образцом и недетермининованного выбора, мы получим
пример реальной многослойной(уровневой) восходящей системы. На рисунке 24-1 
показаны соответствующие уровни абстракци.

Вторичной целью этой главы является изучение самого пролога. Для опытных программистов
наиболее удобным объяснением Prolog-а может быть набросок его реализации.
Написание Пролога на Лиспе особенно интересно, потому что оно выявляет сходство
между двумя языками.

@menu
* 24-1 Concepts::               
* 24-2 An Interpreter::         
* 24-3 Rules::                  
* 24-4 The Need for Nondeterminism::  
* 24-5 New Implementation::     
* 24-6 Adding Prolog Features::  
* 24-7 Examples::               
* 24-8 The Senses of Compile::  
@end menu

@node 24-1 Concepts, 24-2 An Interpreter, 24 Prolog, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-1 Концепции(идеи)
@cindex 24-1 Concepts

Глава 19 показала, как написать систему базы данных, которая будет принимать сложные
запросы, содержащие переменные, и генерировать все привязки, которые сделали запрос
истинным в базе данных. В следующем примере (после вызова clear-db) мы утверждаем
два факта и затем запрашиваем базу данных:

@cartouche
                              Рисунок 24-1: Уровни абстракции.
@end cartouche

@example
> (fact painter reynolds)
(REYNOLDS)
> (fact painter gainsborough)
(GAINSBOROUGH)
> (with-answer (painter ?x)
         (print ?x))
GAINSBOROUGH
REYNOLDS
NIL
@end example

Концептуально Prolog  - это программа базы данных с добавлением правил, которые позволяют
удовлетворить запрос не только путем поиска его в базе данных, но и путем вывода его
из других известных фактов. Например, если у на есть правило, подобное:

@example
If       (hungry ?x) and (smells-of ?x turpentine)
Then (painter ?x)
если ?х голодный и пахнет скипидаром, тогда он художник! (глубокомысленно)

@end example

@noindent
тогда запрос (painter ?x) будет удовлетворен для ?x = raoul, если база данных
содержит как (hungry raoul), так  и (smells-of raoul turpentine), даже если
она не содержит (painter raoul).

В Prolog-е, if-часть правила(условие) называется телом, а then-часть(следствие) - головой.
(В логике, имена антседент(antecedent)/предшествие и консекуент(consequent)последствие, 
но с тем же успехом можно было присвоить и другие имена, подчеркивают то, что в  Prolog
логический вывод это не тоже самое что логический.) При попытке установить привязки
@footnote{Многие понятия, используемые в этой главе, включая значение привязка, объяснены
в Главе 18-4.} для запроса, программа смотрит вначале на голову правила. Если голова 
соответствует запросу, на который пытается ответить программа, она попытается установить
привязки для тела правила. Привязки которые удовлетворяют тело, по определению, удовлетворяют
и голову.

Факты используемые в теле правила, могут быть в свою очередь, выведены из других
правил:

@example
If      (gaunt ?x) or (eats-ravenously ?x)
Then (hungry ?x)
@end example

и правила могут быть рекурсивными, как в:

@example
If      (surname ?f ?n) and (father ?f ?c)
Then (surname ?c ?n)
@end example

Prolog сможет установить привязки для запроса, если он сможет найти какой-то
путь через правила, который в конечном итоге приведет к известным фактам. Таким
образом, это по сути поисковая система: она обходит дерево логических следствий,
сформированных правилами, ища успешный путь.

Хотя правила и факты звучат как отдельные типы объектов, концептуально они 
взаимозаменяемы. Правила можно рассматривать как виртуальные факты. Если мы 
хотим, чтобы наша база данных отражала открытие, что большие(big), жестокие
(fierce) животные(animals) встречаются редко(rare), мы могли бы найти
все x, такие, что все факты (species x), (big x), и (fierce x), и добавить
новый факт (rare x). Однако, определив правило говорящее

@example
If      (species ?x) and (big ?x) and (fierce ?x)
Then (rare ?x)
@end example

мы получаем тот же самый эффект, фактически не добавляя всем признак (rare x) в
базу данных. Мы даже можем определить правила, которые подразумевают бесконечное
количество фактов. Таким образом, правила уменьшают базу данных за счет дополнительной
обработки, когда приходит время отвечать на вопросы.

Тем временем, Факты, являются вырожденным случаем правил. Эффект от любого
факта F может дублироваться правилом, тело которого всегда истинно:

@example
If      true
Then F
@end example

Чтобы упростить нашу реализацию, мы воспользуемся этим принципом и представим факты
в виде правил не имеющих тела.                                                        

@node 24-2 An Interpreter, 24-3 Rules, 24-1 Concepts, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-2 Интерпретатор
@cindex 24-2 An Interpreter

Раздел 18-4 показывает два способа определения if-match. Первый был простым, но
неэффективным. Его преемник был быстрее, потому что делал большую часть своей 
работы во время компиляции. Мы будем следовать аналогичной стратегии и здесь. Чтобы
предоставить некоторые из затронутых тем, мы начнем с простого интерпретатора.
Позже мы покажем, как написать ту же программу более эффективно.

@cartouche
@lisp
 (defmacro with-inference (query &body body)
  `(progn
         (setq *paths* nil)
         (=bind (binds) (prove-query ',(rep_ query) nil)
            (let ,(mapcar #'(lambda (v)
                                   `(,v (fullbind ',v binds)))
                              (vars-in query #'atom))
              ,@@body
              (fail)))))

 (defun rep_ (x)
       (if (atom x)
            (if (eq x '_) (gensym "?") x)
            (cons (rep_ (car x)) (rep_ (cdr x)))))

 (defun fullbind (x b)
       (cond ((varsym? x) (aif2 (binding x b)
                                       (fullbind it b)
                                       (gensym)))
              ((atom x) x)
              (t (cons (fullbind (car x) b)
                          (fullbind (cdr x) b)))))

 (defun varsym? (x)
       (and (symbolp x) (eq (char (symbol-name x) 0) #\?)))
@end lisp

                            Рисунок 24-2: Макрос верхнего уровня.
@end cartouche

Рисунки 24-2­24-4 содержат код для простого интерпретатора Prolog-а. Он принимает
те же запросы, что и интерпретатор запросов в Разделе 19-3, но использует
правила вместо базы данных для генерации привязок. Интерпретатор запросов
вызывался с помощью макроса названного with-answer. Интерфейсом для интерпретатора
Prolog-а будет похожий макрос, называемый with-inference. Подобно with-answer,
with-inference предоставляется запрос и последовательность выражений Lisp. Переменные
в запросе - это символы, начинающиеся со знака вопроса:

@lisp
(with-inference (painter ?x)
  (print ?x))
@end lisp

Вызов with-inference расширяется до кода, который будет вычислять врыважения Lisp
длял каждого набора привязок, сгенерированных запросом. Например, приведенный выше
вызов напечатает каждый  x для которого можно сделать вывод, что (painter x).                          

На Рисунке 24-2 показано определение with-inference, вместе с функцией, которую
он вызывает для получения привязок. Одно заметное отличие между with-answer и
with-inference заключается в том, что первый просто собирал все допустимые 
привязки. Новая программа ищет недетерминированно. Мы видим это в определении
with-inference: вместо расширения в цикл, оно расширяется в код, который возвращает
один набор привязок, следующий за ним fail перезапускает поиск. Это дает нам,
неявно, итерацию, как в:

@example
> (choose-bind x '(0 1 2 3456789)
        (princ x)
        (if (= x 6) x (fail)))
0123456
6
@end example

Функция fullbind указывает на другое различие между  with-answer и with-inference. 
Обратная трассировака последовательности правил може тсоздать списки привязок, 
в которых привязка переменной является списком других переменных. Чтобы использовать
результаты запроса, нам теперь нужна рекурсивная функция для плучения привязок.
Это цель  fullbind:

@example
> (setq b '((?x . (?y . ?z)) (?y . foo) (?z . nil)))
((?X ?Y . ?Z) (?Y . FOO) (?Z))
> (values (binding '?x b))
(?Y . ?Z)
> (fullbind '?x b)
(FOO)
@end example

Привязки для запроса генерируются вызовом prove-query в расширении with-inference.
На Рисунке 24-3 показано определение этой функции и функций, которые она вызывает.
Этот код структурно изоморфен интерпретатору запросов, описанному в разделе 19-3. 
Обе программы используют одинаковые функции для сопоставления, но там где интерпретатор
запросов использовал отображение(mapping) или итеарцию, интерпретатор Prolog-а использует
эквивалентные варианты chooses.

Использование недетерминированного поиска вместо итерации делает интерпретацию
отритцающих(negated) запросов немного более сложной. Данный запрос, подобный

@lisp
(not (painter ?x))
@end lisp

@noindent
интерперетатор запросов может просто попытаться установить привязки для
(painter ?x) возвращающие nil, если таковые были найдены. При недетерминированном
поиске мы должны быть более осторожными: мы не хотим, чтобы интерепретация
(painter ?x) в ложь возвращалась за пределы действия области отритцания(not), 
и поэтому мы не хотим, чтобы она оставляла сохраненные пути, которые могли бы

@cartouche
@lisp
 (=defun prove-query (expr binds)
       (case (car expr)
         (and (prove-and (cdr expr) binds))
         (or     (prove-or (cdr expr) binds))
         (not (prove-not (cadr expr) binds))
         (t      (prove-simple expr binds))))

 (=defun prove-and (clauses binds)
       (if (null clauses)
            (=values binds)
            (=bind (binds) (prove-query (car clauses) binds)
                (prove-and (cdr clauses) binds))))

 (=defun prove-or (clauses binds)
       (choose-bind c clauses
         (prove-query c binds)))

 (=defun prove-not (expr binds)
       (let ((save-paths *paths*))
         (setq *paths* nil)
         (choose (=bind (b) (prove-query expr binds)
                      (setq *paths* save-paths)
                      (fail))
                    (progn
                      (setq *paths* save-paths)
                      (=values binds)))))

 (=defun prove-simple (query binds)
       (choose-bind r *rlist*
         (implies r query binds)))
@end lisp

                        Рисунок 24-3: Интерпретация запросов.
@end cartouche

@noindent
быть перезапущены позже. Итак, теперь тест для (painter ?x) выполняется с временно
пустым списком сохраненных состояний, а старый список восстанавливается при выходе.

Другое отличие между этой программой и интерпретатором запросов заключается в 
интерпретации простых образцов - выражений таких как (painter ?x) которые состоят
только из предиката и несокльких аргументов. Когда интерпретатор запросов генерировал
привязки для простых образцов, он вызывал lookup (стр. 251). Теперь, вместо вызова
lookup, мы должны получить любые привязки , подразумеваемые правилами.

@cartouche
@lisp
 (defvar *rlist* nil)

 (defmacro <- (con &rest ant)
    (let ((ant (if (= (length ant) 1)
                       (car ant)
                       `(and ,@@ant))))
        `(length (conc1f *rlist* (rep_ (cons ',ant ',con))))))

 (=defun implies (r query binds)
    (let ((r2 (change-vars r)))
        (aif2 (match query (cdr r2) binds)
              (prove-query (car r2) it)
              (fail))))

 (defun change-vars (r)
    (sublis (mapcar #'(lambda (v)
                                (cons v (symb '? (gensym))))
                            (vars-in r #'atom))
              r))
@end lisp

                       Рисунок 24-4: Code involving rules.
@end cartouche

@cartouche
@lisp
  rule        : (<-  sentence  query )
  query       : (not  query )
              : (and  query *)
              : (or  query *)
              :  sentence 
  sentence  : ( symbol  argument *)
  argument  :  variable 
              :  symbol 
              :  number 
  variable  : ? symbol 
@end lisp

                            Рисунок 24-5: Синтаксис правил.
@end cartouche

Код для определения и использования правил показан на рисунке 24-4. Правила храняться
в глобальном списке *rlist*. Каждое правило представлено в виде точечной пары тела и
головы. Во время определения правила все подчеркивания заменяются уникальными 
переменными.

Определение <- следует трем соглашениям, часто используемым в программах подобного
типа:

@enumerate
@item
Новые правила добавляются в конец, а не в начало списка, так что они будут применяться
         в том порядке, в котором они были определены.
@item
Правила выражены так, что голова(head) стоит первой, так как это порядок в котором программа
         их проверяет(рассматривает).
@item
Множественные выражения в теле находятся внутри неявных и(and).
@end enumerate

Самый внешний вызов length в расширении <- нужен просто для того, чтобы не печатать
длинный список, когда <- вызывается из верхнего уровня.

Синтаксис правил приведен на Рисунке 24-5. Голова(head) правила должна быть образцом
для факта: список предиката, за которым следует ноль или более аргументов. Тело(body)
может быть любым запросом, который может быть обработан интерпретатором запросов
главы 19. Вот правило ранее упоминавшееся в данной главе:

@lisp
(<- (painter ?x) (and (hungry ?x)
                                 (smells-of ?x turpentine)))
@end lisp

@noindent
или просто

@lisp
(<- (painter ?x) (hungry ?x)
                           (smells-of ?x turpentine))
@end lisp

Как и в интерпретаторе запросов, аргументы типа turpentine(скипидара) не вычисляются,
поэтому их надо квотировать(ставить кавычку).

Когда prove-simple запрашивается для создания привязко для запроса, он 
недетерминированно выбирает правило и посылает как правило, так и запрос
в implies. Последняя функция(implies) затем пытается сопоставить(найти соответсвие)
запрос с головой(head) правила. Если сопоставление выполнено успешно,
implies вызовет prove-query, чтобы установить привязки для тела(body).
Таким образом, мы рекурсивно ищем дерево следствий.

Функция change-vars заменяет все переменные в правиле на новые. ?x используемый в
одном правиле, должен быть независимым от ?x используемого в другом правиле. Чтобы
измежать конфликтов с существующими привязками, change-vars вызывается каждый раз,
когда используется правило.

Для удобства пользователя в правлах можно использовать _(подчеркивание) в качестве
безразличной переменной в правиле. Когда правило определено, вызывается функция rep_is
чтобы изменить подчерквивание на реальную переменную. Подчеркивания также могут
использоваться в запросах, переданных with-inference.

@node 24-3 Rules, 24-4 The Need for Nondeterminism, 24-2 An Interpreter, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-3 Правила
@cindex 24-3 Rules

В этом разделе показано, как написать правила для нашего Prolog-а. В начале, вот
два правилаа из Раздела 24-1:

@lisp
(<- (painter ?x) (hungry ?x)
                       (smells-of ?x turpentine))

(<- (hungry ?x) (or (gaunt ?x) (eats-ravenously ?x)))
@end lisp

Если мы также утвердим следующие факты:

@lisp
(<- (gaunt raoul))
(<- (smells-of raoul turpentine))
(<- (painter rubens))
@end lisp

Тогда мы получим привязки, которые они генериуют в соответствии с порядком, в котором
они были определены:

@example
> (with-inference (painter ?x)
        (print ?x))
RAOUL
RUBENS
@
@end example

Макрос with-inference имеет те же ограничения на привязку переменных, что и
with-answer. (См. Раздел 19-4.)

Мы можем написать правила, которые подразумевают, что факты данной формы верны
для всех возможных привязок. Это происходит, например, когда некоторая переменная
встречается в голове(head) правила, но не в его теле. Правило

@lisp
(<- (eats ?x ?f) (glutton ?x))
@end lisp

говорит, что если ?x это glutton(обжора), то ?x есть всё(eats everything). Поскольку ?f 
не встречается в теле, мы можем доказать любой факт вида (eats ?x y), просто установив
привязк для ?x. Если мы сделаем запрос с буквальным значением в качестве второго аргумента
в eats(есть),

@example
> (<- (glutton hubert))
7> (with-inference (eats ?x spinach)
        (print ?x))
HUBERT
@
@end example

@noindent
тогда любое литеральное значение будет работать. Когда мы дадим переменную в 
качестве второго аргумента:

@example
> (with-inference (eats ?x ?y)
        (print (list ?x ?y)))
(HUBERT #:G229)
@
@end example

@noindent
мы получаем gensym назад. Возврат gensym в качестве привязки переменной в запросе -
это способ показать, что любое значение будет истинным. Программы могут быть написаны
явно, чтобы использовать в своих интересах это соглашение:

@example
> (progn
        (<- (eats monster bad-children))
        (<- (eats warhol candy)))
9> (with-inference (eats ?x ?y)
        (format t "~A eats ~A.~%"
                  ?x
                  (if (gensym? ?y) 'everything ?y)))
HUBERT eats EVERYTHING.
MONSTER eats BAD-CHILDREN.
WARHOL eats CANDY.
@
@end example

Наконец, если мы хотим указать, что факты определенной формы будут верны для
любых аргументов, мы делаем тело соединением(conjunction) без аргументов. 
Выражение и(and) всегда будет вести себя как истинный факт. В макросе <- 
(рисунок 24-4), тело по умолчанию имеет значение (and), поэтому для таких
правил мы можем просто опустить(не писать) тело:

@example
> (<- (identical ?x ?x))
10
> (with-inference (identical a ?x)
        (print ?x))
A@
@end example

Для читателей знакомых с Prolog-ом, на Рисунке 24-6 показан перевод синтаксиса
Prolog-а в синтаксис нашей программы. Традиционно, первая программа пролога Prolog
это append, которая будет написана в конце рисунка 24-6. В случае добавления, 
два коротких списка объединяются в один более длинны. Любые два из этих списков
определяют, каким должен быть третий. Функция Lisp append принимает два коротких
списка как аргументы и возвращает более длинный. append из Пролога является более
общим; два правила на Рисунке 24-6 определяют программу, которая, учитывая любые 
два из задействованных списков, может найти третий.

@cartouche
     Наш синтаксис отличается от традиционного синтаксиса Prolog-а следующим:

@enumerate
@item
Переменные представлены символами, начинающимися с вопросительных знаков вместо
           заглавных букв. Common Lisp по умолчанию не учитывает регистр букв,
           поэтому от использования заглавных букв было бы больше проблем.
@item
[] становиться nil.
@item
Выражения вида [x | y] становятся (x . y).
@item
Выражения вида [x, y, ...] становятся (x y . . .).
@item
Предикаты перемещаются внутрь круглых скобок, и запятые не являются разделителями
           аргументов: pred(x, y, ...) становится (pred x y ...).
@end enumerate

Таким образом Prolog определение append:

@example
     append([ ], Xs, Xs).
     append([X | Xs], Ys, [X | Zs]) <- append(Xs, Ys, Zs).
@end example

     становится:

@lisp
     (<- (append nil ?xs ?xs))
     (<- (append (?x . ?xs) ?ys (?x . ?zs))
          (append ?xs ?ys ?zs))
@end lisp

                        Рисунок 24-6: синтаксическая эквивалентность Prolog-а
@end cartouche

@example
> (with-inference (append ?x (c d) (a b c d))
        (format t "Left: ~A~%" ?x))
Left: (A B)
@@> (with-inference (append (a b) ?x (a b c d))
        (format t "Right: ~A~%" ?x))
Right: (C D)
@@> (with-inference (append (a b) (c d) ?x)
        (format t "Whole: ~A~%" ?x))
Whole: (ABCD)
@
@end example

Мало того, учитывая последний список, он может найти всеп возможности для первых двух:

@example
> (with-inference (append ?x ?y (a b c))
        (format t "Left: ~A Right: ~A~%" ?x ?y))
Left: NIL Right: (A B C)
Left: (A) Right: (B C)
Left: (A B) Right: (C)
Left: (A B C) Right: NIL
@
@end example

       Случай append указывает на большую разницу между Prolog-ом и другими языками.
Набор правил Prolog-а  не обязательно должен давать конкретное значение. Вместо этого
он может давать ограничения(constraints), которые в сочетании с ограничениями 
генерируемыми другими частями программы, дают конкретное значение. Например, если мы
определим member таким образом:

@lisp
(<- (member ?x (?x . ?rest)))
(<- (member ?x (_ . ?rest)) (member ?x ?rest))
@end lisp

@noindent
тогда мы сможем использовать его для проверки членства(membership) в списке, как 
если бы использовали функцию Lisp member:

@example
> (with-inference (member a (a b)) (print t))
T@
@end example

@noindent
но мы также можем использовать ее для установления ограничения на членство, которе
в сочетании с другими ограничениями приводит к определенному списку. Если мы
так же имеем предикат cara

@lisp
(<- (cara (a _)))
@end lisp

@noindent
который истинен для двух-элементного списка, чье начало(car) равно a, тогда между
ним и member у нас достаточно ограничений для Prolog-а, чтобы построить
определенный ответ:

@example
> (with-inference (and (cara ?lst) (member b ?lst))
        (print ?lst))
(A B)
@
@end example

Это довольно тривиальный пример, но большие программы могут быть построены по тому
же принципу. Когда мы хотим программировать, комбинируя частичные решения, Prolog
может быть полезен. Действительно, удивительное разнообразие проблем может быть
выражено в таких терминах: например, на рисунке 24-14 показан алгоритм сортировки,
выраженный в виде набора ограничений на решение.

@node 24-4 The Need for Nondeterminism, 24-5 New Implementation, 24-3 Rules, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-4 Необходимость Недетерминизма
@cindex 24-4 The Need for Nondeterminism

Глава 22 объяснила связь между детерминированным и недетерминированным поиском.
Детерминированная поисковая программа может принять запрос и сгенерировать все
решения, которые его удовлетворяют. Недетерминированная программа поиска будет
использовать выбор(choose) для генерации решений по одному, или если потребуется
больше, вызовет fail для перезапуска поиска.

Когда у нас есть правила, которые все дают конечные наборы привязок, и мы хотим,
чтобы они были все сразу, нет причин предпочитать недетерминированный поиск. Разница
межды этими двумя стратегиями становиться очевидной, когда у нас есть запросы, которые
генерируют бесконечное количество привязок, из которых мы хотим получить конечное
подмножество. Например, правила

@lisp
(<- (all-elements ?x nil))
(<- (all-elements ?x (?x . ?rest))
        (all-elements ?x ?rest))
@end lisp

@noindent
подразумевают все факты вида (all-elements x y), где каждый член y
равен x. Без обратной трассировки мы могли бы обрабатывать такие запросы,
подобно:

@lisp
(all-elements a (a a a))
(all-elements a (a a b))
(all-elements ?x (a a a))
@end lisp

Тем не менее, запрос (all-elements a ?x) выполняется для бесконечного числа возможных
?x: nil, (a), (a a), и т.д. Если мы попытаемся сгенерировать ответы для этого запроса
с помощью итерации, итерация никогда не прекратиться. Даже если бы нам нужен был
только один из ответов, мы бы никогда не получили разультата от реализации, которая
должна была бы сгенерировать все привязки для запроса, прежде чем он мог бы начать
перебирать выражения Lisp, следующие за ним.

Вот почему with-inference перемежает генерацию привязок с вычислением своего тела.
Там, где запросы могут привести к бесконечному количеству ответов, единственным
успешным подходом будет генерировать ответы по одному и возвращаться, чтобы получить
новые ответы, перезапустив приостановленный поиск. Поскольку он использует choose
и fail, наша программа может обработать этот случай:

@example
> (block nil
        (with-inference (all-elements a ?x)
          (if (= (length ?x) 3)
               (return ?x)
               (princ ?x))))
NIL(A)(A A)
(AAA)
@end example

Как и любая другая реализация Prolog-а, наша имитирует недетерминизм, выполняя
поиск в глубину с возвратами. В теории, "логические программы" работают в
условиях истинного недетерминизма. По факту, реализации Prolog-а всегда используют
поиск в глубину. Отнюдь не будучи скованными этим выбором, обычные программы на 
Prolog-е зависят от него. В истинно недетерминированном мире, запрос

@lisp
(and (all-elements a ?x) (length ?x 3))
@end lisp

@noindent
имеет ответ, но вам понадобится сколь угодно времени, чтобы выяснить, что
это такое.

Prolog не только использует поиск в глубину реализованны на основе недетерминированности,
он также использует версию эквивалентну определенной на странице 293. Как объяснялось
там, данная реализация не всегда гарантирует прекращение. Поэтому программисты Prologо-а
должны предпринять преднамеренные шаги, чтобы избежать петель в пространстве поиска.
Например, если мы определим member в обратном порядке

@lisp
(<- (member ?x (_ . ?rest)) (member ?x ?rest))
(<- (member ?x (?x . ?rest)))
@end lisp

@noindent
тогда логически это будет иметь то же значение, но как программа на Prolog-е это
будет иметь другой эффект. Первоначальное определение member дало бы бесконечный 
поток ответов на запрос(member 'a ?x), но обратное определение даст бесконечную
рекурсию, и никаких ответов.

@node  24-5 New Implementation, 24-6 Adding Prolog Features, 24-4 The Need for Nondeterminism, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-5 Новая Реализация
@cindex 24-5 New Implementation

В этом разделе мы увидим еще один пример знакомого шаблона. В разделе 18-4,
мы обнаружили после написания исходной версиии, что if-match может работать
намного быстрее. Используюя информацию известную во время компилияции, мы
смогли написать новую версию, которая выполняла меньше работы во время выполнения.
Мы увидели то же явление в более широком маштабе в главе 19. Наш интерпретатор 
запросов был заменен эквивалентной, но более быстрой версией. То же самое
случиться и с нашим интерпретатором Prolog-а.

Рисунки 24-7, 24-8, и 24-10 определяют Prolog новым способом. Макрос
with-inference был просто интерфейсом для интерпретатора Prolog-а. Сейчас он, это
большая часть программы. Новая программа имеет ту же общую форму, что и старая,
но из функций определенных на Рисунке 24-8, только prove вызывается во время
выполнения. Другие вызываются с помощью with-inference, чтобы сгенерировать
его расширение.

На рисунке 24-7 показано новое определение with-inference. Как в случае с if-match
и with-answer, переменные образца изначально связаны с gensyms, чтобы указать, что
им не были присвоены реальные значения при сопоставлении. Таким образом функция
varsym?, которую используют match и fullbind для обнраружения переменных, должна
быть изменена для поиска gensyms.

@cartouche
@lisp
 (defmacro with-inference (query &rest body)
    (let ((vars (vars-in query #'simple?)) (gb (gensym)))
        `(with-gensyms ,vars
           (setq *paths* nil)
           (=bind (,gb) ,(gen-query (rep_ query))
                (let ,(mapcar #'(lambda (v)
                                      `(,v (fullbind ,v ,gb)))
                                vars)
                 ,@@body)
                (fail)))))

 (defun varsym? (x)
    (and (symbolp x) (not (symbol-package x))))
@end lisp

                        Рисунок 24-7: Новый макрос верхнего уровня.
@end cartouche

Чтобы сгенерировать код для установления привязок для запроса, with-inference
вызывает gen-query (Рисунок 24-8). Первое что делает gen-query, это проверяет,
является ли первый аргумент сложным запросом, начинающимся с оператора подобного
and или or. Этот процесс продолжается рекурсивно, пока не достигнет простых
запросов, которые расширяются в вызовы prove. В первоначальной реализации
такая логическая струкутра, анализировалась во время выполнения. Сложное выражение,
встречающееся в теле правила, нужно было анализировать заново, каждый раз, когда
оно использовалось. Это расточительно, потому что логическая структура правил и
запросов известна заранее. Новая реализация разбирает(декопозирует) сложные выражения
во время компиляции.

Как и в предыдущей реализации, выражение with-inference расширяется в код, который
выполняет итерацию по Lisp коду следующему за запросом с переменными образца,
связываемыми с последовательными значениями, устанавливаемыми правилами. Расширение
with-inference завершается с fail, который перезапускает любые сохраненные 
состояния.

Остальные функции на Рисунке 24-8 генерируют расширения для сложных запросов -
запросов, объединенных с помощью операторов подобных and, or, и not. Если у
нас есть запрос подобный

@lisp
(and (big ?x) (red ?x))
@end lisp

@noindent
мы хотим, чтобы код на Lisp-е вычислялся только с теми ?x, для которых могут быть
доказаны оба коньюнкта(conjuncts/члена выражения and). Таким образом, чтобы создать
расширение and, мы вкладываем расширение второго коньюнкта в расширение первого.
Когда (big ?x) успешно, мы попытаемся вычислить (red ?x), и если оно тоже успешно,
мы вычисллим выражения Lisp. Таким образом, всё выражение расширяется, как показано
на Рисунке 24-9.

@cartouche
@lisp
 (defun gen-query (expr &optional binds)
       (case (car expr)
        (and (gen-and (cdr expr) binds))
        (or (gen-or (cdr expr) binds))
        (not (gen-not (cadr expr) binds))
        (t     `(prove (list ',(car expr)
                                 ,@@(mapcar #'form (cdr expr)))
                        ,binds))))

 (defun gen-and (clauses binds)
       (if (null clauses)
          `(=values ,binds)
          (let ((gb (gensym)))
               `(=bind (,gb) ,(gen-query (car clauses) binds)
                   ,(gen-and (cdr clauses) gb)))))

 (defun gen-or (clauses binds)
       `(choose
         ,@@(mapcar #'(lambda (c) (gen-query c binds))
                       clauses)))

 (defun gen-not (expr binds)
       (let ((gpaths (gensym)))
        `(let ((,gpaths *paths*))
              (setq *paths* nil)
              (choose (=bind (b) ,(gen-query expr binds)
                        (setq *paths* ,gpaths)
                        (fail))
                       (progn
                        (setq *paths* ,gpaths)
                        (=values ,binds))))))

 (=defun prove (query binds)
        (choose-bind r *rules* (=funcall r query binds)))

 (defun form (pat)
       (if (simple? pat)
          pat
          `(cons ,(form (car pat)) ,(form (cdr pat)))))
@end lisp

                       Рисунок 24-8: Компиляция запросов.
@end cartouche

@cartouche
@lisp
 (with-inference (and (big ?x) (red ?x))
    (print ?x))
@end lisp

@noindent
расширяется в:

@lisp
 (with-gensyms (?x)
    (setq *paths* nil)
    (=bind (#:g1) (=bind (#:g2) (prove (list 'big ?x) nil)
                           (=bind (#:g3) (prove (list 'red ?x) #:g2)
                              (=values #:g3)))
        (let ((?x (fullbind ?x #:g1)))
           (print ?x))
        (fail)))
@end lisp

                     Рисунок 24-9: Расширение коньюнкции(соединения - and).
@end cartouche

and означает вложение; а or означает выбор(choose). Получая запрос, подобный

@lisp
(or (big ?x) (red ?x))
@end lisp

@noindent
мы хотим, чтобы выражения Lisp вычислялись для значений ?x установленных
любым из подзапросов. Функция gen-or расширяется в choose поверх gen-query 
каждого из аргументов. Что касается not, gen-not почти идентичен prove-not
(Рисунок 24-3).

На рисунке 24-10 показан код для определения правил. Правила переводятся непосредственно
в код Lisp сгенерированный rule-fn. Поскольку <- теперь расширет правила в код на Lisp-е,
компиляция фала, содержащего определения правил, приведет к тому, что правила будут
скомпилироваными функциями.

Когда rule-function отправляет шаблон, она пытается сопоставить его головой(head)
правила, которое он представляет.  Если сопоставление выполнено успешно, 
rule-function пытается установить привязки для тела. Эта задача, по сути, та же,
что и with-inference, и на самом деле  rule-fn заканчивается вызовом gen-query. 
В конечном итоге, rule-function возвращает привязки, установленные для переменных,
встречающихся в  начале(head) правила.

@node 24-6 Adding Prolog Features, 24-7 Examples, 24-5 New Implementation, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-6 Добавление свойств(функций) Prolog-а
@cindex 24-6 Adding Prolog Features

Уже представленный код может запускать большинство "чистых" Prolog программ. Последний
шаг - добавить такие дополнения, как cuts, arithmetic, и ввод/вывод(I/O).

Помещение cut в правило Prolog-а приводит к обрезке/сокращению дерева поиска. 
Обычно, когда наша программа сталкиваестя с fail, он возвращется к последней точке
выбора(choice).

@cartouche
@lisp
 (defvar *rules* nil)

 (defmacro <- (con &rest ant)
       (let ((ant (if (= (length ant) 1)
                          (car ant)
                          `(and ,@@ant))))
         `(length (conc1f *rules*
                               ,(rule-fn (rep_ ant) (rep_ con))))))

 (defun rule-fn (ant con)
       (with-gensyms (val win fact binds)
         `(=lambda (,fact ,binds)
             (with-gensyms ,(vars-in (list ant con) #'simple?)
                (multiple-value-bind
                     (,val ,win)
                     (match ,fact
                              (list ',(car con)
                                     ,@@(mapcar #'form (cdr con)))
                              ,binds)
                  (if ,win
                       ,(gen-query ant val)
                       (fail)))))))
@end lisp

                       Рисунок 24-10: Код для определиния правил.
@end cartouche

@noindent
Реализация choose в Разделе 22-4 хранит точки выбора в глобальной переменной
*paths*. Вызов fail возобновляет поиск с самой последней точки выбора, которая 
является началом(car) списка *paths*. Оператор Cut вносит новое усложнение. Когда
программа встречает cut, он отбрасывает некоторые самые последние точки выбора,
хранящиеся в *paths*, в частности, все те, котоыре были сохранены с момента
последнего вызова prove.

Эффект состоит в том, чтобы сделать правила взаимоисключающими. Мы можем использвать
cut, чтобы получить эффект оператора  case в программах Prolog. Например, если мы
пределим minimum следующим образом:

@lisp
(<- (minimum ?x ?y ?x) (lisp (<= ?x ?y)))
(<- (minimum ?x ?y ?y) (lisp (> ?x ?y)))
@end lisp

@noindent
он будет работать правильно, но не эффективно. Получив запрос

@lisp
(minimum 1 2 ?x)
@end lisp

Prolog сразу установит, что ?x = 1 из первого правила. Человек на этом остановится, но
программа будет тратить время на поиск овтетов для второго правила, потому что небыло
никаких указаний, на то, что эти два правила взаимоисключающие. В среднем эта 
версия minimum будет выполнять на 50% больше работы, чем нужно. Мы можем решить проблему,
добавив cut после первого теста:

@lisp
(<- (minimum ?x ?y ?x) (lisp (<= ?x ?y)) (cut))
(<- (minimum ?x ?y ?y))
@end lisp

Теперь, когда Prolog завершит работу с первым правилом, он потерпит неудачу
обрабатывая все возможные пути, не переходя к следующему правилу.

Очень легко изменить нашу программу для обработки cut. При каждом вызове prove
текущее состояние *paths* передается в качестве параметра. Если программа встречает
cut, она просто устанавливает *paths* обратно на старое значение, переданное в параметре.
На рисунках 24-11 и 24-12 показан код, который необходимо изменить для обработки cut.
(Измененные строки отмечены точкой с запятой. Не все изменения происходят из-за cut.)

Cut(срезы), которые просто делают программу более эффективной, называются 
зелеными cut. Cut как минимум будет зеленым cut. Cut, которые заставляют 
программу вести себя по-другому, называются красными cut. Например, если 
мы определим предикат artist следующим образом:

@lisp
(<- (artist ?x) (sculptor ?x) (cut))
(<- (artist ?x) (painter ?x))
@end lisp

@noindent
результат состоит в том, что, если есть какие-либо sculptor, тогда запрос может 
на этом и закончиться. Если sculptor нет, тогда painter будет рассматриваться 
как artist:

@example
> (progn (<- (painter 'klee))
            (<- (painter 'soutine)))
4> (with-inference (artist ?x)
        (print ?x))
KLEE
SOUTINE
@
@end example

Но если есть sculptor, cut останавливает вывод на первом правиле:

@example
> (<- (sculptor 'hepworth))
5> (with-inference (artist ?x)
        (print ?x))
HEPWORTH
@
@end example

@cartouche
@lisp
 (defun rule-fn (ant con)
       (with-gensyms (val win fact binds paths)                     ;
        `(=lambda (,fact ,binds ,paths)                             ;
              (with-gensyms ,(vars-in (list ant con) #'simple?)
               (multiple-value-bind
                   (,val ,win)
                   (match ,fact
                             (list ',(car con)
                                    ,@@(mapcar #'form (cdr con)))
                             ,binds)
                 (if ,win
                      ,(gen-query ant val paths)                    ;
                      (fail)))))))

 (defmacro with-inference (query &rest body)
       (let ((vars (vars-in query #'simple?)) (gb (gensym)))
        `(with-gensyms ,vars
              (setq *paths* nil)
              (=bind (,gb) ,(gen-query (rep_ query) nil '*paths*) ;
               (let ,(mapcar #'(lambda (v)
                                     `(,v (fullbind ,v ,gb)))
                                vars)
                 ,@@body)
               (fail)))))

 (defun gen-query (expr binds paths)                                ;
       (case (car expr)
        (and (gen-and (cdr expr) binds paths))                      ;
        (or      (gen-or (cdr expr) binds paths))                   ;
        (not (gen-not (cadr expr) binds paths))                     ;
        (lisp (gen-lisp (cadr expr) binds))                         ;
        (is      (gen-is (cadr expr) (third expr) binds))           ;
        (cut `(progn (setq *paths* ,paths)                          ;
                         (=values ,binds)))                         ;
        (t       `(prove (list ',(car expr)
                                 ,@@(mapcar #'form (cdr expr)))
                         ,binds *paths*))))                         ;

 (=defun prove (query binds paths)                                  ;
        (choose-bind r *rules*
          (=funcall r query binds paths)))                          ;
@end lisp

                 Рисунок 24-11: Добавление поддержки для новых операторов.
@end cartouche

@cartouche
@lisp
 (defun gen-and (clauses binds paths)                              ;
   (if (null clauses)
         `(=values ,binds)
         (let ((gb (gensym)))
          `(=bind (,gb) ,(gen-query (car clauses) binds paths);
             ,(gen-and (cdr clauses) gb paths)))))                 ;

 (defun gen-or (clauses binds paths)                               ;
   `(choose
         ,@@(mapcar #'(lambda (c) (gen-query c binds paths))        ;
                    clauses)))

 (defun gen-not (expr binds paths)                                 ;
   (let ((gpaths (gensym)))
        `(let ((,gpaths *paths*))
          (setq *paths* nil)
          (choose (=bind (b) ,(gen-query expr binds paths)         ;
                      (setq *paths* ,gpaths)
                      (fail))
                    (progn
                      (setq *paths* ,gpaths)
                      (=values ,binds))))))

 (defmacro with-binds (binds expr)
   `(let ,(mapcar #'(lambda (v) `(,v (fullbind ,v ,binds)))
                      (vars-in expr))
         ,expr))

 (defun gen-lisp (expr binds)
   `(if (with-binds ,binds ,expr)
          (=values ,binds)
          (fail)))

 (defun gen-is (expr1 expr2 binds)
   `(aif2 (match ,expr1 (with-binds ,binds ,expr2) ,binds)
            (=values it)
            (fail)))
@end lisp

               Рисунок 24-12: Добавление поддержки для новых операторов.
@end cartouche

@cartouche
@example
       rule       : (<-  sentence  query )
       query      : (not  query )
                  : (and  query *)
                  : (lisp  lisp expression )
                  : (is  variable  lisp expression )
                  : (cut)
                  : (fail)
                  :  sentence 
       sentence  : ( symbol  argument *)
       argument  :  variable 
                  :  lisp expression 
       variable  : ? symbol 
@end example

                             Рисунок 24-13: Новый синтаксис правил.
@end cartouche

Иногда cut используется вместе с оператором Prolog fail. Наша функция fail 
делает то же самое. Помещение cut в правило превращает его в улицу с 
односторонним движением: когда вы входите, вы обязуетесь использовать 
только это правило. Помещение в правило комбинации cut-fail превращает ее 
в улицу с односторонним движением в опасном районе: как только вы входите, 
вы полны решимости уйти ни с чем. Типичный пример - реализация not-equal:

@lisp
(<- (not-equal ?x ?x) (cut) (fail))
(<- (not-equal ?x ?y))
@end lisp

Первое правило здесь - ловушка для самозванцев. Если мы пытаемся доказать факт в 
виде (not-equal 1 1), он будет соответствовать голове(head) первого правила и
таким образом, будет обречен. Запрос (not-equal 1 2), с другой стороны, не будет 
соответствовать голове(head) первого правила и перейдет ко второму, где он 
завершится успешно:

@example
> (with-inference (not-equal 'a 'a)
         (print t))
@@> (with-inference (not-equal '(a a) '(a b))
         (print t))
T@
@end example

Код, показанный на рисунках 24-11 и 24-12, также дает нашей программе арифметику, 
ввод-вывод и оператор Prolog is. На рисунке 24-13 показан полный синтаксис 
правил и запросов.

Мы добавляем арифметику (и многое другое), добавляя люк в Лисп. Теперь в дополнение 
к таким операторам, как and и or, у нас есть оператор lisp. После него может следовать
любое выражение Lisp, которое будет вычисляться с переменными внутри границ привязок, 
установленными для них запросом. Если выражение вычисляется как nil, тогда Lisp выражение
в целом эквивалентно (fail); в противном случае оно эквивалентно (and).

В качестве примера использования оператора lisp рассмотрим определение ordered
в Прологе, которое верно для списков, элементы которых расположены в порядке 
возрастания:
@lisp
(<- (ordered (?x)))
(<- (ordered (?x ?y . ?ys))
        (lisp (<= ?x ?y))
        (ordered (?y . ?ys)))
@end lisp

В английском языке список одного элемента упорядочен, а список двух или более элементов 
упорядочен, если первый элемент списка меньше или равен второму, а список из второго 
элемента упорядочен.

@example
> (with-inference (ordered '(1 2 3))
        (print t))
T@@> (with-inference (ordered '(1 3 2))
        (print t))
@
@end example

С помощью оператора lisp мы можем предоставить другие функции, предлагаемые
Типичными реализациями Пролога. Предикаты ввода/вывода Prolog-а можно дублировать, 
помещая вызовы Lisp I/O в выражение lisp. Утверждение Prolog-а, которое в качестве 
побочного эффекта определяет новые правила, может быть продублировано путем вызова 
макроса <- в выражениях lisp.

Оператор is предлагает форму присваивания. Он принимает два аргумента, образец и 
выражение Lisp, и пытается сопоставить образец с результатом, возвращаемым выражением. 
Если совпадение не удается, то вызовы программы завершаются неудачно; в противном 
случае оно продолжается с новыми привязками. Таким образом, выражение (is? X 1) 
имеет эффект установки ?X в 1, или, точнее, настаивая на том, чтобы ?X было 1. 
Нам нужно вычислить, например, factorials(факториалы):

@lisp
(<- (factorial 0 1))
(<- (factorial ?n ?f)
        (lisp (> ?n 0))
        (is ?n1 (- ?n 1))
        (factorial ?n1 ?f1)
        (is ?f (* ?n ?f1)))
@end lisp

Мы используем это определение, делая запрос с номером n в качестве первого аргумента 
и переменной в качестве второго:

@example
> (with-inference (factorial 8 ?x)
             (print ?x))
40320
@
@end example

Обратите внимание, что переменные, используемые в выражении lisp или во втором 
аргументе is, должны иметь привязки, чтобы выражение возвращало значение. 
Это ограничение действует в любом Прологе. Например, запрос:

@lisp
(with-inference (factorial ?x 120)                                          ; wrong
     (print ?x))
@end lisp

не будет работать с этим определением факториала, потому что ?n будет неизвестно 
при вычислении выражения lisp. Так что не все программы Prolog похожи на append: 
многие настаивают, как факториал, на том, что некоторые их аргументы являются 
реальными значениями.

@node 24-7 Examples, 24-8 The Senses of Compile, 24-6 Adding Prolog Features, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-7 Примеры
@cindex 24-7 Examples

В этом последнем разделе показано, как написать несколько примеров программ на
Prolog в нашей реализации. Правила на Рисунке 24-14 определяют быструю сортировку
- quicksort. Эти правила подразумевают факты вида (quicksort xy), где x это список,
а y это список тех же элементов, отсортированных в порядке возрастания. Переменные
могут появляться в позиции второго аргумента:

@example
     > (with-inference (quicksort '(3 2 1) ?x)
             (print ?x))
     (123)
     @
@end example

Цикл ввода/вывода является тестом для нашего Prolog, поскольку он использует
операторы cut, lisp, и is. Код показан на рисунке 24-15. Эти правила следует
вызывать, пытаясь доказать (echo), без аргументов. Этот запрос будет соответствовать
первому правилу, которое связывает ?x с результатом возвращенным read, и затем 
пытаестя установить (echo ?x). Новый запрос может соответствовать любому из
двух вторых правил. Если ?x = done, то запрос завершиться на втором правиле. В
противном случае запрос будет соответствовать только третьему правилу,
котое печатает прочитанное значение и запускает процесс заново.

@cartouche
@lisp
 (setq *rules* nil)

 (<- (append nil ?ys ?ys))
 (<- (append (?x . ?xs) ?ys (?x . ?zs))
        (append ?xs ?ys ?zs))

 (<- (quicksort (?x . ?xs) ?ys)
        (partition ?xs ?x ?littles ?bigs)
        (quicksort ?littles ?ls)
        (quicksort ?bigs ?bs)
        (append ?ls (?x . ?bs) ?ys))
 (<- (quicksort nil nil))

 (<- (partition (?x . ?xs) ?y (?x . ?ls) ?bs)
        (lisp (<= ?x ?y))
        (partition ?xs ?y ?ls ?bs))
 (<- (partition (?x . ?xs) ?y ?ls (?x . ?bs))
        (lisp (> ?x ?y))
        (partition ?xs ?y ?ls ?bs))
 (<- (partition nil ?y nil nil))
@end lisp

                            Рисунок 24-14: Быстрая сортировка(Quicksort).
@end cartouche

@cartouche
@lisp
 (<- (echo)
        (is ?x (read))
        (echo ?x))
 (<- (echo 'done)
        (cut))
 (<- (echo ?x)
        (lisp (prog1 t (format t "~A~%" ?x)))
        (is ?y (read))
        (cut)
        (echo ?y))
@end lisp

                      Рисунок 24-15: Цикл ввода/вывода(I/O) в Prolog-е.
@end cartouche

В совокупности правила определяют программу, которая будет продолжать повторять, то
что вы печатаете, до тех пор, пока вы не напечатаете done:

@example
> (with-inference (echo))
hi
HI
ho
HO
done
@
@end example

Такие программы трудно читать, потому что они разрушают абстрактную модель Prolog-а. 
Может быть, легче понять echo если мы посмотрим на буквальную трансляцию в код Lisp.

@lisp
(defun echo (&rest args)
     (cond ((null args) (echo (read)))
             ((eq (car args) 'done) nil)
             (t (format t "~A~%" (car args))
                 (echo (read)))))
@end lisp

@noindent
который в идиоматическом Common Lisp будет:

@lisp
(defun echo (&optional (arg (read)))
     (unless (eq arg 'done)
        (format t "~A~%" arg)
        (echo)))
@end lisp

@node 24-8 The Senses of Compile,  , 24-7 Examples, 24 Prolog
@comment  node-name,  next,  previous,  up
@section 24-8 Смыслы Компиляции
@cindex 24-8 The Senses of Compile

Слово "компиляция"(compile) имеет несколько смыслов. В самом общем смысле, компиляция
это преобразование некоторого абстрактного описания программы в код более низкого
уровня. Программа, описанная в этой главе, безусловно является компилятором, в этом
смысле, потому что она переводит правила в функции Lisp.

В более конкретном смысле, компиляция означает преобразование программы в машинный
язык. Хороший Common Lisp-ы компилируют функции в машинный код. Как упомянуто на
стр. 25, если код, который генерирует замыкания, скомпилирован, он даст скомпилированные
замыкания. Таким образом, описанная здесь программа, также является более строгим
компилятором. В хорошем Lisp, наши Prolog программы будут переведены на машинный язык.

Вместе с тем, описанная здесь программа, все еще не является компилятором Prolog-а.
Для языков программирования существует еще более конкретный смысл "компиляции", 
и простого создания машинного кода недостаточно для удовлетворения этого определения.
Компилятор для языка программирования должен как оптимизировать код, так и транслировать
его. Например, если компилятору Lisp предлагается скомпилировать выражение вроде

@lisp
(+ x (+ 2 5))
@end lisp

@noindent
он должен быть достаточно умен, чтобы понять, что нет причин ждать, пока во время
выполнения вычислиться (+ 2 5). Программу можно оптимизировать, заменив это выражение
на 7, и вместо него компилировать

@lisp
(+ x 7)
@end lisp

В нашей программе, вся компиляция выполняется компилятором Lisp, и он ищет
оптимизацию для Lisp-аs, а не оптимизацию Prolog-а. Ее оптимизация будет действенной,
но слижком низкоуровневой. Компилятор Lisp не знает, что код, который он компилирует,
предназначен для представления правил. В то время как настоящий компилятор Prolog будет
искать правила, которые можно преобразовывать в циклы, наша программа ищет выражения,
которые выдают констатны, или замыкания, которые могут быть размещены в стеке.

Встроенные языки позволяют максимально использовать доступные абстракции, но они
не волшебны. Если вы хотите пройти путь от очень абстрактного представления до
быстрого машинного кода, кто-то еще длолжен сказать компьютеру, как это сделать.
В этой главе мы прошли большую часть этого расстояния с удивительно небольшим кодом,
но это не тоже самое, что написиать настоящий компилятор Prolog-а.