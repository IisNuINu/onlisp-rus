#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-14.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-08-30 12:45+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-14.texi:5
msgid ""
"@node 14 Anaphoric Macros, 15 Macros Returning Functions, 13 Computation at "
"Compile-Time, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 14 Anaphoric Macros\n"
"@cindex 14 Anaphoric Macros"
msgstr ""
"@node 14 Anaphoric Macros, 15 Macros Returning Functions, 13 Computation at "
"Compile-Time, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 14 Анафорические(ссылающиеся или отсылающие к ранее сказанному) "
"Макросы\n"
"@cindex 14 Anaphoric Macros"

#: texi/node-14.texi:10
msgid ""
"Chapter 9 treated variable capture exclusively as a problem-as something "
"which\n"
"happens inadvertently, and which can only affect programs for the worse. "
"This\n"
"chapter will show that variable capture can also be used constructively. "
"There are\n"
"some useful macros which couldn't be written without it."
msgstr ""
"Глава 9 рассматривала захват переменных исключительно как проблему, как "
"нечто, что\n"
"происходит не преднамеренно, и что может повлиять на программы в худшую "
"сторону. Эта\n"
"глава покажет, что захват переменных также можно использовать конструктивно. "
"Есть\n"
"некоторые полезные макросы, которые нельзя было бы написать без этого."

#: texi/node-14.texi:14
msgid ""
"It's not uncommon in a Lisp program to want to test whether an expression\n"
"returns a non-nil value, and if so, to do something with the value. If the "
"expression\n"
"is costly to evaluate, then one must normally do something like this:"
msgstr ""
"В программах на Lisp нередко хочется проверить, является ли возвращаемое "
"выраженим\n"
"значение не nil, и если да, что-то сделать с этим значением. Если выражение "
"дорого\n"
"вычислять, тогда обычно нужно сделать, что то вроде этого:"

#: texi/node-14.texi:20
msgid ""
"@lisp\n"
"(let ((result (big-long-calculation)))\n"
"  (if result\n"
"        (foo result)))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:22
msgid "Wouldn't it be easier if we could just say, as we would in English:"
msgstr ""
"Но не проще было бы, если бы мы могли просто сказать, как мы это сделали\n"
"бы на английском:"

#: texi/node-14.texi:27
msgid ""
"@lisp\n"
"(if (big-long-calculation)\n"
"     (foo it))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:30
msgid ""
"By taking advantage of variable capture, we can write a version of if which "
"works\n"
"just this way."
msgstr ""
"Используя преимущества захвата переменных, мы можем написать версию if, "
"которая\n"
"работает подобным способом."

#: texi/node-14.texi:36
msgid ""
"@menu\n"
"* 14-1 Anaphoric Variants::     \n"
"* 14-2 Failure::                \n"
"* 14-3 Referential Transparency::  \n"
"@end menu"
msgstr ""

#: texi/node-14.texi:42
msgid ""
"@node 14-1 Anaphoric Variants, 14-2 Failure, 14 Anaphoric Macros, 14 "
"Anaphoric Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 14-1 Anaphoric Variants\n"
"@cindex 14-1 Anaphoric Variants\n"
"@findex 14-1 Anaphoric Variants"
msgstr ""
"@node 14-1 Anaphoric Variants, 14-2 Failure, 14 Anaphoric Macros, 14 "
"Anaphoric Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 14-1 Варианты Анафоризмов\n"
"@cindex 14-1 Anaphoric Variants\n"
"@findex 14-1 Anaphoric Variants"

#: texi/node-14.texi:50
msgid ""
"In natural language, an anaphor is an expression which refers back in the "
"con-\n"
"versation. The most common anaphor in English is probably \"it,\" as in "
"\"Get the\n"
"wrench and put it on the table.\" Anaphora are a great convenience in "
"everyday\n"
"language-imagine trying to get along without them-but they don't appear "
"much\n"
"in programming languages. For the most part, this is good. Anaphoric "
"expressions\n"
"are often genuinely ambiguous, and present-day programming languages are "
"not\n"
"designed to handle ambiguity."
msgstr ""
"В естественном языке, анафор - это выражение, которое ссылается к уже\n"
"сказанному. Наиболее распространённым анафором в Английском языке вероятно\n"
"является \"it,\"(это, оно, он, оно) как в \"Возьми гаеечный ключ, и положи "
"it(его)\n"
"на стол.\" Анафоры очень удобны в повседневном языке - представьте, как вы "
"бы\n"
"обходидлись без них, но они не очень часто используются в языках "
"программирования.\n"
"По большей части, это хорошо. Анафорные выражения часто являются по "
"настоящему\n"
"двусмысленными, а современные языки программирования не предназначены для \n"
"устранения двусмысленностей."

#: texi/node-14.texi:56
msgid ""
"However, it is possible to introduce a very limited form of anaphora into\n"
"Lisp programs without causing ambiguity. An anaphor, it turns out, is a lot "
"like\n"
"a captured symbol. We can use anaphora in programs by designating certain\n"
"symbols to serve as pronouns, and then writing macros intentionally to "
"capture\n"
"these symbols."
msgstr ""
"Тем не менее, можно ввести ограниченную форму анофоры в программы на Lisp "
"не \n"
"вызывая двусмысленности. Оказывается, анафор очень похож на захват символа.\n"
"Мы можем использовать анафору в программах, назначая определенные символы,\n"
"для использования в качестве местоимений, а затем намеренно писать макросы \n"
"захватывающие эти символы."

#: texi/node-14.texi:59
msgid ""
"In the new version of if, the symbol it is the one we want to capture. The\n"
"anaphoric if, called aif for short, is defined as follows:"
msgstr ""
"В новой версии if, символ it является символом, который мы хотим захватить. "
"Анафорный\n"
"if, коротко называемый  aif, определяется следующим образом:"

#: texi/node-14.texi:65
msgid ""
"@lisp\n"
"(defmacro aif (test-form then-form &optional else-form)\n"
"  `(let ((it ,test-form))\n"
"         (if it ,then-form ,else-form)))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:68
msgid ""
"@noindent\n"
"and used as in the previous example:"
msgstr ""
"@noindent\n"
"и используется как в предыдущем примере:"

#: texi/node-14.texi:73
msgid ""
"@lisp\n"
"(aif (big-long-calculation)\n"
"         (foo it))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:78
msgid ""
"When you use an aif, the symbol it is left bound to the result returned by "
"the\n"
"test clause. In the macro call, it seems to be free, but in fact the "
"expression (foo\n"
"it) will be inserted by expansion of the aif into a context in which the "
"symbol\n"
"it is bound:"
msgstr ""
"Когда вы используете aif, символl it является связываемым слева с "
"результатом возвращаемым\n"
"тестовым предложением. В вызове макроса, it кажется свободным, но на самом "
"деле выражение\n"
"(foo it) будет вставлено при расширении aif в контекст, в котором символ it "
"является \n"
"связанным:"

#: texi/node-14.texi:83
msgid ""
"@lisp\n"
"(let ((it (big-long-calculation)))\n"
"  (if it (foo it) nil))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:87
msgid ""
"So a symbol which looks free in the source code is left bound by the "
"macroex-\n"
"pansion. All the anaphoric macros in this chapter use some variation of the "
"same\n"
"technique."
msgstr ""
"Таким образом, символ, который выглядит свободным в исходном коде, является\n"
"связанным в расширении макроса. Все анафорические макросы в этой главе\n"
"используют вариации одной и той же техники."

#: texi/node-14.texi:90
msgid ""
"Figure 14-1 contains anaphoric variants of several Common Lisp operators.\n"
"After aif comes awhen, the obvious anaphoric variant of when:"
msgstr ""
"Рисунок 14-1 содержит анафорические варианты нескольких операторов Common "
"Lisp.\n"
"После aif идет awhen, очевидный анафорический вариант when(когда):"

#: texi/node-14.texi:96
msgid ""
"@lisp\n"
"(awhen (big-long-calculation)\n"
"  (foo it)\n"
"  (bar it))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:103
msgid ""
"Both aif and awhen are frequently useful, but awhile is probably unique\n"
"among the anaphoric macros in being more often needed than its regular "
"cousin,\n"
"while (defined on page 91). Macros like while and awhile are typically used\n"
"in situations where a program needs to poll some outside source. And when "
"you\n"
"are polling a source, unless you are simply waiting for it to change state, "
"you will\n"
"usually want to do something with the object you find there:"
msgstr ""
"И aif и awhen часто полезны, но  awhile вероятно уникальный среди "
"анафорических\n"
"макросов в том, что он является более полезным, чем его кузен while "
"(определенный\n"
"на странице 91). Макросы типа while и awhile обычно используются в ситуациях "
"где\n"
"программе необходимо опрашивать какой-то внешний источник. И когда вы "
"опрашиваете\n"
"источник, если вы не ждете, что он просто изменит свое состояние, вам обычно "
"хочется\n"
"что-то сделать с возвращенным из него объектом:"

#: texi/node-14.texi:108
msgid ""
"@lisp\n"
" (defmacro aif (test-form then-form &optional else-form)\n"
"        `(let ((it ,test-form))\n"
"             (if it ,then-form ,else-form)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro aif (test-form then-form &optional else-form)\n"
"        `(let ((it ,test-form))\n"
"             (if it ,then-form ,else-form)))"

#: texi/node-14.texi:112
msgid ""
" (defmacro awhen (test-form &body body)\n"
"        `(aif ,test-form\n"
"                 (progn ,@@body)))"
msgstr ""

#: texi/node-14.texi:117
msgid ""
" (defmacro awhile (expr &body body)\n"
"        `(do ((it ,expr ,expr))\n"
"                ((not it))\n"
"             ,@@body))"
msgstr ""

#: texi/node-14.texi:122
msgid ""
" (defmacro aand (&rest args)\n"
"        (cond ((null args) t)\n"
"                 ((null (cdr args)) (car args))\n"
"                 (t `(aif ,(car args) (aand ,@@(cdr args))))))"
msgstr ""
" (defmacro aand (&rest args)\n"
"        (cond ((null args) t)\n"
"              ((null (cdr args)) (car args))\n"
"              (t `(aif ,(car args) (aand ,@@(cdr args))))))"

#: texi/node-14.texi:133
msgid ""
" (defmacro acond (&rest clauses)\n"
"        (if (null clauses)\n"
"              nil\n"
"              (let ((cl1 (car clauses))\n"
"                       (sym (gensym)))\n"
"                 `(let ((,sym ,(car cl1)))\n"
"                      (if ,sym\n"
"                            (let ((it ,sym)) ,@@(cdr cl1))\n"
"                            (acond ,@@(cdr clauses)))))))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:135
msgid ""
"               Figure 14-1: Anaphoric variants of Common Lisp operators."
msgstr ""
"               Рисунок 14-1: Анафорные варианты операторов Common Lisp.\n"
"@end cartouche"

#: texi/node-14.texi:140
msgid ""
"@lisp\n"
"(awhile (poll *fridge*)\n"
"   (eat it))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:151
msgid ""
"The definition of aand is a bit more complicated than the\n"
"preceding ones.  It provides an anaphoric version of and; during the\n"
"evaluation of each of its arguments, it will be bound to the value\n"
"returned by the previous argument. @footnote{Although one tends to\n"
"think of and and or together, there would be no point in writing an\n"
"anaphoric version of or. An argument in an or expression is evaluated\n"
"only if the previous argument evaluated to nil, so there would be\n"
"nothing useful for an anaphor to refer to in an aor.} In practice,\n"
"aand tends to be used in programs which make conditional queries, as\n"
"in:"
msgstr ""
"Определение aand немного сложнее чем предыдущие.  Оно представлляет\n"
"анафорическую верисию and; во время вычисления каждого из его аргументов,\n"
"it будет привязан к значению возвращенному предыдущим аргументом. \n"
"@footnote{Хотя кто-то склонен думать одновременно об and и or, было бы\n"
"бессмысленно писать анафорническую версию or. Аргумент в выражении or\n"
"вычисляется только, если предыдущий аргумент вычисляется в nil, так \n"
"что анафору будет не на что ссылаться в aor.} На практике, aand, как \n"
"правило используется в программах, которые делают условные запросы,\n"
"как в:"

#: texi/node-14.texi:155
msgid ""
"@lisp\n"
"(aand (owner x) (address it) (town it))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:159
msgid ""
"@noindent\n"
"which returns the town (if there is one) of the address (if there is one) of "
"the owner\n"
"(if there is one) of x. Without aand, this expression would have to be "
"written"
msgstr ""
"@noindent\n"
"который возвращает владельца (если он есть)  x, затем адресс(address) (если "
"он есть), а затем\n"
"город(town) (если он есть). Без aand, это выражение должно было бы написано "
"как:"

#: texi/node-14.texi:166
msgid ""
"@lisp\n"
"(let ((own (owner x)))\n"
"  (if own\n"
"           (let ((adr (address own)))\n"
"              (if adr (town adr)))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(let ((own (owner x)))\n"
"  (if own\n"
"      (let ((adr (address own)))\n"
"        (if adr \n"
"            (town adr)))))\n"
"@end lisp"

#: texi/node-14.texi:171
msgid ""
"The definition of aand shows that the expansion will vary depending on the\n"
"number of arguments in the macro call. If there are no arguments, then aand, "
"like\n"
"the regular and, should simply return t. Otherwise the expansion is "
"generated\n"
"recursively, each step yielding one layer in a chain of nested aifs:"
msgstr ""
"Определение aand показыает, что расширение будет варьироваться в зависимости "
"от\n"
"количества аргументов в вызове макроса. Если аргументов нет, то aand  как "
"и \n"
"обычный and, должен просто вернуть t. В противном случае расширение "
"генерируется\n"
"рекурсивно, каждый шаг дает один слой в цепочке вложенных aif:"

#: texi/node-14.texi:176
msgid ""
"@lisp\n"
"(aif  first argument \n"
"          expansion for rest of arguments )\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:181
msgid ""
"The expansion of an aand must terminate when there is one argument left, "
"instead\n"
"of working its way down to nil like most recursive functions. If the "
"recursion\n"
"continued until no conjuncts remained, the expansion would always be of the\n"
"form:"
msgstr ""
"Расширение aand должно прекратиться, когда останется один аргумент, вместо "
"работы\n"
"до nil подобно большинству рекурсивных функций. Если бы рекурсия "
"продолжалась до\n"
"тех пор, пока не осталось бы никаких аргументов, расширение всегда будет\n"
"иметь форму:"

#: texi/node-14.texi:186
msgid ""
"@lisp\n"
"(aif  c1 \n"
"         ...(aif  cn t)...)\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:189
msgid ""
"Such an expression would always return t or nil, and the example above "
"wouldn't\n"
"work as intended."
msgstr ""
"Такое выражение всегда будет возвращать t или nil, а приведенный выше пример "
"не\n"
"будет работать как задумано."

#: texi/node-14.texi:193
msgid ""
"Section 10-4 warned that if a macro always yielded an expansion containing\n"
"a call to itself, the expansion would never terminate. Though recursive, "
"aand is\n"
"safe because in the base case its expansion doesn't refer to aand."
msgstr ""
"Раздел 10-4 предупредил, что если макрос всегда дает расширение, содержащее\n"
"вызов самого себя, расширение никогда не прекратится(компиляция \"зависнет"
"\"). \n"
"Но рекурсивный aand является безопасным, потому что в базовом случаее его \n"
"расширение не обращается к aand."

#: texi/node-14.texi:198
msgid ""
"The last example, acond, is meant for those cases where the remainder of a\n"
"cond clause wants to use the value returned by the test expression. (This "
"situation\n"
"arises so often that some Scheme implementations provide a way to use the "
"value\n"
"returned by the test expression in a cond clause.)"
msgstr ""
"Последний пример, acond, предназначен для тех случаев, когда в остатке "
"предложения\n"
"cond хочется использовать значение возвращаемое тестовым выражением. (Эта "
"ситуация\n"
"возникает так часто, что некоторые реализации Scheme предоставляют способ "
"использовать\n"
"значение возвращаемое тестовым выражением в предложении cond.)"

#: texi/node-14.texi:203
msgid ""
"In the expansion of an acond clause, the result of the test expression will\n"
"initially be kept in a gensymed variable, in order that the symbol it may be "
"bound\n"
"only within the remainder of the clause. When macros create bindings, they "
"should\n"
"always do so over the narrowest possible scope. Here, if we dispensed with "
"the"
msgstr ""
"В расширениии предложения acond, результат тестового выражения будет вначале "
"храниться\n"
"в переменной gensym, чтобы символ it мог быть связан только в оставшейся "
"части\n"
"предложения. Когда макросы создают привязки, они должны всегда делать это в "
"самой узкой\n"
"области видимости. Вот, если бы мы обошлись без"

#: texi/node-14.texi:208
msgid ""
"@lisp\n"
" (defmacro alambda (parms &body body)\n"
"       `(labels ((self ,parms ,@@body))\n"
"         #'self))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro alambda (parms &body body)\n"
"       `(labels ((self ,parms ,@@body))\n"
"         #'self))"

#: texi/node-14.texi:219
msgid ""
" (defmacro ablock (tag &rest args)\n"
"       `(block ,tag\n"
"         ,(funcall (alambda (args)\n"
"                          (case (length args)\n"
"                            (0 nil)\n"
"                            (1 (car args))\n"
"                            (t `(let ((it ,(car args)))\n"
"                                    ,(self (cdr args))))))\n"
"                       args)))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:221
msgid "                       Figure 14-2: More anaphoric variants."
msgstr ""
"                       Рисунок 14-2: Еще варианты анафорных макросов.\n"
"@end cartouche"

#: texi/node-14.texi:225
msgid ""
"@noindent\n"
"gensym and instead bound it immediately to the result of the test "
"expression, as\n"
"in:"
msgstr ""
"@noindent\n"
"gensym и вместо этого сразу бы связали it с результатом тестового выражения, "
"как \n"
"в:"

#: texi/node-14.texi:236
msgid ""
"@lisp\n"
"(defmacro acond (&rest clauses)                                            ; "
"wrong\n"
"  (if (null clauses)\n"
"         nil\n"
"         (let ((cl1 (car clauses)))\n"
"           `(let ((it ,(car cl1)))\n"
"                (if it\n"
"                     (progn ,@@(cdr cl1))\n"
"                     (acond ,@@(cdr clauses)))))))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:243
msgid ""
"@noindent\n"
"then that binding of it would also have within its scope the following test "
"expres-\n"
"sion.Figure 14-2contains some more complicatedanaphoricvariants. The macro\n"
"alambda is for referring literally to recursive functions. When does one "
"want to\n"
"refer literally to a recursive function? We can refer literally to a "
"function by using\n"
"a sharp-quoted lambda-expression:"
msgstr ""
"@noindent\n"
"тогда привязку it также будет иметь в своем окружении последующее тестовое "
"выражение.\n"
"Рисунок 14-2 содержит несколько более сложных анафорических вариантов. "
"Макрос\n"
"alambda используется для создания само рекурсивной функции. Когда кто то "
"хочет буквально\n"
"ссылаться на рекурсивную функцию? Мы можем сослаться на неименованную "
"функцию используя\n"
"решетку c квотированием (#') для лямбда-выражения:"

#: texi/node-14.texi:247
msgid ""
"@lisp\n"
"#'(lambda (x) (* x 2))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:251
msgid ""
"But as Chapter 2 explained, you can't express a recursive function with a "
"simple\n"
"lambda-expression. Instead you have to define a local function with labels. "
"The\n"
"following function (reproduced from page 22)"
msgstr ""
"Но как объяснялось во второй главе, вы не можете просто выразить рекурсивную "
"функцию\n"
"с помощью простого лямбда выражения. В место этого вы должны определить "
"локальное\n"
"определение именованной функции используя labels. Следующая функция \n"
"(воспроизводим со страницы 22)"

#: texi/node-14.texi:261
msgid ""
"@lisp\n"
"(defun count-instances (obj lists)\n"
"  (labels ((instances-in (list)\n"
"                    (if list\n"
"                         (+ (if (eq (car list) obj) 1 0)\n"
"                               (instances-in (cdr list)))\n"
"                         0)))\n"
"        (mapcar #'instances-in lists)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun count-instances (obj lists)\n"
"  (labels ((instances-in (list)\n"
"             (if list\n"
"                 (+ (if (eq (car list) obj) \n"
"                        1 \n"
"                        0)\n"
"                    (instances-in (cdr list)))\n"
"                 0)))\n"
"     (mapcar #'instances-in lists)))\n"
"@end lisp"

#: texi/node-14.texi:265
msgid ""
"@noindent\n"
"takes an object and a list, and returns a list of the number of occurrences "
"of the\n"
"object in each element:"
msgstr ""
"@noindent\n"
"получает объект и список, и возвращает список числа вхождений объекта в "
"каждый элемент\n"
"списка:"

#: texi/node-14.texi:270
msgid ""
"@example\n"
"> (count-instances 'a '((a b c) (darpa)(dar)(aa)))\n"
"(1212)\n"
"@end example"
msgstr ""
"@example\n"
"> (count-instances 'a '((a b c) (d a r p a)(d a r)(a a)))\n"
"(1 2 1 2)\n"
"@end example"

#: texi/node-14.texi:274
msgid ""
"With anaphora we can make what amounts to a literal recursive function. The\n"
"alambda macro uses labels to create one, and thus can be used to express, "
"for\n"
"example, the factorial function:"
msgstr ""
"С анафорой мы можем сделать то, что представляет собой буквальную "
"рекурсивную\n"
"функцию. Макрос alambda использует labels для создания функции, и может \n"
"использоваться для выражения, например, рекурсивной функции факториала:"

#: texi/node-14.texi:278
msgid ""
"@lisp\n"
"(alambda (x) (if (= x 0) 1 (* x (self (1- x)))))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:281
msgid ""
"Using alambda we can define an equivalent version of count-instances as\n"
"follows:"
msgstr ""
"Используя alambda мы можем определить эквивалентную версию count-instances \n"
"следующим образом:"

#: texi/node-14.texi:291
msgid ""
"@lisp\n"
"(defun count-instances (obj lists)\n"
"  (mapcar (alambda (list)\n"
"                   (if list\n"
"                        (+ (if (eq (car list) obj) 1 0)\n"
"                             (self (cdr list)))\n"
"                        0))\n"
"                lists))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:297
msgid ""
"Unlike the other macros in Figures 14-1 and 14-2, which all capture it, "
"alambda\n"
"captures self. An instance of alambda expands into a labels expression in\n"
"which self is bound to the function being defined. As well as being "
"smaller,\n"
"alambda expressions look like familiar lambda expressions, making code "
"which\n"
"uses them easier to read."
msgstr ""
"В отличии от других макросов на Рисунке 14-1 и 14-2, которые все "
"захватывают\n"
"символ it, alambda захватывает символ self. Экземпляр alambda расширяется \n"
"до выражения labels в котором self связывается с определяемой функцией.\n"
"Помимо того что оно меньше, выражение alambda выглядит как привычные лямбда\n"
"выражения, создавая код, который легче читать, при их использовании."

#: texi/node-14.texi:302
msgid ""
"The new macro is used in the definition of ablock, an anaphoric version of "
"the\n"
"built-in block special form. In a block, the arguments are evaluated left-to-"
"right.\n"
"The same happens in an ablock, but within each the variable it will be bound "
"to\n"
"the value of the previous expression."
msgstr ""
"Новый макрос используется в определении ablock, анафорической версии "
"встроенной \n"
"специальной формы block. В block, аргументы вычисляются слева направо.\n"
"Тоже самое происходит и в ablock, но внутри каждого выражения перменная it "
"будет \n"
"связана со значением предыдущего выражения."

#: texi/node-14.texi:306
msgid ""
"This macro should be used with discretion. Though convenient at times,\n"
"ablock would tend to beat what could be nice functional programs into "
"imperative\n"
"form. The following is, unfortunately, a characteristically ugly example:"
msgstr ""
"Этот макрос следует использовать по своему усмотрению. Хотя иногда, ablock \n"
"будет превращаеть, то что могло быть хорошей функциональной программой, в\n"
"императивнрую форму. Следущий, к сожалениею, характерно некрасивый пример:"

#: texi/node-14.texi:316
msgid ""
"@example\n"
"> (ablock north-pole\n"
"        (princ \"ho \")\n"
"        (princ it)\n"
"        (princ it)\n"
"        (return-from north-pole))\n"
"ho ho ho\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-14.texi:322
msgid ""
"Whenever a macro which does intentional variable capture is exported to\n"
"another package, it is necessary also to export the symbol being captured. "
"For\n"
"example, wherever aif is exported, it should be as well. Otherwise the it "
"which\n"
"appears in the macro definition would be a different symbol from an it used "
"in a\n"
"macro call."
msgstr ""
"Всякий раз, когда макрос, который делает преднамеренный захват переменной, \n"
"экспортируется в другой пакет, необходимо также экспортировать захватываемый "
"символ. \n"
"Например, куда бы не экспортировался aif, it также должен экспортиоваться. В "
"противном\n"
"случае it, которое появлялется в определении макроса, будет отличаться от "
"символа it \n"
"используемого при вызове макроса."

#: texi/node-14.texi:327
msgid ""
"@node 14-2 Failure, 14-3 Referential Transparency, 14-1 Anaphoric Variants, "
"14 Anaphoric Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 14-2 Failure\n"
"@cindex 14-2 Failure"
msgstr ""
"@node 14-2 Failure, 14-3 Referential Transparency, 14-1 Anaphoric Variants, "
"14 Anaphoric Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 14-2 Неудачи\n"
"@cindex 14-2 Failure"

#: texi/node-14.texi:330
msgid ""
"In Common Lisp the symbol nil has at least three different jobs. It is first "
"of all\n"
"the empty list, so that"
msgstr ""
"В Common Lisp символ nil выполняет три разных задачи. Он в первую очередь "
"является\n"
"пустым списком, так что"

#: texi/node-14.texi:335
msgid ""
"@example\n"
"> (cdr '(a))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-14.texi:337
msgid "As well as the empty list, nil is used to represent falsity, as in"
msgstr ""
"Как и пустой список, nil используется для представления ложности, как в"

#: texi/node-14.texi:342
msgid ""
"@example\n"
">(=10)\n"
"NIL\n"
"@end example"
msgstr ""
"@example\n"
">(= 1 0)\n"
"NIL\n"
"@end example"

#: texi/node-14.texi:346
msgid ""
"And finally, functions return nil to indicate failure. For example, the job "
"of the\n"
"built-in find-if is to return the first element of a list which satisfies "
"some test.\n"
"If no such element is found, find-if returns nil:"
msgstr ""
"И наконец, функции возвращающие nil указывают на неудачу(сбой). Например, "
"работа\n"
"встроенного find-if должна возвращать первый элемент списка, который "
"удовлетворяет\n"
"некоторому критерию(тесту). Если такой элемент не найден, find-if вернет nil:"

#: texi/node-14.texi:351
msgid ""
"@example\n"
"> (find-if #'oddp '(2 4 6))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-14.texi:354
msgid ""
"Unfortunately, we can't tell this case from the one in which find-if "
"succeeds,\n"
"but succeeds in finding nil:"
msgstr ""
"К сожалению, мы не можем отличить этот случай от случая, когда find-if "
"завершается\n"
"успехом, но успех состоит в нахождении nil:"

#: texi/node-14.texi:359
msgid ""
"@example\n"
"> (find-if #'null '(2 nil 6))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-14.texi:364
msgid ""
"In practice, it doesn't cause too much trouble to use nil to represent both "
"falsity\n"
"and the empty list. In fact, it can be rather convenient. However, it is a "
"pain to\n"
"have nil represent failure as well, because it means that the result "
"returned by a\n"
"function like find-if can be ambiguous."
msgstr ""
"На практике, это не вызывает особых проблем, если использовать nil для "
"представления\n"
"ложности и пустого списка. На самом деле это может быть довольно удобно. Тем "
"не менее,\n"
"огорчает, иметь nil для представления неудачи, потому что это означает, что "
"результат\n"
"возвращаемый функциями типа find-if может быть не однозначным."

#: texi/node-14.texi:371
msgid ""
"The problem of distinguishing between failure and a nil return value arises\n"
"with any function which looks things up. Common Lisp offers no less than "
"three\n"
"solutions to the problem. The most common approach, before multiple return\n"
"values, was to return gratuitous list structure. There is no trouble "
"distinguishing\n"
"failure with assoc, for example; when successful it returns the whole pair "
"in\n"
"question:"
msgstr ""
"Возникает проблема различения неудачи и найденного значения nil "
"возвращаемого\n"
"любой функцией которая осуществляет поиск. Common Lisp предлагает не менее "
"трех\n"
"решений этой проблемы. Наиболее распространенный подходом - , до появления "
"возврата\n"
"множественных значений, - возвращать списковую структуру. Нет проблем в "
"различении\n"
"неудачи с использованием assoc, например; в случае успеха должна "
"возвращаться пара в \n"
"качестве результата:"

#: texi/node-14.texi:378
msgid ""
"@example\n"
"> (setq synonyms '((yes . t) (no . nil)))\n"
"((YES . T) (NO))\n"
"> (assoc 'no synonyms)\n"
"(NO)\n"
"@end example"
msgstr ""

#: texi/node-14.texi:382
msgid ""
"Following this approach, if we were worried about ambiguity with find-if,we\n"
"would use member-if, which instead of just returning the element satisfying "
"the\n"
"test, returns the whole cdr which begins with it:"
msgstr ""
"Следуя этому подходу, если мы беспокоимся о неоднозначности при "
"использовании find-if,\n"
"мы будем использовать member-if, который вместо простого возврата элемента, "
"удовлетворяющего\n"
"выражению test, возвращает весь (остаток списка) cdr, который начинается с "
"искомого элемента:"

#: texi/node-14.texi:387
msgid ""
"@example\n"
"> (member-if #'null '(2 nil 6))\n"
"(NIL 6)\n"
"@end example"
msgstr ""

#: texi/node-14.texi:392
msgid ""
"Since the advent of multiple return values, there has been another solution "
"to\n"
"this problem: use one value for data and a second to indicate success or "
"failure.\n"
"The built-in gethash works this way. It always returns two values, the "
"second\n"
"indicating whether anything was found:"
msgstr ""
"С момента появления возврата множественных значений, было принято другое "
"решение\n"
"этой проблемы: использовать одно значение для данных и второе для указания "
"на успех\n"
"или неудачу поиска. Таким образом работает встроенный gethash. Он всегда "
"возвращает\n"
"два значения, второе указывает, было ли что найдено, или нет:"

#: texi/node-14.texi:402
msgid ""
"@example\n"
"> (setf edible                                     (make-hash-table)\n"
"              (gethash 'olive-oil edible) t\n"
"              (gethash 'motor-oil edible) nil)\n"
"NIL\n"
"> (gethash 'motor-oil edible)\n"
"NIL\n"
"T\n"
"@end example"
msgstr ""
"@example\n"
"> (setf edible (make-hash-table)\n"
"        (gethash 'olive-oil edible) t\n"
"        (gethash 'motor-oil edible) nil)\n"
"NIL\n"
"> (gethash 'motor-oil edible)\n"
"NIL\n"
"T\n"
"@end example"

#: texi/node-14.texi:405
msgid ""
"So if you want to detect all three possible cases, you can use an idiom like "
"the\n"
"following:"
msgstr ""
"Так что, если вам необходимо различать все три возможных случая, вы можете "
"использовать\n"
"идиому, такую как следующее выражение:"

#: texi/node-14.texi:413
msgid ""
"@lisp\n"
"(defun edible? (x)\n"
"     (multiple-value-bind (val found?) (gethash x edible)\n"
"        (if found?\n"
"              (if val 'yes 'no)\n"
"              'maybe)))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:416
msgid ""
"@noindent\n"
"thereby distinguishing falsity from failure:"
msgstr ""
"@noindent\n"
"тем самым отличая ложь от неудачи:"

#: texi/node-14.texi:421
msgid ""
"@example\n"
"> (mapcar #'edible? '(motor-oil olive-oil iguana))\n"
"(NO YES MAYBE)\n"
"@end example"
msgstr ""

#: texi/node-14.texi:426
msgid ""
"Common Lisp supports yet a third way of indicating failure: to have the\n"
"access function take as an argument a special object, presumably a gensym, "
"to\n"
"be returned in case of failure. This approach is used with get, which takes "
"an\n"
"optional argument saying what to return if the specified property isn't "
"found:"
msgstr ""
"Common Lisp поддерживает еще один способ обозначить неудачу: Функция "
"доступа\n"
"принимает как аргумент специальный объект, предположительно сгенерированный\n"
"gensym, который возвращается в случае неудачи. Этот подход используется с "
"get, \n"
"который получает необязательный аргумент, указывающий, что вернуть, если \n"
"указанное свойство не найдено:"

#: texi/node-14.texi:431
msgid ""
"@example\n"
"> (get 'life 'meaning (gensym))\n"
"#:G618\n"
"@end example"
msgstr ""

#: texi/node-14.texi:439
msgid ""
"Where multiple return values are possible, the approach used by gethash\n"
"is the cleanest. We don't want to have to pass additional arguments to "
"every\n"
"access function, as we do with get. And between the other two alternatives, "
"using\n"
"multiple values is the more general; find-if could be written to return two "
"values,\n"
"but gethash could not, without consing, be written to return disambiguating "
"list\n"
"structure. Thus in writing new functions for lookup, or for other tasks "
"where\n"
"failure is possible, it will usually be better to follow the model of "
"gethash."
msgstr ""
"Подход, где возможен возврат множественного значения, используемый gethash,\n"
"является самым ясным. Нам не надо передавать дополнительные аргументы "
"каждой\n"
"функции доступа, как мы делаем с  get. И между двумя другими "
"альтернативами,\n"
"использование множественных значений является более общим; find-if может "
"быть\n"
"написан, чтобы возвращать два значения, но gethash так написать нельзя, без\n"
"выполнения создания списка(consing), чтобы вернуть, устраняющую "
"неоднозначность,\n"
"списковую структуру. Таким образом, при написании новых функций для поиска,\n"
"или других задач, где возможна неудача, обычно лучше следовать модели "
"поведения\n"
"используемой в gethash."

#: texi/node-14.texi:445
msgid ""
"The idiom found in edible? is just the sort of bookkeeping which is well\n"
"hidden by a macro. For access functions like gethash we will want a new "
"version\n"
"of aif which, instead of binding and testing the same value, binds the first "
"but also\n"
"tests the second. The new version of aif, called aif2, is shown in Figure "
"14-3.\n"
"Using it we could write edible? as:"
msgstr ""
"Идиома, которую можно найти в edible? это просто разновидность рутинных "
"операций, которые\n"
"хорошо скрыть макросом. Для функций доступа таких как gethash нам нужна "
"новая версия условного\n"
"оператора aif, которая вместо связывания и проверки того же значения, "
"возвращаемого\n"
"функцией доступа, связывает первый возвращенный элемент(val), но также "
"проверяет\n"
"второе значение. Новая версия aif, называемая aif2, показана на рисунке "
"14-3.\n"
"Используя её мы могли бы написать edible? как:"

#: texi/node-14.texi:452
msgid ""
"@lisp\n"
"(defun edible? (x)\n"
"  (aif2 (gethash x edible)\n"
"           (if it 'yes 'no)\n"
"           'maybe))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:457
msgid ""
"Figure 14-3 also contains similarly altered versions of awhen, awhile, and\n"
"acond. For an example of the use of acond2, see the definition of match on\n"
"page 239. By using this macro we are able to express in the form of a cond "
"a\n"
"function that would otherwise be much longer and less symmetrical."
msgstr ""
"Рисунок 14-3 также содержит аналогично измененные версии awhen, awhile, и\n"
"acond. Для примера использования acond2, см. определение соответствующее\n"
"стр. 239. Используя этот макрос мы можем выразить cond в виде функции,\n"
"которая в противном случае была бы намного длиннее и менее симетричной."

#: texi/node-14.texi:466
msgid ""
"The built-in read indicates failure in the same way as get. It takes "
"optional\n"
"arguments saying whether or not to generate an error in case of eof, and if "
"not,\n"
"what value to return. Figure 14-4 contains an alternative version of read "
"which\n"
"uses a second return value to indicate failure: read2 returns two values, "
"the input\n"
"expression and a flag which is nil upon eof. It calls read with a gensym to\n"
"be returned in case of eof, but to save the trouble of building the gensym "
"each\n"
"time read2 is called, the function is defined as a closure with a private "
"copy of a\n"
"gensym made at compile time."
msgstr ""
"Встроенный read указывает на неудачу так же как get. Ему требуется "
"необязательный\n"
"аргумент, говорящий, следует ли генерировать ошибку в случае eof, и если "
"нет,\n"
"какаое значени вернуть. Рисунок 14-4 содержит альтернативную версию read, "
"которая\n"
"использует второе возвращаемое значение для сообщения о неудаче: read2 "
"возвращает\n"
"два значения, входное выражение и флак, который равен nil при eof. Он "
"вызывает read\n"
"с символом сгенерированным gensym, который должен быть возвращен в случае "
"eof, но\n"
"чтобы избавитсья от хлопот по построению gensym для каждого вызова  read2, "
"функция\n"
"определяется как замыкание со скрытой копией символа из gensym "
"сгенерированного\n"
"во время компиляции."

#: texi/node-14.texi:470
msgid ""
"Figure 14-4 also contains a convenient macro to iterate over the expressions "
"in\n"
"a file, written using awhile2 and read2. Using do-file we could, for "
"example,\n"
"write a version of load as:"
msgstr ""
"Рисунок 14-4 также содержит удобный макрос для перебора выражений в файле, "
"написанный\n"
"с использованием awhile2 и read2. Используя do-file мы могли бы, например, "
"написать\n"
"версию load как:"

#: texi/node-14.texi:474
msgid ""
"@lisp\n"
"(defun our-load (filename)\n"
"  (do-file filename (eval it)))"
msgstr ""
"@lisp\n"
"(defun our-load (filename)\n"
"  (do-file filename (eval it)))\n"
"@end lisp"

#: texi/node-14.texi:479
msgid ""
"      (defmacro aif2 (test &optional then else)\n"
"            (let ((win (gensym)))\n"
"               `(multiple-value-bind (it ,win) ,test\n"
"                   (if (or it ,win) ,then ,else))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"      (defmacro aif2 (test &optional then else)\n"
"            (let ((win (gensym)))\n"
"               `(multiple-value-bind (it ,win) ,test\n"
"                   (if (or it ,win) ,then ,else))))"

#: texi/node-14.texi:483
msgid ""
"      (defmacro awhen2 (test &body body)\n"
"            `(aif2 ,test\n"
"                        (progn ,@@body)))"
msgstr ""
"      (defmacro awhen2 (test &body body)\n"
"            `(aif2 ,test\n"
"                   (progn ,@@body)))"

#: texi/node-14.texi:491
msgid ""
"      (defmacro awhile2 (test &body body)\n"
"            (let ((flag (gensym)))\n"
"               `(let ((,flag t))\n"
"                   (while ,flag\n"
"                        (aif2 ,test\n"
"                              (progn ,@@body)\n"
"                              (setq ,flag nil))))))"
msgstr ""

#: texi/node-14.texi:503
msgid ""
"      (defmacro acond2 (&rest clauses)\n"
"            (if (null clauses)\n"
"                 nil\n"
"                 (let ((cl1 (car clauses))\n"
"                          (val (gensym))\n"
"                          (win (gensym)))\n"
"                    `(multiple-value-bind (,val ,win) ,(car cl1)\n"
"                         (if (or ,val ,win)\n"
"                              (let ((it ,val)) ,@@(cdr cl1))\n"
"                              (acond2 ,@@(cdr clauses)))))))\n"
"@end lisp"
msgstr ""
"      (defmacro acond2 (&rest clauses)\n"
"            (if (null clauses)\n"
"                 nil\n"
"                 (let ((cl1 (car clauses))\n"
"                       (val (gensym))\n"
"                       (win (gensym)))\n"
"                    `(multiple-value-bind (,val ,win) ,(car cl1)\n"
"                         (if (or ,val ,win)\n"
"                              (let ((it ,val)) ,@@(cdr cl1))\n"
"                              (acond2 ,@@(cdr clauses)))))))\n"
"@end lisp"

#: texi/node-14.texi:505
msgid "                          Figure 14-3: Multiple-value anaphoric macros."
msgstr ""
"                          Рисунок 14-3: Анафорические макросы использующие "
"множественные значения.\n"
"@end cartouche"

#: texi/node-14.texi:510
msgid ""
"@node 14-3 Referential Transparency,  , 14-2 Failure, 14 Anaphoric Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 14-3 Referential Transparency\n"
"@cindex 14-3 Referential Transparency"
msgstr ""
"@node 14-3 Referential Transparency,  , 14-2 Failure, 14 Anaphoric Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 14-3 Ссылочная Прозрачность\n"
"@cindex 14-3 Referential Transparency"

#: texi/node-14.texi:513
msgid ""
"Anaphoric macros are sometimes said to violate referential transparency, "
"which\n"
"Gelernter and Jagannathan define as follows:"
msgstr ""
"Иногда говорят, что анафорические макросы нарушают ссылочную прозрачность, "
"которую\n"
"Gelernter и Jagannathan определяют следующим образом:"

#: texi/node-14.texi:520
msgid ""
"@quotation\n"
"A language is referentially transparent if (a) every subexpression\n"
"can be replaced by any other that's equal to it in value and (b) all\n"
"occurrences of an expression within a given context yield the same\n"
"value.\n"
"@end quotation"
msgstr ""
"@quotation\n"
"Язык ссылочно прозрачен, если (a) какждое подвыражение может быть\n"
"заменено любым другим, равным по ему по значению и (b) все вхождения\n"
"выражения в данном контексте приводят к одному и тому же значению.\n"
"@end quotation"

#: texi/node-14.texi:523
msgid ""
"Note that this standard applies to languages,not to programs. No language "
"with\n"
"assignment is referentially transparent. The first and the last x in this "
"expression"
msgstr ""
"Обратите внимание, что стандарт применяется к языкам, а не к программам. Нет "
"языков с\n"
"присваиванием являющихся ссылочно прозрачными. Первый и последний x в этом "
"выражении"

#: texi/node-14.texi:529
msgid ""
"@lisp\n"
" (let ((g (gensym)))\n"
"    (defun read2 (&optional (str *standard-input*))\n"
"        (let ((val (read str nil g)))\n"
"          (unless (equal val g) (values val t)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (let ((g (gensym)))\n"
"    (defun read2 (&optional (str *standard-input*))\n"
"        (let ((val (read str nil g)))\n"
"          (unless (equal val g) (values val t)))))"

#: texi/node-14.texi:536
msgid ""
" (defmacro do-file (filename &body body)\n"
"    (let ((str (gensym)))\n"
"        `(with-open-file (,str ,filename)\n"
"               (awhile2 (read2 ,str)\n"
"                ,@@body))))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:538
msgid "                              Figure 14-4: File utilities."
msgstr ""
"                              Рисунок 14-4: Файловые утилиты.\n"
"@end cartouche"

#: texi/node-14.texi:544
msgid ""
"@lisp\n"
"(list x(setq x (not x))\n"
"         x)\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(list x\n"
"      (setq x (not x))\n"
"      x)\n"
"@end lisp"

#: texi/node-14.texi:548
msgid ""
"@noindent\n"
"yield different values, because a setq intervenes. Admittedly, this is ugly "
"code.\n"
"The fact that it is even possible means that Lisp is not referentially "
"transparent."
msgstr ""
"@noindent\n"
"дают разные значения, поскольку вмешивается setq. Правда, это ужасный код.\n"
"Тот факт, что это возможно, означает что Lisp не является ссылочно "
"прозрачным."

#: texi/node-14.texi:550
msgid ""
"Norvig mentions that it would be convenient to redefine if "
"as:                           "
msgstr ""
"Norvig(Норвиг) отмечает, что было бы удобно переопределить if "
"как:                           "

#: texi/node-14.texi:556
msgid ""
"@lisp\n"
"(defmacro if (test then &optional else)\n"
"  `(let ((that ,test))\n"
"        (if that ,then ,else)))\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:559
msgid ""
"@noindent\n"
"but rejects this macro on the grounds that it violates referential "
"transparency."
msgstr ""
"@noindent\n"
"но отклоняет этот макрос на том основании, что он нарушает ссылочную "
"прозрачность."

#: texi/node-14.texi:564
msgid ""
"However, the problem here comes from redefining built-in operators, not "
"from\n"
"using anaphora. Clause (b) of the definition above requires that an "
"expression\n"
"always return the same value \"within a given context.\" It is no problem "
"if, within\n"
"this let expression,"
msgstr ""
"Однако проблема здесь заключается в переопределении встроенных операторов, а "
"не в \n"
"использовании анафоры. Предложение (b) приведенного выше определения "
"требует, чтобы\n"
"выражение всегда возвращало одно и тоже значение \"в данном контексте.\" Это "
"не проблема\n"
"if, внутри этого let выражения,"

#: texi/node-14.texi:569
msgid ""
"@lisp\n"
"(let ((that 'which))\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: texi/node-14.texi:573
msgid ""
"@noindent\n"
"the symbol that denotes a new variable, because let is advertised to create "
"a\n"
"new context."
msgstr ""
"@noindent\n"
"символ that обозначает новыю переменную, потому что let объявлено чтобы "
"создать\n"
"новый контекст."

#: texi/node-14.texi:579
msgid ""
"The trouble with the macro above is that it redefines if, which is not "
"supposed\n"
"to create a new context. This problem goes away if we give anaphoric macros\n"
"distinct names. (As of CLTL2, it is illegal to redefine if anyway.) As long "
"as it is\n"
"part of the definition of aif that it establishes a new context in which it "
"isanew\n"
"variable, such a macro does not violate referential transparency."
msgstr ""
"Проблема с макросом в том, что он переопределяет if, который не "
"предполагает\n"
"создание нового контекста. Эта проблема исчезнет, если мы дадим "
"анафорическим макросам имена\n"
"отличающиеся от стандартных. (Начиная с CLTL2, это переопределение так или "
"иначе является незаконным.)\n"
"На протяжении всей части определения aif устанавливается новый контекст в "
"котором it \n"
"является новой переменной, такой макрос не нарушает ссылочную прозрачность."

#: texi/node-14.texi:586
msgid ""
"Now, aif does violate another convention, which has nothing to do with\n"
"referential transparency: that newly established variables somehow be "
"indicated\n"
"in the source code. The let expression above clearly indicates that that "
"will\n"
"refer to a new variable. It could be argued that the binding of it within an "
"aif is\n"
"not so clear. However, this is not a very strong argument: aif only creates "
"one\n"
"variable, and the creation of that variable is the only reason to use it."
msgstr ""
"Теперь, aif действительно нарушает другое соглашение, которое не имеет "
"ничего общего\n"
"со ссылочной прозрачностью: всегда указывать вновь устанавливаемые "
"переменные в\n"
"исходном коде. Выражение let выше ясно указывает на то, что that хочет "
"сослаться на\n"
"новую переменную. Можно утверждать, что привязка it в aif не достаточно "
"ясна(видна).\n"
"Однако это не очень сильный аргумент: aif создает только одну переменную, и "
"создание\n"
"этой переменной является единственной причиной его использования."

#: texi/node-14.texi:594
msgid ""
"Common Lisp itself does not treat this convention as inviolable. The "
"binding\n"
"of the CLOS function call-next-method depends on the context in just the "
"same\n"
"way that the binding of the symbol it does within the body of an aif.(Fora\n"
"suggestion of how call-next-method would be implemented, see the macro\n"
"defmeth on page 358.) In any case, such conventions are only supposed to be\n"
"a means to an end: programs which are easy to read. And anaphora do make\n"
"programs easier to read, just as they make English easier to read."
msgstr ""
"Common Lisp и сам не рассматривает это соглашение как неприкосновенное. "
"Привязка\n"
"функции CLOS call-next-method зависит от контекста точно таким же образом, "
"как\n"
"привязка символа it делается в теле aif. (Для намека о том, как будет "
"реализован\n"
"call-next-method, смотрите макрос defmeth на странице 358.) В любом случае, "
"такие\n"
"соглашения введены только для достижения цели: облегчения чтения программ. И "
"анафоры\n"
"делают программы более легко читаемыми, также как они облегчают чтение в "
"Английском\n"
"языке."
