#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-21.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 12:23+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-21.texi:5
msgid ""
"@node 21 Multiple Processes, 22 Nondeterminism, 20 Continuations, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 21 Multiple Processes\n"
"@cindex 21 Multiple Processes"
msgstr ""
"@node 21 Multiple Processes, 22 Nondeterminism, 20 Continuations, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 21 Множество Процессов(многопроцессность/Многозадачность)\n"
"@cindex 21 Multiple Processes"

#: texi/node-21.texi:13
msgid ""
"The previous chapter showed how continuations allow a running program to "
"get\n"
"hold of its own state, and store it away to be restarted later. This chapter "
"deals\n"
"with a model of computation in which a computer runs not one single "
"program,\n"
"but a collection of independent processes. The concept of a process "
"corresponds\n"
"closely with our concept of the state of a program. By writing an additional "
"layer\n"
"of macros on top of those in the previous chapter, we can embed "
"multiprocessing\n"
"in Common Lisp programs."
msgstr ""
"В предыдущей главе показано, как продолжения позволяют работающей программе "
"получить\n"
"свое собственное состояние и сохранить его для последующего перезапуска. В "
"этой главе\n"
"рассматривается модель вычислений, в которой компьютер запускает не одну "
"отдельную\n"
"программу, а набор независимых процессов. Концепция процесса(задачи) тесно "
"соответствует\n"
"с нашей конецепцией состояния программы. Написав дополнительный слой "
"макросов поверх тех,\n"
"что были описаны в предыдущей главе, мы можем встроить многозадачность в "
"программы \n"
"Common Lisp."

#: texi/node-21.texi:19
msgid ""
"@menu\n"
"* 21-1 The Process Abstraction::  \n"
"* 21-2 Implementation::         \n"
"* 21-3 The Less-than-Rapid Prototype::  \n"
"@end menu"
msgstr ""

#: texi/node-21.texi:24
msgid ""
"@node 21-1 The Process Abstraction, 21-2 Implementation, 21 Multiple "
"Processes, 21 Multiple Processes\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 21-1 The Process Abstraction\n"
"@cindex 21-1 The Process Abstraction"
msgstr ""
"@node 21-1 The Process Abstraction, 21-2 Implementation, 21 Multiple "
"Processes, 21 Multiple Processes\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 21-1 Абстракция Процесса/Задачи\n"
"@cindex 21-1 The Process Abstraction"

#: texi/node-21.texi:34
msgid ""
"Multiple processes are a convenient way of expressing programs which must "
"do\n"
"several things at once. A traditional processor executes one instruction at "
"a time.\n"
"To say that multiple processes do more than one thing at once is not to say "
"that\n"
"they somehow overcome this hardware limitation: what it means is that they "
"allow\n"
"us to think at a new level of abstraction, in which we don't have to specify "
"exactly\n"
"what the computer is doing at any given time. Just as virtual memory allows "
"us to\n"
"act as though the computer had more memory than it actually does, the notion "
"of\n"
"a process allows us to act as if the computer could run more than one "
"program at\n"
"a time."
msgstr ""
"Много Процессность/Задачность - это удобный способ выражения программ, "
"которые должны\n"
"выполнять несколько действий одновременно. Традиционный процессор выполняет "
"одну\n"
"инструкцию за раз. Сказать что несколько процессов выполняются одновременно, "
"это не\n"
"значит, что они каким-то образом преодолевают это аппаратное ограничение: "
"это означает,\n"
"что они позволяют нам мыслить на уровне абстракции, на котором нам не нужно "
"точно \n"
"указывать, что делает компьютер в некоторый момент времени. Точно также как "
"виртуальная\n"
"память позволяет нам действовать так, как если бы у компьютера было больше "
"памяти, чем\n"
"на самом деле, понятие процесса/задачи позволяет нам действовать так, как "
"если бы\n"
"компьютер мог запускать более одной программы одновременно."

#: texi/node-21.texi:38
msgid ""
"The study of processes is traditionally in the domain of operating systems. "
"But\n"
"the usefulness of processes as an abstraction is not limited to operating "
"systems.\n"
"They are equally useful in other real-time applications, and in simulations."
msgstr ""
"Изучение процессов традиционно относиться к области операционных систем. Но "
"полезность\n"
"процессов как абстракции не ограничивается операционными системами. Они "
"одинаково\n"
"полезны и в других приложениях реального времени, и в симуляциях."

#: texi/node-21.texi:48
msgid ""
"Much of the work done on multiple processes has been devoted to avoiding\n"
"certain types of problems. Deadlock is one classic problem with multiple "
"pro-\n"
"cesses: two processes both stand waiting for the other to do something, like "
"two\n"
"people who each refuse to cross a threshold before the other. Another "
"problem is\n"
"the query which catches the system in an inconsistent state-say, a balance "
"inquiry\n"
"which arrives while the system is transferring funds from one account to "
"another.\n"
"This chapter deals only with the process abstraction itself; the code "
"presented here\n"
"could be used to test algorithms for preventing deadlock or inconsistent "
"states, but\n"
"it does not itself provide any protection against these problems."
msgstr ""
"Большая часть работы, проделываемой по управлению несколькими процессами, "
"была\n"
"посвящена предотвращению определенных типов проблем. Тупик(Deadlock) - это "
"одна\n"
"классическая проблема для нескольких процессов: два процесса ждут, пока "
"другой\n"
"что-то сделает, подобно двум людям, каждый из которых отказывается "
"переступить\n"
"порог прежде чем другой это сделает. Другая проблема - это запрос, который "
"ловит\n"
"систему в несогласованном состоянии, скажем, запрос баланса, который "
"поступает,\n"
"когда система переводит средства с одного счета на другой. В этой главе "
"рассматривается\n"
"только сама абстракция процесса/задачи; код, представленный здесь, может "
"быть использован\n"
"для тестирования алгоритмов предотвращаения тупиковых или несогласованных "
"состояний, но\n"
"сам по себе он не обеспечивает никакой защиты от этих проблем."

#: texi/node-21.texi:55
msgid ""
"The implementation in this chapter follows a rule implicit in all the "
"programs\n"
"in this book: disturb Lisp as little as possible. In spirit, a program ought "
"to be\n"
"as much as possible like a modification of the language, rather than a "
"separate\n"
"application written in it. Making programs harmonize with Lisp makes them\n"
"more robust, like a machine whose parts fit together well. It also saves "
"effort;\n"
"sometimes you can make Lisp do a surprising amount of your work for you."
msgstr ""
"Реализация в этой главе следует правилу, неявному во всех программах этой "
"книги:\n"
"как можно меньше нарушать Lisp. По сути, программа должна быть как можно "
"больше\n"
"похожа на модификацию языка, а не на отдельное приложение написанное на "
"нем.\n"
"Создание программ согласованных с Lisp делает их более надежными, как "
"машины,\n"
"чьи части хорошо сочетаются друг с другом. Это также экономит усилия;\n"
"иногда вы можете заставить Lisp сделать для вас удивительное количество "
"работы."

#: texi/node-21.texi:59
msgid ""
"The aim of this chapter is to make a language which supports multiple pro-\n"
"cesses. Our strategy will be to turn Lisp into such a language, by adding a "
"few\n"
"new operators. The basic elements of our language will be as follows:"
msgstr ""
"Цель этой главы - создать язык, который поддерживает несколько процессов. \n"
"Наша стратегия состоит в том, чтобы превратить Lisp в такой язык, добавив\n"
"несколько новых операторов. Основные элементы нашего языка будут следующими:"

#: texi/node-21.texi:62
msgid ""
"Functions will be defined with the =defun or =lambda macros from the\n"
"previous chapter."
msgstr ""
"Функции будут определяться с помощью макросов =defun или =lambda из \n"
"предыдущей главы."

#: texi/node-21.texi:67
msgid ""
"Processes will be instantiated from function calls. There is no limit on "
"the\n"
"number of active processes, or the number of processes instantiated from\n"
"any one function. Each process will have a priority, initially given as an\n"
"argument when it is created."
msgstr ""
"Процессы будут создадваться из вызовов функций. Нет ограничений на "
"количество\n"
"активных процессов или количество процессов, созданных из какой-либо одной \n"
"функции. Каждый процесс будет иметь приоритет, изначально заданный в "
"качестве\n"
"аргумента при его создании."

#: texi/node-21.texi:75
msgid ""
"Wait expressions may occur within functions. A wait expression will take\n"
"a variable, a test expression, and a body of code. If a process encounters\n"
"a wait, the process will be suspended at that point until the test "
"expression\n"
"returns true. Once the process restarts, the body of code will be "
"evaluated,\n"
"with the variable bound to the value of the test expression. Test "
"expressions\n"
"should not ordinarily have side-effects, because there are no guarantees\n"
"about when, or how often, they will be evaluated."
msgstr ""
"Выражения ожидания(Wait) могут возникать внутри функций. Выражение "
"ожидания \n"
"будет принимать переменную, тестовое выражение и тело кода. Если процесс\n"
"встречает команду ожидать(wait), процесс будет приостановлен в этой точке,\n"
"до тех пор пока тестовое выражение не вернет истину. Как только процесс\n"
"перезапустится, будет вычислено тело кода с переменной, связанной со "
"значением\n"
"тестового выражения. Тестовые выражения, обычно, не должны иметь побочных \n"
"эффектов, потому что нет никаких гарантий относительно того, когда и как "
"часто\n"
"они будут вычисляться."

#: texi/node-21.texi:78
msgid ""
"Scheduling will be done by priority. Of all the processes able to restart, "
"the\n"
"system will run the one with the highest priority."
msgstr ""
"Планирование(Scheduling) будет сделано по приоритету. Из всех процессов, "
"которые \n"
"могут быть перезапущены, система будет запускать процесс с наивысшим "
"приоритетом."

#: texi/node-21.texi:81
msgid ""
"The default process will run if no other process can. It is a read-eval-"
"print\n"
"loop."
msgstr ""
"Процесс по умолчанию будет запущен, если никакой другой процесс запустить "
"нельзя.\n"
"Это будет процесс REPL (read-eval-print loop)."

#: texi/node-21.texi:85
msgid ""
"Creation and deletion of most objects will be possible on the fly. From "
"run-\n"
"ning processes it will be possible to define new functions, and to "
"instantiate\n"
"and kill processes."
msgstr ""
"Создание и удаление большинства объектов будет возможно на лету. Из "
"запущенных\n"
"процессов можно будет определять новые функции, а также создавать и "
"уничтожать\n"
"процессы."

#: texi/node-21.texi:87
msgid "@lisp"
msgstr ""
"@cartouche\n"
"@lisp"

#: texi/node-21.texi:89
msgid " (defstruct proc pri state wait)"
msgstr ""

#: texi/node-21.texi:91
msgid " (proclaim '(special *procs* *proc*))"
msgstr ""

#: texi/node-21.texi:93
msgid " (defvar *halt* (gensym))"
msgstr ""

#: texi/node-21.texi:99
msgid ""
" (defvar *default-proc*\n"
"              (make-proc :state #'(lambda (x)\n"
"                                           (format t \"~%>> \")\n"
"                                           (princ (eval (read)))\n"
"                                           (pick-process))))"
msgstr ""

#: texi/node-21.texi:108
msgid ""
" (defmacro fork (expr pri)\n"
"    `(prog1 ',expr\n"
"               (push (make-proc\n"
"                           :state #'(lambda (,(gensym))\n"
"                                          ,expr\n"
"                                          (pick-process))\n"
"                           :pri      ,pri)\n"
"                        *procs*)))"
msgstr ""

#: texi/node-21.texi:115
msgid ""
" (defmacro program (name args &body body)\n"
"    `(=defun ,name ,args\n"
"        (setq *procs* nil)\n"
"        ,@@body\n"
"        (catch *halt* (loop (pick-process)))))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:117
msgid "                  Figure 21-1: Process structure and instantiation."
msgstr ""
"                  Рисунок 21-1: Структура процесса и его создание.\n"
"@end cartouche"

#: texi/node-21.texi:123
msgid ""
"Continuations make it possible to store the state of a Lisp program. Being "
"able to\n"
"store several states at once is not very far from having multiple processes. "
"Starting\n"
"with the macros defined in the previous chapter, we need less than 60 lines "
"of code\n"
"to implement multiple processes."
msgstr ""
"Продолжения позволяют сохранять состояние программы Lisp. Возможность "
"хранить\n"
"несколько состояний одновременно не так уж далеко стоит от реализации \n"
"многопроцессности. Начиная с макросов, определенных в предыдущей главе, нам "
"нужно\n"
"менее  60 строк кода для реализации многопроцессности."

#: texi/node-21.texi:128
msgid ""
"@node 21-2 Implementation, 21-3 The Less-than-Rapid Prototype, 21-1 The "
"Process Abstraction, 21 Multiple Processes\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 21-2 Implementation\n"
"@cindex 21-2 Implementation"
msgstr ""
"@node 21-2 Implementation, 21-3 The Less-than-Rapid Prototype, 21-1 The "
"Process Abstraction, 21 Multiple Processes\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 21-2 Реализация\n"
"@cindex 21-2 Implementation"

#: texi/node-21.texi:133
msgid ""
"Figures 21-1 and 21-2 contain all the code needed to support multiple "
"processes.\n"
"Figure 21-1 contains code for the basic data structures, the default "
"process, initial-\n"
"ization, and instantiation of processes. Processes, or procs, have the "
"following\n"
"structure:"
msgstr ""
"Рисунки 21-1 и 21-2 содержат весь код, необходимый для поддержки "
"многопроцессности.\n"
"Рисунок 21-1 содержит код для основных структур данных, процесса по "
"умолчанию, \n"
"инициализации и создания процессов. Процессы или procs, имеют следующую "
"структуру:"

#: texi/node-21.texi:135
msgid ""
"    pri is the priority of the process, which should be a positive number."
msgstr ""
"    pri является приоритетом процесса, который должен быть положительным "
"числом."

#: texi/node-21.texi:138
msgid ""
"    state is a continuation representing the state of a suspended process. A "
"process\n"
"         is restarted by funcalling its state."
msgstr ""
"    state является продолжением, представляющим состояние приостановленного "
"процесса.\n"
"        Процесс перезапускается путем вызова как функции(funcalling) этого "
"состояния."

#: texi/node-21.texi:142
msgid ""
"    wait is usually a function which must return true in order for the "
"process to be\n"
"        restarted, but initially the wait of a newly created process is nil. "
"A process\n"
"         with a null wait can always be restarted."
msgstr ""
"    wait - это обычно функция, которая должна возвращать истину для "
"перезапуска процесса,\n"
"        но вначале  wait для вновь созданного процесса равен nil. Процесс с "
"wait равным\n"
"        nil всегда можно перезапустить."

#: texi/node-21.texi:146
msgid ""
"The program uses three global variables: *procs*, the list of currently "
"sus-\n"
"pended processes; *proc*, the process now running; and *default-proc*, the\n"
"default process."
msgstr ""
"Программа использует три глобальные переменные: *procs*, список "
"приостановленных \n"
"процессов; *proc*, текущий запущеный процесс; и *default-proc*, процесс\n"
"по умолчанию."

#: texi/node-21.texi:152
msgid ""
"The default process runs only when no other process can. It simulates the\n"
"Lisp toplevel. Within this loop, the user can halt the program, or type "
"expressions\n"
"which enable suspended processes to restart. Notice that the default process "
"calls\n"
"eval explicitly. This is one of the few situations in which it is legitimate "
"to do so.\n"
"Generally it is not a good idea to call eval at runtime, for two reasons:"
msgstr ""
"Процесс по умолчанию выполняется только тогда, когда нет другого готового к "
"выполнению\n"
"процесса. Он имитирует верхний уровень Lisp. В этом цикле, пользователь "
"может остановить\n"
"программу, или ввести выражение, позволяющее перезапустить приостановленные "
"процессы.\n"
"Обратите внимание, что процесс по умолчанию явно вызывает eval. Эта одна из "
"немногих\n"
"ситуаций, в которых это допустимо. Обычно не рекомендуется вызывать eval во "
"время выполнения\n"
"по двум причинам:"

#: texi/node-21.texi:158
msgid ""
"@enumerate\n"
"@item\n"
"It's inefficient: eval is handed a raw list, and either has to compile it on "
"the\n"
"spot, or evaluate it in an interpreter. Either way is slower than compiling\n"
"the code beforehand, and just calling it."
msgstr ""
"@enumerate\n"
"@item\n"
"Это не эффективно: eval работает с необработанным(сырым) списком, и он "
"должен\n"
"либо скомпилировать его на месте, либо вычислить в интерпретаторе. В любом\n"
"случае  это медленнее, чем предварительно скомпилировать код и потом просто\n"
"вызвать его."

#: texi/node-21.texi:164
msgid ""
"@item\n"
"It's less powerful, because the expression is evaluated with no lexical "
"con-\n"
"text. Among other things, this means that you can't refer to ordinary\n"
"variables visible outside the expression being evaluated.\n"
"@end enumerate"
msgstr ""
"@item\n"
"Это менее мощно, потому что выражение вычисляется без лексического "
"контекста.\n"
"Среди прочего, это означает, что вы не можете ссылаться на обычные "
"переменные,\n"
"видимые снаружи вычисляемого выражения.\n"
"@end enumerate"

#: texi/node-21.texi:168
msgid ""
"Usually, calling eval explicitly is like buying something in an airport gift-"
"shop.\n"
"Having waited till the last moment, you have to pay high prices for a "
"limited\n"
"selection of second-rate goods."
msgstr ""
"Обычно, вызывать eval это все равно что покупать что-то в сувенирном "
"магазине в\n"
"аэропорту. Дождавшись последнего момента, вы должны заплатить высокую цену "
"за\n"
"ограниченный выбор второсортных товаров."

#: texi/node-21.texi:175
msgid ""
"Cases like this are rare instances when neither of the two preceding "
"arguments\n"
"applies. We couldn't possibly have compiled the expressions beforehand. We "
"are\n"
"just now reading them; there is no beforehand. Likewise, the expression "
"can't\n"
"refer to surrounding lexical variables, because expressions typed at the "
"toplevel\n"
"are in the null lexical environment. In fact, the definition of this "
"function simply\n"
"reflects its English description: it reads and evaluates what the user types."
msgstr ""
"Случаи подобные этому, являются редкими случаями, когда ни один из двух "
"предыдущих\n"
"аргументов не применим. Мы не могли составить выражение заранее. Мы только "
"сейчас\n"
"читаем их; их ранее не было. Аналогично, выражение не может ссылаться на "
"окружающие\n"
"лексические переменные, потому что выражения, набранные на верхнем уровне, "
"находятся\n"
"в нулевой лексической среде. Фактически, определение этой функции отражает "
"ее\n"
"английское описание: она читает и вычисляет, то что вводит пользователь."

#: texi/node-21.texi:178
msgid ""
"The macro fork instantiates a process from a function call. Functions are\n"
"defined as usual with =defun:"
msgstr ""
"Макрос fork создает экземпляр процесса вызывая функцию. Функции\n"
"определяются обычно с помощью =defun:"

#: texi/node-21.texi:184
msgid ""
"@lisp\n"
"(=defun foo (x)\n"
"  (format t \"Foo was called with ~A.~%\" x)\n"
"  (=values (1+ x)))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:186
msgid "Now when we call fork with a function call and a priority number:"
msgstr "Теперь когда мы вызваем fork с вызовом функции и номером приоритета:"

#: texi/node-21.texi:190
msgid ""
"@lisp\n"
"(fork (foo 2) 25)\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:195
msgid ""
"@noindent\n"
"a new process is pushed onto *procs*. The new process has a priority of 25,"
"a\n"
"proc-wait of nil, since it hasn't been started yet, and a proc-state "
"consisting\n"
"of a call to foo with the argument 2."
msgstr ""
"@noindent\n"
"новый процесс помещается в *procs*. Новый процесс имеет приоритет равный 25, "
"а\n"
"процедура wait равна nil, поскольку она еще не была запущена, а процедура \n"
"state состоит из вызова foo с аргументом 2."

#: texi/node-21.texi:198
msgid ""
"The macro program allows us to create a group of processes and run them\n"
"together. The definition:"
msgstr ""
"Макрос program позволяет нам создать группу процессов и запустить их\n"
"вместе. Определение:"

#: texi/node-21.texi:204
msgid ""
"@lisp\n"
"(program two-foos (a b)\n"
"  (fork (foo a) 99)\n"
"  (fork (foo b) 99))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:212
msgid ""
"@noindent\n"
"macroexpands into the two fork expressions, sandwiched between code which\n"
"clears out the suspended processes, and other code which repeatedly chooses "
"a\n"
"process to run. Outside this loop, the macro establishes a tag to which "
"control can\n"
"be thrown to end the program. As a gensym, this tag will not conflict with "
"tags\n"
"established by user code. A group of processes defined as a program returns "
"no\n"
"particular value, and is only meant to be called from the toplevel."
msgstr ""
"@noindent\n"
"макрорасширяется в два выражени fork, зажатых между кодом который очищает \n"
"приостановленные процессы, и другим кодом, который повторясь выбирает "
"процесс\n"
"для запуска. Вне этого цикла, макрос устанавливает тег, в который можно "
"добавить\n"
"элемент управления для завершения программы. Как gensym, этот тег не будет\n"
"конфликтовать с тегами, установленными пользовательским кодом. Группа "
"процессов,\n"
"определенных как program, не возвращает никакого конкретного значения и "
"предназначена\n"
"только для вызоыва с верхнего уровня."

#: texi/node-21.texi:222
msgid ""
"After the processes are instantiated, the process scheduling code takes "
"over.\n"
"This code is shown in Figure 21-2. The function pick-process selects and "
"runs\n"
"the highest priority process which is able to restart. Selecting this "
"process is the\n"
"job of most-urgent-process. A suspended process is eligible to run if it "
"has\n"
"no wait function, or its wait function returns true. Among eligible "
"processes,\n"
"the one with the highest priority is chosen. The winning process and the "
"value\n"
"returned by its wait function (if there is one) are returned to pick-"
"process.\n"
"There will always be some winning process, because the default process "
"always\n"
"wants to run."
msgstr ""
"После того, как процессы созданы, код планирования процссов вступает в "
"управление\n"
"над ними. Этот код показан на Рисунке 21-2. Функция pick-process выбирает "
"и \n"
"запускает процесс с наивысшим приоритетом, который может быть перезапущен. "
"Выбор\n"
"этого процесса является задачей most-urgent-process. Приостановленный "
"процесс\n"
"может быть запущен, если у него нет функции ожидания, или его функция "
"ожидания\n"
"wait возвращает истину. Среди приемлимых процессов выбирается тот, который "
"имеет\n"
"наивысший приоритет. Выигравший процесс и значение возвращаемое его функцией "
"wait\n"
"(если она есть) возвращаются в pick-process. Всегда будет какой-нибудь "
"выигрышный\n"
"процесс, потому что процесс по умолчанию всегда хочет запуститься."

#: texi/node-21.texi:227
msgid ""
"The remainder of the code in Figure 21-2 defines the operators used to "
"switch\n"
"control between processes. The standard wait expression is wait, as used in "
"the\n"
"function pedestrian in Figure 21-3. In this example, the process waits "
"until\n"
"there is something in the list *open-doors*, then prints a message:"
msgstr ""
"Оставшаяся часть кода на рисунке 21-2 определяет операторы используемые для\n"
"переключения управления между процессами. Стандартное выражение wait, как "
"оно\n"
"используется в функции pedestrian на Рисунке 21-3. В этом примере, процесс\n"
"ждет, пока что-то не появиться в списке *open-doors*, а затем печатает\n"
"сообщение:"

#: texi/node-21.texi:235
msgid ""
"@example\n"
"> (ped)\n"
">> (push 'door2 *open-doors*)\n"
"Entering DOOR2\n"
">> (halt)\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-21.texi:241
msgid ""
"A wait is similar in spirit to an =bind (page 267), and carries the same\n"
"restriction that it must be the last thing to be evaluated. Anything we want "
"to\n"
"happen after the wait must be put in its body. Thus, if we want to have a "
"process\n"
"wait several times, the wait expressions must be nested. By asserting facts "
"aimed\n"
"at one another, processes can cooperate in reaching some goal, as in Figure "
"21-4."
msgstr ""
"Ожидание(wait) по духу аналогично =bind (стр 267), и имеет те же "
"ограничения, что\n"
"и последняя ее вычисление. Все, что мы хотим, чтобы произошло после  wait, "
"должно\n"
"быть помещено в ее тело. Таким образом, если мы хотим, чтобы процесс ожидал "
"несколько\n"
"раз, выражения ожидания должны быть вложенными. Утверждая факты "
"предназначенные друг\n"
"для друга, процессы могут сотрудничать в достижении некоторой цели, как "
"показано\n"
"на рисунке 21-4."

#: texi/node-21.texi:248
msgid ""
"@lisp\n"
" (defun pick-process ()\n"
"       (multiple-value-bind (p val) (most-urgent-process)\n"
"        (setq *proc* p\n"
"                  *procs* (delete p *procs*))\n"
"        (funcall (proc-state p) val)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun pick-process ()\n"
"       (multiple-value-bind (p val) (most-urgent-process)\n"
"        (setq *proc* p\n"
"                  *procs* (delete p *procs*))\n"
"        (funcall (proc-state p) val)))"

#: texi/node-21.texi:261
msgid ""
" (defun most-urgent-process ()\n"
"       (let ((proc1 *default-proc*) (max -1) (val1 t))\n"
"        (dolist (p *procs*)\n"
"          (let ((pri (proc-pri p)))\n"
"             (if (> pri max)\n"
"                   (let ((val (or (not (proc-wait p))\n"
"                                      (funcall (proc-wait p)))))\n"
"                     (when val\n"
"                       (setq proc1 p\n"
"                               max     pri\n"
"                               val1 val))))))\n"
"        (values proc1 val1)))"
msgstr ""

#: texi/node-21.texi:267
msgid ""
" (defun arbitrator (test cont)\n"
"       (setf (proc-state *proc*) cont\n"
"             (proc-wait *proc*) test)\n"
"       (push *proc* *procs*)\n"
"       (pick-process))"
msgstr ""

#: texi/node-21.texi:271
msgid ""
" (defmacro wait (parm test &body body)\n"
"       `(arbitrator #'(lambda () ,test)\n"
"                      #'(lambda (,parm) ,@@body)))"
msgstr ""

#: texi/node-21.texi:274
msgid ""
" (defmacro yield (&body body)\n"
"       `(arbitrator nil #'(lambda (,(gensym)) ,@@body)))"
msgstr ""

#: texi/node-21.texi:276
msgid " (defun setpri (n) (setf (proc-pri *proc*) n))"
msgstr ""

#: texi/node-21.texi:278
msgid " (defun halt (&optional val) (throw *halt* val))"
msgstr ""

#: texi/node-21.texi:284
msgid ""
" (defun kill (&optional obj &rest args)\n"
"       (if obj\n"
"          (setq *procs* (apply #'delete obj *procs* args))\n"
"          (pick-process)))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:286
msgid "                         Figure 21-2: Process scheduling."
msgstr ""
"                         Рисунок 21-2: Планирование Процессов.\n"
"@end cartouche"

#: texi/node-21.texi:292
msgid ""
"@lisp\n"
" (defvar *open-doors* nil)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *open-doors* nil)"

#: texi/node-21.texi:296
msgid ""
" (=defun pedestrian ()\n"
"      (wait d (car *open-doors*)\n"
"        (format t \"Entering ~A~%\" d)))"
msgstr ""

#: texi/node-21.texi:300
msgid ""
" (program ped ()\n"
"      (fork (pedestrian) 1))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:302
msgid "                      Figure 21-3: One process with one wait."
msgstr ""
"                      Рисунок 21-3: Один процесс с одним wait.\n"
"@end cartouche"

#: texi/node-21.texi:306
msgid ""
"Processes instantiated from visitor and host, if given the same door, will\n"
"exchange control via messages on a blackboard:"
msgstr ""
"Процессы, созданные из visitor(посетитель) и host(хоста), если им "
"представлена одна\n"
"и та же дверь(door), обменяются управлением через сообщения на "
"blackboard(черной доске):"

#: texi/node-21.texi:314
msgid ""
"@example\n"
"> (ballet)\n"
"Approach DOOR2. Open DOOR2. Enter DOOR2. Close DOOR2.\n"
"Approach DOOR1. Open DOOR1. Enter DOOR1. Close DOOR1.\n"
">>\n"
"@end example"
msgstr ""

#: texi/node-21.texi:320
msgid ""
"There is another, simpler type of wait expression: yield, whose only "
"purpose\n"
"is to give other higher-priority processes a chance to run. A process might "
"want to\n"
"yield after executing a setpri expression, which resets the priority of the "
"current\n"
"process. As with a wait, any code to be executed after a yield must be put\n"
"within its body."
msgstr ""
"Существует еще один, более простой тип выражения ожидания(wait): yield, "
"единственная\n"
"цель которого - дать возможноть другим процессам с более высоким "
"приоритетом, работать.\n"
"Процесс может захотеть выполнить yield после выполнения выражения setpri, "
"которое \n"
"сбрасывает приоритет текущего процесса. Как и в случае wait, любой код, "
"который будет\n"
"выполнен после выхода, должен быть помещен в его тело."

#: texi/node-21.texi:326
msgid ""
"The program in Figure 21-5 illustrates how the two operators work together.\n"
"Initially, the barbarians have two aims: to capture Rome and to plunder it. "
"Captur-\n"
"ing the city has (slightly) higher priority, and so will run first. However, "
"after the\n"
"city has been reduced, the priority of the capture process decreases to 1. "
"Then\n"
"there is a vote, and plunder, as the highest-priority process, starts "
"running."
msgstr ""
"Программа на Рисунке 21-5 иллюстрирует, как два оператора работают вместе.\n"
"Изначально, у варваров(barbarians) было две цели: заватить(capture) "
"Рим(Rome) и\n"
"разграбить(plunder) его. Зхват города имеет (немного) более высокий "
"приоритет и\n"
"поэтому будет выполняться первым. Однако после захвата города приоритет \n"
"процесса захвата уменьшается до 1. Затем происходит голосование, и стартует\n"
"процесс разрграбления(plunder), как процесс с наивысшим приоритетом."

#: texi/node-21.texi:336
msgid ""
"@example\n"
"> (barbarians)\n"
"Liberating ROME.\n"
"Nationalizing ROME.\n"
"Refinancing ROME.\n"
"Rebuilding ROME.\n"
">>\n"
"@end example"
msgstr ""

#: texi/node-21.texi:340
msgid ""
"Only after the barbarians have looted Rome's palaces and ransomed the "
"patricians,\n"
"does the capture process resume, and the barbarians turn to fortifying their "
"own\n"
"position."
msgstr ""
"Только после того, как варвары(barbarians) разграбили римские дворцы и "
"освободили\n"
"за выкуп патрициев, процесс захвата возобновляется, и варвары начинают "
"укреплять\n"
"свои позиции."

#: texi/node-21.texi:343
msgid ""
"Underlying wait expressions is the more general arbitrator. This function\n"
"stores the current process, and then calls pick-process to start some process"
msgstr ""
"В основе выражений wait лежит более общий арбитр(arbitrator). Эта функция\n"
"сохраняет текущий процесс, а затем вызывает  процесс выбора(pick-process)\n"
"для того чтобы запустить какой-либо процесс"

#: texi/node-21.texi:346
msgid ""
"@lisp\n"
" (defvar *bboard* nil)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *bboard* nil)"

#: texi/node-21.texi:348
msgid " (defun claim          (&rest f) (push f *bboard*))"
msgstr ""

#: texi/node-21.texi:350
msgid " (defun unclaim (&rest f) (pull f *bboard* :test #'equal))"
msgstr ""

#: texi/node-21.texi:352
msgid " (defun check          (&rest f) (find f *bboard* :test #'equal))"
msgstr ""

#: texi/node-21.texi:360
msgid ""
" (=defun visitor (door)\n"
"       (format t \"Approach ~A. \" door)\n"
"       (claim 'knock door)\n"
"       (wait d (check 'open door)\n"
"         (format t \"Enter ~A. \" door)\n"
"         (unclaim 'knock door)\n"
"         (claim 'inside door)))"
msgstr ""

#: texi/node-21.texi:368
msgid ""
" (=defun host (door)\n"
"       (wait k (check 'knock door)\n"
"         (format t \"Open ~A. \" door)\n"
"         (claim 'open door)\n"
"         (wait g (check 'inside door)\n"
"            (format t \"Close ~A.~%\" door)\n"
"            (unclaim 'open door))))"
msgstr ""

#: texi/node-21.texi:375
msgid ""
" (program ballet ()\n"
"       (fork (visitor 'door1) 1)\n"
"       (fork (host 'door1) 1)\n"
"       (fork (visitor 'door2) 1)\n"
"       (fork (host 'door2) 1))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:377
msgid "                  Figure 21-4: Synchronization with a blackboard."
msgstr ""
"                  Рисунок 21-4: Синхронизация с черной доской.\n"
"@end cartouche"

#: texi/node-21.texi:385
msgid ""
"@noindent\n"
"(perhaps the same one) running again. It will be given two arguments: a "
"test\n"
"function and a continuation. The former will be stored as the proc-wait of\n"
"the process being suspended, and called later to determine if it can be "
"restarted.\n"
"The latter will become the proc-state, and calling it will restart the "
"suspended\n"
"process."
msgstr ""
"@noindent\n"
"(возможно тот же самый) запускает снова. Ему передаются два аргумента: "
"тестовая\n"
"функция и продолжение. Первый будет сохранен как процедура ожидания wait "
"процесса,\n"
"который будет приостановлен, и  будет вызвана позже , чтобы определить, "
"можно\n"
"ли его перезапустить. Последний станет состоянием процесса proc-state, и "
"его\n"
"вызов перезапустит приостановленный процесс."

#: texi/node-21.texi:388
msgid ""
"The macros wait and yield build this continuation function simply by wrap-\n"
"ping their bodies in lambda-expressions. For example,"
msgstr ""
"Макросы wait и yield создают продолжение этой функции, просто заключив ее "
"в \n"
"тело в лямбда выражение. Например,"

#: texi/node-21.texi:391
msgid ""
"@lisp\n"
"(wait d (car *bboard*) (=values d))"
msgstr ""
"@lisp\n"
"(wait d (car *bboard*) (=values d))\n"
"@end lisp"

#: texi/node-21.texi:397
msgid ""
" (=defun capture (city)\n"
"    (take city)\n"
"    (setpri 1)\n"
"    (yield\n"
"        (fortify city)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (=defun capture (city)\n"
"    (take city)\n"
"    (setpri 1)\n"
"    (yield\n"
"        (fortify city)))"

#: texi/node-21.texi:401
msgid ""
" (=defun plunder (city)\n"
"    (loot city)\n"
"    (ransom city))"
msgstr ""

#: texi/node-21.texi:406
msgid ""
" (defun take (c)           (format t \"Liberating ~A.~%\" c))\n"
" (defun fortify (c) (format t \"Rebuilding ~A.~%\" c))\n"
" (defun loot (c)           (format t \"Nationalizing ~A.~%\" c))\n"
" (defun ransom (c) (format t \"Refinancing ~A.~%\" c))"
msgstr ""

#: texi/node-21.texi:411
msgid ""
" (program barbarians ()\n"
"    (fork (capture 'rome) 100)\n"
"    (fork (plunder 'rome) 98))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:413
msgid "                    Figure 21-5: Effect of changing priorities."
msgstr ""
"                    Рисунок 21-5: Влияние изменения приоритетов.\n"
"@end cartouche"

#: texi/node-21.texi:417
msgid ""
"@noindent\n"
"expands into:"
msgstr ""
"@noindent\n"
"расширяется в:"

#: texi/node-21.texi:422
msgid ""
"@lisp\n"
"(arbitrator #'(lambda () (car *bboard*))\n"
"                 #'(lambda (d) (=values d)))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:426
msgid ""
"If the code obeys the restrictions listed in Figure 20-5, making a closure "
"of the\n"
"wait's body will preserve the whole current continuation. With its =values\n"
"expanded the second argument becomes:"
msgstr ""
"Если код подчиняется ограниченям, перечисленным на Рисунке 20-5, созданное "
"замыкание\n"
"тела ожидания(wait) сохранит все  текущие продолжения. Вместе с его "
"расширением \n"
"=values второй аргумент становиться:"

#: texi/node-21.texi:430
msgid ""
"@lisp\n"
"#'(lambda (d) (funcall *cont* d))\n"
"@end lisp"
msgstr ""

#: texi/node-21.texi:434
msgid ""
"Since the closure contains a reference to *cont*, the suspended process "
"with\n"
"this wait function will have a handle on where it was headed at the time it "
"was\n"
"suspended."
msgstr ""
"Поскольку замыкание содержит ссылку на *cont*, приостановленный процесс с "
"этой\n"
"функцией ожидания будет иметь указатель того, куда он направлялся во время\n"
"приостановки."

#: texi/node-21.texi:440
msgid ""
"The halt operator stops the whole program, by throwing control back to the\n"
"tag established by the expansion of program. It takes an optional argument,\n"
"which will be returned as the value of the program. Because the default "
"process is\n"
"always willing to run, the only way programs end is by explicit halts. It "
"doesn't\n"
"matter what code follows a halt, since it won't be evaluated."
msgstr ""
"Оператор остановки(halt) останавливает всю программу, возвращая управление "
"обратно\n"
"тегу установленному расширением program. Он принимает необязательный "
"аргумент, \n"
"который будет возвращаен в качестве значения program. Поскольку процесс по "
"умолчанию\n"
"всегда готов к запуску, единственный способ завершить программу явный вызов "
"halt. \n"
"Неважно, какой код следует за halt, поскольку он никогда не будет "
"вычисляться."

#: texi/node-21.texi:449
msgid ""
"Individual processes can be killed by calling kill. If given no arguments,\n"
"this operator kills the current process. In this case, kill is like a wait "
"expression\n"
"which neglects to store the current process. If kill is given arguments, "
"they\n"
"become the arguments to a delete on the list of processes. In the current "
"code,\n"
"there is not much one can say in a kill expression, because processes do not "
"have\n"
"many properties to refer to. However, a more elaborate system would "
"associate\n"
"more information with processes-time stamps, owners, and so on. The default\n"
"process can't be killed, because it isn't kept in the list *procs*."
msgstr ""
"Отдельные процессы можно убивать вызвав kill. Если нет аргументов, этот "
"оператор\n"
"убивает текущий процесс. В этолм случае, kill напоминает выражение wait, "
"которое\n"
"игнорирует сохранение текущего процесса. Если заданы аргументы для kill, "
"они \n"
"становяться аргументами для  удаления(delete) в списке процессов. В текущем "
"коде,\n"
"мало что можно сказать о выражении kill, поскольку процессы не имеют "
"можества \n"
"свойств, на которые можно ссылаться. Однако более сложная система будет "
"ассоциировать\n"
"больше информации с процессами - отметки времени, владельцы и так далее. "
"Процесс по\n"
"умолчанию не может быть уничтожен, поскольку он не сохраняется в списке "
"*procs*."

#: texi/node-21.texi:454
msgid ""
"@node 21-3 The Less-than-Rapid Prototype,  , 21-2 Implementation, 21 "
"Multiple Processes\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 21-3 The Less-than-Rapid Prototype\n"
"@cindex 21-3 The Less-than-Rapid Prototype"
msgstr ""
"@node 21-3 The Less-than-Rapid Prototype,  , 21-2 Implementation, 21 "
"Multiple Processes\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 21-3 Меньше чем быстрый прототип\n"
"@cindex 21-3 The Less-than-Rapid Prototype"

#: texi/node-21.texi:458
msgid ""
"Processes simulated with continuations are not going to be nearly as "
"efficient as\n"
"real operating system processes. What's the use, then, of programs like the "
"one\n"
"in this chapter?"
msgstr ""
"Процессы, смоделированные с продожениями, не будут столь же эффективны. как "
"процессы\n"
"реальной операционной системы. Какая польза от программ, подобных той, что "
"приведена\n"
"в этой главе?"

#: texi/node-21.texi:466
msgid ""
"Such programs are useful in the same way that sketches are. In exploratory\n"
"programming or rapid prototyping, the program is not an end in itself so "
"much\n"
"as a vehicle for working out one's ideas. In many other fields, something "
"which\n"
"serves this purpose is called a sketch. An architect could, in principle, "
"design an\n"
"entire building in his head. However, most architects seem to think better "
"with\n"
"pencils in their hands: the design of a building is usually worked out in a "
"series\n"
"of preparatory sketches."
msgstr ""
"Такие программы полезны так же, как эскизы(наброски). В исследовательском \n"
"программировании или быстром прототипировании, программа является не "
"самоцелью,\n"
"а средством выражения(реализации) свой идей. Во многих других областях, то "
"что служит\n"
"этой цели называется эскизом. Архитектор, в принципе, мог бы спроектировать "
"целое\n"
"здание в своей голове. Тем не менее, большинство архитекторов, кажется "
"думают лучше\n"
"с карандашами в руках: дизайн здания обычно разрабатывается в виде серии "
"предварительных\n"
"набросков."

#: texi/node-21.texi:472
msgid ""
"Rapid prototyping is sketching software. Like an architect's first "
"sketches,\n"
"software prototypes tend to be drawn with a few sweeping strokes. "
"Considerations\n"
"of cost and efficiency are ignored in an initial push to develop an idea to "
"the full.\n"
"The result, at this stage, is likely to be an unbuildable building or a "
"hopelessly\n"
"inefficient piece of software. But the sketches are valuable all the same, "
"because"
msgstr ""
"Быстрое прототипирование - это набросок программы. Как и первые наброски "
"архитектора,\n"
"программные прототипы, как правило, рисуются несколькими быстрыми штрихами. "
"Соображения\n"
"стоимости и эффективности вначале игнорируются до разработки идеи в полной "
"мере.\n"
"Результатом, на этом этапе может стать невыстраиваемое здание или безнадежно "
"неэффективная\n"
"часть программы. Но эскизы все равно ценны,потому что"

#: texi/node-21.texi:479
msgid ""
"@enumerate\n"
"@item\n"
"They convey information briefly.\n"
"@item\n"
"They offer a chance to experiment.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Они излагают информацию кратко.\n"
"@item\n"
"Они предлагают возможность поэксперементировать.\n"
"@end enumerate"

#: texi/node-21.texi:485
msgid ""
"The program described in this chapter is, like those in succeeding chapters, "
"a\n"
"sketch. It suggests the outlines of multiprocessing in a few, broad strokes. "
"And\n"
"though it would not be efficient enough for use in production software, it "
"could\n"
"be quite useful for experimenting with other aspects of multiple processes, "
"like\n"
"scheduling algorithms."
msgstr ""
"Программа описанная в этой главе, как и в последующих главах, представляет "
"собой\n"
"эскиз. Он передает очертания много процессной обработки в нескольких "
"широких\n"
"штихах. И хотя он будет достаточно эффективным для использования в "
"производственном\n"
"программном обеспечении, он может быть весьма полезен для экспериментов с "
"другими\n"
"аспектами много процессности, такими как алгоритмы планирования."

#: texi/node-21.texi:494
msgid ""
"Chapters 22­24 present other applications of continuations. None of them is\n"
"efficient enough for use in production software. Because Lisp and rapid "
"proto-\n"
"typing evolved together, Lisp includes a lot of features specifically "
"intended for\n"
"prototypes: inefficient but convenient features like property lists, keyword "
"param-\n"
"eters, and, for that matter, lists. Continuations probably belong in this "
"category.\n"
"They save more state than a program is likely to need. So our continuation-"
"based\n"
"implementation of Prolog, for example, is a good way to understand the "
"language,\n"
"but an inefficient way to implement it."
msgstr ""
"В главах 22-­24 представлены другие применения продолжений. Ни одно из них не "
"является\n"
"достаточно эффективным для использования в производстве программного "
"обеспечения.\n"
"Поскольку  Lisp и быстрое проттипрование развивались вместе, Lisp включает в "
"себя\n"
"множество функций, специально предназначенных для проттипирования: "
"неэффективных\n"
"но удобных функций, таких как списки свойств(property lists), параметры "
"ключевые слова,\n"
"и в этом отношении списки. Продолжения, вероятно, относяться к этой "
"категории. Они\n"
"сохраняют больше состояния чем требуется программе. Так что наша реализация "
"Prolog, \n"
"например, является хорошим способом понимания языка, но не эффективным "
"способом \n"
"его реализации."

#: texi/node-21.texi:503
msgid ""
"This book is concerned more with the kinds of abstractions one can build\n"
"in Lisp than with efficiency issues. It's important to realize, though, that "
"Lisp\n"
"is a language for writing production software as well as a language for "
"writing\n"
"prototypes. If Lisp has a reputation for slowness, it is largely because so "
"many\n"
"programmers stop with the prototype. It is easy to write fast programs in "
"Lisp.\n"
"Unfortunately, it is very easy to write slow ones. The initial version of a "
"Lisp\n"
"program can be like a diamond: small, clear, and very expensive. There may "
"be\n"
"a great temptation to leave it that way."
msgstr ""
"Эта книга больше посвящена тем типам абстракций, которе можно построить на "
"Lisp,\n"
"чем вопросам эффективности. Тем не менее, важно понимать, что Lisp это язык\n"
"для написания производственных программ, а также язык для написания "
"прототипов.\n"
"Если Lisp и имеет репутацию медленного языка, то это во многом потому, что\n"
"что многие программисты останавливаются на прототипе. Это просто писать на\n"
"Lisp быстрые программы. К сожалению, еще легче писать на нем медленные.\n"
"Начальная версия программы Lisp похожа на бриллиант: маленькая, чистая и \n"
"очень дорогая. Может быть великим искушением оставить ее в этом состоянии."

#: texi/node-21.texi:514
msgid ""
"In other languages, once you succeed in the arduous task of getting your\n"
"program to work, it may already be acceptably efficient. If you tile a "
"floor\n"
"with tiles the size of your thumbnail, you don't waste many. Someone used "
"to\n"
"developing software on this principle may find it difficult to overcome the "
"idea\n"
"that when a program works, it's finished. \"In Lisp you can write programs "
"in no\n"
"time at all,\" he may think, \"but boy, are they slow.\" In fact, neither is "
"the case.\n"
"You can get fast programs, but you have to work for them. In this respect, "
"using\n"
"Lisp is like living in a rich country instead of a poor one: it may seem "
"unfortunate\n"
"that one has to work to stay thin, but surely this is better than working to "
"stay\n"
"alive, and being thin as a matter of course."
msgstr ""
"В других языках, как только вы преуспеете в трудной задаче, заставить вашу "
"программу\n"
"работать, она уже может быть приемлемо эффективной. Если вы выложите пол "
"плиткой\n"
"размером с ноготь вашего большого пальца, ваши отходы будут небольшими. Кто-"
"то\n"
"привыкший к разработке программного обеспечения по этому принципу, может "
"столкнуться\n"
"с трудностями при преодолении идеи, что когда программа работает, она "
"закончена. \n"
"\"В Lisp вы можете писать программы в кратчайшие сроки,\" - может подумать "
"он - \"но они\n"
"медленные.\". На самом деле, это не так.  Вы можете получить быстрые "
"программы, но вы\n"
"должны работать для этого. В этом отношении, использование Lisp похоже "
"жизни\n"
"в богатой стране, а не в бедной: может показаться прискорбным, что нужно "
"работать\n"
"чтобы остаться худым, но конечно это лучше, чем работать чтобы остаться в "
"живых, и\n"
"конечно быть худым, как само собо разумещееся."

#: texi/node-21.texi:518
msgid ""
"In less abstract languages, you work for functionality. In Lisp you work "
"for\n"
"speed. Fortunately, working for speed is easier: most programs only have a "
"few\n"
"critical sections in which speed matters."
msgstr ""
"В менее абстрактных языках вы работаете над функциональностью. В Lisp вы "
"работаете\n"
"над скоростью. К счастью, работать над скоростью проще: у большинства "
"программ есть\n"
"только несколько критических разделов, в которых скорость имеет значение."
