@node 25 Object-Oriented Lisp, Appendix Packages, 24 Prolog, Top
@comment  node-name,  next,  previous,  up
@chapter 25 Объектно Ориентированный Lisp
@cindex 25 Object-Oriented Lisp

В этой главе обсуждается объектно-ориентированное программирование на Lisp. Common Lisp
включает в себя набор операторов для написания объектно-ориентриованных программ. В
совокупности они называются Common Lisp Object System, или CLOS. Здесь мы рассматриваем
CLOS не просто как способ написания объектно ориентированных программ, а как саму
программу на Lisp. Видение CLOS в этом свете является ключом к пониманию связи между
Lisp и объектно ориентированным программированием.

@menu
* 25-1 Plus ça Change::         
* 25-2 Objects in Plain Lisp::  
* 25-3 Classes and Instances::  
* 25-4 Methods::                
* 25-5 Auxiliary Methods and Combination::  
* 25-7 When to Object::         
@end menu

@node 25-1 Plus ça Change, 25-2 Objects in Plain Lisp, 25 Object-Oriented Lisp, 25 Object-Oriented Lisp
@comment  node-name,  next,  previous,  up
@section 25-1 Plus ça Change
@cindex 25-1 Plus ça Change

Объектно-ориентированное программирование означает изменение способа организации
программ. Это изменение аналогично тому, какое имело место при распределении
мощности процессора. В 1970, многопользовательская компьютерная система означала
один или два больших мэйн фрейма, подключенных к большому количеству "глупых"(dumb)
терминалов. Теперь это скорее всего означает большое количество рабочих станций,
соединенных друг с другом сетью. Теперь вычислительная мощность системы распределяется
между отдельными пользователями, а не централизованно на одном большом компьютере.

Объектно-ориентированное программирование разбивает традиционные программы почти
таким же образом: вместо единой программы, которая работает с инертной массой данных,
самим данным сообщается, как себя вести, и программа является неявным взаимодействием
этих новых "объектов" данных.

Например, предположим, что мы хотим написать программу для поиска площадей
двумерных фигур. Одним из способов сделать это было бы написать функцию,
которая смотрела бы на тип свого аргумента и вела бы себя соответственно:

@lisp
(defun area (x)
  (cond ((rectangle-p x) (* (height x) (width x)))
           ((circle-p x) (* pi (expt (radius x) 2)))))
@end lisp

Объектно-ориентированный подход заключается в том, чтобы каждый объект мог сам
рассчитывать свою собственную площадь. Функция area разбита на части и каждое
предложение распространяется на соответствующий класс объекта; метод area класса
прямоугольника(rectangle) может быть

@lisp
#'(lambda (x) (* (height x) (width x)))
@end lisp

@noindent
и для класса круга(circle),

@lisp
#'(lambda (x) (* pi (expt (radius x) 2)))
@end lisp

В этой модели, мы спрашиваем объект, какова его площадь, и он отвечает в соответствии
с методом, предоставленным для его класса.

Появление CLOS может показаться признаком того, что Lisp меняется, чтобы принять
объектно-ориентированную парадигму. На самом деле, было бы точнее сказать, что Lisp
остается неизменным, чтобы принять объектно-ориентированную парадигму. Но принципы
лежащие в основе Lisp не имеют названия, как у объектно-ориентированного программирования,
поэтому сейчас существует тенденция описывать Lisp как объектно-ориентированный язык. 
Но было бы ближе к правде сказть, что Lisp является расширяемым языком, на котором легко
могут быть написаны конструкции для объектно-ориентированного программирования.

Поскольку CLOS поставляется предварительно написанным, описание Lisp как объектно-
ориентированного языка не является ложной рекламой. Однако было бы ограничением
смотреть так на Lisp. Да, Lisp это объектно-ориентированный язык, но не потому,
что он принял объектно ориентированную модель. Скроее, эта модель оказывается
еще одной перестановкой абстракций, лежащих в основе Lisp. И чтобы доказть это, у
нас есть CLOS, программа написанная на Lisp, которая делает Lisp объектно-
ориентированным языком.

Цель этой главы - выявить связь между Lisp и объектно-ориентированным программированием,
изучая CLOS как пример встроенного языка. Это также хороший способ понять сам CLOS:
в конце концов, ничто не объясняет языковую функцию более эффективно, ем набросок её
реализации. В разделе 7-6, таким образом объяснялись макросы. В следующем разделе
дается аналогичный эскиз того, как создавать объектно-ориентированные абстракции поверх
Lisp. Эта программа обеспечивает ориентир для описания CLOS в Разделах 25.3 - ­25-6.

@node 25-2 Objects in Plain Lisp, 25-3 Classes and Instances, 25-1 Plus ça Change, 25 Object-Oriented Lisp
@comment  node-name,  next,  previous,  up
@section 25-2 Объекты в простом/чистом Lisp
@cindex 25-2 Objects in Plain Lisp

Мы можем лепить из Lisp множество видов языков. Существует прямое соответствие
между концепциями объектно-ориентированного программирования и фундаментальными
абстракциями Lisp. Размер CLOS имеет тенденцию скрывать этот факт. Итак, прежде
чем посмотреть, что мы можем сделать с CLOS, давайте посмотрим, что мы можем 
сделать с простым Lisp. 
  Многое из того, что мы хотем от объектно-ориентированного программирования, 
уже есть в Lisp. И мы можем получить остальное с удивительно небольшим кодом. 
В этом разделе мы определим объектную систему, достаточную для многих реальных
приложений, на двух страницах кода.
  Объектно ориентированное программирование, как минимум, подразумевает

@enumerate
@item
объекты, которые имеют свойства
@item
и отвечают на сообщения,
@item
и которые наследуют свойства и методы от своих родителей.
@end enumerate

В Lisp уже есть несколько способов хранения коллекций свойств.
Один из способов - представить объекты в виде хеш-таблиц и сохранить их свойства
в виде записепй внутри них. Затем у нас есть доступ к отдельным свойствам через
gethash:

@lisp
(gethash 'color obj)
@end lisp

Поскольку функции являются объектами данных, мы также можем хранить их как свойства.
Это означает, что у нас также могут быть методы; Вызов данного метода объекета означает
передачу funcall свойства с этим именем:

@lisp
(funcall (gethash 'move obj) obj 10)
@end lisp

Основываясь на этой идее мы можем определить Smalltalk стиль передачи сообщений:

@lisp
(defun tell (obj message &rest args)
  (apply (gethash message obj) obj args))
@end lisp

@noindent
так чтобы указать obj, чтобы он переместился на 10 мы можем сказать:

@lisp
(tell obj 'move 10)
@end lisp

Фактически, единственный компонент отсутствующий в простом Lisp это наследование, и мы
можем предоставить его элементарную версию в шести строках кода, определяющих рекурсивную
версию gethash:

@cartouche
@lisp
(defun rget (obj prop)
  (multiple-value-bind (val win) (gethash prop obj)
        (if win
              (values val win)
              (let ((par (gethash 'parent obj)))
                (and par (rget par prop))))))

 (defun rget (obj prop)
    (some2 #'(lambda (a) (gethash prop a))
             (get-ancestors obj)))

 (defun get-ancestors (obj)
    (labels ((getall (x)
                   (append (list x)
                             (mapcan #'getall
                                        (gethash 'parents x)))))
        (stable-sort (delete-duplicates (getall obj))
                        #'(lambda (x y)
                             (member y (gethash 'parents x))))))

 (defun some2 (fn lst)
    (if (atom lst)
         nil
         (multiple-value-bind (val win) (funcall fn (car lst))
            (if (or val win)
                 (values val win)
                 (some2 fn (cdr lst))))))
@end lisp

                       Рисунок 25-1: Множественное наследование.
@end cartouche

Если мы просто используем rget вместо gethash, мы получим наследование
свойств и методов. Мы указываем объект-родитель следующим образом:

(setf (gethash 'parent obj) obj2)

Поскольку у нас только одно наследование у объекта может быть только один родитель(parent).
НО мы можем иметь множественное наследование, сделав свойство parent списком, и
определивg rget как показано на Рисунке 25-1.
   При одиночном наследовании, когда мы хотели получить какое-либо свойство объекта,
мы просто рекурсивно искали его предков. Если сам объект не имел информации о
желаемом свойстве, мы смотрели на его родителя и так далее.
   При множественном наследовании мы хотим выполнять поиск того же рода, но наша работа
осложняется тем фактом, что предки объекта могут формировать граф, вместо простого
списка. Мы не можем просто искать в этом графе в глубину. С множественным наследованием
мы можем иметь иерархию показанную на Рисунке 25-2: a происходит от b и c, которые оба
происходят от d. Обход в глубину (точнее, в высоту), будет идти по a, b, d, c, d. Если
бы желаемое свойство присутствовало как в d, так и  c, мы бы

 

@cartouche
                         Figure 25-2: Multiple paths to a superclass.
@end cartouche

   получили значение хранящееся в d, а не то, которое хранится в c. Это нарушило бы
принцип, согласно которому подклассы переопределяют значения по умолчанию, предоставленные
их родителями.
   Если мы хотим реализовать обычную идею наследования, мы никогда не должны исследовать 
объект прежде исследования его потомков. В этом случае правильный порядок поиска будет:
a, b, c, d. Как мы можем гарантировать, что поиск всегда вначале проверяет потомков?
Самый простой способ - собрать всех предков исходного объекта, отсортировать этот список 
так,  чтобы ни один объект не появился перед одним из своих потомков, а затем посмотреть
на каждый элемент по очереди.
    Эта стратегия используется get-ancestors, которая возвращает правильно упорядоченный
список объекта и его предков. Чтобы отсортировать список, get-ancestors вызывает 
stable-sort, а не  sort, чтобы избежать возможного переупорядочивания параллельных
предков. Как только список отсортирован,  rget просто ищет первый объект с желаемым
свойством.
(Утилита some2 это версия some для использования с такими функциями как gethash, которые
указывают на успех или неудачу во втором возвращаемом значении.)
    Список предков объекта проходит от наиболее специфического к наименее конкретному: 
если апельсин это плод цитрусовых, которыйй является фруктом, тогда список будет иметь
порядок (orange citrus fruit).
    Когда у объекта несколько родителей, их приоритет идет слева направо. То есть если
мы скажем

   (setf (gethash 'parents x) (list y z))

тогда y будет рассматриваться перед z когда мы будем искать унаследованное свойство.
Например, мы можем сказать что  патриот-негодяй(patriotic scoundrel) это сначала негодяй
(scoundrel), а потом патриот(patriot):

   > (setq scoundrel (make-hash-table)
           patriot   (make-hash-table)
           patriotic-scoundrel (make-hash-table))
   #<Hash-Table C4219E>

@cartouche
@lisp
     (defun obj (&rest parents)
      (let ((obj (make-hash-table)))
         (setf (gethash 'parents obj) parents)
         (ancestors obj)
         obj))

     (defun ancestors (obj)
      (or (gethash 'ancestors obj)
           (setf (gethash 'ancestors obj) (get-ancestors obj))))

     (defun rget (obj prop)
      (some2 #'(lambda (a) (gethash prop a))
               (ancestors obj)))
@end lisp

                      Рисунок 25-3: Функции для создания объектов.
@end cartouche

@example
> (setf (gethash 'serves scoundrel) 'self
            (gethash 'serves patriot)             'country
            (gethash 'parents patriotic-scoundrel)
                         (list scoundrel patriot))
(#<Hash-Table C41C7E> #<Hash-Table C41F0E>)
> (rget patriotic-scoundrel 'serves)
SELF
T
@end example

      Давайте внесем некоторые улучшения в эту скелетную систему. Мы могли бы начать с
функции для создания объектов. Эта функция должна составлять список предков объекта во
время создания объекта. Текущий код строит эти списки при выполнении запросов, но нет
никаких причин не сделать это раньше. На рисунке 25-3 определена функция с именем obj,
которая создает новый объект, сохраняя в нем список его предков. Чтобы воспользоваться
преимуществами хранимых предков, мы также переопределяем rget.

      Другое место для улучшения - это синтаксис вызовов сообщений. Само по себе
сообщение(tell) является ненужным беспорядком, поскольку оно заставляет глаголы
стоять на втором месте, а это означает, что наши программы больше не могут читаться
как обычные префиксные выражения Lisp:
(tell (tell obj 'find-owner) 'find-owner)

      Мы можем избавиться от синтаксиса tell, определив каждое имя свойства как функцию,
как показано на рисунке 25-4. Необязательный аргумент meth?, если истина(true), означает,
что это свойство следует рассматривать как метод. В противном случае оно будет рассматриваться
как слот, а значение, полученное с помощью rge, будет просто возвращено. После того, как мы
определили название любого вида свойств,

@cartouche
@lisp
     (defmacro defprop (name &optional meth?)
       `(progn
           (defun ,name (obj &rest args)
             ,(if meth?
                   `(run-methods obj ',name args)
                   `(rget obj ',name)))
           (defsetf ,name (obj) (val)
             `(setf (gethash ',',name ,obj) ,val))))

     (defun run-methods (obj name args)
       (let ((meth (rget obj name)))
         (if meth
              (apply meth obj args)
              (error "No ~A method for ~A." name obj))))

@end lisp
                           Рисунок 25-4: Функциональный синтаксис.
@end cartouche

@lisp
(defprop find-owner t)
@end lisp

мы можем обратиться к нему с помощью вызова функции, и наш код снова будет выглядеть
как Lisp:

@lisp
(find-owner (find-owner obj))
@end lisp

Наш предыдущий пример теперь стал более читабельным:

@example
> (progn
        (setq scoundrel (obj))
        (setq patriot (obj))
        (setq patriotic-scoundrel (obj scoundrel patriot))
        (defprop serves)
        (setf (serves scoundrel) 'self)
        (setf (serves patriot) 'country)
        (serves patriotic-scoundrel))
SELF
T
@end example

       В текущей реализации объект может иметь не более одного метода для определенного
имени. У объекта либо есть собственный метод, либо он наследуется. Было бы удобно иметь
больше гибкости в этом вопросе, чтобы мы могли соединять локальный и унаследованный
методы. Например, мы могли бы захотеть, чтобы метод move некоторых объектов, был методом move его родителя, но с некоторым дополнительным кодом, выполняемым до него, или после.

   Чтобы предоставить такие возможности, мы изменим нашу программу, включив в неё
методы before-, after- и around- . Before- методы позволяют нам сказать "Но сначала,
сделаете это.". Они вызываются впереди всех, как прелюдия к остальной части вызова
метода. After- методы позволяют нам сказать "P.S. Сделай то тоже." Они вызываются,
позже всех, как эпилог вызова метода. Между ними, мы запускаем то, что раньше было
методом, и теперь называется первичным методом. Значение вызова этого метода будет
возвращаеться, даже если after- методы будут вызваны позже.
   Before- и after-методы позволяют нам обернуть новое поведение вокруг вызова 
первичного метода. Around-методы обеспечивают более радикальный способ сделать
тоже самое. Если существует метод around-, он будет вызываться вместо первичного
метода. Затем, по своему усмотрению, метод around- может сам вызвать первичный
метод (через call-next, который будет представлен на Рисунке 25-7).
   Чтобы разрешить вспомогательные методы, мы изменим run-методы и  rget как
на Рисунках 25-5 и 25-6. В предыдущей версии, когда мы запускали какой-то
метод объекта, мы просто запускали одну функцию: наиболее конкретный первичный
метод. Мы запускали первый метод, с которым мы сталкивались при поиске по
списку предков. С вспомогательными методами, вызывающая последовательность 
теперь выглядит следующим образом:

   1. Наиболее конкретный метод around- если он есть.

   2. Otherwise, in order:

           (a) Все методы before-, от наиболее конкртетных до наименее конкретных.
           (b) Наиболее конкретный первичный метод (то что мы привыкли вызывать).
           (c) Все методы after-, от наименее конкретных до наиболее конкретных.

   Обратите внимание, что вместо того, чтобы быть единой функцией, метод становиться
структурой из четырех частей. Чтобы определить (основной/первичный) метод, вместо того
чтобы сказать:

(setf (gethash 'move obj) #'(lambda ...))

мы скажем:

(setf (meth-primary (gethash 'move obj)) #'(lambda ...))

По этой и другим причинам, нашим следующим шагом должно стать определение макроса
для определения методов.
   На Рисунке 25-7 показано определение такого макроса. Большая часть этого кода
занята реализацией двух функций, которые методы могут использовать для ссылки на
другие методы. Методы around- и primary могут использовать call-next для вызова
следующего метода, который должен был бы выполниться, если бы текущего метода
не существовало. Например, если текущий запущенный метод является единственным
around- методом,

@cartouche
@lisp
 (defstruct meth around before primary after)

 (defmacro meth- (field obj)
       (let ((gobj (gensym)))
        `(let ((,gobj ,obj))
           (and (meth-p ,gobj)
                   (,(symb 'meth- field) ,gobj)))))

 (defun run-methods (obj name args)
       (let ((pri (rget obj name :primary)))
        (if pri
             (let ((ar (rget obj name :around)))
              (if ar
                    (apply ar obj args)
                    (run-core-methods obj name args pri)))
             (error "No primary ~A method for ~A." name obj))))

 (defun run-core-methods (obj name args &optional pri)
       (multiple-value-prog1
        (progn (run-befores obj name args)
               (apply (or pri (rget obj name :primary))
                        obj args))
        (run-afters obj name args)))

 (defun rget (obj prop &optional meth (skip 0))
       (some2 #'(lambda (a)
                   (multiple-value-bind (val win) (gethash prop a)
                     (if win
                          (case meth (:around (meth- around val))
                                        (:primary (meth- primary val))
                                        (t (values val win))))))
             (nthcdr skip (ancestors obj))))

@end lisp
                        Рисунок 25-5: Вспомогательные методы.
@end cartouche

следующим методом будет сендвич(набор следующих друг за другом) из before- методов, 
наиболее конкретного первичного метода и методов after-. В пределах наиболее
конкретного метода, следующий метод будет вторым наиболее конкретным методом. 
Поскольку поведение call-next зависит от того, где он вызывается, он никогда не
определяется глобально с помощью defun, а определяется локально в каждом методе,
определённом с помощью defmeth.

@cartouche
@lisp
     (defun run-befores (obj prop args)
      (dolist (a (ancestors obj))
         (let ((bm (meth- before (gethash prop a))))
            (if bm (apply bm obj args)))))

     (defun run-afters (obj prop args)
      (labels ((rec (lst)
                    (when lst
                       (rec (cdr lst))
                       (let ((am (meth- after
                                              (gethash prop (car lst)))))
                         (if am (apply am (car lst) args))))))
         (rec (ancestors obj))))

@end lisp
                    Рисунок 25-6: Вспомогательные методы (продолжение).
@end cartouche

      Метод around- или primary может использовать next-p, чтобы проверить, 
существует ли следующий метод. Например, если текущий метод является первичным
методом объекта не имеющим родителей, то следующего метода не будет. Так как 
call-next выдает ошибку, когда нет следующего метода, обычно следует вызвать 
next-p чтобы проверить его наличие. Как и call-next, next-p определяется локально
в отдельных методах.
      Новый макрос defmeth используется следующим образом. Если мы просто хотим
определить метод area объекта rectangle, мы скажем

(setq rectangle (obj))
(defprop height)
(defprop width)
(defmeth (area) rectangle (r)
     (* (height r) (width r)))

Теперь площадь(area) экземпляра рассчитывается как метод класса:

> (let ((myrec (obj rectangle)))
        (setf (height myrec) 2
               (width myrec) 3)
        (area myrec))
6

@cartouche
@lisp
 (defmacro defmeth ((name &optional (type :primary))
                          obj parms &body body)
       (let ((gobj (gensym)))
        `(let ((,gobj ,obj))
           (defprop ,name t)
           (unless (meth-p (gethash ',name ,gobj))
             (setf (gethash ',name ,gobj) (make-meth)))
           (setf (,(symb 'meth- type) (gethash ',name ,gobj))
                     ,(build-meth name type gobj parms body)))))

 (defun build-meth (name type gobj parms body)
       (let ((gargs (gensym)))
        `#'(lambda (&rest ,gargs)
              (labels
                ((call-next ()
                       ,(if (or (eq type :primary)
                                   (eq type :around))
                            `(cnm ,gobj ',name (cdr ,gargs) ,type)
                            '(error "Illegal call-next.")))
                     (next-p ()
                       ,(case type
                         (:around
                          `(or (rget ,gobj ',name :around 1)
                                   (rget ,gobj ',name :primary)))
                         (:primary
                          `(rget ,gobj ',name :primary 1))
                         (t nil))))
                (apply #'(lambda ,parms ,@@body) ,gargs)))))

 (defun cnm (obj name args type)
       (case type
        (:around (let ((ar (rget obj name :around 1)))
                       (if ar
                            (apply ar obj args)
                            (run-core-methods obj name args))))
        (:primary (let ((pri (rget obj name :primary 1)))
                       (if pri
                            (apply pri obj args)
                            (error "No next method."))))))

@end lisp
                         Рисунок 25-7: Определение методов.
@end cartouche

@cartouche
@lisp
 (defmacro undefmeth ((name &optional (type :primary)) obj)
    `(setf (,(symb 'meth- type) (gethash ',name ,obj))
             nil))
@end lisp

                        Рисунок 25-8: Удаление методов.
@end cartouche

В более сложном примере предположим, что мы определили метод backup для
объекта filesystem:

(setq filesystem (obj))
(defmeth (backup :before) filesystem (fs)
  (format t "Remember to mount the tape.~%"))
(defmeth (backup) filesystem (fs)
  (format t "Oops, deleted all your files.~%")
  'done)
(defmeth (backup :after) filesystem (fs)
  (format t "Well, that was easy.~%"))

Обычная последовательность вызовов будет следующей:

> (backup (obj filesystem))
Remember to mount the tape.
Oops, deleted all your files.
Well, that was easy.
DONE

Позднее мы хотим узнать, сколько времени занимает выполнения резервирования(backup), 
поэтому определим следующий метод:

(defmeth (backup :around) filesystem (fs)
  (time (call-next)))

Теперь, всякий раз, когда вызвается backup для потомка filesystem (если не вмешиваются
более конкретные around-методы), будет вызываться наш метод around-. Он вызовет код
который обычно запускается при вызове backup, но в вызове time. Значение возвращаемое
time, будет возвращено как значение вызова backup:

> (backup (obj filesystem))
Remember to mount the tape.
Oops, deleted all your files.
Well, that was easy.
Elapsed Time = .01 seconds
DONE

Как только мы закончим подсчитывать время выполнения метода backup, мы захотим
удалить метод around-. Это можно сделать, вызвав undefmeth (Рисунокe 25-8), который
принимает те же первые два аргумента, что и defmeth:

(undefmeth (backup :around) filesystem)

       Еще одна вещь, которую мы могли бы изменить - это список родителей объекта.
Но после любого такого изменения мы должны также обновить список предков объекта и
всех его потомков. Пока что у нас нет возможности получить из объекта его потомков,
поэтому мы также должны добавить свойство children(потомки).
       На рисунке 25-9 приведен код для работы с родителями и потомками. Вместо того,
чтобы получать родителей и детей через gethash, мы используем операторы parents и 
children. Последний является макросом и поэтому прозрачен для setf. Первый это
функция, инверсия которой определяется defsetf как set-parents, которая делает
все необходимое для поддержания согласованности в новом двусвязном мире.
       Чтобы обновить предков всех объектов в поддереве, set-parents вызывает
maphier, который похож на mapc для иерархий наследования. Как и mapc вызывает
функцию для каждого элемента списка, maphier вызывает функцию для объекта и
всех его потомков. Если они не образуют правильное дерево, функция может вызываться
несколько раз для некоторых объектов. Здесь это безвредно, потому что get-ancestors
делает тоже самое, когда вызывается несколько раз.
       Теперь мы можем изменить иерархию наследования, просто используя setf для 
родителей объекта:

> (progn (pop (parents patriotic-scoundrel))
               (serves patriotic-scoundrel))
COUNTRY
T

Когда иерархия изменена, затронутые списки потомков и предков будут обновлены
автоматически. (Свойство потомки(children) не предназначено для прямого манипулирования,
но оно бы могло быть, если бы мы определили set-children аналогично set-parents.)
Последняя функция на рисунке 25-9 это obj переопределенная для использования нового кода.
       В качестве окончательного усовершенствования нашей системы, мы дадим возможность
указать новые способы объединения методов. В настоящее время, единственный первичный
метод, является наиболее конкретным(хотя он может вызвать другие используя call-next). 
Вместо этого нам может потребоваться объединить результаты первичных методов каждого
из предков объекта. Например, предположим, что my-orange это потомок orange,
который является потомком citrus. Если метод props возвращает (round acidic) для
citrus и (orange sweet) для orange, и (dented) для my-orange, было бы удобно
иметь возможность (props my-orange) возвращать  объединение всех этих значений:
(dented orange sweet round acidic).

@cartouche
@lisp
 (defmacro children (obj)
    `(gethash 'children ,obj))

 (defun parents (obj)
    (gethash 'parents obj))

 (defun set-parents (obj pars)
    (dolist (p (parents obj))
        (setf (children p)
                 (delete obj (children p))))
    (setf (gethash 'parents obj) pars)
    (dolist (p pars)
        (pushnew obj (children p)))
    (maphier #'(lambda (obj)
                       (setf (gethash 'ancestors obj)
                              (get-ancestors obj)))
                 obj)
    pars)

 (defsetf parents set-parents)

 (defun maphier (fn obj)
    (funcall fn obj)
    (dolist (c (children obj))
        (maphier fn c)))

 (defun obj (&rest parents)
    (let ((obj (make-hash-table)))
        (setf (parents obj) parents)
        obj))

@end lisp
                  Рисунок 25-9: Поддержание родительских и дочерних ссылок.
@end cartouche

   Мы могли бы иметь это, если бы позволили методам применять некоторую функцию
к значениям своих первичных методов, вместо того, чтобы просто возвращать 
значение наиболее конкретного метода.
Рисунок 25-10 содержит макрос, который позволяет нам определить способ 
объединения методов и новую версию run-core-methods, которые могут выполнять
объединение методов.
   Мы определяем форму комбинации для метода через defcomb, который принимает
имя метода и второй аргумент, описывающий желаемую комбинацию.

@cartouche
@lisp
 (defmacro defcomb (name op)
       `(progn
         (defprop ,name t)
         (setf (get ',name 'mcombine)
                  ,(case op
                      (:standard nil)
                      (:progn '#'(lambda (&rest args)
                                     (car (last args))))
                      (t op)))))

 (defun run-core-methods (obj name args &optional pri)
       (let ((comb (get name 'mcombine)))
        (if comb
            (if (symbolp comb)
                   (funcall (case comb (:and #'comb-and)
                                            (:or #'comb-or))
                               obj name args (ancestors obj))
                   (comb-normal comb obj name args))
            (multiple-value-prog1
                  (progn (run-befores obj name args)
                         (apply (or pri (rget obj name :primary))
                                 obj args))
                  (run-afters obj name args)))))

 (defun comb-normal (comb obj name args)
       (apply comb
             (mapcan #'(lambda (a)
                               (let* ((pm (meth- primary
                                                       (gethash name a)))
                                      (val (if pm
                                                  (apply pm obj args))))
                                 (if val (list val))))
                         (ancestors obj))))

@end lisp
                       Рисунок 25-10: Комбинация Методов.
@end cartouche

Обычно этот второй аргумент должен быть функцией. Тем не менее, он также может
быть одним из :progn, :and, :or или :standard. С первыми тремя первичные методы
будут объединены как будто согласно согласно соответствующим оператором, тогда 
как :standard указывает, что мы хотим традиционный способ выполнения операторов.

@cartouche
@lisp
     (defun comb-and (obj name args ancs &optional (last t))
      (if (null ancs)
             last
             (let ((pm (meth- primary (gethash name (car ancs)))))
                (if pm
                      (let ((new (apply pm obj args)))
                         (and new
                                 (comb-and obj name args (cdr ancs) new)))
                      (comb-and obj name args (cdr ancs) last)))))

     (defun comb-or (obj name args ancs)
      (and ancs
              (let ((pm (meth- primary (gethash name (car ancs)))))
                 (or (and pm (apply pm obj args))
                        (comb-or obj name args (cdr ancs))))))

@end lisp
                     Рисунок 25-11: Комбинация методов (продолжение).
@end cartouche

      Центральной функцией на рисунке 25-10 является новый run-core-methods. Если
вызываемый метод не имеет свойства mcombine, то вызов метода продолжается как и
раньше. В противном случае mcombine метода это либо функция (такая как +) или
ключевое слово (такое как :or). В перовм случае функция просто применяется к
списку значений возвращенных всеми первичными методами.@footnote{Более сложная версия
этого кода может использовать reduce чтобы избежать создания списка(consingа) здесь.} 
Во втором случае, мы используем функцию связанную с ключевым словом, для итерации
по первичным методам.

      Операторы and и or должны обрабатываться специальнго, как показано на рисунке 25-11.
Они получают специальное обращение не только потому, что они являются специальными
формами, но и потому что они  вычисляются по укороченной схеме.:

> (or 1 (princ "wahoo"))
1

Здесь ничего не печатается, потому что  or возвращается как только оно видит не
нулевой(не nil) аргумент.
Точно так же первичный метод или комбинация не будут вызваны, если более конкретный
метод вернет истину(true). Чтобы обеспечить такую укороченную схему для and и
or, мы используем различные функции comb-and и comb-or.
      Чтобы реализовать наш предыдущий пример, мы бы написали:

@lisp
(setq citrus (obj))
(setq orange (obj citrus))

(setq my-orange (obj orange))

(defmeth (props) citrus (c) '(round acidic))
(defmeth (props) orange (o) '(orange sweet))
(defmeth (props) my-orange (m) '(dented))

(defcomb props #'(lambda (&rest args) (reduce #'union args)))
@end lisp

после чего props будет возвращать объединение всех значений первичных методов: 
@footnote{Так как объединение функций для props вызывает union, элементы списка
не обязательно будут идти в этом порядке.}

@example
> (props my-orange)
(DENTED ORANGE SWEET ROUND ACIDIC)
@end example

Между прочим, этот пример предлалгает выбор, который вы имеете только при
объектно-ориентированном программировании на Lisp: хранить информацию в
слотах или методах.

       Впоследствии, если мыхотим, чтобы метод props вернулся к повдению по умолчанию,
мы просто установим комбинацию методов обратно в standard:

@example
> (defcomb props :standard)
NIL
> (props my-orange)
(DENTED)
@end example

Обратите внимание, что методы before- и after- выполняются только в стандартной
комбинации методов. Однако, методы around- работают так же, как и раньше.

       Программа, представленная в этом разделе, задумана как модель, а не как реальная
основа для объектно-ориентированного программирования. Этот код был написан для
краткости, а не для эффективности. Тем не менее, это по крайней мере рабочая модель,
и поэтому может быть использован для экспериментов и прототипов. Если вы захотите
использовать программу для этих целей, одно небольшое изменение сделает её гораздо
более эффективной: не вычисляйте и не сохраняйте списки предков для объектов с
одним родителем.

@node 25-3 Classes and Instances, 25-4 Methods, 25-2 Objects in Plain Lisp, 25 Object-Oriented Lisp
@comment  node-name,  next,  previous,  up
@section 25-3 Классы и Экземпляры
@cindex 25-3 Classes and Instances

Программа в предыдущем разделе была написана так, чтобы походить на CLOS на столько
близко, насколько могла бы такая маленькая программа. Поняв её, мы уже продвинулись
к пониманию CLOS. В следующих нескольких разделах мы рассмотрим сам CLOS.

       В нашем наброске мы не делали синтаксического различия между классами и
экземплярами или между слотами и методами. В CLOS, мы используем макрос defclass
для определения класса и одновременно объявляем слоты в списке:

2

(defclass circle ()
     (radius center))

Это выражение говорит о том, что у класса circle нет суперклассов, а есть два
слота, radius и center. Мы можем создать экземпляр класса circle сказав:

(make-instance 'circle)

К сожалению мы не определили способ обращаения к слотам circle, поэтому любой
созданный нами экземпляр будет довольно инертным. Чтобы получить слот мы определяем
функцию доступа для него:

(defclass circle ()
     ((radius :accessor circle-radius)
      (center :accessor circle-center)))

Теперь если мы создаем экзепляр circle, мы можем установить его слоты radius и center
исползуя setf с соответствующими функциями доступа:

> (setf (circle-radius (make-instance 'circle)) 2)
2

Мы можем выполнить этот тип инициализации прямо в вызове make-instance слоты
позволяющие это:

(defclass circle ()
     ((radius :accessor circle-radius :initarg :radius)
      (center :accessor circle-center :initarg :center)))

Ключевое слово :initarg в определении слота говорит, что следующий аргумент должен
стать ключевым параметром в make-instance. Значение параметра ключевого слова станет
начальным значением слота:

> (circle-radius (make-instance 'circle
                             :radius 2
                             :center '(0 . 0)))
2

     Объявляя :initform, мы также можем определить слоты, которые инициализируются
сами. Видимый слот класса shape

(defclass shape ()
     ((color     :accessor shape-color           :initarg :color)
      (visible :accessor shape-visible :initarg :visible
                 :initform t)))

по умолчанию будет установлено значение t:
> (shape-visible (make-instance 'shape))
T
Если в слоте есть и initarg, и initform, initarg имеет приоритет, если он указан:
> (shape-visible (make-instance 'shape :visible nil))
NIL
       Слоты наследуются экземплярами и подклассами. Если класс имеет более одного
суперкласса, он наследует объединение из их слотов. Так что, если мы определим
класс screen-circle как подкласс circle и shape,
(defclass screen-circle (circle shape)
     nil)
тогда экземпляры screen-circle будут иметь четыре слота, по два унаследованых от
каждого родителя. Обратите внимание, что этот класс не должен создавать никаких
новых собственных слотов; этот класс существует только для того, чтобы обеспечить
создания того, что наследует как от circle, так и от shape.
       Функция доступа и initargs работают для экземпляров screen-circle точно так же,
как и для экземпляров circle или shape:
> (shape-color (make-instance 'screen-circle
                                          :color 'red :radius 3))
RED
Мы можем заставить каждый screen-circle иметь некоторый начальны цвет по умолчанию, указав
initform для этого слота в определении класса defclass:
(defclass screen-circle (circle shape)
     ((color :initform 'purple)))
Теперь экземпляры screen-circle будут purple по умолчанию,
> (shape-color (make-instance 'screen-circle))
PURPLE
хотя все еще возможно инициализировать слот, в противном случае, задав явный ицинцализирующий
аргумент :color initarg.
       В нашем наброске объектно-ориентированного программирования, экземпляры наследовали
значения непсредственно из слотов в своих же родительстких классах. В  CLOS, экземпляры не
имеют слотов таких же как классы. Мы определяем наследуемое значение по умолчанию для экземпляров,
определяя initform в родительском классе. В некотором смысле, это более гибко, потому что
initform может быть не только константой, но и выражением, которое возвращает разное значение при
каждом его вычислении:

(defclass random-dot ()
     ((x :accessor dot-x :initform (random 100))
      (y :accessor dot-y :initform (random 100))))

Каждый раз, когда мы создаем экземпляр случайной точки, её координаты x и y 
будут случайным целым числом от 0 до 99:

> (mapcar #'(lambda (name)
                   (let ((rd (make-instance 'random-dot)))
                      (list name (dot-x rd) (dot-y rd))))
              '(first second third))
((FIRST 25 8) (SECOND 26 15) (THIRD 75 59))

     В нашем наброске мы также не делали различий между слотами, значения которых
доложны были варьироваться от экземпляра к экземпляру, и слотами, которые должны
быть постоянными по всему классу. В CLOS мы можем указать, что некоторые слоты
должны быть общими, то есть их значение одинаково для каждого экземпляра. Мы сделаем
это объявив слот имеющий :allocation :class. (Альтернативно это для слота должно
быть :allocation :instance, но так как это значение по умолчанию, нет необходимости
говорить об этом явнор.) Например, если все совы(owls) ведут ночной образ жизни(nocturnal),
то мы можем сделать слот nocturnal класса owl разделяемым слотом, и задать ему
начальное значение t:

(defclass owl ()
     ((nocturnal :accessor owl-nocturnal
                   :initform t
                   :allocation :class)))

Теперь каждый экземпляр класса owl будет наследовать этот слот:

> (owl-nocturnal (make-instance 'owl))
T

Если мы изменим "локальное" значение этого слота в некотором экземпляре, мы фактически
изменим значение, хранящееся в классе:

> (setf (owl-nocturnal (make-instance 'owl)) 'maybe)
MAYBE
> (owl-nocturnal (make-instance 'owl))
MAYBE

     Это может вызвать некоторую путаницу, поэтому мы можем сделать такой слот
доступным только для чтения. Когда мы определяем функцию доступа для слота, мы
создаем способ чтения и записи значения слота. Если мы хотим, чтобы значение было
читаемым, но не доступным для записи, мы можем сделать это, предоставив слоту только
функцию чтения, а не полноценную функцию доступа:

(defclass owl ()
  ((nocturnal :reader owl-nocturnal
                      :initform t
                      :allocation :class)))

Тепарь попытки изменить слот nocturnal для экземпляра приведут к генерации ошибки:

> (setf (owl-nocturnal (make-instance 'owl)) nil)
>>Error: The function (SETF OWL-NOCTURNAL) is undefined.

@node 25-4 Methods, 25-5 Auxiliary Methods and Combination, 25-3 Classes and Instances, 25 Object-Oriented Lisp
@comment  node-name,  next,  previous,  up
@section 25-4 Методы
@cindex 25-4 Methods

Наш набросок подчеркивал сходство между слотами и методами в языке, которые 
предоставляет лексические замыкания. В нашей программе основной/первичный метод
хранился и наследовался так же, как и значения слота. Единственная разница
между слотом и методом заключалась в том, что определение имени как слота

(defprop area)

делало area функцией, которая будет просто извлекать и возвращаеть значение,
определяя его как метод

@lisp
(defprop area t)
@end lisp

делало area функцией, которая после получения значения, вызывась бы (funcall)
с этим аргументом.

       В CLOS функциональные блоки по прежнему называются методами, и их можно определить
так, чтобы каждый из них казался свойством некоторого класса. Здесь мы определяем метод
area для класса circle:

@lisp
(defmethod area ((c circle))
  (* pi (expt (circle-radius c) 2)))
@end lisp

Список параметров для этого метода говорит, что это функция одного аргумента, которая
применяется к экземплярам класса circle.

       Мы вызываем этот метод как функцию, как в нашем наброске:

@example
> (area (make-instance 'circle :radius 1))
3.14...
@end example

Мы также можем определить методы, которые принимают дополнительные аргументы:

@lisp
(defmethod move ((c circle) dx dy)
  (incf (car (circle-center c)) dx)
  (incf (cdr (circle-center c)) dy)
  (circle-center c))
@end lisp

Если мы вызовем этот метод для экземпляра circle, его центр(center) будет сдвинут на
 dx,dy :

> (move (make-instance 'circle :center '(1 . 1)) 2 3)
(3.4)

Значение возвращаемое методом, отражает новую позицию circle.
   Как и в нашем наброске, если есть метод для экземпляра класса, и для суперкласса
этого класса, запускается самый конкретный метод. Так что, если unit-circle это
подкласс circle, со следующим методом area

@lisp
(defmethod area ((c unit-circle)) pi)
@end lisp

тогда этот метод, а не более общий, будет выполняться, когда мы вызовем area
для экземпляра unit-circle.
   Когда у класса несколько суперклассов, их приоритет идет слева на право. 
Определив класс patriotic-scoundrel следующим образом

@lisp
(defclass scoundrel nil nil)
(defclass patriot nil nil)
(defclass patriotic-scoundrel (scoundrel patriot) nil)
@end lisp

мы уточняем, что патриотичные негодяи(patriotic scoundrels) являются сначала негодяями
(scoundrels), а потом патриотами(patriots). Когда есть подходящий метод для обоих
суперклассов,

@lisp
(defmethod self-or-country? ((s scoundrel))
  'self)

(defmethod self-or-country? ((p patriot))
  'country)
@end lisp

будет выполняться метод класса негодяев(scoundrel):

> (self-or-country? (make-instance 'patriotic-scoundrel))
SELF

   Пока приведенные примеры поддерживают иллюзию, что методы CLOS являются методами
некоторого объекта. На самом деле они являются чем-то более общим. В списке параметров
метода move, элемент (c circle) называется особенным(специализированным) параметром; он
говорит, что этот метод применяется когда первый аргумент для move является экземпляром
класса circle. В методе CLOS, может быть специализировано более одного параметра.
Следующий метод имеет два специализированных и один не обязательный не специализированный
параметр:

@lisp
(defmethod combine ((ic ice-cream) (top topping)
                               &optional (where :here))
   (append (list (name ic) 'ice-cream)
                   (list 'with (name top) 'topping)
                   (list 'in 'a
                         (case where
                             (:here 'glass)
                             (:to-go 'styrofoam))
                         'dish)))
@end lisp
Он вызывается, когда первые два аргумента, которые нужно объединить, являются
экземплярами ice-cream(мороженное) и topping(начинка), соответственно. Если
мы определим некоторые минимальные классы для создания экземпляров
@lisp
(defclass stuff () ((name :accessor name :initarg :name)))
(defclass ice-cream (stuff) nil)
(defclass topping (stuff) nil)
@end lisp
тогда мы сможем определить и запустить этот метод:
> (combine (make-instance 'ice-cream :name 'fig)
                   (make-instance 'topping :name 'olive)
                   :here)
(FIG ICE-CREAM WITH OLIVE TOPPING IN A GLASS DISH)
       Когда методы специализируются более чем одним из их параметров, трудно
продолжать рассматривать их как свойства классов. Наш метод combine относиться
к классу ice-cream или классу topping? В CLOS модель объектнов, отвечающих на
сообщения, просто испаряется. Эта модель кажеться естественной, пока мы вызываем
методы, говоря что-то вроде:

(tell obj 'move 2 3)

Здесь мы явно вызваем метод move объекта obj. Но как только мы отбросим этот
синтаксис в пользу функционального эквивалента:

@lisp
(move obj 2 3)
@end lisp

тогда мы имеем определениеe move, такое что его поведение диспетчеризируется в 
зависимости от первого аргумента, т.е. просматривает первый аргумент и вызывает
соответствующий метод.

После того, как мы сделали этот шаг, возникает вопрос: почему разрешается проводить
диспетчеризацию только по первому аргументу? CLOS отвечает: действительно, почему? В CLOS, 
методы могут специализироваться любым количеством своих параметров - и не только на
определяемых пользователем классах, но и на типах Common Lisp,@footnote{Или точнее, на
типах подобных классам, которые определяет CLOS параллельно с иерархией типов Common Lisp.} 
и даже на отдельных объектах. Вот метод combine который применяется к строкам(string):

@lisp
(defmethod combine ((s1 string) (s2 string) &optional int?)
   (let ((str (concatenate 'string s1 s2)))
        (if int? (intern str) str)))
@end lisp

Это означает не только то, что методы больше не являются свойствами классов, но
и то, что мы можем использовать методы вообще без определения классов.

> (combine "I am not a " "cook.")
"I am not a cook."

Здесь второй параметр специализируется символом palindrome(палиндром):

@lisp
(defmethod combine ((s1 sequence) (x (eql 'palindrome))
                                   &optional (length :odd))
   (concatenate (type-of s1)
                          s1
                          (subseq (reverse s1)
                                        (case length (:odd 1) (:even 0)))))
@end lisp

Этот конкретный метод делает палиндромы последовательностей любого вида: 
@footnote{В одной(в остальном очень хорошей) реализации Common Lisp, concatenate 
не принимает cons в качестве первого аргумента, поэтому там этот вызов работать не будет.}

> (combine '(able was i ere) 'palindrome)
(ABLE WAS I ERE I WAS ABLE)

     Здесь у нас больше нет объектно-ориентированного программирования. а есть 
нечто большее. CLOS разработан с пониманием того, что под методами существует
такая концепция диспетчеризации(распределения вызовов), которая может быть сделана
для более чем одного аргумента и может основываться больше чем на классе аргументов.
Когда методы построены на этом более общем понятии, они становятся независимыми от
отдельных классов. Вместо того, чтобы концептуально придерживаться классов, методы
теперь придерживаются других методов с теми же именами. В CLOS такой набор методов
называется обобщенной/родовой/общей функцией(generic function). Все наши методы 
combine неявно определяют обобщенную функцию combine.

     Мы можем определить обобщенные функции явно с помощью макроса defgeneric. Нет
необходимости вызывать defgeneric для определения обобщенной функции, но оно может
быть удобным местом для размещения документации или какой-то защитной сеткой от
ошибок. Здесь мы делаем обе вещи:

@lisp
(defgeneric combine (x y &optional z)
   (:method (x y &optional z)
         "I can't combine these arguments.")
   (:documentation "Combines things."))
@end lisp

Поскольку метод, указанный здесь для объединения, не специализирует ни один из
его аргументов, он будет вызываться в том случае, если ни один другой метод 
не применим.

@example
> (combine #'expt "chocolate")
"I can't combine these arguments."
@end example

Ранее, этот вызов вызывал бы ошибку.

Обобщенные функции накладывают одно ограничение, которого у нас небыло, когда
методы являлись свойствами объектов: когда все методы с одинаковым именем объединяются
в одну обобщенную функцию, их списоки параметров должны быть согласованы. Вот почему
все наши методы combine имеют дополнительный необязательный параметр. После определения
первого метода combine, который может принимать до трех аргументов, это вызвало бы ошибку,
если бы мы попытались определить другой метод, который бы принимал только два параметра.

CLOS требует, чтобы списки параметров всех методов с одинаковыми именами были
конгруэнтными(соответствующими). Два списка параметров являются соответствующими,
если они имеют одинаковое количество обязательных параметров, одинаковое количество
необязательных параметров и совместимое использование &rest и &key. Фактические
параметры ключевые слова, принимаемые различными методами, не обязательно должны
быть одинаковыми, но defgeneric может настаивать на том, что все его методы
принимают определенный минимальный набор. Следующие пары списков параметров
являются конгруэнтными(соответствующими):

@example
(x)                     (a)
(x &optional y) (a &optional b)
(x y &rest z)           (a b &rest c)
(x y &rest z)           (a b &key c d)
@end example

@noindent
а следующие пары таковыми не являются:

@example
(x)                     (a b)
(x &optional y) (a &optional b c)
(x &optional y) (a &rest b)
(x &key x y)            (a)
@end example

Переопределение методов аналогично переопределению функций. Поскольку специализироваными
могут быть только обязательные параметры, каждый метод уникально идентифицируется
своей обобщенной функцией и типами его обязательных параметров. Если мы определяем другой
метод с теми же специализациями, он перезаписывает исходный. Итак, сказав:

@lisp
(defmethod combine ((x string) (y string)
                               &optional ignore)
  (concatenate 'string x "+"y))
@end lisp

@noindent
мы переопределяем то, что combine делает, когда два первых аргумента являются
строками(string).

К сожалению, если вместо переопределения метода мы хотим удалить его, встроенной
функции обратной defmethod - нет. К счастью, это Lisp, поэтому мы можем его написать

@cartouche
@lisp
 (defmacro undefmethod (name &rest args)
    (if (consp (car args))
         (udm name nil (car args))
         (udm name (list (car args)) (cadr args))))

 (defun udm (name qual specs)
    (let ((classes (mapcar #'(lambda (s)
                                       `(find-class ',s))
                                    specs)))
        `(remove-method (symbol-function ',name)
                            (find-method (symbol-function ',name)
                                               ',qual
                                               (list ,@@classes)))))
@end lisp

                  Рисунок 25-12: Макрос для удаления методов.
@end cartouche

@noindent
Детали того, как можно удалить метод в ручную, приведены в реализации
undefmethod на Рисунке 25-12. Мы используем этот макрос, передавая аргументы
аналогичные тем, котоыре мы передаем в defmethod, за исключением того, что вместо
того, чтобы передавать полный списко параметров в качестве второго и третьего
аргументов, мы передаем просто названия классов требуемых параметров. Итак,
чтобы удалить метод combine для двух строк(string), мы скажем:

@lisp
(undefmethod combine (string string))
@end lisp

Неспециализированные аргументы неявно относятся к классу  t, поэтому, если бы мы
определили метод с обязательными, но неспециализированными параметрами:

@lisp
(defmethod combine ((fn function) x &optional y)
  (funcall fn x y))
@end lisp

мы бы могли избавиться от него, сказав

@lisp
(undefmethod combine (function t))
@end lisp

Если мы хотим удалить всю обобщенную функцию, мы можем сделать это так же, как
мы бы удаляли определение любой функции, вызывав fmakunbound:

@lisp
(fmakunbound 'combine)
@end lisp

@node 25-5 Auxiliary Methods and Combination, 25-7 When to Object, 25-4 Methods, 25 Object-Oriented Lisp
@comment  node-name,  next,  previous,  up
@section 25-5 Вспомогательные Методы и Комбинации
@cindex 25-5 Auxiliary Methods and Combination

Вспомогательные методы работали в нашем наброске в основном так же как они 
работаю и в CLOS. До сих пор мы видели только первичные методы, но у нас
также могут быть методы before-, after- и around-. Такие вспомогательные
методы определяются путем добавления ключевого слова после имени метода в
вызове defmethod. Если мы определим первичный метод speak для класса
speaker следующим образом:

@lisp
(defclass speaker nil nil)

(defmethod speak ((s speaker) string)
  (format t "~A" string))
@end lisp

Затем вызов speak с экземпляром speaker просто напечатает второй аргумент:

> (speak (make-instance 'speaker)
            "life is not what it used to be")
life is not what it used to be
NIL

Определим подкласс intellectual, который оборачивает методы before- и after-
вокруг первичного метода speak,

@lisp
(defclass intellectual (speaker) nil)

(defmethod speak :before ((i intellectual) string)
  (princ "Perhaps "))

(defmethod speak :after ((i intellectual) string)
  (princ " in some sense"))
@end lisp

мы можем создать подкласс ораторов(speakers), у которых всегда есть последнее (и первое)
слово:

> (speak (make-instance 'intellectual)
            "life is not what it used to be")
Perhaps life is not what it used to be in some sense
NIL

В стандартной комбинации методов, методы вызываются так, как описано в нашем наброске%
все методы before-, сначала наиболее конкретные, затем наиболее конкретный первичный
метод, затем все методы after, где самый конкретный вызывается последним. Поэтому, если
мы определим методы before- или after- для суперкласса speaker,

@lisp
(defmethod speak :before ((s speaker) string)
  (princ "I think "))
@end lisp

они будут вызваны в середине "сендвича" из методов:

> (speak (make-instance 'intellectual)
            "life is not what it used to be")
Perhaps I think life is not what it used to be in some sense
NIL

Независимо от того, что вызываются методы before- или after-, значение возвращаемое
обобщенной функцией будет значением наиболее конкретного первичного метода - в данном
случае nil возвращаемый функцией format.
   Оно измениться если есть методы around-. Если у одного из классов в семейном дереве
объектов есть метод around- или точнее, если есть метод  around- специализированный для
аргументов передаваемых в обобщенную функцию- сначала будет вызван метод around-, а
остальные методы будут выполняться только в том случае, если метод around- решит ими
воспользоваться. Как и в нашем наброске, метод around- или primary(первичный) может
вызвать следующий метод вызывав функцию: функцию, которую мы определили как call-next 
в CLOS называется call-next-method. Существует также next-method-p, аналог нашего
next-p. С помощью методов around- мы можем определить другой подкласс speaker, который
является более осмотрительным:

@lisp
(defclass courtier (speaker) nil)

(defmethod speak :around ((c courtier) string)
  (format t "Does the King believe that ~A? " string)
  (if (eq (read) 'yes)
        (if (next-method-p) (call-next-method))
        (format t "Indeed, it is a preposterous idea.~%"))
  'bow)
@end lisp

Когда первым аргументом для speak является экземпляр класса courtier, язык
придворного(courtier) теперь защищен методом around-:

> (speak (make-instance 'courtier) "kings will last")
Does the King believe that kings will last? yes
I think kings will last
BOW
> (speak (make-instance 'courtier) "the world is round")
Does the King believe that the world is round? no
Indeed, it is a preposterous idea.
BOW

Обратите внимание, что в отличии от методов before- и after-, значение возвращаемое
методом around-, возвращается как значение обобщенной функции.

Как правило, методы выполняются, как показано в этой схеме, которая перепечатана
из раздела 25-2:

   1. . Наиболее конкретный метод around- если он есть.

   2. Иначе, в порядке:

          (a) Все методы before-, от наиболее конкртетных до наименее конкретных.
          (b) Наиболее конкретный первичный метод (то что мы привыкли вызывать).
          (c) Все методы after-, от наименее конкретных до наиболее конкретных.

Этот способ объединения методов называется стандартным. Как и в нашем наброске,
можно определять методы которые комбирируются другими способами:
например, для обобщенной функции возвращать сумму всех применимых первичных
методов.

В нашей программе, мы указали, как объединять методы, вызывая defcomb.
По умолчанию, методы будут объединяться как в приведенной выше схеме,
но скажем, например,

@lisp
(defcomb price #'+)
@end lisp

@noindent
мы могли бы заставить функцию price возвращать сумму всех применимых первичных
методов.

В CLOS это называется комбинацией операторных методов. Как и в нашей программе,
такая комбинация методов, может быть понята так, как если бы она приводила к 
вычислепнию выражения Lisp, первым элементом которого был бы некоторый оператор,
аргументы которого были бы вызовами соответствующих первичных методов, в порядке
конкретизации. Если мы определили обобщенную функцию price для объединения
значений с помощью +, и небыло бы применимых методов around-, она будет вести себя
так, как если бы она была определена:

@lisp
(defun price (&rest args)
  (+ (apply  most specific primary method  args)
         ...(apply  leastspecificprimarymethod  args)))
@end lisp

Если существуют применимые методы around-, они имеют приоритет, как в стандартной
комбинации методов. В комбинации с операторным методом, метод around- может вызывать
следующий метод через call-next-method. Однако первичные методы больше не могут
испольовать call-next-method. (Это отличие от нашего наброска, где мы оставляли
call-next доступным для таких методов.)

В CLOS, мы можем указать тип комбинации методов, который будет использоваться
обобщенной функцией, указав необязательный аргумент :аргумент method-combination 
для defgeneric:

@lisp
(defgeneric price (x)
  (:method-combination +))
@end lisp

Теперь метод price будет использовать + для комбинации методов. Если мы определим
некоторые классы с prices,

@lisp
(defclass jacket nil nil)
(defclass trousers nil nil)
(defclass suit (jacket trousers) nil)

(defmethod price + ((jk jacket)) 350)
(defmethod price + ((tr trousers)) 200)
@end lisp

@noindent
затем, когда мы запрашиваем price для экземпляра suit, мы получаем сумму применимых
методов price:

> (price (make-instance 'suit))
550

Следующие символы могут использоваться в качестве второго аргумента для defmethod или
в опции :method-combination для defgeneric:

    +      and     append      list       max     min    nconc    or    progn

Вызывая define-method-combination вы можете определить другие виды
комбинации методов, см. CLTL2, p. 830.

После указания метода комбинации, который должна использовать обобщенная функция,
все методы для этой функции должны использовать один и тоже вид. Теперь это
вызовет ошибку, если мы попытаемся испольовать другой оператор (или :before 
или :after) в качестве второго аргумента в defmethod для price. Если мы хотим
изменить комбинацию методов price мы должны удалить всю обобщенную функцию,
вызывав fmakunbound.

@section 25-6 CLOS и Lisp
@cindex 25-6 CLOS and Lisp

CLOS является хорошим примером встроенного языка. Такая программа обычно приносит
двойную выгоду:

   1. Встраиваемые языки могут быть концептуально хорошо интегрированы с их средой,
      так что в рамках встроенного языка мы можем продолжать думать о программах во
      многом в тех же терминах.

   2. Встроенные языки могут быть мощными. потому что они используют все то,
      что базовый язык уже знает как делать.

CLOS побеждает по обоим пунктам. Он очень хорошо интегрирован с Lisp, и он хорошо
использует абстракции, которые уже есть в лиспе.  Действительно, мы часто можем
видеть Lisp через CLOS, также как, мы можем видеть форму объектов через листы,
покрывающие их.

Не случайно мы говорим с CLOS через слой макросов. Макросы выполняют преобразование.
а CLOS по сути, программа, которая берет программы построенные из объектно-ориетированных
абстракций и переводит их в программы, построенные из абстракций Lisp.

Как и предполагалось в первых двух разделах, абстракции объектно-ориентированного
программироания настолько аккуратно отображаются на абстракции Lisp, что практически
можно первые назвать частным случаем последнего. Объекты объектно-ориентированного
программирования легко могут быть реализованы как объекты Lisp, а их методы - как
лексические замыкания. Используя преимущество таких изоморфизмов, мы смогли
представить элементарную форму объектно ориентированного программирования всего в
нескольких строках кода, и эскиз CLOS на нескольких страницах.

CLOS намного крупнее и мощнее нашего эскиза, но не настолько велик, чтобы скрывать
свои корни как встроенного языка. Возьмите defmethod в качестве примера.
Хотя CLTL2 не упоминает это явно, методы CLOS обладают всей силой лексических
замыканий. Если мы определим несколько методов в рамках некоторой переменной,

@lisp
(let ((transactions 0))
  (defmethod withdraw ((a account) amt)
        (incf transactions)
        (decf (balance a) amt))
  (defmethod deposit ((a account) amt)
        (incf transactions)
        (incf (balance a) amt))
  (defun transactions ()
        transactions))
@end lisp

тогда во время выполнения они будут иметь доступ к переменной, как замыкания. Методы
могут сделать это, потому что под синтаксисом они являются замыканиями. В расширении
defmethod, его тело окажеться целиком в теле заквотированного с решёткой ('#) лямбда
выражения.

В разделеn 7-6 предполагается, что проще понять, как работают макросы, чем то,
что они имеют в виду. Аналогично, секрет понимания CLOS заключается в том, чтобы
понять как он отображается на фундаментальные абстракции Lisp.

@node 25-7 When to Object,  , 25-5 Auxiliary Methods and Combination, 25 Object-Oriented Lisp
@comment  node-name,  next,  previous,  up
@section 25-7 Когда использовать Объекты
@cindex 25-7 When to Object

Объектно-ориентированный стиль обеспечивает несколько явных преимуществ. Разные
программы нуждаются в этих преимуществах в разной степени. На одном конце
континуума находяться программы, например симуляторы, которые наиболее естественным
образом выражаются в абстракциях объектно-ориентированного программирования. На другом
конце программы написанные в объектно-ориентированном стиле, главным образом, чтобы
сделать их расширяемыми.

Расширяемость действительно является одним из больших преимуществ объектно-
ориентированного стиля. Вместо того, чтобы быть единым монолитным блоком кода,
программа написана небольшими кусочками, каждый из которых помечен своей целью.
Поэтому позже, когда кто-то захочет изменить программу, будет легко найти ту часть,
которую необходимо изменить. Если мы хотим изменить способ отображения объектов
типа ob на экране, мы изменим метод отображения(display) класса ob. Если мы хотим
создать новый класс объектов подобных ob, но отличающихся от него в нескольких
отношениях, мы можем создать подкласс ob; в подклассе мы поменяем нужные нам свойства,
а все остальное по умолчанию наследуется от класса ob. И если мы просто хотим создать
один объект ob, который ведет себя не так как остальные, мы можем создать новый дочерний 
объект ob и напрямую изменить его свойства. Если программа была тщательно написана
с самого начала, мы можем внести все эти типы изменний, дже не глядя на остальную
часть кода. С этой точки зрения объектно-ориентированная программа - это программа
организованная как таблица: мы можем быстро и безопасно изменить ее, посмотрев 
соответствующую ячейку.

Расширяемость требуется меньше всего от объектно-ориентированного стиля. Фактически,
она требует так мало, что расширяемая программа вообще не должна быть объектно-
ориентированной. Если в предыдущих главах и было чтот-то показано, то оно показало
что программы на Lisp не обязательно являются монолитными блоками. Lisp предлагает
целый ряд возможностей для расширения. Например, вы могли бы буквально иметь программу
организованную как таблица: программу, состоящую из набора замыканий, хранящихся в
массиве.

Если вам нужна расширяемость, вам не нужно выбирать между "объектно-
ориентированной" и "традиционной" программой. Вы можете дать программе на Lisp
именно ту степень расширямости, в которой она нуждается, часто не прибегая к
объектно ориентированным техникам. Слот в классе это глобальная переменная. И также,
как некрасиво использовать глобальную переменную, там где вы могли использовать
параметр, также неэлегантно создавать мир классов и экземпляров, когда вы могли бы
сделать тоже самое с меньшими усилиями в простом Lisp. С добавлением CLOS, Common 
Lisp стал самым мощным используемым широкорасространненым объектно ориентированным 
языком. По иронии судьбы, это также язык, в котором объектно-ориентированное 
программирование наименее необходимо.

@node Appendix Packages, Notes, 25 Object-Oriented Lisp, Top
@comment  node-name,  next,  previous,  up
@chapter Приложение: Пакеты
@cindex Appendix Packages

Пакеты - это способ Common Lisp группировать код в модули. Ранние диалекты Lisp 
содержали таблицу символов, называемую oblist, в которой перечислялись все символы,
которые до сих пор прочитала система. Через ввод символа в oblist, система получала
доступ к таким вещам как его значение и список свойств. Указанный в oblist символ,
как говорят, был интернирован(interned).

Недавние диалекты Lisp разделили концепцию oblist на несколько пакетов. Теперь
символ нре просто интернирован, но иинтернирован в определенном пакете. Пакеты
поддерживают модульность, потому что символы, содержащиеся в одном пакете, доступны
в других пакетах(за исключением читерства(cheating)) только если они явно объявлены
таковыми.

Пакет - это своего рода объект Lisp. Текущий пакет всегда храниться в глобальной
переменной *package*. Когда запускается Common Lisp, текущим пакетом будет 
пользовательский пакет: либо user (в реализации CLTL1), либо common-lisp-user 
(в реализации CLTL2).

Пакеты обычно идентифицируются по их именам, которые являются строками. Чтобы найти
имя текущего пакета, попробуйте:

> (package-name *package*)
"COMMON-LISP-USER"
   Обычно прочитанный символ помещается  в пакет, который был текущим на момент 
его прочтения. Чтобы определить пакет, в который помещается символ, мы можем 
использовать symbol-package:
> (symbol-package 'foo)
#<Package "COMMON-LISP-USER" 4CD15E>

Возвращаемое здесь значение - фактический объект пакета. Для использования в будущем,
давайте дадим foo значение:

> (setq foo 99)
99

Вызвав in-package мы можем переключиться на новый покет, создав его, если это
необходимо(создать можно с помощью команды (defpackage :mine  (:use :common-lisp)):
@footnote{В старых реализациях Common Lisp, опустите аргумент :use.}

> (in-package 'mine :use 'common-lisp)
#<Package "MINE" 63390E>

В этой точке должна быть жуткая музыка, потому что мы находимся в другом мире: foo
здесь не то что раньше.

MINE> foo
>>Error: FOO has no global value.

Почему это случилось? Поскольку foo, который мы выше установили в 99, является
отличающимся символом от foo в  mine.@footnote{Некоторые реализации Common Lisp 
печатаю имя пакета перед запросом верхнего уровня всякий раз, когда мы не находимся
в пользовательском пакете. Это не обязательно, но приятно.} Чтобы обратиться к
оригинальному foo извне пользовательского пакета, мы должны поставить префикс
имени пакета и двух двоеточий:

MINE> common-lisp-user::foo
99

Таким образом, разные символы с одинаково печатающимися именами могут сосуществовать
в разных пакетах. Может быть один foo в пакете common-lisp-user и другой foo в
пакете mine, и они будут разными символами. На самом деле, в этом и заключается суть
пакетов: если вы пишете свою программу в отдельном пакете, вы можете выбирать имена
для своих функций и переменных, не беспокоясь о том, что кто-то будет использовать
то же имя для чего-то другого. Даже если они используют одно и тоже имя, это не будет
одним и тем же символом.

Пакеты также пердоставляют средства сокрытия информации. Программы должны ссылаться
на функции и переменные по их именам. Если вы не делаете данное имя доступным за
пределами вашего пакета, маловероятно, что код в другом пакете сможет использовать
или изменить то, на что оно ссылается.

В программах обычно плохо использовать префиксы пакетов с двойными двоеточиями.
Тем самым вы нарушаете модульность, которую должны предоставлять пакеты. Если вам
нужно использовать двойное двоеточие для обозначения символа, это происходит потому,
что кто-то не хочет чтобы вы это делали.

Обычно следует ссылаться только на символы, которые были экспортированы. Экспортируя
символ из пакета, в котором он находиться, мы делаем его видимым для других пакетов.
Чтобы экспортировать символ, мы  вызываем (как вы уже догадались) export:

@example
MINE> (in-package 'common-lisp-user)
#<Package "COMMON-LISP-USER" 4CD15E>
> (export 'bar)
T> (setq bar 5)
5
@end example

Теперь, когда мы вернемся к пакету mine, мы можем сослаться на bar только с
одним двоеточием, потому что это общедоступное имя:

@example
> (in-package 'mine)
#<Package "MINE" 63390E>
MINE> common-lisp-user:bar
5
@end example

Импортируя(importing) bar в mine мы можем сделать еще один шаг, и сделать так,
чтобы mine фактически поделилась символом bar с пакетом пользователя:

MINE> (import 'common-lisp-user:bar)
TMINE> bar
5

После импорта bar мы можем ссылаться на него без какого либо спецификатора пакета.
Два пакета теперь имеют один и тот же символ; здесь уже нет отдельного mine:bar.

Что если такой символ уже был? В этом случае, вызов import вызвал бы ошибку,
какую мы видим попытавшись имппортировать foo:

MINE> (import 'common-lisp-user::foo)
>>Error: FOO is already present in MINE.

Раньше, когда мы безуспешно пытались вычислить foo в mine, мы тем самым вызывали
интернирование туда символа foo. Он не имел глобального значения, и следовательно,
генерировал ошибку, но интернирование происходило просто как следствие ввода его
имени. Так что теперь, когда мы пытаемся импортировать foo в mine, там уже есть
символ с тем же именем.

Мы также можем импортировать символы массово, определив один пакет для использования другим:

MINE> (use-package 'common-lisp-user)
T

Теперь все символы экспортируемые пользовательским пакетом будут автоматически
импортированы mine. (Если бы foo был экспортирован пользовательским пакетом, этот
вызов также бы вызвал ошибку.)

Начиная с CLTL2, пакет, содержащий имена встроенных операторов и переменных, 
называется common-lisp вметос lisp, и новые пакеты больше не используют его
по умолчанию. Так как мы использовали этот пакет в вызове in-package, который
создал mine, все имена Common Lisp будут видны здесь:

MINE> #'cons
#<Compiled-Function CONS 462A3E>

Вы практически вынуждены заставлять любой новый пакет использовать common-lisp 
(или какой либо другой пакет содержащий операторы Lisp). Иначе вы бы даже не
смогли выбраться из нового пакета.

Как и в случае компиляции, операции над пакетами обычно не выполняются на таком
верхнем уровне как этот. Чаще всего вызовы содержаться в исходныхs файлах. Обычно
достаточно начать файл с in-package и defpackage. (Макрос defpackage является
новым в CLTL2, но некоторые более старые реализации предоставляют его.)
Вот что вы пожете поместить в начало файла, содержащего отдельный пакет кода:

(in-package 'my-application :use 'common-lisp)

(defpackage my-application
                  (:use common-lisp my-utilities)
                  (:nicknames app)
                  (:export win lose draw))

Это приведет к тому, что код в файле- или точнее, имена в файле- будут в пакете
my-application. Этот пакет использует как common-lisp, так и  my-utilities, поэтому
любые экспортируемые символы могут появиться без префикса пакета в этом файле.

Сам пакет my-application экспортирует только три символа: win, lose,
и draw. Поскольку вызов in-package дал my-application прозвище
app, код в других пакетах будет ссылаться на них как, например app:win.

Тип модульности, предоставляемый пакетами, на самом деле немного странный. У нас
есть модули не объектов, а имен. Каждый пакет, который использует common-lisp
импортирует имя cons, потому что common-lisp включает функцию с этим именем. Но
в результате переменная с именем cons также будет видна в каждом пакете который
использует common-lisp. И то же самое относиться к другим пространствам имен
Common Lisp. Если пакеты сбивают с толку, это основная причина; они основаны не
на объектах, а на именах.

Вещи имеющие отношение к пакетам, обычно проихсодят во время чтения, а не
во время выполнения, что может привести к некоторой путанице. Вторым
выражением мы наберем:

(symbol-package 'foo)

вернет значение, которое он прочитал, поскольку чтение запроса создало ответ. Чтобы 
выполнить это выражение, Lisp должен прочитать его, что означает интернирование foo.

В качестве другого примера рассмотрим этот обмен, который появился выше:

MINE> (in-package 'common-lisp-user)
#<Package "COMMON-LISP-USER" 4CD15E>
> (export 'bar)

Обычно два выражения введенные в верхнем уровне эквивалентны тем же двум выражениям,
заключенным в progn. Дело, не в этом. Если мы попробуем сказать

MINE> (progn (in-package 'common-lisp-user)
                 (export 'bar))
>>Error: MINE::BAR is not accessible in COMMON-LISP-USER.

вместо этого мы получаем ошибку. Это происходит потому, что перед вычислением
все выражения progn обрабатываются чтением(read). Когда вызывается read, 
текущий пакет mine, поэтому принятый bar считается mine:bar. Это как если бы
мы попросили экспортировать данный символ вместо common-lisp-user:bar, из
пакета пользователя.

То как определяются пакеты создает неудобства при написании программ, которые
используют символы в качестве данных. Например, если мы определим noise следующим
образомs:

(in-package 'other :use 'common-lisp)
(defpackage other
                (:use common-lisp)
                (:export noise))

(defun noise (animal)
  (case animal
       (dog 'woof)
       (cat 'meow)
       (pig 'oink)))

тогда если мы будем вызывать noise из другого пакета с неквалифицированным символом
(без указания пакета символа) в качестве аргумента, он обычно будет попадать в 
конец предложений case и возвращать nil:

OTHER> (in-package 'common-lisp-user)
#<Package "COMMON-LISP-USER" 4CD15E>
> (other:noise 'pig)
NIL

Это происходит потому, что то что мы передали в качестве аргумента, было
common-lisp-user:pig(без обид), в то время как ключом для выражения case является
other:pig. Чтобы noise работал так как следовало ожидать, мы должны экспортировать
все шесть символов используемых в нем, и импортировать их в любой пакет, из которого
мы собираемся вызывать noise.

В этом случае, мы можем избежать проблем, используя ключевые слова вместо обычных
симолов. Если noise был определен

(defun noise (animal)
  (case animal
        (:dog :woof)
        (:cat :meow)
        (:pig :oink)))

тогда мы можем смело вызывать его из любого пакета:

@example
OTHER> (in-package 'common-lisp-user)
#<Package "COMMON-LISP-USER" 4CD15E>
> (other:noise :pig)
:OINK
@end example

Ключевые слова как золото, универсальные и само вычисляемые. Они видны повсюду, и 
их никогда не нужно цитировать(квотировать). Функция управляемая символами такая как
defanaph (стр. 223) почти всеугда должна быть написана с использованием ключевых слов.

Пакеты являются богатым источником путаницы. Это введение в предмет едва приподняло
завесу тайны. Все поднобности, см. CLTL2, Chapter 11.

@node Notes, Book's Index, Appendix Packages, Top
@comment  node-name,  next,  previous,  up
@chapter Замечания
@cindex Notes

This section is also intended as a bibliography. All the books and papers listed here should
be considered recommended reading.

    v Foderaro, John K. Introduction to the Special Lisp Section. CACM 34, 9 (September
       1991), p. 27.
  viii The final Prolog implementation is 94 lines of code. It uses 90 lines of utilities from
       previous chapters. The ATN compiler adds 33 lines, for a total of 217. Since Lisp
       has no formal notion of a line, there is a large margin for error when measuring the
       length of a Lisp program in lines.
   ix Steele, Guy L., Jr. Common Lisp: the Language, 2nd Edition. Digital Press, Bedford
       (MA), 1990.
    5 Brooks, Frederick P. The Mythical Man-Month. Addison-Wesley, Reading (MA),
       1975, p. 16.
   18 Abelson, Harold, and Gerald Jay Sussman, with Julie Sussman. Structure and
       Interpretation of Computer Programs. MIT Press, Cambridge, 1985.
   21 More precisely, we cannot define a recursive function with a single lambda-expression.
       We can, however, generate a recursive function by writing a function to take itself
       as an additional argument,

       (setq fact
               #'(lambda (f n)
                        (if (= n 0)
                               1(* n (funcall f f (- n 1))))))
       and then passing it to a function that will return a closure in which original function
       is called on itself:

       (defun recurser (fn)
         #'(lambda (&rest args)
                (apply fn fn args)))

       Passing fact to this function yields a regular factorial function,

       > (funcall (recurser fact) 8)
       40320

       which could have been expressed directly as:

       ((lambda (f) #'(lambda (n) (funcall f f n)))
        #'(lambda (f n)
                (if (= n 0)
                       1(* n (funcall f f (- n 1))))))
       Many Common Lisp users will find labels or alambda more convenient.
  23 Gabriel, Richard P. Performance and Standardization. Proceedings of the First
       International Workshop on Lisp Evolution and Standardization, 1988, p. 60.
       Testing triangle in one implementation, Gabriel found that "even when the C
       compiler is provided with hand-generated register allocation information, the Lisp
       code is 17% faster than an iterative C version of this function." His paper mentions
       several other programs which ran faster in Lisp than in C, including one that was
       42% faster.
  24 If you wanted to compile all the named functions currently loaded, you could do it
       by calling compall:
       (defun compall ()
         (do-symbols (s)
            (when (fboundp s)
                (unless (compiled-function-p (symbol-function s))
                  (print s)
                  (compile s)))))
       This function also prints the name of each function as it is compiled.
  26 You may be able to see whether inline declarations are being obeyed by calling
       (disassemble 'foo), which displays some representation of the object code of
       function foo. This is also one way to check whether tail-recursion optimization is
       being done.
  31 One could imagine nreverse defined as:

       (defun our-nreverse (lst)
         (if (null (cdr lst))
                lst
                (prog1 (nr2 lst)
                           (setf (cdr lst) nil))))

                                         NOTES                                      389

   (defun nr2 (lst)
      (let ((c (cdr lst)))
         (prog1 (if (null (cdr c))
                            c(nr2 c))
                    (setf (cdr c) lst))))
43 Good design always puts a premium on economy, but there is an additional reason
   that programs should be dense. When a program is dense, you can see more of it at
   once.
   People know intuitively that design is easier when one has a broad view of one's
   work. This is why easel painters use long-handled brushes, and often step back
   from their work. This is why generals position themselves on high ground, even if
   they are thereby exposed to enemy fire. And it is why programmers spend a lot of
   money to look at their programs on large displays instead of small ones.
   Dense programs make the most of one's field of vision. A general cannot shrink a
   battle to fit on a table-top, but Lisp allows you to perform corresponding feats of
   abstraction in programs. And the more you can see of your program at once, the
   more likely it is to turn out as a unified whole.
   This is not to say that one should make one's programs shorter at any cost. If you
   take all the newlines out of a function, you can fit it on one line, but this does not
   make it easier to read. Dense code means code which has been made smaller by
   abstraction, not text-editing.
   Imagine how hard it would be to program if you had to look at your code on a
   display half the size of the one you're used to. Making your code twice as dense
   will make programming that much easier.
44 Steele, Guy L., Jr. Debunking the "Expensive Procedure Call" Myth or, Procedu-
   ral Call Implementations Considered Harmful or, LAMBDA: The Ultimate GOTO.
   Proceedings of the National Conference of the ACM, 1977, p. 157.
48 For reference, here are simpler definitions of some of the functions in Figures 4-2
   and 4-3. All are substantially (at least 10%) slower:
   (defun filter (fn lst)
      (delete nil (mapcar fn lst)))

   (defun filter (fn lst)
      (mapcan #'(lambda (x)
                       (let ((val (funcall fn x)))
                             (if val (list val))))
                   lst))

   (defun group (source n)
      (if (endp source)
            nil
            (let ((rest (nthcdr n source)))
              (cons (if (consp rest) (subseq source 0 n) source)
                       (group rest n)))))

390                                        NOTES

       (defun flatten (x)
         (mapcan #'(lambda (x)
                              (if (atom x) (mklist x) (flatten x)))
                       x))

       (defun prune (test tree)
         (if (atom tree)
               tree
               (mapcar #'(lambda (x)
                                  (prune test x))
                              (remove-if #'(lambda (y)
                                              (and (atom y)
                                                     (funcall test y)))
                                         tree))))

  49 Written as it is, find2 will generate an error if it runs off the end of a dotted list:

       > (find2 #'oddp '(2 . 3))
       >>Error: 3 is not a list.

       CLTL2 (p. 31) says that it is an error to give a dotted list to a function expecting a
       list. Implementations are not required to detect this error; some do, some don't.
       The situation gets murky with functions that take sequences generally. A dotted
       list is a cons, and conses are sequences, so a strict reading of CLTL would seem to
       require that

       (find-if #'oddp '(2 . 3))

       return nil instead of generating an error, because find-if is supposed to take a
       sequence as an argument.
       Implementations vary here. Some generate an error anyway, and others return nil.
       However, even implementations which follow the strict reading in the case above
       tend to deviate in e.g. the case of (concatenate 'cons '(a . b) '(c . d)),
       which is likely to return (ac.d)instead of (a c).
       In this book, the utilities which expect lists expect proper lists. Those which operate
       on sequences will accept dotted lists. However, in general it would be asking for
       trouble to pass dotted lists to any function that wasn't specifically intended for use
       on them.
  66 If we could tell how many parameters each function had, we could write a version of
       compose so that, in f  g, multiple values returned by g would become the correspond-
       ing arguments to f. In CLTL2, the new function function-lambda-expression
       returns a lambda-expression representing the original source code of a function.
       However, it has the option of returning nil, and usually does so for built-in func-
       tions. What we really need is a function that would take a function as an argument
       and return its parameter list.
  73 A version of rfind-if which searches for whole subtrees could be defined as
       follows:

                                         NOTES                                         391

     (defun rfind-if (fn tree)
       (if (funcall fn tree)
             tree
             (if (atom tree)
                     nil
                     (or (rfind-if fn (car tree))
                            (and (cdr tree) (rfind-if fn (cdr tree)))))))

     The function passed as the first argument would then have to apply to both atoms
     and lists:

     > (rfind-if (fint #'atom #'oddp) '(2 (3 4) 5))
     3> (rfind-if (fint #'listp #'cddr) '(a (b c d e)))
     (B C D E)

 95 McCarthy, John, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, and
     Michael I. Levin. Lisp 1.5 Programmer's Manual, 2nd Edition. MIT Press, Cam-
     bridge, 1965, pp. 70-71.
106 When Section 8-1 says that a certain kind of operator can only be written as a macro,
     it means, can only be written by the user as a macro. Special forms can do everything
     macros can, but there is no way to define new ones.
     A special form is so called because its evaluation is treated as a special case. In an
     interpreter, you could imagine eval as a big cond expression:

     (defun eval (expr env)
       (cond ...
                   ((eq (car expr) 'quote) (cadr expr))
                   ...
                   (t (apply (symbol-function (car expr))
                                (mapcar #'(lambda (x)
                                              (eval x env))
                                        (cdr expr))))))

     Most expressions are handled by the default clause, which says to get the function
     referred to in the car, evaluate all the arguments in the cdr, and return the result of
     applying the former to the latter. However, an expression of the form (quote x)
     should not be treated this way: the whole point of a quote is that its argument is not
     evaluated. So eval has to have one clause which deals specifically with quote.
     Language designers regard special forms as something like constitutional amend-
     ments. It is necessary to have a certain number, but the fewer the better. The special
     forms in Common Lisp are listed in CLTL2, p. 73.
     The preceding sketch of eval is inaccurate in that it retrieves the function before
     evaluating the arguments, whereas in Common Lisp the order of these two operations
     is deliberately unspecified. For a sketch of eval in Scheme, see Abelson and
     Sussman, p. 299.

392                                         NOTES

 115 It's reasonable to say that a utility function is justified when it pays for itself in
       brevity. Utilities written as macros may have to meet a stricter standard. Reading
       macro calls can be more difficult than reading function calls, because they can
       violate the Lisp evaluation rule. In Common Lisp, this rule says that the value of
       an expression is the result of calling the function named in the car on the arguments
       given in the cdr, evaluated left-to-right. Since functions all follow this rule, it is no
       more difficult to understand a call to find2 than to find-books (page 42).
       However, macros generally do not preserve the Lisp evaluation rule. (If one did,
       you could have used a function instead.) In principle, each macro defines its own
       evaluation rule, and the reader can't know what it is without reading the macro's
       definition. So a macro, depending on how clear it is, may have to save much more
       than its own length in order to justify its existence.
 126 The definition of for given in Figure 9-2, like several others defined in this book,
       is correct on the assumption that the initforms in a do expression will be evaluated
       left-to-right. CLTL2 (p. 165) says that this holds for the stepforms, but says nothing
       one way or the other about the initforms.
       There is good cause to believe that this is merely an oversight. Usually if the order
       of some operations is unspecified, CLTL will say so. And there is no reason that
       the order of evaluation of the initforms of a do should be unspecified, since the
       evaluation of a let is left-to-right, and so is the evaluation of the stepforms in do
       itself.
 128 Common Lisp's gentemp is like gensym except that it interns the symbol it creates.
       Like gensym, gentemp maintains an internal counter which it uses to make print
       names. If the symbol it wants to create already exists in the current package, it
       increments the counter and tries again:

       > (gentemp)
       T1
       > (setq t2 1)
       1> (gentemp)
       T3

       and so tries to ensure that the symbol created will be unique. However, it is still
       possible to imagine name conflicts involving symbols created by gentemp. Though
       gentemp can guarantee to produce a symbol not seen before, it cannot foresee what
       symbols might be encountered in the future. Since gensyms work perfectly well
       and are always safe, why use gentemp? Indeed, for macros the only advantage of
       gentemp is that the symbols it makes can be written out and read back in, and in
       such cases they are certainly not guaranteed to be unique.
 131 The capture of function names would be a more serious problem in Scheme, due to
       its single name-space. Not until 1991 did the Scheme standard suggest any official
       way of defining macros. Scheme's current provision for hygienic macros differs
       greatly from defmacro. For details, and a bibliography of recent research on the
       subject, see the most recent Scheme report.

                                          NOTES                                      393

137 Miller, Molly M., and Eric Benson. Lisp Style and Design. Digital Press, Bedford
     (MA), 1990, p. 86.
158 Instead of writing mvpsetq, it would be cleaner to define an inversion for values.
     Then instead of

     (mvpsetq (w x) (values y z) ...)

     we could say

     (psetf (values w x) (values y z) ...)

     Defining an inversion for values would also render multiple-value-setq un-
     necessary. Unfortunately, as things stand in Common Lisp it is impossible to define
     such an inversion; get-setf-method won't return more than one store variable,
     and presumably the expansion function of psetf wouldn't know what to do with
     them if it did.
180 One of the lessons of setf is that certain classes of macros can hide truly enormous
     amounts of computation and yet leave the source code perfectly comprehensible.
     Eventually setf may be just one of a class of macros for programming with
     assertions.
     For example, it might be useful to have a macro insist which took certain ex-
     pressions of the form (predicate . arguments), and would make them true if they
     weren't already. As setf has to be told how to invert references, this macro would
     have to be told how to make expressions true. In the general case, such a macro call
     might amount to a call to Prolog.
198 Gelernter, David H., and Suresh Jagannathan. Programming Linguistics. MIT
     Press, Cambridge, 1990, p. 305.
199 Norvig, Peter. Paradigms of Artificial Intelligence Programming: Case Studies in
     Common Lisp. Morgan Kaufmann, San Mateo (CA), 1992, p. 856.
213 The constant least-negative-normalized-double-float and its three cousins
     have the longest names in Common Lisp, with 38 characters each. The operator
     with the longest name is get-setf-method-multiple-value, with 30.
     The following expression returns a list, from longest to shortest, of all the symbols
     visible in the current package:
     (let ((syms nil))
       (do-symbols (s)
          (push s syms))
       (sort syms
                #'(lambda (x y)
                        (> (length (symbol-name x))
                           (length (symbol-name y))))))
217 As of CLTL2, the expansion function of a macro is supposed to be defined in the
     environment where the defmacro expression appears. This should make it possible
     to give propmacro the cleaner definition:

394                                       NOTES

       (defmacro propmacro (propname)
             `(defmacro ,propname (obj)
                `(get ,obj ',propname)))
       But CLTL2 does not explicitly state whether the propname form originally passed to
       propmacro is part of the lexical environment in which the inner defmacro occurs.
       In principle, it seems that if color were defined with (propmacro color),it
       should be equivalent to:
       (let ((propname 'color))
             (defmacro color (obj)
              `(get ,obj ',propname)))
       or
       (let ((propname 'color))
             (defmacro color (obj)
              (list 'get obj (list 'quote propname))))
       However, in at least some CLTL2 implementations, the new version of propmacro
       does not work.
       In CLTL1, the expansion function of a macro was considered to be defined in the null
       lexical environment. So for maximum portability, macro definitions should avoid
       using the enclosing environment anyway.
 238 Functions like match are sometimes described as doing unification. They don't,
       quite; match will successfully match (f ?x) and ?x, but those two expressions
       should not unify.
       For a description of unification, see: Nilsson, Nils J. Problem-Solving Methods in
       Artificial Intelligence. McGraw-Hill, New York, 1971, pp. 175-178.
 244 It's not really necessary to set unbound variables to gensyms, or to call gensym? at
       runtime. The expansion-generating code in Figures 18-7 and 18-8 could be written
       to keep track of the variables for which binding code had already been generated. To
       do this the code would have to be turned inside-out, however: instead of generating
       the expansion on the way back up the recursion, it would have to be accumulated
       on the way down.
 244 A symbol like ?x occurring in the pattern of an if-match always denotes a new
       variable, just as a symbol in the car of a let binding clause does. So although Lisp
       variables can be used in patterns, pattern variables from outer queries cannot-you
       can use the same symbol, but it will denote a new variable. To test that two lists
       have the same first element, it wouldn't work to write:
       (if-match (?x . ?rest1) lst1
              (if-match (?x . ?rest2) lst2
                  ?x))
       In this case, the second ?x is a new variable. If both lst1 and lst2 had at least one
       element, this expression would always return the car of lst2.
       However, since you can use (non-?ed) Lisp variables in the pattern of an if-match,
       you can get the desired effect by writing:

                                        NOTES                                       395

     (if-match (?x . ?rest1) lst1
          (let ((x ?x))
             (if-match (x . ?rest2) lst2
                  ?x)))

     The restriction, and the solution, apply to the with-answer and with-inference
     macros defined in Chapters 19 and 24 as well.
254 If it were a problem that "unbound" pattern variables were nil, you could have
     them bound to a distinct gensym by saying (defconstant unbound (gensym))
     and then replacing the line

     `(,v (binding ',v ,binds)))

     in with-answer with:

     `(,v (aif2 (binding ',v ,binds) it unbound))

258 Scheme was invented by Guy L. Steele Jr. and Gerald J. Sussman in 1975. The
     language is currently defined by: Clinger, William, and Jonathan A. Rees (Eds.).
     Revised4 Report on the Algorithmic Language Scheme. 1991.
     This report, and various implementations of Scheme, were at the time of printing
     available by anonymous FTP from altdorf.ai.mit.edu:pub.
266 As another example of the technique presented in Chapter 16, here is the derivation
     of the defmacro template within the definition of =defun:

     (defmacro fun (x)
       `(=fun *cont* ,x))

     (defmacro fun (x)
       (let ((fn '=fun))
          `(,fn *cont* ,x)))

     `(defmacro ,name ,parms
         (let ((fn ',f))
           `(,fn *cont* ,,@@parms)))

     `(defmacro ,name ,parms
         `(,',f *cont* ,,@@parms))

267 If you wanted to see multiple return values in the toplevel, you could say instead:

     (setq *cont*
             #'(lambda (&rest args)
                  (if (cdr args) args (car args))))

273 This example is based on one given in: Wand, Mitchell. Continuation-Based
     Program Transformation Strategies. JACM 27, 1 (January 1980), pp. 166.

396                                        NOTES

 273 A program to transform Scheme code into continuation-passing style appears in:
       Steele, Guy L., Jr. LAMBDA: The Ultimate Declarative. MIT Artificial Intelligence
       Memo 379, November 1976, pp. 30-38.
 292 These implementations of choose and fail would be clearer in T, a dialect of
       Scheme which has push and pop, and allows define in non-toplevel contexts:

       (define *paths* ())
       (define failsym '@@)

       (define (choose choices)
         (if (null? choices)
               (fail)
               (call-with-current-continuation
                 (lambda (cc)
                       (push *paths*
                             (lambda () (cc (choose (cdr choices)))))
                       (car choices)))))

       (call-with-current-continuation
         (lambda (cc)
            (define (fail)
               (if (null? *paths*)
                       (cc failsym)
                       ((pop *paths*))))))

       For more on T, see: Rees, Jonathan A., Norman I. Adams, and James R. Meehan.
       The T Manual, 5th Edition. Yale University Computer Science Department, New
       Haven, 1988.
       The T manual, and T itself, were at the time of printing available by anonymous FTP
       from hing.lcs.mit.edu:pub/t3-1.
 293 Floyd, Robert W. Nondeterministic Algorithms. JACM 14, 4 (October 1967),
       pp. 636-644.
 298 The continuation-passing macros defined in Chapter 20 depend heavily on the
       optimization of tail calls. Without it they may not work for large problems. For
       example, at the time of printing, few computers have enough memory to allow the
       Prolog defined in Chapter 24 to run the zebra benchmark without the optimization
       of tail calls. (Warning: some Lisps crash when they run out of stack space.)
 303 It's also possible to define a depth-first correct choose that works by explicitly
       avoiding circular paths. Here is a definition in T:

       (define *paths* ())
       (define failsym '@@)
       (define *choice-pts* (make-symbol-table))

       (define-syntax (true-choose choices)
         `(choose-fn ,choices ',(generate-symbol t)))

                                        NOTES                                         397

    (define (choose-fn choices tag)
       (if (null? choices)
            (fail)
            (call-with-current-continuation
                   (lambda (cc)
                     (push *paths*
                           (lambda () (cc (choose-fn (cdr choices)
                                                             tag))))
                     (if (mem equal? (car choices)
                                       (table-entry *choice-pts* tag))
                         (fail)
                         (car (push (table-entry *choice-pts* tag)
                                      (car choices))))))))
    In this version, true-choose becomes a macro. (The T define-syntax is like
    defmacro except that the macro name is put in the car of the parameter list.) This
    macro expands into a call to choose-fn, a function like the depth-first choose
    defined in Figure 22-4, except that it takes an additional tag argument to identify
    choice-points. Each value returned by a true-choose is recorded in the global
    hash-table *choice-pts*. Ifagiventrue-choose is about to return a value it has
    already returned, it fails instead. There is no need to change fail itself; we can use
    the fail defined on page 396.
    This implementation assumes that paths are of finite length. For example, it would
    allow path as defined in Figure 22-13 to find a path from a to e in the graph displayed
    in Figure 22-11 (though not necessarily a direct one). But the true-choose defined
    above wouldn't work for programs with an infinite search-space:
    (define (guess x)
       (guess-iter x 0))

    (define (guess-iter x g)
       (if (= x g)
            g(guess-iter x (+ g (true-choose '(-1 0 1))))))
    With true-choose defined as above, (guess n) would only terminate for non-
    positive n.
    How we define a correct choose also depends on what we call a choice point. This
    version treats each (textual) call to true-choose as a choice point. That might
    be too restrictive for some applications. For example, if two-numbers (page 291)
    used this version of choose, it would never return the same pair of numbers twice,
    even if it was called by several different functions. That might or might not be what
    we want, depending on the application.
    Note also that this version is intended for use only in compiled code. In interpreted
    code, the macro call might be expanded repeatedly, each time generating a new
    gensymed tag.
305 Woods, William A. Transition Network Grammars for Natural Language Analysis.
    CACM 3, 10 (October 1970), pp. 591-606.

398                                       NOTES

 312 The original ATN system included operators for manipulating registers on the stack
       while in a sub-network. These could easily be added, but there is also a more general
       solution: to insert a lambda-expression to be applied to the register stack directly
       into the code of an arc body. For example, if the node mods (page 316) had the
       following line inserted into the body of its outgoing arc,

       (defnode mods
         (cat n mods/n
            ((lambda (regs)
                 (append (butlast regs) (setr a 1 (last regs)))))
            (setr mods *)))

       then following the arc (however deep) would set the the topmost instance of the
       register a (the one visible when traversing the topmost ATN)to1.
 323 If necessary, it would be easy to modify the Prolog to take advantage of an existing
       database of facts. The solution would be to make prove (page 336) a nested choose:

       (=defun prove (query binds)
         (choose
             (choose-bind b2 (lookup (car query) (cdr query) binds)
                 (=values b2))
             (choose-bind r *rules*
                 (=funcall r query binds))))

 325 To test quickly whether there is any match for a query, you could use the following
       macro:

       (defmacro check (expr)
         `(block nil
             (with-inference ,expr
                 (return t))))

 344 The examples in this section are translated from ones given in: Sterling, Leon, and
       Ehud Shapiro. The Art of Prolog: Advanced Programming Techniques. MIT Press,
       Cambridge, 1986.
 349 The lack of a distinct name for the concepts underlying Lisp may be a serious
       barrier to the language's acceptance. Somehow one can say "We need to use C++
       because we want to do object-oriented programming," but it doesn't sound nearly as
       convincing to say "We need to use Lisp because we want to do Lisp programming."
       To administrative ears, this sounds like circular reasoning. Such ears would rather
       hear that Lisp's value hinged on a single, easily understood concept. For years we
       have tried to oblige them, with little success. Lisp has been described as a "list-
       processing language," a language for "symbolic computation," and most recently, a
       "dynamic language." None of these phrases captures more than a fraction of what
       Lisp is about. When retailed through college textbooks on programming languages,
       they become positively misleading.
       Efforts to sum up Lisp in a single phrase are probably doomed to failure, because the
       power of Lisp arises from the combination of at least five or six features. Perhaps

                                       NOTES                                      399

    we should resign ourselves to the fact that the only accurate name for what Lisp
    offers is Lisp.
352 For efficiency, sort doesn't guarantee to preserve the order of sequence elements
    judged equal by the function given as the second argument. For example, a valid
    Common Lisp implementation could do this:

    > (let ((v #((2 . a) (3 . b) (1 . c) (1 . d))))
         (sort (copy-seq v) #'< :key #'car))
    #((1 . D) (1 . C) (2 . A) (3 . B))

    Note that the relative order of the first two elements has been reversed.
    The built-in stable-sort provides a way of sorting which won't reorder equal
    elements:

    > (let ((v #((2 . a) (3 . b) (1 . c) (1 . d))))
         (stable-sort (copy-seq v) #'< :key #'car))
    #((1 . C) (1 . D) (2 . A) (3 . B))

    It is a common error to assume that sort works like stable-sort. Another
    common error is to assume that sort is nondestructive. In fact, both sort and
    stable-sort can alter the sequence they are told to sort. If you don't want this to
    happen, you should sort a copy. The call to stable-sort in get-ancestors is
    safe because the list to be sorted has been freshly made.

400    NOTES

@node Book's Index, Concept Index, Notes, Top
@comment  node-name,  next,  previous,  up
@chapter Book's Index
@cindex Book's Index

aand 191                                 =apply 267
abbrev 214                               arch
abbrevs 214                                 Lisp as 8
abbreviations 213                           bottom-up program as 4
Abelson, Harold 18                       architects 284
Abelson, Julie 18                        Armstrong, Louis vii
ablock 193                               artificial intelligence 1
Abrahams, Paul W. 391                    asetf 223
:accessor 365                            assignment
accumulators 23, 47, 394                    macros for 170
acond 191                                   order of 177
acond2 198, 239                             parallel 96
Adams, Norman I. 396                        in Prolog 343
after 50                                    and referential transparency 198
aif 191                                     see also: generalized variables
aif2 198                                 assoc 196
alambda 193                              ATNs 305
Algol 8                                     arc types 311
allf 169                                    correctness of 312
:allocation 367                             destructive operations in 313
always 227                                  like functional programs 316
alrec 205                                   for natural language 305
anaphora-see macros, anaphoric              nondeterminism in 308
ANSI Common Lisp ix                         operations on register stack 398
antecedent 322                              order of arcs 308
append                                      recursion in 306
  Prolog implementation 331                 registers of 306, 312
append1 45                                  represented as functions 309
apply 13                                    tracing 309
  with macros 110                        atrec 210
  on &rest parameters 137                augmented transition networks-see ATNs

                                  401

402                                 INDEX

Autocad 1, 5                                 call-next-method 200, 375
automata theory 292                            sketch of 358
avg 182                                      call-with-current-continuation
awhen 191                                               (call/cc) 260
awhen2 198                                     at toplevel 292
awhile 191                                   capital expenditures 43
awhile2 198                                  capture 118
                                               avoiding with gensyms 128
backtraces 111                                 avoiding with packages 130
backtracking 292                               avoiding by prior evaluation 125
backquote (`)84                                of block names 131
   in ATNs 307                                 detecting potential 121
   nested 214, 217, 395                        free symbol capture 119
bad-reverse 29                                    avoiding 125
barbarians 283                                 of function names 131, 392
Basic 30, 33                                   intentional 190, 267, 313
battlefield 8                                  macro argument capture 118
before 50                                      of tags 131
Benson, Eric 137                             case 15
best 52                                      >case 152
Bezier curves 185                            case-sensitivity 331
=bind 267                                    chains of closures 76, 269
binding 239                                  Chocoblobs 298
binding lists 239                            choose 287
bindings, altering 107                         extent of 291
blackboards 281                              choose
block 154                                      Common Lisp version 295
   implicit 131, 155                           Scheme version 293
block-names 131                              choose-bind 295
body (of expressions) 87, 91, 87             chronological backtracking 292
body (of a rule) 322                         classes
&body 87                                       defining 364
bookshops 41                                   see also: superclasses
bottom-up design v, 3, 321                   Clinger, William 395
   and functional arguments 42               CLOS 364
   and incremental testing 38                  as an embedded language 349, 377
   and shape of programs 4                     see also: classes, generic functions,
   multilayer 321                                       methods, slots
bound-see variables, bound                   closed world assumption 249
break-loop 56                                closures 17, 62, 76
brevity viii, 43                             CLTL-see Common Lisp: the Language
bricks, furniture made of 117                code-walkers 237, 273
Brooks, Frederick P. 5                       Common Lisp: the Language ix
                                             Common Lisp
                                               case-sensitivity of 331
C 388                                          definition of ix
C++ 398

                                           INDEX                                          403

  differences between versions                      complement 62
     compilation of closures 25                     compose 66
     complement 62                                  composition-see functions,
     defpackage 384                                            composition of
     destructuring-bind 93                          conc1 45
     dynamic-extent 150                             conc1f 170, 174
     environment of expanders 96, 393               concf 170
     no expansion in compiled code 136              concnew 170
     function-lambda-expression 390                 conditionals 108, 150
     *gensym-counter* 129                           condlet 146
     -if-not deprecated 62                          congruent parameter lists 372
     ignore-errors 147                              consequent 322
     inversions from defun 179                      consing
     Lisp package 384                                 avoiding 31, 150, 197, 363
     name of user package 381                       constitutional amendments 391
     redefining built-in operators 131,             constraints 332
       199                                          *cont* 266
     &rest parameters not fresh 137                 context
     symbol-macros 205                                and referential transparency 199
     with-slots 236                                   see also: environments; macros,
     see also: CLOS, series                                    context-creating
  evaluation rule 392                               continuations 258
  long names in 393                                   destructive operations in 261, 313
  vs. Scheme 259                                      cost of 284
Common Lisp Object System-see CLOS                    see also: call-with-current-con-
common-lisp 384                                                tinuation
common-lisp-user 381                                continuation-passing macros 266
compall 388                                           use in multiprocessing 283
compilation 24                                        use in nondeterministic choice 296
  bounds-checking during 186                          restrictions on 270
  computation during 109, 181, 197,                   and tail-recursion optimization 298
       254, 335                                     continuation-passing style (CPS) 273
  of embedded languages 116, 254                    cookies 184
  errors emerging during 139                        copy-list 71, 206
  inline 26, 109, 110                               copy-tree 71, 210
     testing 388                                    courtiers 375
  of local functions 23, 25, 81, 346                cut 337
  of macro calls 83, 101, 136                         with fail 342
  of networks 79                                      green 339
  restrictions on 25                                  red 339
  senses of 346                                       in Lisp 298
  of queries 254                                    cut 301
  see also: tail-recursion optimization
compile 24, 116, 388                                databases
compile-file 25                                       caching updates to 179
compiled-function-p 24                                locks on 148

404                                     INDEX

  natural language interfaces to 306               generalization of 156
  queries on 246                                 Dolphin Seafood 219
  representation of 247                          dotted lists 70, 390
  with Prolog 398                                duplicate 50
dbind 232                                        dynamic extent 127, 150
def! 64                                          dynamic languages 398
defanaph 223                                     dynamic scope 16
defclass 364
defdelim 228                                     Edwards, Daniel J. 391
defgeneric 371                                   elt 244
define-modify-macro 168                          Emacs-see Gnu Emacs
defmacro 82, 95                                  embedded languages 7, 188, 246
defpackage 384                                     ATNsas309
defprop 354                                        benefits of 110,116, 246, 377
defun 10, 113                                      borderline of 246
  defining inversions with 179                     compilation of 116
=defun 267                                         not quite compilers 346
defsetf 178                                        implementation of 116
delay 211                                          for multiprocessing 275
delete-if 64                                       Prolog as 321
density of source code 59, 389                     query languages as 246
destruc 232                                        see also: CLOS
destructive operations 31, 64                    end-of-file (eof) 197, 225
destructuring                                    English 306
  on arrays 234                                  environment
  on instances 236                                 argument 95
  on lists 230                                     interactive 8
  in macros 93                                     of macro expanders 96, 393
  and reference 236                                of macro expansions 108
  on sequences 231                                 null 96, 278, 394
  on structures 235                              error 148
destructuring-bind 93, 213, 230                  error-checking 45
differences 207                                  eval
disassemble 388                                    explicit 34, 163, 197, 278
dispatching 370, 371                               on macroexpansions 92
do 98                                              sketch of 391
  implicit block in 131                          evaluation
  multiple-valued version 162                      avoiding 151, 181
  order of evaluation in 392                       lazy 211
do-file 199                                        order of
do-symbols 388, 393                                      in Common Lisp 135
do-tuples/c 156                                          in Scheme 259
do-tuples/o 156                                    sketch of 391
do* 97                                           evaluation rule 392
  multiple-valued version 159                    evenp 14
dolist 94                                        evolution

                                         INDEX                                          405

  design by 1                                     funcall 13, 259
  of Lisp 158                                     =funcall 267
  of programming languages 8                      function calls, avoiding
expander code 99                                    by inline compilation 26
expansion code 99                                   with macros 109
explode 58                                          by tail recursion 23
exploratory programming 1, 284                    functional interfaces 35
export 383                                        functional programs 28
:export 384                                         almost 35
expt 32                                             and bottom-up programming 37
extensibility 5                                     from imperative ones 33
  of object-oriented programs 16, 379               shape of 30
extent, dynamic 127, 150                          functions
                                                    as arguments 13, 42, 177
f 173, 222                                          constant 226
factions 167                                        closures of 17, 62, 76
factorials 343, 387                                    use in nondeterministic choice 296
fail 287                                               stack allocation of 150
fail                                                combined with macros 141, 149, 266
  Common Lisp version 295                           compiled 24
  Scheme version 293                                composition of 66, 201, 228
failure 195                                         as a data type 9
fboundp 388                                         defining 10
fif 67                                              filleting 115
filter 47                                           generating recursive 68, 204
  simpler version 389                               generic-see generic functions
find2 50                                            internal 172
  evolution of 41                                   interpreted 24
find-if 41, 195                                     as lists 27
  sketch of 206                                     literal 11
  version for trees 73                                 recursive 21, 193
finished programs 285                               local 21
fint 67                                             vs. macros 109
flatten 47, 72, 210                                 names of 11, 213
  simpler version 389                               as properties 15
Floyd, Robert W. 293                                redefining built-in 131, 174
fmakunbound 373                                     as return values 17, 61, 76, 201
fn 202, 229                                         set operations on 67, 201
Foderaro, John K. v                                 with state 18, 65
for 154                                             tail-recursive 23
force 211                                           transforming into macros 102
Fortran 8                                           undefining 373
free-see variables, free                            see also: compilation; defgeneric;
fullbind 324                                              defun; labels
fun x                                             function-lambda-expression 390
fun 67

406                                       INDEX

Gabriel, Richard P. 23                             incf 171
garbage                                               generalization of 173
  avoiding-see consing, avoiding                   incremental testing 37
  collection 8, 81                                 indexing 249
generalized variables 107, 165                     inheritance
  meaning of 179                                      single 196
  see also: inversions                                of slots 366
generic functions 371                                 multiple 366
  defining 371                                           sketch of 351
  removing 373                                     in-if 152
  see also: methods                                :initarg 365
gensym 128                                         :initform 365
  to indicate failure 197                          in-package 382
  as unbound 244, 330                              inq 152
gensym? 243                                        instances 365
*gensym-counter* 129                               intellectuals 374
gentemp 392                                        interactive development 37, 316
Gelernter, David H. 198                            interactive environment 8
get 63                                             intercourse, lexical 108
gethash 196                                        Interleaf 1, 5
  recursive version 350                            intern 128, 136, 266
get-setf-method 171                                interning 128, 136, 381
gift-shops, airport 278                            intersection 207
Gnu Emacs 1, 5                                     intersections 207
go 100, 155                                        inversions
gods 8                                                asymmetric 179
gold 386                                              defining 178
good-reverse 30                                       see also: generalized variables
group 47                                           iteration
  simpler version 389                                 macros for 108, 154
                                                      vs. nondeterministic choice 291, 325
Hart, Timothy P. 391                                  without loops 264, 325
hash tables 65, 247, 350
head 322                                           Jagannathan, Suresh 198
hiding implementation details 216, 382             jazz vii
hygienic macros 392                                joiner 62
                                                   joke, practical-see Nitzberg, Mark
ice-cream 370
ice-skating 33                                     keywords 386
if3 150
if-match 242                                       labels 21
ignore-errors 147                                  lambda 11
Igor 289                                           =lambda 267
imperative programming 33                          lambda-expressions 11, 21
import 383                                         last 45
in 152                                             last1 45

                                            INDEX                                        407

Latin 306                                            macro-characters-see read-macros
lawyers 298                                          macros 82
let 144, 199                                           as abbreviations 213
let* 172                                               access 167, 216
lengths of programs 387                                anaphoric 189
Levin, Michael I. 391                                    defining automatically 218
lexical scope 16                                         for distinguishing failure from fal-
life, meaning of 197                                        sity 195
lions 37                                                 for generating recursive functions
Lisp                                                        204
   1.5 95                                                multiple-valued 198
   defining features of 1, 8, 349, 398                   and referential transparency 198
   integration with user programs 110                    see also: call-next-method
   slowness of 285                                     and apply 110
   speed of 388                                        applications of 111
   see also Common Lisp, Scheme, T                     arguments to 107
lists                                                  for building functions 201
   accumulating 47                                     calls invertible 166, 216
   as binary trees 70                                  clarity 99, 233
   as code 116                                         and CLOS 378
   decreased role of 44                                for computation at compile-time 181
   disambiguating return values with 196               context-creating 143
   dotted 390                                          combined with functions 141, 149,
   as facts 247                                             266
   flat-see flatten                                    compiled 83, 101, 136
   interleaving 160                                    complex 96
   operating on end of 170                             defining 82
   quoted 37                                           efficiency 99
   recursers on 68, 204                                environment argument to 95
   as trees 262                                        environment of expander 96, 393
   uses for 70                                         environment of expansion 108
list processing 44, 398                                errors in
locality 36                                              modifying arguments 137
logic programs 334                                       modifying expansions 139
longer 47                                                non-functional expanders 136
   simpler version 389                                   nonterminating expansion 139
loop 154                                                 number of evaluations 133, 167
loops                                                    order of evaluation 135
   interrupting 154                                      see also: capture
   see also: iteration                                 expansion of 83
lrec 69                                                  in compiled code 136
                                                         multiple 136, 138
McCarthy, John 1, 391                                    non-terminating 139
mac 92                                                   testing 92
macroexpand 91                                           time of 83
macroexpand-1 91                                       from functions 102

408                                    INDEX

  vs. functions 109                               misuse of 151
  hygienic 392                                    Prolog implementation 332
  justification of 392                            returns a cdr 50
  macro-defining 213, 266                       Miller, Molly M. 137
  parameter lists 93                            member-if 196
  position in source code 102, 266              memq 88
  as programs 96                                memoizing 65, 174
  proportion in a program 117                   message-passing 350
  recursion in 139                                vs. Lisp syntax 353
  redefining 101, 138                           methods
       built-in 199                               adhere to one another 369
  simple 88                                       after- 374
  skeletons of 121                                      sketch of 357
  style for 99                                    around- 375
  testing 91                                            sketch of 356
  unique powers of 106                            auxiliary 374
  when to use 106                                       sketch of 356
  see also: backquote, read-macros,               before- 374
         symbol-macros                                  sketch of 357
mainframes 348                                    of classes 368
make-dispatch-macro-character 226                 without classes 371
make-instance 365                                 as closures 378
make-hash-table 65                                redefining 372
make-string 58                                    removing 373
map-> 54                                                sketch of 359
map0-n 54                                         isomorphic to slots 368
map1-n 54                                         specialization of 369
mapa-b 54, 228                                          on objects 371
mapc 163                                                on types 370
mapcan 41, 46                                     see also: generic functions
  nondestructive version 55                     method combination
  sketch of 55                                    and
mapcar 13                                               sketch of 363
  version for multiple lists 55                   operator 376
  version for trees 55                                  sketch of 362
mapcars 54                                        or
mapcon 176, 218                                         sketch of 363
mappend 54                                        progn
mappend-mklist idiom 160                                sketch of 362
mapping functions 53                              standard 376
mark 301                                                sketch of 358
match 239                                       :method-combination 377
matching-see pattern-matching                   Michelangelo 11
maxmin 207                                      mines 264
Meehan, James R. 396                            mklist 45, 160
member 88                                       mkstr 58

                                              INDEX                                        409

modularity 167, 381, 382                                    restrictions on 297
de Montaigne, Michel 2                                      and tail-recursion optimization 298,
most 52                                                        396
most-of 182                                              Scheme implementation 293
mostn 52                                                 appearance of foresight 289
moving parts 4                                           breadth-first 303
multiple inheritance-see inheritance,                    correct 302
           multiple                                      depth-first 292
multiple values 32                                          in ATNs 308
  to avoid side-effects 32                                  nonterminating 293
  to distinguish failure from falsity 196,                  in Prolog 334
           239                                           in functional programs 286
  in generalized variables 172                           vs. iteration 291, 325
  iteration with 158                                     optimizing 298
  receiving-see multiple-value-bind                      and parsing-see ATNs
  returning-see values                                   and search 290
multiple-value-bind 32                                   see also: choose, fail
  leftover parameters nil 234                          Norvig, Peter 199
multiprocessing 275                                    nreverse 31
mvdo 162                                                 sketch of 388
mvdo* 159                                              nthmost 183
mvpsetq 161
Mythical Man-Month, The 5                              object-oriented programming
                                                         dangers of 379
name-spaces 12, 205, 259, 273, 384, 392                  defining features of 350
natural language-see ATNs                                like distributed systems 348
nconc 31, 35, 137                                        and extensibility 16, 379
negation                                                 name of 349
  of facts 249                                           in plain Lisp 349
  in Prolog 325                                          see also: C++; classes; CLOS; generic
  in queries 252                                               functions; inheritance; methods;
networks                                                       message-passing; slots; Smalltalk
  representing 76, 79                                  on-cdrs 205
next-method-p 375                                      on-trees 210
  sketch of 358                                        open systems 6
:nicknames 384                                         open-coding-see compilation, inline
nif 150                                                orthogonality 63
nildefault block name 131                              *package* 125, 381
  forbidden in case clauses 153                        packages 381
  multiple roles of 51, 195                              aberrations involving 384
nilf 169                                                 avoiding capture with 130, 131
Nitzberg, Mark-see joke, practical                       creating 382
nondeterministic choice 286                              current 381
  Common Lisp implementation 295                         using distinct 131, 382
     need for CPS macros 296                             inheriting symbols from 384

410                                        INDEX

  nicknames for 384                                      order of 329
  switching 382                                       subverting 346
  user 381                                            syntax of 331
  see also: intern; interning                       promises 211
parsers, nondeterministic-see ATNs                  prompt 56
paths, traversing 155                               property lists 15, 63, 216
pat-match 242                                       propmacro 216
pattern-matching 186, 238                             alternative definition 393
pattern variables 238                               propmacros 216
phrenology 30                                       prune 47
planning 2                                            simpler version 389
pointers 76                                         pruning search trees-see cut
pools 313                                           psetq 96
popn 173                                              multiple-valued version 161
pop-symbol 220                                      pull 173, 223
position 49                                         pull-if 173
*print-array* 245                                   push-nreverse idiom 47
*print-circle* 70                                   pushnew 174
print-names 57, 129, 382
processes 275                                       queries
  instantiation of 278                                complex 249, 335
  scheduling of 279                                   conditional 191
  state of 278                                      query languages 249
proclaim 23, 45                                     quicksort 345
productivity 5                                      quote 84, 391
programming languages                                 see also: '
  battlefield of 8                                  quoted lists, returning 37, 139
  embedded-see embedded languages
  expressive power of vii
  extensible 5                                      rapid prototyping 1, 284
  high-level 8                                        of individual functions 24, 48
  see also: Algol; Basic; C; C++; Com-              read 56, 128, 197, 224
         mon Lisp; Fortran; Lisp; Pro-              read-delimited-list 227
         log; Scheme; Smalltalk; T                  :reader 367
Prolog 321                                          read-eval-print loop 57
  assignment in 343                                 read-from-string 58
  calling Lisp from 343                             read-line 56
  case-sensitivity of 331                           readlist 56
  conceptual ingredients 321                        read-macros 224
  nondeterminism in 333                             recurser 388
  programming techniques 332                        recursion
  restrictions on variables 344                       on cdrs 68, 204
  rules 329                                           in grammars 306
       bodyless 323, 330                              in macros 139, 192
       implicit conjunction in body 328               without naming 388
       left-recursive 334                             on subtrees 70, 208
                                                      tail- 23, 140

                                           INDEX                                         411

reduce 207, 363                                     setf 165
Rees, Jonathan A. 395, 396                             see also: generalized variables, inver-
referential transparency 198                                   sions
remove-duplicates                                   set-macro-character 224
  sketch of 206                                     setq
remove-if 14                                           destroys referential transparency 198
remove-if-not 40                                       ok in expansions 100
rep 324                                                now redundant 170
reread 58                                           Shapiro, Ehud 398
&rest parameters 87                                 sharp (#) 226
  not guaranteed fresh 137                          shuffle 161
  in utilities 174                                  side-effects 28
return 131, 155                                        destroy locality 36
return-from 131, 154                                   in macro expanders 136
return values                                          mitigating 35
  functions as-see functions, as return                on &rest parameters 137
           values                                      on quoted objects 37
  multiple-see multiple values                      signum 86
re-use of software 4                                simple? 242
reverse 30                                          single 45
rfind-if 73, 210                                    Sistine Chapel 11
  alternate version 390                             skeletons-see macros, skeletons of
rget 351                                            sketches 284
rich countries 285                                  sleep 65
rmapcar 54                                          slots
Rome 283                                               accessor functions for 365
rotatef 29                                             declaring 364
rplaca 166                                             as global variables 379
rules                                                  initializing 365
  structure of 322                                     isomorphic to methods 368
  as virtual facts 323                                 read-only 367
  see also: Prolog, rules in                           shared 367
                                                    Smalltalk 350
Scheme                                              some
  vs. Common Lisp 259                                  sketch of 206
  cond 192                                          sort 14, 352
  macros in 392                                     sortf 176
  returning functions in 62                         sorting
scope 16, 62                                           of arguments 176
scoundrels, patriotic 352                              partial 184
scrod 219                                              see also: stable-sort
search trees 265                                    special 17
sequence operators 244                              special forms 9, 391
series 55                                           specialization-see methods, specializa-
set 178                                                        tion of
set-difference 207                                  speed 23

412                                         INDEX

splicing 86                                          tagbody 155
splines-see Bezier curves                            tail-recursion optimization 22
split-if 50                                            needed with CPS macros 298
sqrt 32                                                testing for 388, 396
squash 160                                           taxable operators 32
stable-sort 352, 399                                 testing
stacks                                                 incremental 37
  allocation on 150                                    of macros-see macros, testing
  of ATN registers 312                               TEX vi, 5
  in continuations 260, 261                          tf 169
  use for iteration 264                              Theodebert 236
  overflow of 396                                    three-valued logic 151
Steele, Guy Lewis Jr. ix, 43, 213, 395,              till 154
           396                                       time 65, 359
Sterling, Leon 398                                   times of evaluation 224, 229
strings                                              toggle 169
  building 57                                        top-down design 3
  matching 231, 244                                  trace 111, 266, 309
  as vectors 233                                     transition networks 306
Structure and Interpretation of Computer             transformation
           Programs 18                                 embedded languages implemented by
structured programming 100                                      116, 241
subseq 244                                             of macro arguments 107, 112
superclasses                                         trec 75
  precedence of 369                                  trees 70, 262
       sketch of 352                                   cross-products of 265
Sussman, Gerald Jay 18, 395                            leavesof72
symb 58                                                recursers on 70
symbols                                              true-choose
  building 57                                          breadth-first version 304
  as data 385                                                 T implementation 396
  exported 383                                         depth-first version 396
  imported 383                                       truncate 32
  interning-see intern                               ttrav 74
  names of 57, 129, 382                              Turing Machines vii
  see also: keywords                                 twenty questions 77
symbol-function 12, 388                              typecase 62
symbolic computation 398                             type-of 371
symbol-macrolet 105, 205, 210                        typep 243
symbol-name 58                                       types
symbol-package 381                                     declaration of 23
symbol-value 12, 178                                   specialization on 370
symbol-macros 105, 205, 236, 237                     typing 44, 112
swapping values 29
                                                     undefmethod 373
T 396                                                unification 394

                                            INDEX                                413

union 206                                            with-output-to-string 58
   unspecified order of result 207, 364              with-places 237
unions 207                                           with-slots 236
unspecialized parameters 373                         with-struct 235
unwind-protect 148                                   writer's cramp 44
:use 384                                             &whole 95
user 381                                             Woods, William A. 305
utilities 40                                         workstations 348
   as an investment 43, 392                          world, ideal 109
   become languages 113
   mistaken argument against 59                      X Windows vi, 5

var? 239                                             zebra benchmark 396
variable capture-see capture
variables
   bound 16                                          #' 10, 226
   free 16, 121                                      #( 233
   generalized-see generalized variables             #. 75
   global 36, 125, 268, 379                          #: 128
varsym? 239                                          #? 226
   redefined 335                                     #[ 227
vectors                                              #\ 233
   for ATN registers 313                             #@{ 229
   creating with backquote 86                        ' 225
   matching 231, 244                                   see also: quote
visual aspects of source code 30, 213,               , 84
           231                                       ,@@ 86, 138
voussoirs 8                                          : 383
values 32                                            :: 382
   inversion for 393                                 @@ 294
=values 267                                           240, 252, 328
                                                     ` see backquote
                                                     | 58
wait 280
Wand, Mitchell 395
Weicker, Jacqueline J. x
when-bind 145
when-bind* 145
while 154
with-answer 251
   redefined 255
with-array 234
with-gensyms 145
with-inference 324
   redefined 335, 340
with-matrix 234
with-open-file 147

@node Concept Index, Function Index, Book's Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp

@node Function Index,  , Concept Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@bye