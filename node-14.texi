@node 14 Anaphoric Macros, 15 Macros Returning Functions, 13 Computation at Compile-Time, Top
@comment  node-name,  next,  previous,  up
@chapter 14 Анафорические(ссылающиеся или отсылающие к ранее сказанному) Макросы
@cindex 14 Anaphoric Macros

Глава 9 рассматривала захват переменных исключительно как проблему, как нечто, что
происходит не преднамеренно, и что может повлиять на программы в худшую сторону. Эта
глава покажет, что захват переменных также можно использовать конструктивно. Есть
некоторые полезные макросы, которые нельзя было бы написать без этого.

В программах на Lisp нередко хочется проверить, является ли возвращаемое выраженим
значение не nil, и если да, что-то сделать с этим значением. Если выражение дорого
вычислять, тогда обычно нужно сделать, что то вроде этого:

@lisp
(let ((result (big-long-calculation)))
  (if result
        (foo result)))
@end lisp

Но не проще было бы, если бы мы могли просто сказать, как мы это сделали
бы на английском:

@lisp
(if (big-long-calculation)
     (foo it))
@end lisp

Используя преимущества захвата переменных, мы можем написать версию if, которая
работает подобным способом.

@menu
* 14-1 Anaphoric Variants::     
* 14-2 Failure::                
* 14-3 Referential Transparency::  
@end menu

@node 14-1 Anaphoric Variants, 14-2 Failure, 14 Anaphoric Macros, 14 Anaphoric Macros
@comment  node-name,  next,  previous,  up
@section 14-1 Варианты Анафоризмов
@cindex 14-1 Anaphoric Variants
@findex 14-1 Anaphoric Variants

В естественном языке, анафор - это выражение, которое ссылается к уже
сказанному. Наиболее распространённым анафором в Английском языке вероятно
является "it,"(это, оно, он, оно) как в "Возьми гаеечный ключ, и положи it(его)
на стол." Анафоры очень удобны в повседневном языке - представьте, как вы бы
обходидлись без них, но они не очень часто используются в языках программирования.
По большей части, это хорошо. Анафорные выражения часто являются по настоящему
двусмысленными, а современные языки программирования не предназначены для 
устранения двусмысленностей.

Тем не менее, можно ввести ограниченную форму анофоры в программы на Lisp не 
вызывая двусмысленности. Оказывается, анафор очень похож на захват символа.
Мы можем использовать анафору в программах, назначая определенные символы,
для использования в качестве местоимений, а затем намеренно писать макросы 
захватывающие эти символы.

В новой версии if, символ it является символом, который мы хотим захватить. Анафорный
if, коротко называемый  aif, определяется следующим образом:

@lisp
(defmacro aif (test-form then-form &optional else-form)
  `(let ((it ,test-form))
         (if it ,then-form ,else-form)))
@end lisp

@noindent
и используется как в предыдущем примере:

@lisp
(aif (big-long-calculation)
         (foo it))
@end lisp

Когда вы используете aif, символl it является связываемым слева с результатом возвращаемым
тестовым предложением. В вызове макроса, it кажется свободным, но на самом деле выражение
(foo it) будет вставлено при расширении aif в контекст, в котором символ it является 
связанным:

@lisp
(let ((it (big-long-calculation)))
  (if it (foo it) nil))
@end lisp

Таким образом, символ, который выглядит свободным в исходном коде, является
связанным в расширении макроса. Все анафорические макросы в этой главе
используют вариации одной и той же техники.

Рисунок 14-1 содержит анафорические варианты нескольких операторов Common Lisp.
После aif идет awhen, очевидный анафорический вариант when(когда):

@lisp
(awhen (big-long-calculation)
  (foo it)
  (bar it))
@end lisp

И aif и awhen часто полезны, но  awhile вероятно уникальный среди анафорических
макросов в том, что он является более полезным, чем его кузен while (определенный
на странице 91). Макросы типа while и awhile обычно используются в ситуациях где
программе необходимо опрашивать какой-то внешний источник. И когда вы опрашиваете
источник, если вы не ждете, что он просто изменит свое состояние, вам обычно хочется
что-то сделать с возвращенным из него объектом:

@cartouche
@lisp
 (defmacro aif (test-form then-form &optional else-form)
        `(let ((it ,test-form))
             (if it ,then-form ,else-form)))

 (defmacro awhen (test-form &body body)
        `(aif ,test-form
                 (progn ,@@body)))

 (defmacro awhile (expr &body body)
        `(do ((it ,expr ,expr))
                ((not it))
             ,@@body))

 (defmacro aand (&rest args)
        (cond ((null args) t)
              ((null (cdr args)) (car args))
              (t `(aif ,(car args) (aand ,@@(cdr args))))))

 (defmacro acond (&rest clauses)
        (if (null clauses)
              nil
              (let ((cl1 (car clauses))
                       (sym (gensym)))
                 `(let ((,sym ,(car cl1)))
                      (if ,sym
                            (let ((it ,sym)) ,@@(cdr cl1))
                            (acond ,@@(cdr clauses)))))))
@end lisp

               Рисунок 14-1: Анафорные варианты операторов Common Lisp.
@end cartouche

@lisp
(awhile (poll *fridge*)
   (eat it))
@end lisp

Определение aand немного сложнее чем предыдущие.  Оно представлляет
анафорическую верисию and; во время вычисления каждого из его аргументов,
it будет привязан к значению возвращенному предыдущим аргументом. 
@footnote{Хотя кто-то склонен думать одновременно об and и or, было бы
бессмысленно писать анафорническую версию or. Аргумент в выражении or
вычисляется только, если предыдущий аргумент вычисляется в nil, так 
что анафору будет не на что ссылаться в aor.} На практике, aand, как 
правило используется в программах, которые делают условные запросы,
как в:

@lisp
(aand (owner x) (address it) (town it))
@end lisp

@noindent
который возвращает владельца (если он есть)  x, затем адресс(address) (если он есть), а затем
город(town) (если он есть). Без aand, это выражение должно было бы написано как:

@lisp
(let ((own (owner x)))
  (if own
      (let ((adr (address own)))
        (if adr 
            (town adr)))))
@end lisp

Определение aand показыает, что расширение будет варьироваться в зависимости от
количества аргументов в вызове макроса. Если аргументов нет, то aand  как и 
обычный and, должен просто вернуть t. В противном случае расширение генерируется
рекурсивно, каждый шаг дает один слой в цепочке вложенных aif:

@lisp
(aif  first argument 
          expansion for rest of arguments )
@end lisp

Расширение aand должно прекратиться, когда останется один аргумент, вместо работы
до nil подобно большинству рекурсивных функций. Если бы рекурсия продолжалась до
тех пор, пока не осталось бы никаких аргументов, расширение всегда будет
иметь форму:

@lisp
(aif  c1 
         ...(aif  cn t)...)
@end lisp

Такое выражение всегда будет возвращать t или nil, а приведенный выше пример не
будет работать как задумано.

Раздел 10-4 предупредил, что если макрос всегда дает расширение, содержащее
вызов самого себя, расширение никогда не прекратится(компиляция "зависнет"). 
Но рекурсивный aand является безопасным, потому что в базовом случаее его 
расширение не обращается к aand.

Последний пример, acond, предназначен для тех случаев, когда в остатке предложения
cond хочется использовать значение возвращаемое тестовым выражением. (Эта ситуация
возникает так часто, что некоторые реализации Scheme предоставляют способ использовать
значение возвращаемое тестовым выражением в предложении cond.)

В расширениии предложения acond, результат тестового выражения будет вначале храниться
в переменной gensym, чтобы символ it мог быть связан только в оставшейся части
предложения. Когда макросы создают привязки, они должны всегда делать это в самой узкой
области видимости. Вот, если бы мы обошлись без

@cartouche
@lisp
 (defmacro alambda (parms &body body)
       `(labels ((self ,parms ,@@body))
         #'self))

 (defmacro ablock (tag &rest args)
       `(block ,tag
         ,(funcall (alambda (args)
                          (case (length args)
                            (0 nil)
                            (1 (car args))
                            (t `(let ((it ,(car args)))
                                    ,(self (cdr args))))))
                       args)))
@end lisp

                       Рисунок 14-2: Еще варианты анафорных макросов.
@end cartouche

@noindent
gensym и вместо этого сразу бы связали it с результатом тестового выражения, как 
в:

@lisp
(defmacro acond (&rest clauses)                                            ; wrong
  (if (null clauses)
         nil
         (let ((cl1 (car clauses)))
           `(let ((it ,(car cl1)))
                (if it
                     (progn ,@@(cdr cl1))
                     (acond ,@@(cdr clauses)))))))
@end lisp

@noindent
тогда привязку it также будет иметь в своем окружении последующее тестовое выражение.
Рисунок 14-2 содержит несколько более сложных анафорических вариантов. Макрос
alambda используется для создания само рекурсивной функции. Когда кто то хочет буквально
ссылаться на рекурсивную функцию? Мы можем сослаться на неименованную функцию используя
решетку c квотированием (#') для лямбда-выражения:

@lisp
#'(lambda (x) (* x 2))
@end lisp

Но как объяснялось во второй главе, вы не можете просто выразить рекурсивную функцию
с помощью простого лямбда выражения. В место этого вы должны определить локальное
определение именованной функции используя labels. Следующая функция 
(воспроизводим со страницы 22)

@lisp
(defun count-instances (obj lists)
  (labels ((instances-in (list)
             (if list
                 (+ (if (eq (car list) obj) 
                        1 
                        0)
                    (instances-in (cdr list)))
                 0)))
     (mapcar #'instances-in lists)))
@end lisp

@noindent
получает объект и список, и возвращает список числа вхождений объекта в каждый элемент
списка:

@example
> (count-instances 'a '((a b c) (d a r p a)(d a r)(a a)))
(1 2 1 2)
@end example

С анафорой мы можем сделать то, что представляет собой буквальную рекурсивную
функцию. Макрос alambda использует labels для создания функции, и может 
использоваться для выражения, например, рекурсивной функции факториала:

@lisp
(alambda (x) (if (= x 0) 1 (* x (self (1- x)))))
@end lisp

Используя alambda мы можем определить эквивалентную версию count-instances 
следующим образом:

@lisp
(defun count-instances (obj lists)
  (mapcar (alambda (list)
                   (if list
                        (+ (if (eq (car list) obj) 1 0)
                             (self (cdr list)))
                        0))
                lists))
@end lisp

В отличии от других макросов на Рисунке 14-1 и 14-2, которые все захватывают
символ it, alambda захватывает символ self. Экземпляр alambda расширяется 
до выражения labels в котором self связывается с определяемой функцией.
Помимо того что оно меньше, выражение alambda выглядит как привычные лямбда
выражения, создавая код, который легче читать, при их использовании.

Новый макрос используется в определении ablock, анафорической версии встроенной 
специальной формы block. В block, аргументы вычисляются слева направо.
Тоже самое происходит и в ablock, но внутри каждого выражения перменная it будет 
связана со значением предыдущего выражения.

Этот макрос следует использовать по своему усмотрению. Хотя иногда, ablock 
будет превращаеть, то что могло быть хорошей функциональной программой, в
императивнрую форму. Следущий, к сожалениею, характерно некрасивый пример:

@example
> (ablock north-pole
        (princ "ho ")
        (princ it)
        (princ it)
        (return-from north-pole))
ho ho ho
NIL
@end example

Всякий раз, когда макрос, который делает преднамеренный захват переменной, 
экспортируется в другой пакет, необходимо также экспортировать захватываемый символ. 
Например, куда бы не экспортировался aif, it также должен экспортиоваться. В противном
случае it, которое появлялется в определении макроса, будет отличаться от символа it 
используемого при вызове макроса.

@node 14-2 Failure, 14-3 Referential Transparency, 14-1 Anaphoric Variants, 14 Anaphoric Macros
@comment  node-name,  next,  previous,  up
@section 14-2 Неудачи
@cindex 14-2 Failure

В Common Lisp символ nil выполняет три разных задачи. Он в первую очередь является
пустым списком, так что

@example
> (cdr '(a))
NIL
@end example

Как и пустой список, nil используется для представления ложности, как в

@example
>(= 1 0)
NIL
@end example

И наконец, функции возвращающие nil указывают на неудачу(сбой). Например, работа
встроенного find-if должна возвращать первый элемент списка, который удовлетворяет
некоторому критерию(тесту). Если такой элемент не найден, find-if вернет nil:

@example
> (find-if #'oddp '(2 4 6))
NIL
@end example

К сожалению, мы не можем отличить этот случай от случая, когда find-if завершается
успехом, но успех состоит в нахождении nil:

@example
> (find-if #'null '(2 nil 6))
NIL
@end example

На практике, это не вызывает особых проблем, если использовать nil для представления
ложности и пустого списка. На самом деле это может быть довольно удобно. Тем не менее,
огорчает, иметь nil для представления неудачи, потому что это означает, что результат
возвращаемый функциями типа find-if может быть не однозначным.

Возникает проблема различения неудачи и найденного значения nil возвращаемого
любой функцией которая осуществляет поиск. Common Lisp предлагает не менее трех
решений этой проблемы. Наиболее распространенный подходом - , до появления возврата
множественных значений, - возвращать списковую структуру. Нет проблем в различении
неудачи с использованием assoc, например; в случае успеха должна возвращаться пара в 
качестве результата:

@example
> (setq synonyms '((yes . t) (no . nil)))
((YES . T) (NO))
> (assoc 'no synonyms)
(NO)
@end example

Следуя этому подходу, если мы беспокоимся о неоднозначности при использовании find-if,
мы будем использовать member-if, который вместо простого возврата элемента, удовлетворяющего
выражению test, возвращает весь (остаток списка) cdr, который начинается с искомого элемента:

@example
> (member-if #'null '(2 nil 6))
(NIL 6)
@end example

С момента появления возврата множественных значений, было принято другое решение
этой проблемы: использовать одно значение для данных и второе для указания на успех
или неудачу поиска. Таким образом работает встроенный gethash. Он всегда возвращает
два значения, второе указывает, было ли что найдено, или нет:

@example
> (setf edible (make-hash-table)
        (gethash 'olive-oil edible) t
        (gethash 'motor-oil edible) nil)
NIL
> (gethash 'motor-oil edible)
NIL
T
@end example

Так что, если вам необходимо различать все три возможных случая, вы можете использовать
идиому, такую как следующее выражение:

@lisp
(defun edible? (x)
     (multiple-value-bind (val found?) (gethash x edible)
        (if found?
              (if val 'yes 'no)
              'maybe)))
@end lisp

@noindent
тем самым отличая ложь от неудачи:

@example
> (mapcar #'edible? '(motor-oil olive-oil iguana))
(NO YES MAYBE)
@end example

Common Lisp поддерживает еще один способ обозначить неудачу: Функция доступа
принимает как аргумент специальный объект, предположительно сгенерированный
gensym, который возвращается в случае неудачи. Этот подход используется с get, 
который получает необязательный аргумент, указывающий, что вернуть, если 
указанное свойство не найдено:

@example
> (get 'life 'meaning (gensym))
#:G618
@end example

Подход, где возможен возврат множественного значения, используемый gethash,
является самым ясным. Нам не надо передавать дополнительные аргументы каждой
функции доступа, как мы делаем с  get. И между двумя другими альтернативами,
использование множественных значений является более общим; find-if может быть
написан, чтобы возвращать два значения, но gethash так написать нельзя, без
выполнения создания списка(consing), чтобы вернуть, устраняющую неоднозначность,
списковую структуру. Таким образом, при написании новых функций для поиска,
или других задач, где возможна неудача, обычно лучше следовать модели поведения
используемой в gethash.

Идиома, которую можно найти в edible? это просто разновидность рутинных операций, которые
хорошо скрыть макросом. Для функций доступа таких как gethash нам нужна новая версия условного
оператора aif, которая вместо связывания и проверки того же значения, возвращаемого
функцией доступа, связывает первый возвращенный элемент(val), но также проверяет
второе значение. Новая версия aif, называемая aif2, показана на рисунке 14-3.
Используя её мы могли бы написать edible? как:

@lisp
(defun edible? (x)
  (aif2 (gethash x edible)
           (if it 'yes 'no)
           'maybe))
@end lisp

Рисунок 14-3 также содержит аналогично измененные версии awhen, awhile, и
acond. Для примера использования acond2, см. определение соответствующее
стр. 239. Используя этот макрос мы можем выразить cond в виде функции,
которая в противном случае была бы намного длиннее и менее симетричной.

Встроенный read указывает на неудачу так же как get. Ему требуется необязательный
аргумент, говорящий, следует ли генерировать ошибку в случае eof, и если нет,
какаое значени вернуть. Рисунок 14-4 содержит альтернативную версию read, которая
использует второе возвращаемое значение для сообщения о неудаче: read2 возвращает
два значения, входное выражение и флак, который равен nil при eof. Он вызывает read
с символом сгенерированным gensym, который должен быть возвращен в случае eof, но
чтобы избавитсья от хлопот по построению gensym для каждого вызова  read2, функция
определяется как замыкание со скрытой копией символа из gensym сгенерированного
во время компиляции.

Рисунок 14-4 также содержит удобный макрос для перебора выражений в файле, написанный
с использованием awhile2 и read2. Используя do-file мы могли бы, например, написать
версию load как:

@lisp
(defun our-load (filename)
  (do-file filename (eval it)))
@end lisp

@cartouche
@lisp
      (defmacro aif2 (test &optional then else)
            (let ((win (gensym)))
               `(multiple-value-bind (it ,win) ,test
                   (if (or it ,win) ,then ,else))))

      (defmacro awhen2 (test &body body)
            `(aif2 ,test
                   (progn ,@@body)))

      (defmacro awhile2 (test &body body)
            (let ((flag (gensym)))
               `(let ((,flag t))
                   (while ,flag
                        (aif2 ,test
                              (progn ,@@body)
                              (setq ,flag nil))))))

      (defmacro acond2 (&rest clauses)
            (if (null clauses)
                 nil
                 (let ((cl1 (car clauses))
                       (val (gensym))
                       (win (gensym)))
                    `(multiple-value-bind (,val ,win) ,(car cl1)
                         (if (or ,val ,win)
                              (let ((it ,val)) ,@@(cdr cl1))
                              (acond2 ,@@(cdr clauses)))))))
@end lisp

                          Рисунок 14-3: Анафорические макросы использующие множественные значения.
@end cartouche

@node 14-3 Referential Transparency,  , 14-2 Failure, 14 Anaphoric Macros
@comment  node-name,  next,  previous,  up
@section 14-3 Ссылочная Прозрачность
@cindex 14-3 Referential Transparency

Иногда говорят, что анафорические макросы нарушают ссылочную прозрачность, которую
Gelernter и Jagannathan определяют следующим образом:

@quotation
Язык ссылочно прозрачен, если (a) какждое подвыражение может быть
заменено любым другим, равным по ему по значению и (b) все вхождения
выражения в данном контексте приводят к одному и тому же значению.
@end quotation

Обратите внимание, что стандарт применяется к языкам, а не к программам. Нет языков с
присваиванием являющихся ссылочно прозрачными. Первый и последний x в этом выражении

@cartouche
@lisp
 (let ((g (gensym)))
    (defun read2 (&optional (str *standard-input*))
        (let ((val (read str nil g)))
          (unless (equal val g) (values val t)))))

 (defmacro do-file (filename &body body)
    (let ((str (gensym)))
        `(with-open-file (,str ,filename)
               (awhile2 (read2 ,str)
                ,@@body))))
@end lisp

                              Рисунок 14-4: Файловые утилиты.
@end cartouche

@lisp
(list x
      (setq x (not x))
      x)
@end lisp

@noindent
дают разные значения, поскольку вмешивается setq. Правда, это ужасный код.
Тот факт, что это возможно, означает что Lisp не является ссылочно прозрачным.

Norvig(Норвиг) отмечает, что было бы удобно переопределить if как:                           

@lisp
(defmacro if (test then &optional else)
  `(let ((that ,test))
        (if that ,then ,else)))
@end lisp

@noindent
но отклоняет этот макрос на том основании, что он нарушает ссылочную прозрачность.

Однако проблема здесь заключается в переопределении встроенных операторов, а не в 
использовании анафоры. Предложение (b) приведенного выше определения требует, чтобы
выражение всегда возвращало одно и тоже значение "в данном контексте." Это не проблема
if, внутри этого let выражения,

@lisp
(let ((that 'which))
  ...)
@end lisp

@noindent
символ that обозначает новыю переменную, потому что let объявлено чтобы создать
новый контекст.

Проблема с макросом в том, что он переопределяет if, который не предполагает
создание нового контекста. Эта проблема исчезнет, если мы дадим анафорическим макросам имена
отличающиеся от стандартных. (Начиная с CLTL2, это переопределение так или иначе является незаконным.)
На протяжении всей части определения aif устанавливается новый контекст в котором it 
является новой переменной, такой макрос не нарушает ссылочную прозрачность.

Теперь, aif действительно нарушает другое соглашение, которое не имеет ничего общего
со ссылочной прозрачностью: всегда указывать вновь устанавливаемые переменные в
исходном коде. Выражение let выше ясно указывает на то, что that хочет сослаться на
новую переменную. Можно утверждать, что привязка it в aif не достаточно ясна(видна).
Однако это не очень сильный аргумент: aif создает только одну переменную, и создание
этой переменной является единственной причиной его использования.

Common Lisp и сам не рассматривает это соглашение как неприкосновенное. Привязка
функции CLOS call-next-method зависит от контекста точно таким же образом, как
привязка символа it делается в теле aif. (Для намека о том, как будет реализован
call-next-method, смотрите макрос defmeth на странице 358.) В любом случае, такие
соглашения введены только для достижения цели: облегчения чтения программ. И анафоры
делают программы более легко читаемыми, также как они облегчают чтение в Английском
языке.