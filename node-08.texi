@node 8 When to Use Macros, 9 Variable Capture, 7 Macros, Top
@comment  node-name,  next,  previous,  up
@chapter 8 Когда использовать Макросы
@cindex 8 When to Use Macros

Как нам узнать, должна ли данная функция действительно быть функцией, а не макросом?
В большинстве случаев существует четкое различие между необходимостью вызова макроса
и когда его использовать не надо. По умолчанию мы должены использовать функции: т.е не
использовать макрос там, где работу может сделать функция. Мы должны использовать
макросы, только там, где они приносят определенное преимущество.

Когда макросы приносят преимущества? Это предмет этой главы. Обычно вопрос стоит
не о преимуществе, а в необходимости. Большинство вещей которые мы делаем с помощью
макросов, мы не могли бы сделать используя функции. В разделе 8-1 перечислены виды
операторов, которые можно реализовать только как макрос. Тем не менее, есть небольшой
(но интересный) класс пограничных случаев, в которых оператор может записан как функция
или как макрос. Для этих ситуаций, в разделе 8-2 приведены аргументы за и против 
использования макроса. Наконец, рассмотрев, что могут делать макросы, мы обратимся в 
разделе 8-3 к связанному с ним вопросу: Какие вещи люди делают используя их?

@menu
* 8-1 When Nothing Else Will Do::  
* 8-2 Macro or Function?::      
* 8-3 Applications for Macros::  
@end menu

@node 8-1 When Nothing Else Will Do, 8-2 Macro or Function?, 8 When to Use Macros, 8 When to Use Macros
@comment  node-name,  next,  previous,  up
@section 8-1 Когда ничего другое не помогает
@cindex 8-1 When Nothing Else Will Do

Это общий принцип хорошего дизайна: если вы находите похожий код в несокольих местах
программы, вы должны написать подпрограмму и заменить аналогичные последовательности
кода на вызовы подпрограммы. Когда мы применяем этот принцип к Lisp программам, мы
должны решить, должна ли "подпрограмма" быть функцией или макросом.

В некоторых случаях легко выбрать написание макроса вместо функции, поскольку
макрос может сделать то что нужно. Функцию, подобную 1+ можно записать как
функцию или как макрос:

@lisp
(defun 1+ (x) (+ 1 x))

(defmacro 1+ (x) `(+ 1 ,x))
@end lisp

Но while, из Раздела 7-3, можно определить только как макрос:

@lisp
(defmacro while (test &body body)
  `(do ()
             ((not ,test))
          ,@@body))
@end lisp

Нет способа продублировать поведение этого макроса с помощью функции. Определение
while "вшивает" переданные ему в качестве тела выражения в тело цикла do, где они
будут вычисляться только, если тестовое выражение возвращает nil. Но нет функции
спобоной сделать это; при вызове функции, все ее аргументы вычисляются до того как
функция будет вызвана.

Когда вам нужен макрос, что вам от него нужно? Макросы могут сделать только две
вещи, которые не могут сделать функции: они могут контролировать (или предотвращать)
вычисление своих аргументов, и они расширяются прямо в вызывающем контексте. Любому
приложению, которому требуются макросы, в конце концов, требуется одно или оба этих
свойства.

Неформальное объяснение, что "макросы не вычисляют своих аргументов" немного не
правильно. Точнее было бы сказать, что макросы контролируют вычисление аргументов
переданных в вызове макроса. В зависимости от того, где находиться аргумент в
расширении макроса, он будет вычислен, один раз, много раз или вообще не будет
вычисляться. Макросы используют это управление четремя основными способами:

@enumerate
@item
       1. Преобразование. Макрос Common Lisp setf является одним из класса макросов,
          которые разбирают свои аргументы перед вычислением. Встроенной функции
          доступа необходимо определить обратное, целью которого установить, какой доступ
          производит функция. Обратное для car это rplaca, для cdr - rplacd, и так 
          далее. С помощью setf мы можем использовать вызовы таких функций, как если бы
          они были переменными, значеня которых надо установить, как в (setf (car x) 'a),
          которая расширяется в (progn (rplaca x 'a) 'a).
          Чтобы выполнить этот трюк, setf должен заглянуть внутрь первого аргумента. Чтобы
          знать, что в приведенном выше случае требуется rplaca, setf должен увидеть, что
          первый аргумент  - это выражение начинающееся с car. Таким образом setf, и любой
          другой оператор, которые преобразует свои аргументы, должен быть записан как
          макрос.
@item
       2. Связывание. Лексические переменные должны появляться непосредственно в 
          исходном коде. Например, первый аргумент для setq не вычисляется, поэтому
          все что построено на setq должно быть макросом, который расширяется в setq,
          а не функцией, которая его вызывает. Аналогично, для операторов типа let, 
          аргументы которых должны выглядеть как параметры в лямбда выражении, для 
          макросов типа do, которые расширяются в lets, и так далее. Любой новый
          оператор, который должен изменять лексические привязки своих аргументов
          должен быть написан в виде макроса.
@item
   3. Условное вычисление. Все аргументы функции - вычисляются. В таких конструкциях,
          подобных when, когда мы хотим, чтобы некоторые аргументы вычислялись только 
          при определенных условиях. Такая гибкость возможна только при использовании
          макросов.
@item
   4. Многократное вычисление. Аргументы функции не просто вычисляются, они вычисляются
          только один раз. Нам необходим макрос для определения конструкции подобной do, 
          где определенные аргументы должны вычисляться повторно.

@noindent
Есть также несколько способов получить пользу от встраиваемого расширения макросов.
Важно подчеркнуть, что расширение появляются в лексическом контексте вызова макроса,
поскольку два из трех вариантов использования макроса зависят от этого факта. Они
являются:

@item
   5.Использование окружения вызова. Макрос может генерировать расширение, содержащее
        переменные, которые связаны в контексте вызова макроса.
        Поведение следующего макроса:

@lisp
        (defmacro foo (x)
          `(+ ,x y))
@end lisp

        зависит от привязки y в месте, где вызывается foo.
        Этот вид лексического проникновения обычно рассматривается как источник проблем,
        нежели как средство их решения. Обычно является плохим стилем написание подобных
        макросов. Идеал функционального программирования применим и к макросам: 
        предпочтительный способ связи с макросом - через его параметры.
        Действительно, настолько редко требуется использовать окружение вызова, что в 
        большинстве случаев это приводит к ошибкам. (См. главу 9.) Из всех макросов в этой 
        книге, только  макросы передачи продолжений(continuation-passing) (Глава 20) и 
        некоторые части компилятора ATN (глава 23) используют среду вызова таким способом.
@item
   6. Обертывание нового окружения. Макрос также может вызвать вычисление своих аргументов в
        новом лексическом окружении. Классическй пример это  let, который может быть 
        реализован как макрос использущий лямбду (стр. 144). В теле выражения, такого как
        (let ((y 2)) (+ x y)), y будет ссылаться на новую переменную.

@item
       7. Отсутствие затрат на вызов функции. Третье последствие от встраивания
         расширения макроса состоит в том, что в скомпилированном коде нет никаких
         накладных расходов связанных с вызовом макроса. Во время выполнения вызов
         макроса уже заменен расширением. (То же самое, в принципе, верно для 
         встраиваемых функций, объявленных inline.)
@end enumerate

Примечательно, что случаи 5 и 6, когда непреднамеренно захватывается переменная,
представляют собой проблему являющуюся худшей вещью, которой должен бояться
автор макроса. Захват переменной обсуждается в главе 9.

Вместо седьмого способа использования макросов, было бы лучше сказать что есть
шесть с половиной способов. В идельном мире, все компиляторы Common Lisp будут
подчиняться объявлениям inline, и сберегать расходы на вызов функций будет
задачей встраиваемых(inline) функций, а не макросов. Но идельный мир мы оставим
читателю для рассмотрения в качестве упражнения.

@node 8-2 Macro or Function?, 8-3 Applications for Macros, 8-1 When Nothing Else Will Do, 8 When to Use Macros
@comment  node-name,  next,  previous,  up
@section 8-2 Макрос или Функция?
@cindex 8-2 Macro or Function?

В предыдущем разделе рассматривались простые случаи. Любой оператор, которому нужен
достпу к его параметрам, прежде чем они будут вычислены, должен быть записан как
макрос, потому что другого выбора нет. А как на счет операторов, которые могут быть
записаны альтернативным способом(т.е как функции)? Рассмотрим для примера оператор
avg, который возвращает среднее значение своих аргументов. Он может быть определен
как функция

@lisp
(defun avg (&rest args)
  (/ (apply #'+ args) (length args)))
@end lisp

@noindent
но есть хороший способ определить его как макрос,

@lisp
(defmacro avg (&rest args)
  `(/ (+ ,@@args) ,(length args)))
@end lisp

потому что в версия функции, влечт за собой использование ненужный вызов length,
вызваемый каждый раз когда avg вызвается. Во время компиляции, вы можете не знать
значения аргументов, но мы знаем, сколько их,  поэтому вызов length можно сделать
в этот момент(в момент компиляции). Вот несколько моментов, на которые следует 
обратить внимание, когда мы сталкиваемся с таким выбором:

@center @titlefont{ЗА}
@enumerate
@item
Вычисления во время компиляции. Вызов макроса включает в себя вычисления
в два различных момента времени: Когда макрос расширяется и  когда
расширение вычисляется. Все расширения макросов в Lisp программах выполняются
когда программа компилируется, и каждая часть вычислений, которые могут быть
сделаны во время компиляции, это часть вычислений не будет замедлять программу
когда она работает. Если оператор может быть написан, так чтобы сделать некоторую
свою работу на стадии расширении макроса, будет более эффективным сделать его
макросом, поскольку какую бы работу не мог выполнить умнйл компилятор, функция
должна будет выполняться во время выполнения. Глава 13 описывает макросы, такие
как avg, которые выполняют часть своей работы во время фазы расширения.
@item
Интеграция с Lisp. Иногда, использование макросов вместо функций делает
программу более тесно интегрированной с Lisp. Вместо того чтобы писать
программу для решения определенной проблемы, вы можете использовать
макросы, чтобы преобразовать проблему в такую проблему, которую Lisp 
уже знает как решать. Это подход, когда он возможен, обычно делает программы
меньше и более эффективными: меньше потому что Lisp делает часть вашей работы
за вас, и более эффективными потому что производственная система Lisp имеет
более высокую производительность чем пользовательские программы. Это преимущество
проявляется на встроенных языках, которые описываются начиная с главы 19.
@item
Экономия на вызовах функций. Вызов макроса расширяется прямо в код, в котором 
он находиться. Так что если вы напишите какой-то, часто используемый фрагмент
когда в виде макроса, вы можете сэкономить на вызове функции, каждый раз когда
он используется. В более ранних диалектах Lisp программисты пользовались этим
свойством для экономии на вызове функций во время выполнения. В Common Lisp эту
работу должны взять на себя функции объявленые встраиваемыми(inline).
Объявляя функцию встраиваемой(inline), вы запрашиваете ее вставку в правильно
скомпилированный код, вызвавший её, как это былобы с макросом. Тем не менее,
здесь существует разрыв между теорией и практикой; CLTL2 (стр. 229) говорит, что
"компилятор волен игнорировать эти объявления", что и делают некоторые компиляторы
Common Lisp. Возможно все еще разумно использовать макросы для экономии на вызовах
функций, если вы вынуждены использовать подобный компилятор.

@noindent
В некоторых случаях, объединяющих преимущества эффективности и тесной интеграции
с помощью Lisp можно создать сильный аргумент для использования макросов. В запросе
compiler Главы 19, объем вычислений, которые могут быть сдвинуты на время компиляции
настолько велик, что оправдывает превращение всей программы в один гиганский макрос. 
Хотя это делается для скорости, это также приводит программу к более тесной интеграции
с Lisp: в новой версии, проще использовать выражения работающие с арифметикой Lisp, 
например в запросах.

@center @titlefont{ПРОТИВ}
@item
Функции это данные, в то время как макросы больше похожи на инструкции для
компилятора. Функция может быть передана как аргумент(например в apply),
возвращена функцией или сохранена в структуре данных. Ничего из этого не 
возможно с макросами. В некоторых случаях вы можете получить то, что хотите,
заключив вызов макроса в лябда-выражение. Например, это работает, если вы
хотите использовать определение макроса в apply или  funcall:

@example
          > (funcall #'(lambda (x y) (avg x y)) 1 3)
          2
@end example

Однако это не удобно. Это не всегда работает, т.к. даже если макрос, как и  avg,
имеет параметр &rest, ему не всегда можно передать различное количество 
аргументов.
@item
Ясность исходного кода. Определения макросов читать сложнее чем определения
эквивалентных определений функций. Так что если написать нечто как макрос,
делающий программу лишь незначительно лучше, тогда стоит подумать, на тем,
что может быть лучше использовать вместо него функцию.
@item
Ясность во время выполнения. Макросы иногда сложнее отлаживать, чем фунции.
Если вы получаете ошибку времени выполнения в коде, который содержит много
вызовов макросов, код который вы видите в обратной трассе, может состоять
из расширений вызовов всех этих макросов, и может иметь минимальное сходство
с кодом, который вы изначально писали.
И поскольку макросы исчезают при расширении, они не способствуют понимаемости
происходящего во время выполнения. Обычно вы не можете использовать трассировку,
чтобы увидеть как вызывается макрос. Если бы это вообще сработало,  trace покажет
вам вызов функции расширителя макроса, а не сам вызов макроса.
@item
Рекурсия. Использование рекурсии в макросах не так просто как в функциях. Хотя
функция  расширения макроса может быть рекусривной, само расширение не может
им быть. Раздел 10-4 посвящен теме рекусрии в макросах.
@end enumerate

Все эти соображения должны быть учтены вместе при принятии решения, когда использовать
макросы. Только опыт может сказать, что лучше. Тем не менее, примеры макросов,которые
появляются в последующих главах, охватывают большинство ситуаций в которых макросы полезны.
Если потенциальный макрос аналогичен приведенному здесь, тогда, вероятно, безопасно написать
его написать как таковой.

Наконец, следует отметить, что ясность во время выполнения (пункт 6) редко является
проблемой. Отладка кода, который использует многжество макросов, не будет такой уж
сложной, как вы могли бы ожидать. Если бы определения макросов были длиной несколько
сотен строк, неприятно было бы отлаживать их расширение во время выполнения. Но по
крайней мере утилиты, имеют тенденцию быть написанными в небольших, доверенных слоях.
Как правило их определения меньше 15 строк. Таким образом, даже если вы остлеживаете
трассировку вызовов, такие макросы не сильно затуманивают ваш обзор.

@node 8-3 Applications for Macros,  , 8-2 Macro or Function?, 8 When to Use Macros
@comment  node-name,  next,  previous,  up
@section 8-3 Приложения для Макросов
@cindex 8-3 Applications for Macros

Обдумав, что можно сделать с макросами, следующим вопросом будет:
в каких приложениях мы можем их использовать? Наиболее близким к общему
описанию использования макросов было бы сказать, что они используются в
основном для синтаксических преобразований. Это не означает, что область
применения макросов ограничена. Поскольку программы на Lisp состоят из 
списков @footnote{Состоят из, исползуется в том смысле, что списки являются
входными данными для компилятора, Функии больше не состоят из списков, как
это было в более ранних диалектах}, которые представляют собой структуры
данных Lisp, "синтаксические преобразования"  действительно могут иметь
большое значение. Главы 19 - ­24 представляют целые программы, цель которых
может быть описана как синтаксическое преобразование, и которые, по сути
вся являются макросами.

Приложения макросов образуют континуум от небольших макросов общего назначения,
вроде while, и до больших специальных макросов, определяемых в последующих главах.
На одном конце утилиты, макросы напоминающие те, которые встроены в каждый Lisp.
Они обычно маленькие, общие и написаны изолированно. Тем не менее, вы можете писать
утилиты для определенных классов программ, а также когда у вас есть коллекция
макросов для использования, скажем, в графических программах, так что они начинают
выглядеть как язык программирования графики. На дальнем конце конитинуума, макросы,
позволяющие писать на языке отличном от Lisp. Про макросы, используемые таким образом,
можно сказать, что они реализуют встроенный язык.

Утилиты являются первым результатом стилья проектирования снизу-вверх. Даже когда
программа слишком мала, чтобы быть построенной по слоям, она все равно может извлечь
выгоду от дополнений к самым низким слоям, таким как сам Lisp. Утилита nil!, которая
устанавливает свой аргумент в nil, не может быть определена иначе, чем как макрос:

@lisp
(defmacro nil! (x)
   `(setf ,x nil))
@end lisp

Глядя на nil!, хочеться сказать, что она ничего не делает, а просто сохраняет 
ввод. И это верно, но все что делает любой макрос, это сохранение ввода. Если кто-то
хочет подумайте об этом в этих терминах, что работа компилятора заключается в 
сохранении ввода на машинном языке. Значение утилит не следует недооценивать,
поскольку их влияние является комулятивным: несколько слоев простых макросов могут
создать различие между элегантной программой и непонятной программой.

Большинство утилит являются воплощением шаблонов.  Когда вы заметили шаблон в вашем
коде, рассмотрите возможность превратить его в утилиту. Шаблоны это просто то, в
чем компьютеры хороши. Зачем вам следовать за ними(шаблонами), когда у вас может быть
программа которая сделает это за вас? Предположим, при написании какой-то программы вы
испсользуете во многих разных местах циклы do имеющие одинаковую общую форму:

@lisp
(do ()
        ((not  condition ))
   .  body of code )
@end lisp

Когда вы обнаруживаете шаблон, повторящийся в вашем коде, этот шаблон часто имеет
имя. Имя нашего шаблона это while. Если мы хотим представить его в виде новой утилиты,
нам надо использовать макрос, потому что нам нужны условные и повторяющиеся вычисления.
Если мы определим while используя определения со страницы 91:

@lisp
(defmacro while (test &body body)
  `(do ()
            ((not ,test))
         ,@@body))
@end lisp

@noindent
тогда мы сможем заменить экземпляры шаблона на

@lisp
(while  condition 
  .  body of code )
@end lisp

Это сделает код короче, а также объявит то что он делает более ясным голосом.

Возможность преобразовывать свои аргументы делает макросы полезными при написании
интерфейсов. Соответствующий макрос позволить набирать более короткий текст, составлять
более простые и короткие выражения. Хотя графические интерфейсы уменьшают необходимость
в написании таких макросов для конечных пользователй, программисты используют этот
тип макросов как обычно. Самый распространенный пример это defun, который делает
привязку функций, похожей на определения в языках Паскаль или Си. Глава 2 упоминала,
что следующие два выражения имеют примерно одинаковый эффект:

@lisp
(defun foo (x) (* x 2))

(setf (symbol-function 'foo)
           #'(lambda (x) (* x 2)))
@end lisp

Таким образом defun может быть реализован как макрос который превращает первое выражение
во второе. Мы могли бы представить его следующим образом:@footnote{Для ясности, эта
весрия игнорирует всю бухгалтерию, которую должен выполнять defun.}

@lisp
(defmacro our-defun (name parms &body body)
  `(progn
         (setf (symbol-function ',name)
                 #'(lambda ,parms (block ,name ,@@body)))
         ',name))
@end lisp

Макросы подобные while и nil! могут быть описаны как утилиты общего назначения.
Любая программа Lisp может их использовать. Но определенные домены могут иметь
свои утилиты

@cartouche
@lisp
 (defun move-objs (objs dx dy)
       (multiple-value-bind (x0 y0 x1 y1) (bounds objs)
         (dolist (o objs)
            (incf (obj-x o) dx)
            (incf (obj-y o) dy))
         (multiple-value-bind (xa ya xb yb) (bounds objs)
            (redraw (min x0 xa) (min y0 ya)
                      (max x1 xb) (max y1 yb)))))

 (defun scale-objs (objs factor)
       (multiple-value-bind (x0 y0 x1 y1) (bounds objs)
         (dolist (o objs)
            (setf (obj-dx o) (* (obj-dx o) factor)
                   (obj-dy o) (* (obj-dy o) factor)))
         (multiple-value-bind (xa ya xb yb) (bounds objs)
            (redraw (min x0 xa) (min y0 ya)
                      (max x1 xb) (max y1 yb)))))
@end lisp

                        Рисунок 8-1: Исходные move и scale.
@end cartouche

также. Нет оснований полагать, что базовый Lisp является единственным уровнем,
на котором у вас есть для расширений язык программирования. Например, если вы
пишете программу CAD, лучшие результаты иногда получаются при  написании ее на
двух уровнях: язык (или, если вы предпочитаете более скромный термин,
инструментарий) для программ CAD, и в слое выше, ваше конкретное приложение.

Lisp стирает множество различий, которые другие языки воспринимают как должное.
В другоих языках действительно существует концептуальное различие между временем
компиляции и временем выполнения, программой и данными, языком и программой. В
Lisp эти различия существуют только как разговорные соглашения. В нем нет 
разделительной линии, например, между языком и программой. Вы можете сами нарисовать
разделительную линию соответствующую проблеме. Так что это не более чем вопрос
терминологии, следует ли называть нижележащий слой кода инструментарием или языком.
Одно преимущество рассмотрения его как язык, предполагает, что вы можете расширить
этот язык, как вы делаете это с Lisp-ом, создавая утилиты.

Предположим, мы пишем интерактивную программу для 2D рисования. Для простоты,
мы будем предполагать, что единственными объектами, обрабатываемыми программой,
являются отрезки, представленные как начало x,y  и вектор смещения dx, dy. Одна 
из вещей, которую должна делать такая программа это слайд группы объектов. Это
цель функции move-objs на Рисунке 8-1. Для эффективности мы не хотим перерисовывать
весь экран после каждой операции - только те части, которые изменились. Следовательно

@cartouche
@lisp
 (defmacro with-redraw ((var objs) &body body)
       (let ((gob (gensym))
               (x0 (gensym)) (y0 (gensym))
               (x1 (gensym)) (y1 (gensym)))
         `(let ((,gob ,objs))
             (multiple-value-bind (,x0 ,y0 ,x1 ,y1) (bounds ,gob)
                (dolist (,var ,gob) ,@@body)
                (multiple-value-bind (xa ya xb yb) (bounds ,gob)
                      (redraw (min ,x0 xa) (min ,y0 ya)
                                (max ,x1 xb) (max ,y1 yb)))))))

 (defun move-objs (objs dx dy)
       (with-redraw (o objs)
         (incf (obj-x o) dx)
         (incf (obj-y o) dy)))

 (defun scale-objs (objs factor)
       (with-redraw (o objs)
         (setf (obj-dx o) (* (obj-dx o) factor)
                      (obj-dy o) (* (obj-dy o) factor))))
@end lisp

                           Рисунок 8-2: Преобразованные move и scale.
@end cartouche

два вызова функции bounds, которая возвращает четыре координаты (min x, min y, 
max x, max y) представляют ограничивающий прямоугольник. Действующая часть
функции move-objs зажата между двумя вызовами bound, которые ищуют ограничивающий
прямоугольник до и после выполнения перемещения, и затем перерисовыем(redraw) весь
измененный регион.

Функция scale-objs предназначена для изменения размера группы объектов.
Поскольку ограничивающая область может увеличиваться или уменьшаться в зависимости
от маштабирующего коэффициэнта, эта функция так же должна выполнять свою работу
между двумя вызовами bounds. Если бы мы писали больше программ, мы бы увидели больше
повторений этого шаблона: в функциях для поворота(rotate), переворота(flip), 
транспонирования(transpose), и так далее.

С помощью макроса, мы можем абстрагировать общий код, который имеют эти функции.
Макрос with-redraw на Рисунке 8-2  предоставляет общий скелет функций представленных
на Рисунке 8-1.@footnote{Определение этого макроса предвосхищает следующую главу
использующу gensyms. Её назначение будет объяснено в ближайшее время.}. В результате,
эти функции можно теперь определить в четыре строки, каждую, как в конце рисунка 8-2. 
С этими двумя функциями новый макрос уже окупил себя по краткости. И насколько яснее
становяться две функции, когда мы абстрагируемся от деталей перерисовки экрана, 
скрываем их макросом.

Один из способов посмотреть на with-redraw, рассматривать ее как конструкцию
языка для написания интерактивных программ рисования. Поскольку мы разрабатываем
больше таких макросов, они будут напоминать язык программирования, как по сути,
так и по названию, и само наше приложение начнет показывать элегантность, которую
можно ожидать от программы, написанную на языке, определенном для этих конкретных
потребностей.

Другое основное использование макросов - реализация встроенных языков. Lisp
является исключительно хорошим языком для написания языков программирования,
потому что программы на  Lisp могут быть выражены в виде списков, а  Lisp имеет
встроенный парсер(читатель/read) и компилятор (compile) для программ выраженных
таким образом. Большую часть времени вам даже не надо вызывать компиляцию; Вы
можете скомпилировать встроенный язык неявно, путем компиляции кода, который
выполняет преобразования (стр. 25).

Встроенный язык, это язык написанный не столько поверх Lisp-а, сколько в
сочетании с ним, так что его синтаксис представляет собой смесь Lisp-а и
конструкций специфичных для нового языка. Наивный способ реализовать встроенный
язык - это написать интерпретатор для него на Lisp-е. Лучший подход, когда это
возможно, реализовать язык путем преобразований: преобразовывать каждое выражение
в код Lisp, который интерпретатор должен был исполнить в порядке его вычисления.
Это то место где используются макросы. Работа макросов состоит в том, чтобы точно
преобразовать один тип выражений в другой, поэтому они являются естественным выбором
при написании встроенных языков.

В целом, чем больше встроенный язык может быть реализован путем преобразований,
тем лучше. С одной стороны, это уменьшает количество работы. Например, если 
новый язык имеет арифметику, вам не нужно сталкиваться со всеми сложностями
представления и манипулирования числовыми величинами. Если арифметические 
возможности Lisp достаточны для ваших целей, то вы можете просто преобразовать
свои арифметические выражения в эквивалентные выражения Lisp, а остальное 
ставить Lisp-у.

Также использование преобразований обычно делает встроенные языки быстрее. 
Интерпретаторам присущи недостатки в отношении скорости.  Например, когда код
исполняется в цикле, интерпретатору, часто, приходиться повторять работу по
преобразованию кода на каждой итерации, которая в скомпилированном коде могла
быть выполнена только один раз. Поэтому, встроеный язык, который имеет свой 
собственный интерпретатор будет медленне, даже если интерпретатор сам скомпилирован.
Но если выражения в новом языке превращаются в Lisp, полученный код может быть
скомпилирован компилятором Lisp. Язык, реализованный таким образом, во время выполнения
не страдает от накладных расходов на интерпретацию. Если не писать настоящий компилятор
для вашего языка, макросы покажут лучшую скорость. Фактически, макросы которые преобразуют
новый язык, можно рассматривать как компилятор для него - просто возлагающий большую 
часть работы на существующий компилятор Lisp.

Мы не будем рассматривать примеры встроенных языков, так как глаы 19-­25 
целиком посвящены этой теме. Глава 19 конкретно рассматривает разницу между
интерпретацией и преобразованием встроенных языков и показывает один и тот же
язык реализованный каждым из двух методов.

Одна книга по Common Lisp утверждает что область применения макросов ограничена,
ссылаясь в качестве доказательства на тот факкт, что из операторов определенных в
CLTL1, менее 10% были макросами. Это все равно, что сказать, что поскольку наш дом
сделан из кирпича, наша мебель должна быть сделана из него тоже. Доля макросов в
программе Common Lisp будет зависеть полностью от того, что она должна делать.
Некоторые программы не содержат макаросов, а некоторые программы целиком могут быть
макросами.