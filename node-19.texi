@node 19 A Query Compiler, 20 Continuations, 18 Destructuring, Top
@comment  node-name,  next,  previous,  up
@chapter 19 Компилятор Запросов
@cindex 19 A Query Compiler

Некоторые из макросов определенных в предыдущей главе, были большими. Чтобы 
сгенерировать рассширение if-match потребовался весь код на Рисунках 18-7 и 18-8,
плюс destruc из Рисунка 18-1. Макросы такого размера естественным образом ведут
к нашей последней теме - встроенным языкам. Если небольшие макросы являются
расширениями Lisp, большие макросы определяют внутриязыковые подъязыки, возможно
со своим собственным синтаксисом или структурой управления. Мы увидели начало 
этого в  if-match, который имел свое собственное отдельное представление для
переменных.

Язык, реализованный внутри Lisp называется встроенным языком. Как и "полезность(utility)",
этот термин не является четко определенным; if-match вероятно, все еще считается
утилитой, но приближается к границе.

Встроенный язык не похож на язык, реализованный традиционным транслятором или
интерперетатором. Он реализуется в рамках существующего языка, обычно путем
преобразования. Не должно былть никакого барьера между базовым языком и
расширением: должна быть возможность, свободного их смешивания. Для разработчкика
это может означать огромную экономию усилий. Вы можете встраивать только то, что
вам нужно, а в остальном использовать базовый язык.

Преобразование в Lisp, предполагает макросы. В некоторой степени вы можете 
реализовать встроенный языки с препроцессорами. Но препроцессоры обычно работают
только с текстом, в то время как макросы используют уникальное свойство Lisp: 
между читателем(reader) и компилятором, ваша программа Lisp представляется
в виде списков объектов Lisp. Преобразования, сделанные на этом этапе,
могут быть намного умнее.

Наиболее известным примером встроенного языка является CLOS - Common Lisp
Object System. Если вы хотите создать объектно-ориентированную версию обычного
языка, вам придется написать новый компилятор. В Lisp это не так. Настройка 
компилятора заставит CLOS работать быстрее, но в принципе компилятор менять
вообще не нужно. Все это можно написать и на Lisp.

В остальных главах приведены примеры встроенных языков. В этой главе описывается,
как встроить в Lisp программу отвечающую на запросы к базе данных. (В этой программе
вы заметите семейное сходствов с if-match.) Первые разделы описывают, как написать
систему, которая интерпретирует запросы. Затем эта программа реализуется как компилятор
запросов - по сути, как один большой макрос - что делает её более эффективной и лучше
интегрированной с Lisp.

@menu
* 19-1 The Database::           
* 19-2 Pattern-Matching Queries::  
* 19-3 A Query Interpreter::    
* 19-4 Restrictions on Binding::  
* 19-5 A Query Compiler::       
@end menu

@node 19-1 The Database, 19-2 Pattern-Matching Queries, 19 A Query Compiler, 19 A Query Compiler
@comment  node-name,  next,  previous,  up
@section 19-1 База Данных
@cindex 19-1 The Database

Для наших нынешних целей формат базы данных не имеет большого значения. Здесь для
удобства мы будем хранить информацию в списках. Например, мы представим тот факт,
что Joshua Reynolds был английским художником, который жил с 1723 по 1792:

@lisp
(painter reynolds joshua english)
(dates reynolds 1723 1792)
@end lisp

Не существует канонического(общепризнанного) способа сведения информации в списки.
Мы также могли бы использовать один большой список:


@lisp
(painter reynolds joshua 1723 1792 english)
@end lisp

Пользователь должен решить, как организовать записи в базе данных. Единственным ограничением
является то, что записи(факты) будут проиндексированы в соответствии с их первым элементом
(передикатом). В этих рамки подойдет любая совместимая форма, хотя некоторые формы могут
выполнять запросы быстрее, чем другие.

Любой системе баз данных требуются как минимум две операции: одна для изменения
базы данных и одна для её проверки. Код показанный на Рисунке 19-1 передоставляет
эти операции в базовой форме. База данных представлена в виде хеш-таблицы, 
заполненной списками фактов, хешированных в соответствии с их пердикатом(первым 
элементом).

Хотя функции базы данных, определенные на Рисунке 19-1 поддерживают несколько
баз данных, все они по умолчанию работают с  *default-db*.  Как и в случае с 
пакетами в Common Lisp, программы, которым не требуется несколько баз данных,
даже не должны упоминать их. В этой главе во всех примерах будет использоваться
*default-db*.

Мы инициализируем систему, вызывая clear-db, который очищает текущую базу данных.
Мы можем искать факты с заданным предикатом с помощью db-query, и вставлять новые
факты в базу данных с помощью db-push. Как объяснено в Разделе 12-1, макрос который
расширяется в обратимую ссылку, сам по себе будет обратимым. Так как db-query 
определен таким же образом, мы можем просто вставить новые факты в db-query в виде
его предикатов. В Common Lisp, записи хеш-таблицы инициализируются как nil

@cartouche
@lisp
     (defun make-db (&optional (size 100))
       (make-hash-table :size size))

     (defvar *default-db* (make-db))

     (defun clear-db (&optional (db *default-db*))
       (clrhash db))

     (defmacro db-query (key &optional (db '*default-db*))
       `(gethash ,key ,db))

     (defun db-push (key val &optional (db *default-db*))
       (push val (db-query key db)))

     (defmacro fact (pred &rest args)
       `(progn (db-push ',pred ',args)
               ',args))
@end lisp

                     Рисунок 19-1: Базовые функции работы с базой данных.
@end cartouche

@noindent
если не указано иное, поэтому любой ключ изначально имеет пустой список, связанный с
ним. Наконец, макрос fact добавляет новый факт в базу данных.

@example
> (fact painter reynolds joshua english)
(REYNOLDS JOSHUA ENGLISH)
> (fact painter canale antonio venetian)
(CANALE ANTONIO VENETIAN)
> (db-query 'painter)
((CANALE ANTONIO VENETIAN)
     (REYNOLDS JOSHUA ENGLISH))
T
@end example

Значение t возвращаемое как второе значение db-query появляется потому, что db-query
расширяется в gethash, который возвращает в качестве второго значения флаг, позволяющий
различать, не найде на ли запись, или найдена запись, значение которой равно nil.

@node 19-2 Pattern-Matching Queries, 19-3 A Query Interpreter, 19-1 The Database, 19 A Query Compiler
@comment  node-name,  next,  previous,  up
@section 19-2 Запросы Сопоставление с Образцом(Pattern-Matching Queries)
@cindex 19-2 Pattern-Matching Queries

Вызов db-query не очень гибкий способ просмотра содержимого базы данных. Обычно
пользователь хочет задать вопросы, которые зависят не только от первого элемента
факта. Язык запросов - это язык для выражения

@cartouche
@lisp
  query         : ( symbol  argument *)
                : (not  query )
                : (and  query *)
                : (or  query *)
  argument  : ? symbol 
                :  symbol 
                :  number 
@end lisp

                         Рисунок 19-2: Синтаксис запросов.
@end cartouche

более сложных запросов. В типичном языке запросов пользователь может запросить все
значения, которые удовлетворяют некоторой комбинации ограничений, например, фамилии
всех художников родившихся в 1697.

Наша программа предоставляет декларативный язык запросов. В декларативном языке
запросов пользователь указывает ограничения, которым должны удовлетворять ответы
и предоставляет системе возможность выяснить, как их сгенерировать. Этот способ
выражения запросов близок к форме, которую люди используют в повседневной беседе. 
С нашей программой мы можем выразить пример запроса, запросив все x, то есть 
факты формы (painter x ...), и факты формы (dates x 1697 ...). Мы можем сослаться
на всех художников(painters) родившихся в 1697 году записав:

@lisp
(and (painter ?x ?y ?z)
        (dates ?x 1697 ?w))
@end lisp

Помимо принятия простых запросов, состоящих из предиката и некоторых аргументов,
наша программа сможет отвечать на произвольно сложные запросы, объединенные
логическими операторами, такими как and и or. Синтаксис языка запросов показан
на рисунке 19-2.

Поскольку факты индексируются по их предикатам, переменные не могут появлятья в
позиции предиката. Если вы готовы отказаться от преимуществ индексирования, вы
можете обойти это ограничение, всегда используя один и тот же предикат и делая
первый аргумент предикатом де-факто.

Как и в большинстве подобных систем, в этой программе скептическое представление об
истинности: некоторые факты известны, а все остальное ложно. Оператор not завершается
успехом, если рассматриваемый факт отсутствует в базе данных. В некоторой степени
вы могли бы представить явную ложь методом Мира Уэйна:

@lisp
(edible motor-oil not)
@end lisp

Однако оператор not не будет относиться к этим фактам иначе, чем другие.

В языках программирования существует принципиальное различие между интерпретируемыми
и скомпилированными программами. В этой главе мы рассмотрим тот же вопрос в отношении
запросов. Интеретатор запросов принимает запрос и использует его для генерации ответов
из базы данных. Компилятор запросов принимаетт запрос и генерирует программу, которая
при запуске дает тот же результат. В следующих разделах описывается интерпретатор
запросов, а затем компилятор запросов.

@node 19-3 A Query Interpreter, 19-4 Restrictions on Binding, 19-2 Pattern-Matching Queries, 19 A Query Compiler
@comment  node-name,  next,  previous,  up
@section 19-3 Интерпретатор Запросов
@cindex 19-3 A Query Interpreter

Для реализации декларативного языка запросов мы будем использовать утилиты
сопоставления с образцом, определенные в разделе 18-4. Функции, показанные на
рисунке 19-3 интерпретируют запросы представленные в форме показанной на 
рисунке 19-2. Центральной функцией в этом коде является interpret-query, которая
рекурсивно работает проходя через структуру сложного запроса, генерируя
в процессе привязки. Вычисление сложных запросов происходит слева на право, 
как и в самом Common Lisp.

Когда рекурсия опускается вниз к образцам для фактов, interpret-query вызывает lookup. 
Здесь происходит сопоставление с образцом. Функция lookup принимает образец состоящий из
предиката и списка аргументов, и возвращает список всех привязок, которые делают
соответствующим образец некоторым фактам в базе данных. Он получает все записи базы данных
для предиката и вызывает match(сопоставление) (стр 239), чтобы сравнить каждую из них с
образцом. Каждое успешное сравнение возвращает список привязок, а lookup, в свою очередь,i
возвращает список всех этих списков.

@example
> (lookup 'painter '(?x ?y english))
(((?Y . JOSHUA) (?X . REYNOLDS)))
@end example

Эти результаты затем фильтруются или объединяются в зависимости от окружающих
логических операторов. Окончательный результат возвращается в виде списка
наборов привязок. Учитывая утверждения показанные на Рисунке 19-4, вот
пример интерпретации запроса указанного ранее в этой главе:

@example
> (interpret-query '(and (painter ?x ?y ?z)
                                   (dates ?x 1697 ?w)))
(((?W . 1768) (?Z . VENETIAN) (?Y . ANTONIO) (?X . CANALE))
 ((?W . 1772) (?Z . ENGLISH) (?Y . WILLIAM) (?X . HOGARTH)))
@end example

Как правило, запросы могут быть объединены и вложены без ограничений. В некоторых
случаях существуют тонкие ограничения на синтаксис запросов, но лучше всего с ними
разобраться посмотрев некотоыре примеры использования этого кода.

Макрос with-answer обеспечивает понятный способ использования интерпретатора
запросов в программах Lisp. В качестве первого аргумента он принимает любой
правильно сформированный запрос; остальные аргументы обрабатываются как тело
кода. Макрос with-answer расширяется в

@cartouche
@lisp
 (defmacro with-answer (query &body body)
   (let ((binds (gensym)))
        `(dolist (,binds (interpret-query ',query))
              (let ,(mapcar #'(lambda (v)
                                  `(,v (binding ',v ,binds)))
                              (vars-in query #'atom))
               ,@@body))))

 (defun interpret-query (expr &optional binds)
   (case (car expr)
        (and (interpret-and (reverse (cdr expr)) binds))
        (or      (interpret-or (cdr expr) binds))
        (not (interpret-not (cadr expr) binds))
        (t       (lookup (car expr) (cdr expr) binds))))

 (defun interpret-and (clauses binds)
   (if (null clauses)
         (list binds)
         (mapcan #'(lambda (b)
                        (interpret-query (car clauses) b))
                    (interpret-and (cdr clauses) binds))))

 (defun interpret-or (clauses binds)
   (mapcan #'(lambda (c)
                    (interpret-query c binds))
                 clauses))

 (defun interpret-not (clause binds)
   (if (interpret-query clause binds)
         nil
         (list binds)))

 (defun lookup (pred args &optional binds)
   (mapcan #'(lambda (x)
                    (aif2 (match x args binds) (list it)))
                 (db-query pred)))
@end lisp

                        Рисунок 19-3: Интерпретатор Запросов.
@end cartouche

@cartouche
@lisp
 (clear-db)
 (fact painter hogarth william english)
 (fact painter canale antonio venetian)
 (fact painter reynolds joshua english)
 (fact dates hogarth 1697 1772)
 (fact dates canale 1697 1768)
 (fact dates reynolds 1723 1792)
@end lisp

                       Рисунок 19-4: Утверждение фактов для примера.
@end cartouche

@noindent
код, который собирает все наборы привязок, сгенерированных запросом, затем итерирует 
тело выражений с переменными связанными в запросе, которые определены в каждом наборе
привязок. Переменные, которые появляются в with-answer могут (обычно) использоваться
внутри его тела. Когда запрос успешен, но не содержит переменных with-answer исполняет
тело кода только один раз.

С базой данных, определенной на рисунке 19-4, на риснуке 19-5 показаны некоторые
примеры запросов, сопровождаемые переводами на английский язык. Поскольку сопоставление
с образцом выполняется с помощью match, можно использовать подчеркивание как безразличное
поле в образце.

Чтобы эти примеры были короткими, код внутри тел запросов не делает ничего, кроме
печати нескольких результатов. В общем, тело with-answer может состоять из
любых выражений Lisp.

@node 19-4 Restrictions on Binding, 19-5 A Query Compiler, 19-3 A Query Interpreter, 19 A Query Compiler
@comment  node-name,  next,  previous,  up
@section 19-4 Ограничения на связывание
@cindex 19-4 Restrictions on Binding

Существуеют некоторые ограничения на то, какие переменные будут связаны запросом.
Например, почему запрос

@lisp
(not (painter ?x ?y ?z))
@end lisp

@noindent
должен назначать какие либо привязки ?x и ?y вообще? Существует бесконечное 
количество комбинаций ?x и ?y, которые не являются именем какого либо художника(painter).
Таким образом, мы добавляем следующее ограничение: оператор not будет отфильтровывать
привязки, котоыре уже созданы, как в

@lisp
(and (painter ?x ?y ?z) (not (dates ?x 1772 ?d)))
@end lisp

@noindent
но вы не можете ожидать, что он будет генерировать привязки сам по себе. Мы должны
создать наборы привязок, при поиске художников(painters), прежде чем мы сможем отобрать
тех, кто не родился в 1772. Если бы мы поместили предложения в обратном порядке:

@lisp
(and (not (dates ?x 1772 ?d)) (painter ?x ?y ?z))                        ; wrong
@end lisp

@cartouche
Первое имя(имя) и национальность каждого художника называемого Hogarth.

@example
 > (with-answer (painter hogarth ?x ?y)
         (princ (list ?x ?y)))
 (WILLIAM ENGLISH)
 NIL
@end example

Последнее имя(фамилия) каждого художника родившегося в 1697. (Наш оригинальный пример.)

@example
 > (with-answer (and (painter ?x _ _)
                            (dates ?x 1697 _))
         (princ (list ?x)))
 (CANALE)(HOGARTH)
 NIL
@end example

Последнее имя(фамилия) и год рождения любого кто умер в  1772 или  1792.

@example
 > (with-answer (or (dates ?x ?y 1772)
                          (dates ?x ?y 1792))
         (princ (list ?x ?y)))
 (HOGARTH 1697)(REYNOLDS 1723)
 NIL
@end example

Последнее имя(фамилия) каждого английского художника, который родился не в тот
же год, что и Venetian
one.

@example
 > (with-answer (and (painter ?x _ english)
                            (dates ?x ?b _)
                            (not (and (painter ?x2 _ venetian)
                                         (dates ?x2 ?b _))))
         (princ ?x))
 REYNOLDS
 NIL
@end example

                   Рисунок 19-5: Использование интерпретатора запросов.
@end cartouche

@noindent
тогда мы получим nil в качестве результата, если в 1772 году рождались художники. Даже
в первом примере, мы не должны ожидать, что сможем использовать значение ?d в теле выражения
with-answer.

Кроме того, выражение вида (or q1 ... qn) гарантировано генерирует реальные
привязки только для переменных, которые встречаются во всех qi. Если with-answer
содержал запрос

@lisp
(or (painter ?x ?y ?z) (dates ?x ?b ?d))
@end lisp

можно ожидать использования привязки ?x, потому что не зависимо от того, какой из
подзапросов будет успешным, он сгенерирует привязку для ?x. Но ни ?y, ни ?b не
гарантировано получение привязки  из запроса, хотя тот или другой её получат. 
Переменные образца не связанные с запросом, будут равны nil для этой итерации.

@node 19-5 A Query Compiler,  , 19-4 Restrictions on Binding, 19 A Query Compiler
@comment  node-name,  next,  previous,  up
@section 19-5 Компилятор Запросов
@cindex 19-5 A Query Compiler

Код на рисунке 19-3 делает то что мы хотим, но неэффективно. Он анализирует
структуру запроса во время выполнения, хотя она известна уже во время компиляции.
И он содержит списки для хранения привязок переменных, когда мы можем использовать
переменные для хранения своих собственных значений. Обе эти проблемы могут быть
решены путем определения with-answer другим способом.

Рисунок 19-6 оеределяет новую версию with-answer. Новая версия продолжает 
тенденцию, которая началась с avg (стр. 182), и продолжилась в if-match
(стр. 242): она выполняет во время компиляции большую часть работы, которую
старая версия выполняла во время выполнения. Код на рисунке 19-6 имеет внешнее
сходство с кодом на рисунке 19-3, но ни одна из этих функций не вызывается во
время выполнения. Вместо того, чтобы генерировать привязки, они генерируют код,
который становиться частью расширения with-answer. Во время выполнения этот код
будет генерировать все привязки, которые удовлетворяют запросу в соответствии с
текущим состоянием базы данных.

По сути, эта программа является одним большим макросом. На рисунке 19-7 показано
расширение макроса with-answer. Большая часть работы выполняется с помощью pat-match 
(стр. 242), который сам является макросом. Теперь единственными новыми функциями,
необходимыми во время выполнения, являются функции базы данных, показанные на
Рисунке 19-1.

Когда with-answer вызвается на верхнем уровне, компиляция запросов имеет мало
преимуществ. Код, представляющий запрос, генерируется, выполняется, а затем
отбрасывается. Но когда в программе на Lisp появляется выражение with-answer,
код, представляющий запрос, становиться частью расширения этого макроса. Поэтому,
когда содержащая его программа компилируется, код для всех запросов будет
скомпилирован и встроен в процесс.

Хотя основным преимуществом нового подхода является скорость, он также позволяет
лучше интегрировать выражения with-answer в код, в котором они появляются.
Здесь показаны два конкретных улучшения. Во-первых, теперь вычисляются аргументы
в запросе, поэтому мы можем сказать:

@example
   > (setq my-favorite-year 1723)
   1723
   > (with-answer (dates ?x my-favorite-year ?d)
           (format t "~A was born in my favorite year.~%" ?x))
   REYNOLDS was born in my favorite year.
   NIL
@end example

@cartouche
@lisp
 (defmacro with-answer (query &body body)
   `(with-gensyms ,(vars-in query #'simple?)
         ,(compile-query query `(progn ,@@body))))

 (defun compile-query (q body)
   (case (car q)
        (and (compile-and (cdr q) body))
        (or     (compile-or (cdr q) body))
        (not (compile-not (cadr q) body))
        (lisp `(if ,(cadr q) ,body))
        (t      (compile-simple q body))))

 (defun compile-simple (q body)
   (let ((fact (gensym)))
        `(dolist (,fact (db-query ',(car q)))
              (pat-match ,(cdr q) ,fact ,body nil))))

 (defun compile-and (clauses body)
   (if (null clauses)
         body
         (compile-query (car clauses)
                              (compile-and (cdr clauses) body))))

 (defun compile-or (clauses body)
   (if (null clauses)
         nil
         (let ((gbod (gensym))
                  (vars (vars-in body #'simple?)))
               `(labels ((,gbod ,vars ,body))
                 ,@@(mapcar #'(lambda (cl)
                                   (compile-query cl `(,gbod ,@@vars)))
                              clauses)))))

 (defun compile-not (q body)
   (let ((tag (gensym)))
        `(if (block ,tag
                 ,(compile-query q `(return-from ,tag nil))
                 t)
               ,body)))
@end lisp

                           Рисунок 19-6: Компилятор Запросов.
@end cartouche

@cartouche
@lisp
 (with-answer (painter ?x ?y ?z)
       (format t "~A ~A is a painter.~%" ?y ?x))

 расширеяется интерпретатором запросов в:

 (dolist (#:g1 (interpret-query '(painter ?x ?y ?z)))
       (let ((?x (binding '?x #:g1))
               (?y (binding '?y #:g1))
               (?z (binding '?z #:g1)))
         (format t "~A ~A is a painter.~%" ?y ?x)))

 и компилятором запросов в:

 (with-gensyms (?x ?y ?z)
       (dolist (#:g1 (db-query 'painter))
         (pat-match (?x ?y ?z) #:g1
                (progn
                   (format t "~A ~A is a painter.~%" ?y ?x))
                nil)))
@end lisp

                   Рисунок 19-7: Два расширения одного и того же запроса.
@end cartouche

Это можно было бы сделать и в интерпретаторе запросов, но только за счет явного
вызова eval. И даже тогда не было бы возможности ссылаться на лексические 
переменные в аргументах запроса.

Посокльку аргументы в запросах теперь вычисляются, любой буквенный аргумент 
(например english), который не вычисляет сам себя, теперь должен заключаться
в кавычки. (См. Рисунок 19-8.)

Второе преимущество нового подхода состоит в том, что теперь гораздо проще 
включать нормальные выражения Lisp в запросы. Компилятор запросов добавляет
оператор lisp, за которым может следовать любое выражение Lisp. Как и оператор
not, он не может генерировать привязки сам по себе, но отсеивает привязки, для
которых выражение возвращает nil. Оператор lisp полезен для получения встроенных
предикатов, таких как >:

@example
> (with-answer (and (dates ?x ?b ?d)
                             (lisp (> (- ?d ?b) 70)))
        (format t "~A lived over 70 years.~%" ?x))
CANALE lived over 70 years.
HOGARTH lived over 70 years.
NIL
@end example

Хорошо реализованный встроенный язык может иметь цельный интерфейс с базовым
языком с обеих сторон.

@cartouche
The first name and nationality of every painter called Hogarth.

@example
 > (with-answer (painter 'hogarth ?x ?y)
        (princ (list ?x ?y)))
 (WILLIAM ENGLISH)
 NIL
@end example

The last name of every English painter not born in the same year as a Venetian
painter.

@example
 > (with-answer (and (painter ?x _ 'english)
                           (dates ?x ?b _)
                           (not (and (painter ?x2 _ 'venetian)
                                         (dates ?x2 ?b _))))
        (princ ?x))
 REYNOLDS
 NIL
@end example

The last name and year of death of every painter who died between 1770 and
1800 exclusive.

@example
 > (with-answer (and (painter ?x _ _)
                           (dates ?x _ ?d)
                           (lisp (< 1770 ?d 1800)))
        (princ (list ?x ?d)))
 (REYNOLDS 1792)(HOGARTH 1772)
 NIL
@end example

                    Рисунок 19-8: Использование компилятора запросов.
@end cartouche

@noindent


Помимо этих двух дополнений - вычисления аргументов и нового оператора lisp -
язык запросов, поддерживаемый компилятором запросов, идентичен языку, 
поддерживаемому интерпретатором. На рисунке 19-8 показаны примеры результатов,
полученных кодом сгенерированным компилятором запросов с базой данных определенной 
на рисунке 19-4.

В разделе 17-2 приведены две причины, по которым лучше скомпилировать выражение,
чем передаавать его в виде списка, для выполнения. Первая из них, быстрота и 
возможность вычислять выражение в окружающем лексическом контексте. Преимущества
составления запросов в точности аналогичны. Работа, которая раньше выполнялась
во время выполнения, теперь выполняется во время компиляции. И поскольку запросы
компилируются как часть окружающего Lisp кода, они могут использовать преимущества
окружающего лексического контекста.