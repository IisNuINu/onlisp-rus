#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-22.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 12:37+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-22.texi:5
msgid ""
"@node 22 Nondeterminism, 23 Parsing with ATNs, 21 Multiple Processes, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 22 Nondeterminism\n"
"@cindex 22 Nondeterminism"
msgstr ""
"@node 22 Nondeterminism, 23 Parsing with ATNs, 21 Multiple Processes, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 22 Недетерминированность\n"
"@cindex 22 Nondeterminism"

#: texi/node-22.texi:11
msgid ""
"Programming languages save us from being swamped by a mass of detail. Lisp "
"is\n"
"a good language because it handles so many details itself, enabling "
"programmers\n"
"to make the most of their limited tolerance for complexity. This chapter "
"describes\n"
"how macros can make Lisp handle another important class of details: the "
"details\n"
"of transforming a nondeterministic algorithm into a deterministic one."
msgstr ""
"Языки программирования помогают не утонуть в деталях.  Язык Лисп хорош\n"
"тем, что сам управляется со многими из них, предоставляя программисту\n"
"выжать максимум из ограниченной способности удерживать сложное.  Эта\n"
"глава посвящена тому, как с помощью макросов можно обращаться с ещё\n"
"одним важным классом подробностей: подробностей преобразования\n"
"недетерминированного алгоритма в детерминированный."

#: texi/node-22.texi:19
msgid ""
"This chapter is divided into five parts. The first explains what "
"nondeterminism\n"
"is. The second describes a Scheme implementation of nondeterministic choose "
"and\n"
"fail which uses continuations. The third part presents Common Lisp versions "
"of\n"
"choose and fail which build upon the continuation-passing macros of Chapter "
"20.\n"
"The fourth part shows how the cut operator can be understood independently\n"
"of Prolog. The final part suggests refinements of the original "
"nondeterministic\n"
"operators."
msgstr ""
"В главе пять частей.  Первая объясняет смысл недетерминированности.\n"
"Вторая описывает реализацию недетерминированного /выбора/ и /неудачи/\n"
"на Scheme с использованием продолжений.  В третьей представлена версия\n"
"на Common Lisp на основе передающих продолжения макросов из 20-ой\n"
"главы.  Четвёртая показывает, как понять оператор отсечения (cut) вне\n"
"зависимости от Пролога.  Последняя предлагает уточнения исходных\n"
"недетерминированных операторов."

#: texi/node-22.texi:22
msgid ""
"The nondeterministic choice operators defined in this chapter will be used "
"to\n"
"write an ATN compiler in Chapter 23 and an embedded Prolog in Chapter 24."
msgstr ""
"Оператор недетерминированного выбора используется в дальнейшем при\n"
"написании ATN-компилятора в 23-ей главе и встроенного Пролога в 24-ой."

#: texi/node-22.texi:31
msgid ""
"@menu\n"
"* 22-1 The Concept::            \n"
"* 22-2 Search::                 \n"
"* 22-3 Scheme Implementation::  \n"
"* 22-4 Common Lisp Implementation::  \n"
"* 22-5 Cuts::                   \n"
"* 22-6 True Nondeterminism::    \n"
"@end menu"
msgstr ""

#: texi/node-22.texi:36
msgid ""
"@node 22-1 The Concept, 22-2 Search, 22 Nondeterminism, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-1 The Concept\n"
"@cindex 22-1 The Concept"
msgstr ""
"@node 22-1 The Concept, 22-2 Search, 22 Nondeterminism, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-1  Общая идея\n"
"@cindex 22-1 The Concept"

#: texi/node-22.texi:44
msgid ""
"A nondeterministic algorithm is one which relies on a certain sort of "
"supernatural\n"
"foresight. Why talk about such algorithms when we don't have access to "
"computers\n"
"with supernatural powers? Because a nondeterministic algorithm can be "
"simulated\n"
"by a deterministic one. For purely functional programs-that is, those with\n"
"no side-effects-simulating nondeterminism is particularly straightforward. "
"In\n"
"purely functional programs, nondeterminism can be implemented by search "
"with\n"
"backtracking."
msgstr ""
"Недетерминированный алгоритм — алгоритм на основе сверхъестественного\n"
"предвидения.  Зачем говорить о них, не располагая сверхъестественными\n"
"компьютерами?  Потому что недетерминированный алгоритм можно\n"
"имитировать детерминированным.  Это особенно просто в чисто\n"
"функциональных программах (не имеющих побочных эффектов).  В них его\n"
"можно реализовать с помощью поиска с отступлением.\n"

#: texi/node-22.texi:53
msgid ""
"This chapter shows how to simulate nondeterminism in functional programs.\n"
"If we have a simulator for nondeterminism, we can expect it to produce "
"results\n"
"whenever a truly nondeterministic machine would. In many cases, writing a\n"
"program which depends on supernatural insight to solve a problem is easier "
"than\n"
"writing one which doesn't, so such a simulator would be a good thing to have."
msgstr ""
"Эта глава посвящена имитации неопределённости в функциональных\n"
"программах.  Располагая таким имитатором, мы рассчитываем справляться\n"
"с проблемами, разрешимыми на действительно недетерминированной машине.\n"
"Зачастую программа с сверхъестественными озарениями пишется проще\n"
"обычной, так что этот имитатор иметь в наличии хорошо."

#: texi/node-22.texi:58
msgid ""
"In this section we will define the class of powers that nondeterminism "
"allows\n"
"us; the next section demonstrates their utility in some sample programs. "
"The\n"
"examples in these first two sections are written in Scheme. (Some "
"differences\n"
"between Scheme and Common Lisp are summarized on page 259.)"
msgstr ""
"Данный раздел очерчивает класс возможностей, предоставляемых нам\n"
"неопределённостью; следующий демонстрирует их полезность в некоторых\n"
"программах.  Примеры написаны на Scheme.  (О некоторых различиях между\n"
"Scheme и Common Lisp сказано в начале 20-ой главы.)"

#: texi/node-22.texi:63
msgid ""
"A nondeterministic algorithm differs from a deterministic one because it "
"can\n"
"use the two special operators choose and fail. Choose is a function which "
"takes a\n"
"finite set and returns one element. To explain how choose chooses, we must "
"first\n"
"introduce the concept of a computational future."
msgstr ""
"Недетерминированный алгоритм отличается от детерминированного\n"
"использованием специальных операторов /выбора/ и /неудачи/.  /Выбор/\n"
"принимает ограниченное множество и возвращает один элемент.  Чтобы\n"
"объяснить принцип работы /выбора/, нужно ввести понятие\n"
"вычислительного /будущего/."

#: texi/node-22.texi:67
msgid ""
"Here we will represent choose as a function choose which takes a list and\n"
"returns one element. For each element, there is a set of futures the "
"computation\n"
"could have if that element were chosen. In the following expression"
msgstr ""
"Здесь /выбор/ представлен функцией =choose=, принимающей список и\n"
"возвращающей его элемент.  Для каждого элемента есть набор будущих,\n"
"принимаемых вычислением при условии выбора этого элемента.  В\n"
"следующем примере"

#: texi/node-22.texi:74
msgid ""
"@lisp\n"
"(let ((x (choose '(1 2 3))))\n"
"  (if (odd? x)\n"
"         (+ x 1)\n"
"         x))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:78
msgid ""
"@noindent\n"
"there are three possible futures for the computation when it reaches the "
"point of\n"
"the choose:"
msgstr ""
"@noindent\n"
"к моменту достижения =choose= у вычисления три возможных будущих:"

#: texi/node-22.texi:83
msgid ""
"@enumerate\n"
"@item\n"
"If choose returns 1, the computation will go through the then-clause of the\n"
"        if, and will return 2."
msgstr ""
"@enumerate\n"
"@item\n"
"    Если =choose= возвращает 1, вычисление по ветви “то” вернёт 2."

#: texi/node-22.texi:87
msgid ""
"@item\n"
"If choose returns 2, the computation will go through the else-clause of the\n"
"        if, and will return 2."
msgstr ""
"@item\n"
"     Если =choose= возвращает 2, вычисление по ветви “иначе” вернёт 2."

#: texi/node-22.texi:92
msgid ""
"@item\n"
"If choose returns 3, the computation will go through the then-clause of the\n"
"        if, and will return 4.\n"
"@end enumerate"
msgstr ""
"@item\n"
"      Если =choose= возвращает 3, вычисление по ветви “то” вернёт 4.\n"
"@end enumerate"

#: texi/node-22.texi:97
msgid ""
"In this case, we know exactly what the future of the computation will be as "
"soon\n"
"as we see what choose returns. In the general case, each choice is "
"associated with\n"
"a set of possible futures, because within some futures there could be "
"additional\n"
"chooses. For example, with"
msgstr ""
"В данном случае мы знаем точное будущее сразу, как только =choose=\n"
"вернёт какое-либо значение.  Вообще же каждый выбор связан с набором\n"
"возможных будущих, потому что в некоторых из них могут быть\n"
"дополнительные выборы.  К примеру\n"

#: texi/node-22.texi:104
msgid ""
"@lisp\n"
"(let ((x (choose '(2 3))))\n"
"  (if (odd? x)\n"
"         (choose '(a b))\n"
"         x))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:107
msgid ""
"@noindent\n"
"there are two sets of futures at the time of the first choose:"
msgstr ""
"@noindent\n"
"после первого выбора имеется два набора будущих:"

#: texi/node-22.texi:117
msgid ""
"@enumerate\n"
"@item\n"
"If choose returns 2, the computation will go through the else-clause of the\n"
"         if, and will return 2.\n"
"@item\n"
"If choose returns 3, the computation will go through the then-clause of\n"
"         the if. At this point, the path of the computation splits into two "
"possible\n"
"         futures, one in which a is returned, and one in which b is.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"      Если =choose= возвращает 2, вычисление по ветви “иначе” вернёт 2.\n"
"@item\n"
"      Если =choose= возвращает 3, вычисление по ветви “то” разделится на\n"
"      два возможных будущих, одно из которых возвращает =a=, другое — =b=.\n"
"@end enumerate"

#: texi/node-22.texi:120
msgid ""
"The first set has one future and the second set has two, so the computation "
"has\n"
"three possible futures."
msgstr "У первого набора одно будущее, у второго — два; всего — три."

#: texi/node-22.texi:124
msgid ""
"The point to remember is, if choose is given a choice of several "
"alternatives,\n"
"each one is associated with a set of possible futures. Which choice will it "
"return?\n"
"We can assume that choose works as follows:"
msgstr ""
"Здесь важно, что каждый из альтернативных выборов связан со своим\n"
"набором возможных будущих.  Какой из них будет возвращён?  Можно\n"
"предположить, что /выбор/ работает следующим образом:"

#: texi/node-22.texi:132
msgid ""
"@enumerate\n"
"@item\n"
"It will only return a choice for which some future does not contain a call "
"to\n"
"         fail.\n"
"@item\n"
"A choose over zero alternatives is equivalent to a fail.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"    Он вернёт лишь тот набор будущих, в котором хотя бы одно не\n"
"    заканчивается /неудачей/.\n"
"@item\n"
"    /Выбор/ из нуля альтернатив эквивалентен /неудаче/.\n"
"@end enumerate"

#: texi/node-22.texi:134
msgid "So, for example, in"
msgstr "Так, к примеру, в:"

#: texi/node-22.texi:141
msgid ""
"@lisp\n"
"(let ((x (choose '(1 2))))\n"
"  (if (odd? x)\n"
"           (fail)\n"
"           x))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:146
msgid ""
"@noindent\n"
"each of the possible choices has exactly one future. Since the future for a "
"choice\n"
"of 1 contains a call to fail, only 2 can be chosen. So the expression as a "
"whole\n"
"is deterministic: it always returns 2."
msgstr ""
"@noindent\n"
"каждый возможный выбор имеет по одному будущему.  Поскольку выбор 1\n"
"содержит вызов =fail=, может быть выбрано лишь 2.  Поэтому выражение в\n"
"целом детерминированно, всегда возвращая 2."

#: texi/node-22.texi:148
msgid "However, the following expression is not deterministic:"
msgstr "Однако, следующее выражение недетерминированно:"

#: texi/node-22.texi:158
msgid ""
"@lisp\n"
"(let ((x (choose '(1 2))))\n"
"  (if (odd? x)\n"
"           (let ((y (choose '(a b))))\n"
"                  (if (eq? y 'a)\n"
"                     (fail)\n"
"                     y))\n"
"           x))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:163
msgid ""
"At the first choose, there are two possible futures for a choice of 1, and "
"one for a\n"
"choice of 2. Within the former, though, the future is really deterministic, "
"because\n"
"a choice of a would result in a call to fail. So the expression as a whole "
"could\n"
"return either b or 2."
msgstr ""
"После первого выбора, у =1= два возможных будущих и у =2= одно.  У\n"
"первого, однако, будущее детерминированно, поскольку выбор =a= вызвал\n"
"бы =fail=.  Поэтому выражение в целом может вернуть либо =b=, либо\n"
"=2=.\n"

#: texi/node-22.texi:165
msgid "Finally, there is only one possible value for the expression"
msgstr "Наконец, однозначно следующее выражение:"

#: texi/node-22.texi:172
msgid ""
"@lisp\n"
"(let ((x (choose '(1 2))))\n"
"  (if (odd? x)\n"
"           (choose '())\n"
"           x))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:175
msgid ""
"because if 1 is chosen, the future goes through a choose with no choices. "
"This\n"
"example is thus equivalent to the last but one."
msgstr ""
"потому что выбор =1= означает последующий выбор без единого варианта.\n"
"Так что этот пример эквивалентен пред-предпоследнему."

#: texi/node-22.texi:181
msgid ""
"It may not be clear yet from the preceding examples, but we have just got\n"
"ourselves an abstraction of astounding power. In nondeterministic algorithms "
"we\n"
"are allowed to say \"choose an element such that nothing we do later will "
"result in a\n"
"call to fail.\" For example, this is a perfectly legitimate nondeterministic "
"algorithm\n"
"for discovering whether you have a known ancestor called Igor:"
msgstr ""
"Возможно, это ещё не стало очевидным, но мы обрели абстракцию\n"
"изумительной силы.  В недетерминированных алгоритмах можно сказать\n"
"“выбери элемент так, чтобы ничего в дальнейшем не привело к неудаче”.\n"
"Например, вот полностью корректный алгоритм для установления, есть ли\n"
"у кого-либо предок по имени Игорь:"

#: texi/node-22.texi:190
msgid ""
"@example\n"
"Function Ig(n)\n"
"  if name(n) = `Igor'\n"
"        then return n\n"
"  else if parents(n)\n"
"        then return Ig(choose(parents(n)))\n"
"  else fail\n"
"@end example"
msgstr ""

#: texi/node-22.texi:198
msgid ""
"The fail operator is used to influence the value returned by choose.If we \n"
"ever encounter a fail, choose would have chosen incorrectly. By definition "
"choose\n"
"guesses correctly. So if we want to guarantee that the computation will "
"never\n"
"pursue a certain path, all we need do is put a fail somewhere in it, and "
"that path\n"
"will never be followed. Thus, as it works recursively through generations "
"of\n"
"ancestors, the function Ig is able to choose at each step a path which leads "
"to an\n"
"Igor-to guess whether to follow the mother's or father's line."
msgstr ""
"Оператор /неудачи/ используется, чтобы повлиять на значение,\n"
"возвращаемое /выбором/.  Если встречается /неудача/, /выбор/ сработал\n"
"неправильно.  Но он по определению выбирает правильно.  Поэтому всё,\n"
"что нам нужно, чтобы предотвратить вычисление определённой ветви -\n"
"поместить где-либо в ней /неудачу/.  Так, рекурсивно проходя\n"
"поколения предков, функция Иг на каждом шаге выбирает ветвь, ведущую к\n"
"Игорю, угадывая, по отцовской или материнской линии идти.\n"

#: texi/node-22.texi:204
msgid ""
"It is as if a program can specify that choose pick some element from a set "
"of\n"
"alternatives, use the value returned by choose for as long as it wants, and "
"then\n"
"retroactively decide, by using fail as a veto, what it wants choose to have "
"picked.\n"
"And, presto, it turns out that that's just what choose did return. Hence the "
"model\n"
"in which choose has foresight."
msgstr ""
"Это как если бы программа могла указать /выбору/ взять один из\n"
"альтернативных элементов, использовать возвращённое значение сколько\n"
"понадобится, и ретроспективно решить, используя /неудачу/ как запрет,\n"
"что /выбору/ нужно было взять.  И вуаля, оказывается, что /выбор/ его\n"
"и взял.  Именно в этом смысле говорят, что /выбор/ обладает\n"
"предвидением."

#: texi/node-22.texi:212
msgid ""
"In reality choose cannot have supernatural powers. Any implementation of\n"
"choose must simulate correct guessing by backtracking when it discovers "
"mistakes,\n"
"like a rat finding its way through a maze. But all this backtracking can be "
"done\n"
"beneath the surface. Once you have some form of choose and fail, you get to "
"write\n"
"algorithms like the one above, as if it really were possible to guess what "
"ancestor\n"
"to follow. By using choose it is possible to write an algorithm to search "
"some\n"
"problem space just by writing an algorithm to traverse it."
msgstr ""
"На деле, конечно, /выбор/ не сверхъестественен.  Всякая его реализация\n"
"имитирует нужное угадывание отступлением от ошибок, подобно мыши в\n"
"лабиринте.  Но всё это отступление - скрываемо.  Располагая лишь\n"
"какими-либо /выбором/ и /неудачей/, уже можно писать алгоритмы подобно\n"
"вышеприведённому, как если бы действительно возможно было угадать, по\n"
"пути какого из предков следовать.  Используя /выбор/, можно получить\n"
"алгоритм поиска в проблемной области, написав лишь алгоритм её обхода.\n"

#: texi/node-22.texi:219
msgid ""
"@lisp\n"
" (define (descent n1 n2)\n"
"       (if (eq? n1 n2)\n"
"             (list n2)\n"
"             (let ((p (try-paths (kids n1) n2)))\n"
"                   (if p (cons n1 p) #f))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (descent n1 n2)\n"
"       (if (eq? n1 n2)\n"
"             (list n2)\n"
"             (let ((p (try-paths (kids n1) n2)))\n"
"                   (if p (cons n1 p) #f))))"

#: texi/node-22.texi:225
msgid ""
" (define (try-paths ns n2)\n"
"       (if (null? ns)\n"
"             #f\n"
"             (or (descent (car ns) n2)\n"
"                    (try-paths (cdr ns) n2))))"
msgstr ""
" (define (try-paths ns n2)\n"
"       (if (null? ns)\n"
"             #f\n"
"             (or (descent (car ns) n2)\n"
"                    (try-paths (cdr ns) n2))))\n"
"@end lisp"

#: texi/node-22.texi:227
msgid "                         Figure 22-1: Deterministic tree search."
msgstr ""
"                         Рисунок 22-1: Детерминированный поиск по дереву.\n"
"@end cartouche"

#: texi/node-22.texi:234
msgid ""
" (define (descent n1 n2)\n"
"       (cond ((eq? n1 n2) (list n2))\n"
"                   ((null? (kids n1)) (fail))\n"
"                   (else (cons n1 (descent (choose (kids n1)) n2)))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (descent n1 n2)\n"
"       (cond ((eq? n1 n2) (list n2))\n"
"                   ((null? (kids n1)) (fail))\n"
"                   (else (cons n1 (descent (choose (kids n1)) n2)))))\n"
"@end lisp"

#: texi/node-22.texi:236
msgid "                        Figure 22-2: Nondeterministic tree search."
msgstr ""
"                        Рисунок 22-2: Недетерминированный поиск по дереву.\n"
"@end cartouche"

#: texi/node-22.texi:241
msgid ""
"@node 22-2 Search, 22-3 Scheme Implementation, 22-1 The Concept, 22 "
"Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-2 Search\n"
"@cindex 22-2 Search"
msgstr ""
"@node 22-2 Search, 22-3 Scheme Implementation, 22-1 The Concept, 22 "
"Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-2 Поиск\n"
"@cindex 22-2 Search"

#: texi/node-22.texi:249
msgid ""
"Many classic problems can be formulated as search problems, and for such "
"prob-\n"
"lems nondeterminism often turns out to be a useful abstraction. Suppose "
"nodes\n"
"is bound to a list of nodes in a tree, and (kids n) is a function which "
"returns\n"
"the descendants of node n,or#f if there are none. We want to write a "
"function\n"
"(descent n1 n2) which returns a list of nodes on some path from n1 to its "
"de-\n"
"scendant n2, if there is one. Figure 22-1 shows a deterministic version of "
"this\n"
"function."
msgstr ""
"Многие классические проблемы можно описать как проблемы поиска, и\n"
"недетерминированность часто оказывается для них полезной абстракцией.\n"
"Допустим, =nodes= содержит список вершин в дереве, а функция =(kids\n"
"n)= возвращает наследников вершины =n=, либо =#f= в их отсутствие.  Мы\n"
"хотим определить функцию =(descent n1 n2)=, возвращающую список вершин\n"
"на каком либо пути между =n1= и её наследником =n2=.  Рисунок 22.1\n"
"представляет детерминированный вариант этой функции."

#: texi/node-22.texi:254
msgid ""
"Nondeterminism allows the programmer to ignore the details of finding a "
"path.\n"
"It's possible simply to tell choose to find a node n such that there is a "
"path from\n"
"n to our destination. Using nondeterminism we can write the simpler version "
"of\n"
"descent shown in Figure 22-2."
msgstr ""
"Недетерминированность позволяет программисту не заботится о способе\n"
"поиска пути.  Можно просто сказать /выбору/ найти вершину =n= такую,\n"
"чтобы от неё до цели был путь.  Этот вариант =descent=, изображённый\n"
"на рисунке 22.2, проще."

#: texi/node-22.texi:259
msgid ""
"The version shown in Figure 22-2 does not explicitly search for a node on "
"the\n"
"right path. It is written on the assumption that choose has chosen an n with "
"the\n"
"desired properties. If we are used to looking at deterministic programs, we "
"may\n"
"not perceive that choose has to work as if it could guess what n would make "
"it"
msgstr ""
"Версия показанная на Рисунке 22-2 не занимается явным поиском вершины на \n"
"правильном пути. Он написан в предположении, что =choose= выбирает желаемую "
"=n=.\n"
"Привыкший лишь к детерминированным программам может и не заметить, что\n"
"=choose= словно /угадывает/, какая =n= войдёт в удачное вычисление.\n"

#: texi/node-22.texi:264
msgid ""
"@lisp\n"
" (define (two-numbers)\n"
"     (list (choose '(012345))\n"
"              (choose '(012345))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (two-numbers)\n"
"     (list (choose '(012345))\n"
"              (choose '(012345))))"

#: texi/node-22.texi:271
msgid ""
" (define (parlor-trick sum)\n"
"     (let ((nums (two-numbers)))\n"
"        (if (= (apply + nums) sum)\n"
"              `(the sum of ,@@nums)\n"
"              (fail))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:273
msgid "                           Figure 22-3: Choice in a subroutine."
msgstr ""
"                           Рисунок 22-3: Выбор в подпрограмме.\n"
"@end cartouche"

#: texi/node-22.texi:277
msgid ""
"@noindent\n"
"through the computation which follows without failing."
msgstr ""

#: texi/node-22.texi:285
msgid ""
"Perhaps a more convincing example of the power of choose is its ability to\n"
"guess what will happen even in calling functions. Figure 22-3 contains a "
"pair\n"
"of functions to guess two numbers which sum to a number given by the "
"caller.\n"
"The first function, two-numbers, nondeterministically chooses two numbers "
"and\n"
"returns them in a list. When we call parlor-trick, it calls two-numbers for "
"a\n"
"list of two integers. Note that, in making its choice, two-numbers doesn't "
"have\n"
"access to the number entered by the user."
msgstr ""
"Возможно, ещё убедительнее возможности /выбора/ продемонстрирует\n"
"угадывание при вызове функций.  На рисунке 22.3 пара функций угадывает\n"
"два числа, суммирующихся к заданному.  Первая, =two-numbers=,\n"
"недетерминированно выбирает два числа и возвращает их в виде списка.\n"
"Вторая, =parlor-trick=, обращается за ним к первой.  Отметим, что\n"
"=two-numbers= не знает о заданном числе"

#: texi/node-22.texi:294
msgid ""
"If the two numbers guessed by choose don't sum to the number entered\n"
"by the user, the computation fails. We can rely on choose having\n"
"avoided computational paths which fail, if there are any which\n"
"don't. Thus we can assume that if the caller gives a number in the\n"
"right range, choose will have guessed right, as indeed it\n"
"does:@footnote{Since the order of argument evaluation is unspecified\n"
"in Scheme (as opposed to Common Lisp, which specifies left-to-right),\n"
"this call might also return (THE SUM OF 5 2).}"
msgstr ""
"Если два угаданных /выбором/ числа не образуют требуемой суммы,\n"
"вычисление не удаётся.  Можно считать, что =choose= избегает неудачных\n"
"вычислительных путей, если есть хоть один удачный.  Предположительно,\n"
"при задании числа в правильном диапазоне, =choose= угадывает верно;\n"
"так и происходит:[fn:: Поскольку порядок вычисления аргументов в\n"
"Scheme (в отличие от Common Lisp, в котором он слева направо), этот\n"
"вызов может вернуть и =(THE SUM OF 5 2)=.]"

#: texi/node-22.texi:299
msgctxt "texi/node-22.texi:299"
msgid ""
"@example\n"
"> (parlor-trick 7)\n"
"(THE SUM OF 2 5)\n"
"@end example"
msgstr ""

#: texi/node-22.texi:310
msgid ""
"In simple searches, the built-in Common Lisp function find-if would do\n"
"just as well. Where is the advantage of nondeterministic choice? Why not "
"just\n"
"iterate through the list of alternatives in search of the element with the "
"desired\n"
"properties? The crucial difference between choose and conventional iteration "
"is\n"
"that its extent with respect to fails is unbounded. Nondeterministic choose "
"can\n"
"see arbitrarily far into the future; if something is going to happen at any "
"point in\n"
"the future which would have invalidated some guess choose might make, we "
"can\n"
"assume that choose knows to avoid guessing it. As we saw in parlor-trick,\n"
"the fail operator works even after we return from the function in which the "
"choose\n"
"occurs."
msgstr ""
"В случае простого поиска, встроенная функция =find-if= из Common Lisp\n"
"сработает не хуже.  Где же преимущество недетерминированного выбора?\n"
"Почему не пройти просто в цикле по списку альтернатив в поиске\n"
"желаемого элемента?  Ключевое отличие /выбора/ от обыкновенной\n"
"итерации в том, что его область действия по отношению к /неудаче/ не\n"
"ограничена.  Недетерминированный /выбор/ смотрит сколь угодно далеко в\n"
"будущее; если в будущем случится что-либо, аннулирующее прошлый\n"
"/выбор/, можно считать, что он и не совершался.  Как было показано на\n"
"примере =parlor-trick=, оператор неудачи работает даже после возврата\n"
"из функции, содержащей /выбор/.\n"

#: texi/node-22.texi:317
msgid ""
"This kind of failure happens in the search done by Prolog, for\n"
"example. Nondeterminism is useful in Prolog because one of the central\n"
"features of this language is its ability to return answers to a query\n"
"one at a time. By following this course instead of returning all the\n"
"valid answers at once, Prolog can handle recursive rules which would\n"
"otherwise yield infinitely large sets of answers."
msgstr ""
"Такие же неудачи случаются и при поиске в Прологе.\n"
"Недетерминированность в нём полезна, поскольку одна из характерных\n"
"особенностей этого языка — возможность получать ответы на запросы по\n"
"одному за раз.  Не возвращая все удовлетворяющие ответы сразу, Пролог\n"
"справляется с рекурсивными правилами, которые иначе бы выдавали\n"
"бесконечное множество ответов."

#: texi/node-22.texi:323
msgid ""
"The initial reaction to descent may be like the initial reaction to a\n"
"merge sort: where does the work get done? As in a merge sort, the work\n"
"gets done implicitly, but it does get done. Section 22-3 describes an\n"
"implementation of choose in which all the code examples presented so\n"
"far are real running programs."
msgstr ""
"Вашим первым впечатлением от =descent=, возможно, как и от сортировки\n"
"слиянием, был вопрос: где же выполняется работа?  Как и при сортировке\n"
"слиянием, она происходит неявно, но всё же происходит.  В разделе 22.3\n"
"описана реализация /выбора/, превращающая все вышеприведённые примеры\n"
"в рабочие программы."

#: texi/node-22.texi:329
msgid ""
"These examples show the value of nondeterminism as an abstraction. The\n"
"best programming language abstractions save not just typing, but\n"
"thought. In automata theory, some proofs are difficult even to\n"
"conceive of without relying on nonde- terminism. A language which\n"
"allows nondeterminism may give programmers a similar advantage."
msgstr ""
"Эти примеры иллюстрируют значение недетерминированности как\n"
"абстракции.  Лучшие абстракции программирования сокращают не только\n"
"код, но и мысль.  В теории автоматов некоторые доказательства\n"
"затруднительно даже понять без обращения к недетерминированности.\n"
"Язык, допускающий недетерминированность, вероятно, предоставляет\n"
"программистам сравнимое преимущество."

#: texi/node-22.texi:334
msgid ""
"@node 22-3 Scheme Implementation, 22-4 Common Lisp Implementation, 22-2 "
"Search, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-3 Scheme Implementation\n"
"@cindex 22-3 Scheme Implementation"
msgstr ""
"@node 22-3 Scheme Implementation, 22-4 Common Lisp Implementation, 22-2 "
"Search, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-3 Реализация на Scheme\n"
"@cindex 22-3 Scheme Implementation"

#: texi/node-22.texi:340
msgid ""
"This section explains how to use continuations to simulate nondeterminism. "
"Figure 22-4 contains Scheme implementations of choose and fail. Beneath the "
"surface,\n"
"choose and fail simulate nondeterminism by backtracking. A backtracking\n"
"search program must somehow store enough information to pursue other "
"alterna-\n"
"tives if the chosen one fails. This information is stored in the form of "
"continuations\n"
"on the global list *paths*."
msgstr ""
"Этот раздел объясняет, как имитировать недетерминированность с помощью\n"
"продолжений.  Рисунок 22.4 содержит реализацию /выбора/ и /неудачи/ на\n"
"Scheme, задействующую отступления.  Ищущая с отступлением программа\n"
"должна как-либо сохранять достаточно информации для следования по иным\n"
"альтернативам, если избранная заканчивается неудачей.  Эта информация\n"
"хранится в виде продолжений в глобальном списке =*paths*=.\n"

#: texi/node-22.texi:345
msgid ""
"The function choose is passed a list of alternatives in choices.Ifchoices "
"is\n"
"empty, then choose calls fail, which sends the computation back to the "
"previous\n"
"choose.If choices is (first . rest), choose first pushes onto *paths* a\n"
"continuation in which choose is called on rest, then returns first."
msgstr ""
"Функция =choose= принимает список альтернатив =choices=.  Если он\n"
"пуст, вызывается =fail=, возвращающая вычисление обратно к последнему\n"
"/выбору/.  Если он имеет вид =(first . rest)=, =choose= добавляет в\n"
"=*paths*= продолжение, в котором =choose= вызывается с =rest=, и\n"
"возвращает =first=."

#: texi/node-22.texi:353
msgid ""
"The function fail is simpler: it just pops a continuation off *paths* and\n"
"calls it. If there aren't any saved paths left, then fail returns the symbol "
"@.\n"
"However, it won't do simply to return it as a function ordinarily returns "
"values, or\n"
"it will be returned as the value of the most recent choose. What we really "
"want to\n"
"do is return @ right to the toplevel. We do this by binding cc to the "
"continuation\n"
"where fail is defined, which presumably is the toplevel. By calling cc, "
"fail\n"
"can return straight there."
msgstr ""
"Функция =fail= проще, она всего лишь забирает продолжение из =*paths*=\n"
"и вызывает его.  Если сохранённых путей больше нет, она возвращает\n"
"символ =@=.  Однако недостаточно просто вернуть его, иначе он станет\n"
"результатом последнего вызова =choose=.  Нужно вернуть его прямо на\n"
"верхний уровень.  Мы достигаем этого, связывая =cc= с продолжением, в\n"
"котором определена =fail= — предположительно, на верхнем уровне.\n"
"Вызывая =cc=, =fail= возвращает прямо туда.\n"

#: texi/node-22.texi:358
msgid ""
"The implementation in Figure 22-4 treats *paths* as a stack, always fail-\n"
"ing back to the most recent choice point. This strategy, known as "
"chronological\n"
"backtracking, results in depth-first search of the problem space. The word "
"\"non-\n"
"determinism\" is often used as if it were synonymous with the depth-first "
"imple-"
msgstr ""
"Реализация на рисунке 22.4 использует =*paths*= в качестве стека,\n"
"всегда возвращаясь обратно к последнему моменту выбора.  Эта\n"
"стратегия, называемая /хронологическим отступлением/, осуществляет\n"
"поиск проблемной области в глубину.  И слово «недетерминированность»\n"
"часто ассоциируют только с реализацией, ищущей в глубину.  Так - и в\n"

#: texi/node-22.texi:362
msgctxt "texi/node-22.texi:362"
msgid ""
"@lisp\n"
" (define *paths* ())\n"
" (define failsym '@@)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define *paths* ())\n"
" (define failsym '@@)"

#: texi/node-22.texi:373
msgid ""
" (define (choose choices)\n"
"    (if (null? choices)\n"
"         (fail)\n"
"         (call-with-current-continuation\n"
"            (lambda (cc)\n"
"               (set! *paths*\n"
"                       (cons (lambda ()\n"
"                                  (cc (choose (cdr choices))))\n"
"                               *paths*))\n"
"            (car choices)))))"
msgstr ""

#: texi/node-22.texi:375
msgctxt "texi/node-22.texi:375"
msgid " (define fail)"
msgstr ""

#: texi/node-22.texi:386
msgid ""
" (call-with-current-continuation\n"
"    (lambda (cc)\n"
"        (set! fail\n"
"               (lambda ()\n"
"                 (if (null? *paths*)\n"
"                       (cc failsym)\n"
"                       (let ((p1 (car *paths*)))\n"
"                         (set! *paths* (cdr *paths*))\n"
"                         (p1)))))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:388
msgid "            Figure 22-4: Scheme implementation of choose and fail."
msgstr ""
"            Рисунок 22-4: Scheme реализация choose и fail.\n"
"@end cartouche"

#: texi/node-22.texi:398
msgid ""
"@noindent\n"
"mentation. Floyd's classic paper on nondeterministic algorithms uses the "
"term in  \n"
"this sense, and this is also the kind of nondeterminism we find in "
"nondetermin-\n"
"istic parsers and in Prolog. However, it should be noted that the "
"implementation\n"
"given in Figure 22-4 is not the only possible implementation, nor even a "
"correct\n"
"one. In principle, choose ought to be able to choose an object which meets "
"any\n"
"computable specification. But a program which used these versions of choose\n"
"and fail to search a graph might not terminate, if the graph contained "
"cycles."
msgstr ""
"@noindent\n"
"классической статье Флойда о недетерминированных алгоритмах, и\n"
"недетерминированных парсерах, и в Прологе.  Однако, нужно отметить,\n"
"что реализация на рисунке 22.4 - не единственная возможная, и даже не\n"
"корректная.  В принципе, /выбор/ должен уметь возвращать объекты,\n"
"удовлетворяющие любой вычислимой спецификации, тогда как наш вариант\n"
"=choose= и =fail= может никогда не завершиться, если граф содержит\n"
"циклы."

#: texi/node-22.texi:403
msgid ""
"In practice, nondeterminism usually means using a depth-first "
"implementation\n"
"equivalent to the one in Figure 22-4, and leaving it to the user to avoid "
"loops in\n"
"the search space. However, for readers who are interested, the last section "
"in this\n"
"chapter describes how to implement true choose and fail."
msgstr ""
"С другой стороны, на практике недетерминированность часто означает\n"
"именно поиск в глубину, эквивалентный нашему, оставляя на пользователе\n"
"обязанность избегать циклов в области поиска.  Однако заинтересованный\n"
"читатель найдёт реализацию настоящих /выбора/ и /неудачи/ в последнем\n"
"разделе этой главы."

#: texi/node-22.texi:410
msgid ""
"@node 22-4 Common Lisp Implementation, 22-5 Cuts, 22-3 Scheme "
"Implementation, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-4 Common Lisp Implementation\n"
"@cindex 22-4 Common Lisp Implementation"
msgstr ""
"@node 22-4 Common Lisp Implementation, 22-5 Cuts, 22-3 Scheme "
"Implementation, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-4 Реализация на Common Lisp\n"
"@cindex 22-4 Common Lisp Implementation"

#: texi/node-22.texi:418
msgid ""
"This section describes how to write a form of choose and fail in Common "
"Lisp.\n"
"As the previous section showed, call/cc makes it easy to simulate "
"nondetermin-\n"
"ism in Scheme. Continuations provide the direct embodiment of our "
"theoretical\n"
"concept of a computational future. In Common Lisp, we can use instead the\n"
"continuation-passing macros of Chapter 20. With these macros we will be able "
"to\n"
"provide a form of choose slightly uglier than the Scheme version presented "
"in the\n"
"previous section, but equivalent in practice."
msgstr ""
"В этом разделе говорится о том, как написать /выбор/ и /неудачу/ на\n"
"Common Lisp.  Предыдущий раздел показал лёгкость имитации\n"
"недетерминированности на Scheme с использованием =call/cc=; ведь\n"
"продолжения - прямое воплощение нашей теоретической идеи\n"
"вычислительного будущего.  На Common Lisp же вместо этого можно\n"
"применить передающие продолжения макросы из 20-ой главы.  Вариант\n"
"/выбора/, полученный с их помощью, будет несколько безобразнее\n"
"написанного ранее на Scheme, но на деле эквивалентен ему.\n"

#: texi/node-22.texi:425
msgid ""
"Figure 22-5 contains a Common Lisp implementation of fail, and two versions\n"
"of choose. The syntax of a Common Lisp choose is slightly different from "
"the\n"
"Scheme version. The Scheme choose took one argument: a list of choices from\n"
"which to select a value. The Common Lisp version has the syntax of a progn.\n"
"It can be followed by any number of expressions, from which it chooses one "
"to\n"
"evaluate:"
msgstr ""
"Рисунок 22.5 демонстрирует реализацию /неудачи/ и двух вариантов\n"
"/выбора/ на Common Lisp.  Синтаксис этого =choose= немного отличен от\n"
"предыдущего.  Тот принимал один параметр: список вариантов выбора.\n"
"Этот же совпадает по синтаксису с =progn=.  За ним может следовать\n"
"любое число выражений, из которых для вычисления выбирается только\n"
"одно:\n"

#: texi/node-22.texi:441
msgid ""
"@example\n"
"> (defun do2 (x)\n"
"        (choose (+ x 2) (* x 2) (expt x 2)))\n"
"DO2\n"
"> (do2 3)\n"
"5> (fail)\n"
"6\n"
"@end example\n"
"At the toplevel, we see more clearly the backtracking which underlies "
"nondeter-\n"
"ministic search. The variable *paths* is used to store paths which have not "
"yet\n"
"been followed. When the computation reaches a choose expression with "
"several\n"
"alternatives, the first alternative is evaluated, and the remaining choices "
"are stored\n"
"on *paths*. If the program later on encounters a fail, the last stored "
"choice\n"
"will be popped off *paths* and restarted. When there are no more paths left "
"to\n"
"restart, fail returns a special value:"
msgstr ""
"@example\n"
"> (defun do2 (x)\n"
"        (choose (+ x 2) (* x 2) (expt x 2)))\n"
"DO2\n"
"> (do2 3)\n"
"5> (fail)\n"
"6\n"
"@end example\n"
"На верхнем уровне работа отступления, лежащего в основе\n"
"недетерминированного поиска, заметнее.  Переменная =*paths*= содержит\n"
"ещё не пройденные пути.  Когда вычисление достигает вызова =choose= с\n"
"несколькими альтернативами, первая из них вычисляется, а остальные\n"
"сохраняются в =*paths*=.  Если программа в дальнейшем достигает\n"
"=fail=, последнее сохранённое значение извлекается из =*paths*= и\n"
"перезапускается.  Когда список исчерпывается, =fail= возвращает\n"
"специальное значение:"

#: texi/node-22.texi:447
msgid ""
"@example\n"
"> (fail)\n"
"9> (fail)\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-22.texi:451
msgid ""
"In Figure 22-5 the constant failsym, which represents failure, is defined to "
"be\n"
"the symbol @. If you wanted to be able to have @ as an ordinary return "
"value, you\n"
"could make failsym a gensym instead."
msgstr ""
"На рисунке 22.5 константа =failsym=, обозначающая неудачу, определена\n"
"как символ =@=.  При желании использовать его в качестве обычного\n"
"возвращаемого значения, можно в качестве =failsym= использовать\n"
"=(gensym)=."

#: texi/node-22.texi:456
msgid ""
"The other nondeterministic choice operator, choose-bind, has a slightly\n"
"different form. It should be given a symbol, a list of choices, and a body "
"of code.\n"
"It will do a choose on the list of choices, bind the symbol to the value "
"chosen, and\n"
"evaluate the body of code:"
msgstr ""
"Второй оператор недетерминированного выбора, =choose-bind=, отличен по\n"
"форме, принимая символ, список вариантов выбора и блок кода.  Он\n"
"/выберет/ одну из альтернатив, свяжет с ней символ и выполнит код."

#: texi/node-22.texi:460
msgid ""
"@lisp\n"
" (defparameter *paths* nil)\n"
" (defconstant failsym '@@)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defparameter *paths* nil)\n"
" (defconstant failsym '@@)"

#: texi/node-22.texi:469
msgid ""
" (defmacro choose (&rest choices)\n"
"    (if choices\n"
"           `(progn\n"
"              ,@@(mapcar #'(lambda (c)\n"
"                               `(push #'(lambda () ,c) *paths*))\n"
"                          (reverse (cdr choices)))\n"
"              ,(car choices))\n"
"           '(fail)))"
msgstr ""

#: texi/node-22.texi:472
msgid ""
" (defmacro choose-bind (var choices &body body)\n"
"    `(cb #'(lambda (,var) ,@@body) ,choices))"
msgstr ""

#: texi/node-22.texi:481
msgid ""
" (defun cb (fn choices)\n"
"    (if choices\n"
"          (progn\n"
"            (if (cdr choices)\n"
"                (push #'(lambda () (cb fn (cdr choices)))\n"
"                        *paths*))\n"
"            (funcall fn (car choices)))\n"
"          (fail)))"
msgstr ""

#: texi/node-22.texi:487
msgid ""
" (defun fail ()\n"
"    (if *paths*\n"
"           (funcall (pop *paths*))\n"
"           failsym))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:489
msgid "            Figure 22-5: Nondeterministic operators in Common Lisp."
msgstr ""
"            Рисунок 22-5: Недетерминированные операторы в Common Lisp.\n"
"@end cartouche"

#: texi/node-22.texi:497
msgid ""
"@example\n"
"> (choose-bind x '(marrakesh strasbourg vegas)\n"
"        (format nil \"Let's go to ~A.\" x))\n"
"\"Let's go to MARRAKESH.\"\n"
"> (fail)\n"
"\"Let's go to STRASBOURG.\"\n"
"@end example"
msgstr ""

#: texi/node-22.texi:501
msgid ""
"It is only for convenience that the Common Lisp implementation provides two\n"
"choice operators. You could get the effect of choose from choose-bind by\n"
"always translating"
msgstr ""
"То, что на Common Lisp целых два оператора выбора - лишь вопрос\n"
"удобства.  Эффекта =choose= можно было бы добиться, всякий раз заменяя\n"

#: texi/node-22.texi:505
msgid ""
"@lisp\n"
"(choose (foo) (bar))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:508
msgid ""
"@noindent\n"
"into"
msgstr ""
"@noindent\n"
"на"

#: texi/node-22.texi:515
msgid ""
"@lisp\n"
"(choose-bind x '(1 2)\n"
"   (case x\n"
"        (1 (foo))\n"
"        (2 (bar))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:520
msgid ""
"@noindent\n"
"but programs are easier to read if we have a separate operator for this\n"
"case.@footnote{If desired, the exported interface to this code could consist "
"of\n"
"just a single operator, because (fail) is equivalent to (choose).}"
msgstr ""
"@noindent\n"
"но программы более читаемы, когда на этот случай имеется особый\n"
"оператор.@footnote{ Более того, внешний интерфейс мог бы состоять всего\n"
"из одного оператора, потому что =(fail)= эквивалентен =(choose)=.}"

#: texi/node-22.texi:527
msgid ""
"The Common Lisp choice operators store the bindings of relevant variables\n"
"using closures and variable capture. As macros, choose and choose-bind get\n"
"expanded within the lexical environment of the containing expressions. "
"Notice\n"
"that what they push onto *paths* is a closure over the choice to be saved, "
"locking\n"
"in all the bindings of the lexical variables referred to within it. For "
"example, in\n"
"the expression"
msgstr ""
"Операторы выбора на Common Lisp сохраняют связи соответствующих\n"
"переменных в замыканиях с захватом переменных.  Будучи макросами,\n"
"=choose= и =choose-bind= раскрываются в лексической среде содержащих\n"
"их выражений.  Заметьте, что в =*paths*= помещается замыкание вокруг\n"
"сохраняемой альтернативы, включающее в себя все связи имеющихся\n"
"лексических переменных.  К примеру, в выражении\n"

#: texi/node-22.texi:534
msgid ""
"@lisp\n"
"(let ((x 2))\n"
"   (choose\n"
"        (+x1)\n"
"        (+ x 100)))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:539
msgid ""
"@noindent\n"
"the value of x will be needed when the saved choices are restarted. This is "
"why\n"
"choose is written to wrap its arguments in lambda-expressions. The "
"expression\n"
"above gets macroexpanded into:"
msgstr ""
"@noindent\n"
"при перезапуске замыкания понадобится значение =x=.  Вот почему\n"
"=choose= оборачивает свои аргументы в лямбды.  Выражение выше\n"
"макрорасширяется до\n"

#: texi/node-22.texi:547
msgid ""
"@lisp\n"
"(let ((x 2))\n"
"   (progn\n"
"        (push #'(lambda () (+ x 100))\n"
"                *paths*)\n"
"        (+ x 1)))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:551
msgid ""
"The object which gets stored on *paths* is a closure containing a pointer to "
"x.It\n"
"is the need to preserve variables in closures which dictates the difference "
"between\n"
"the syntax of the Scheme and Common Lisp choice operators."
msgstr ""
"В =*paths*= сохраняется замыкание с указателем на =x=.  Именно\n"
"необходимость хранить переменные в замыканиях диктует различие\n"
"синтаксиса между операторами выбора на Scheme и Common Lisp.\n"

#: texi/node-22.texi:557
msgid ""
"If we use choose and fail together with the continuation-passing macros\n"
"of Chapter 20, a pointer to our continuation variable *cont* will get saved "
"as\n"
"well. By defining functions with =defun, calling them with =bind, and "
"having\n"
"them return values with =values, we will be able to use nondeterminism in "
"any\n"
"Common Lisp program."
msgstr ""
"Если использовать =choose= и =fail= вместе с передающими продолжения\n"
"макросами из главы 20, указатель на переменную продолжения =*cont*=\n"
"тоже сохраняется.  Определяя функции с помощью ~=defun~, вызывая с\n"
"~=bind~, получая возвращаемые значения с ~=values~, можно применять\n"
"недетерминированность во всякой программе на Common Lisp.\n"

#: texi/node-22.texi:561
msgid ""
"With these macros, we can successfully run the example in which the nonde-\n"
"terministic choice occurs in a subroutine. Figure 22-6 shows the Common "
"Lisp\n"
"version of parlor-trick, which works as it did in Scheme:"
msgstr ""
"С этими макросами можно успешно запустить примеры с недетерминированным\n"
"выбором в подпрограммах.  Рисунок 22.6 показывает версию\n"
"=parlor-trick= на Common Lisp, работающую так же, как в Scheme:\n"

#: texi/node-22.texi:567
msgid ""
"@lisp\n"
" (=defun two-numbers ()\n"
"    (choose-bind n1 '(012345)\n"
"         (choose-bind n2 '(0 12345)\n"
"           (=values n1 n2))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (=defun two-numbers ()\n"
"    (choose-bind n1 '(012345)\n"
"         (choose-bind n2 '(0 12345)\n"
"           (=values n1 n2))))"

#: texi/node-22.texi:574
msgid ""
" (=defun parlor-trick (sum)\n"
"    (=bind (n1 n2) (two-numbers)\n"
"         (if (= (+ n1 n2) sum)\n"
"             `(the sum of ,n1 ,n2)\n"
"             (fail))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:576
msgid "               Figure 22-6: Common Lisp choice in a subroutine."
msgstr ""
"               Рисунок 22-6: Выбор в подпрограмме на Common Lisp\n"
"@end cartouche"

#: texi/node-22.texi:581
msgctxt "texi/node-22.texi:581"
msgid ""
"@example\n"
"> (parlor-trick 7)\n"
"(THE SUM OF 2 5)\n"
"@end example"
msgstr ""

#: texi/node-22.texi:583
msgid "This works because the expression"
msgstr "Это работает, потому что выражение"

#: texi/node-22.texi:587
msgid ""
"@lisp\n"
"(=values n1 n2)\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:590
msgid ""
"@noindent\n"
"gets macroexpanded into"
msgstr ""
"@noindent\n"
"макрорасширяется до"

#: texi/node-22.texi:594
msgid ""
"@lisp\n"
"(funcall *cont* n1 n2)\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:599
msgid ""
"@noindent\n"
"within the choose-binds. Each choose-bind is in turn macroexpanded into a\n"
"closure, which keeps pointers to all the variables referred to in the body, "
"including\n"
"*cont*."
msgstr ""
"@noindent\n"
"внутри =choose-bind=.  Каждый =choose-bind= в свою очередь расширяется\n"
"в замыкание, сохраняющее указатели на все переменные в теле кода,\n"
"включая =*cont*=."

#: texi/node-22.texi:605
msgid ""
"The restrictions on the use of choose, choose-bind, and fail are the same\n"
"as the restrictions given in Figure 20-5 for code which uses the "
"continuation-\n"
"passing macros. Where a choice expression occurs, it must be the last thing "
"to\n"
"be evaluated. Thus if we want to make sequential choices, in Common Lisp "
"the\n"
"choices have to be nested:"
msgstr ""
"Ограничения применимости =choose=, =choose-bind= и =fail= совпадают с\n"
"данными на рисунке 20.5 для кода с передающими продолжения макросами.\n"
"Встречающееся выражение выбора должно вычисляться последним.  Поэтому\n"
"для последовательных выборов операторы выбора на Common Lisp должны\n"
"быть вложены друг в друга:\n"

#: texi/node-22.texi:616
msgid ""
"@example\n"
"> (choose-bind first-name '(henry william)\n"
"        (choose-bind last-name '(james higgins)\n"
"          (=values (list first-name last-name))))\n"
"(HENRY JAMES)\n"
"> (fail)\n"
"(HENRY HIGGINS)\n"
"> (fail)\n"
"(WILLIAM JAMES)\n"
"@end example"
msgstr ""

#: texi/node-22.texi:619
msgid ""
"@noindent\n"
"which will, as usual, result in depth-first search."
msgstr ""
"@noindent\n"
"что приведёт, как обычно, к поиску в глубину."

#: texi/node-22.texi:624
msgid ""
"The operators defined in Chapter 20 claimed the right to be the last "
"expressions\n"
"evaluated. This right is now preempted by the new layer of macros; an "
"=values\n"
"expression should appear within a choose expression, and not vice versa. "
"That\n"
"is,"
msgstr ""
"Операторы, определённые в главе 20, нуждались в том, чтобы вычисляться\n"
"последними.  Это право теперь унаследовано новым слоем макросов;\n"
"~=values~ должно встречаться в =choose=, а не наоборот.  То есть,\n"

#: texi/node-22.texi:628
msgid ""
"@lisp\n"
"(choose (=values 1) (=values 2))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:631
msgid ""
"@noindent\n"
"will work, but"
msgstr ""
"@noindent\n"
"будет работать, а"

#: texi/node-22.texi:635
msgid ""
"@lisp\n"
"(=values (choose 1 "
"2))                                                      ; wrong\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:639
msgid ""
"@noindent\n"
"will not. (In the latter case, the expansion of the choose would be unable "
"to\n"
"capture the instance of *cont* in the expansion of the =values.)"
msgstr ""
"@noindent\n"
"нет.  (В последнем случае расширение =choose= не захватит употребление\n"
"=*cont*= в расширении ~=values~.)"

#: texi/node-22.texi:645
msgid ""
"As long as we respect the restrictions outlined here and in Figure 20-5, "
"non-\n"
"deterministic choice in Common Lisp will now work as it does in Scheme. "
"Fig-\n"
"ure 22-7 shows a Common Lisp version of the nondeterministic tree search "
"pro-\n"
"gram given in Figure 22-2. The Common Lisp descent is a direct translation,\n"
"though it comes out slightly longer and uglier."
msgstr ""
"До тех пор, пока эти требования, как и указанные на рисунке 20.5,\n"
"будут соблюдаться, недетерминированный выбор на Common Lisp будет\n"
"работать как и на Scheme.  Рисунок 22.7 показывает вариант\n"
"недетерминированного поиска по дереву с рисунка 22.2 на Common Lisp.\n"
"Функция =descent= - результат прямого преобразования, правда, чуть\n"
"более длинный и неприятный."

#: texi/node-22.texi:652
msgid ""
"We now have Common Lisp utilities which make it possible to do nondeter-\n"
"ministic search without explicit backtracking. Having taken trouble to write "
"this\n"
"code, we can reap the benefits by writing in very few lines programs which "
"would\n"
"otherwise be large and messy. By building another layer of macros on top of\n"
"those presented here, we will be able to write an ATN compiler in one page "
"of code\n"
"(Chapter 23), and a sketch of Prolog in two (Chapter 24)."
msgstr ""
"Теперь мы располагаем в Common Lisp средствами для\n"
"недетерминированного поиска без явного отступления.  Озаботившись\n"
"написанием этого кода, теперь можно пожинать плоды, несколькими\n"
"строками описывая в противном случае большие и спутанные программы.\n"
"Построив ещё один уровень макросов над этими, можно будет написать\n"
"ATN-компилятор на одной странице кода (глава 23) и набросок Пролога на\n"
"двух (глава 24)"

#: texi/node-22.texi:658
msgid ""
"Common Lisp programs which use choose should be compiled with tail-\n"
"recursion optimization-not just to make them faster, but to avoid running "
"out of\n"
"stack space. Programs which \"return\" values by calling continuation "
"functions\n"
"never actually return until the final fail. Without the optimization of tail-"
"calls,\n"
"the stack would just grow and grow."
msgstr ""
"Программы с использованием /выбора/ на Common Lisp стоит компилировать\n"
"с оптимизацией хвостовой рекурсии - не только ради ускорения, но и\n"
"чтобы предотвратить исчерпание места на стеке.  Программы,\n"
"«возвращающие» значения вызовом продолжений, в действительности не\n"
"возвращаются до последней /неудачи/.  Без хвостовой оптимизации стек\n"
"будет расти и расти."

#: texi/node-22.texi:662
msgid ""
"@node  22-5 Cuts, 22-6 True Nondeterminism, 22-4 Common Lisp Implementation, "
"22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-5 Cuts"
msgstr ""
"@node  22-5 Cuts, 22-6 True Nondeterminism, 22-4 Common Lisp Implementation, "
"22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-5 Отсечения"

#: texi/node-22.texi:667
msgid ""
"This section shows how to use cuts in Scheme programs which do nondetermin-\n"
"istic choice. Though the word cut comes from Prolog, the concept belongs to\n"
"nondeterminism generally. You might want to use cuts in any program that "
"made\n"
"nondeterministic choices."
msgstr ""
"Этот раздел рассказывает про использование отсечений в\n"
"недетерминированных программах на Scheme.  Хотя слово /отсечение/\n"
"пришло из Пролога, сама идея принадлежит недетерминированности вообще.\n"
"Она может пригодиться во всякой программе с недетерминированным\n"
"выбором.\n"

#: texi/node-22.texi:673
msgid ""
"Cuts are easier to understand when considered independently of Prolog. "
"Let's\n"
"imagine a real-life example. Suppose that the manufacturer of Chocoblob "
"candies\n"
"decides to run a promotion. A small number of boxes of Chocoblobs will also\n"
"contain tokens entitling the recipient to valuable prizes. To ensure "
"fairness, no\n"
"two of the winning boxes are sent to the same city."
msgstr ""
"Отсечения легче понять независимо от Пролога.  Представим жизненный\n"
"пример.  Производитель шоколадных конфет решает провести рекламную\n"
"кампанию.  Небольшое число коробок будут содержать жетоны,\n"
"обмениваемые на ценные призы.  Ради справедливости, никакие две\n"
"выигрышные коробки не отправляются в один город.\n"

#: texi/node-22.texi:700
msgid ""
"@example\n"
" > (=defun descent (n1 n2)\n"
"        (cond ((eq n1 n2) (=values (list n2)))\n"
"                ((kids n1) (choose-bind n (kids n1)\n"
"                                  (=bind (p) (descent n n2)\n"
"                                      (=values (cons n1 p)))))\n"
"                (t (fail))))\n"
" DESCENT\n"
" > (defun kids (n)\n"
"        (case n\n"
"           (a '(b c))\n"
"           (b '(d e))\n"
"           (c '(d f))\n"
"           (f '(g))))\n"
" KIDS\n"
" > (descent 'a 'g)\n"
" (ACFG)\n"
" > (fail)\n"
" @@> (descent 'a 'd)\n"
" (ABD)\n"
" > (fail)\n"
" (ACD)\n"
" > (fail)\n"
" @@> (descent 'a 'h)\n"
" @\n"
"@end example"
msgstr ""
"@cartouche\n"
"@example\n"
" > (=defun descent (n1 n2)\n"
"        (cond ((eq n1 n2) (=values (list n2)))\n"
"                ((kids n1) (choose-bind n (kids n1)\n"
"                                  (=bind (p) (descent n n2)\n"
"                                      (=values (cons n1 p)))))\n"
"                (t (fail))))\n"
" DESCENT\n"
" > (defun kids (n)\n"
"        (case n\n"
"           (a '(b c))\n"
"           (b '(d e))\n"
"           (c '(d f))\n"
"           (f '(g))))\n"
" KIDS\n"
" > (descent 'a 'g)\n"
" (ACFG)\n"
" > (fail)\n"
" @@> (descent 'a 'd)\n"
" (ABD)\n"
" > (fail)\n"
" (ACD)\n"
" > (fail)\n"
" @@> (descent 'a 'h)\n"
" @\n"
"@end example"

#: texi/node-22.texi:702
msgid "               Figure 22-7: Nondeterministic search in Common Lisp"
msgstr ""
"               Рисунок 22-7: Недетерминированный поиск в Common Lisp\n"
"@end cartouche"

#: texi/node-22.texi:711
msgid ""
"After the promotion has begun, it emerges that the tokens are small enough "
"to\n"
"be swallowed by children. Hounded by visions of lawsuits, Chocoblob lawyers\n"
"begin a frantic search for all the special boxes. Within each city, there "
"are multiple\n"
"stores that sell Chocoblobs; within each store, there are multiple boxes. "
"But the\n"
"lawyers may not have to open every box: once they find a coin-containing box "
"in\n"
"a given city, they do not have to search any of the other boxes in that "
"city, because\n"
"each city has at most one special box. To realize this is to do a cut."
msgstr ""
"После начала рекламной кампании выясняется, что жетоны достаточно\n"
"малы, чтобы быть проглочены детьми.  Преследуемые видениями грядущих\n"
"исков, юристы компании начинают неистово выискивать все выигрышные\n"
"коробки.  В каждом городе их продают во многих магазинах, в каждом\n"
"магазине - много коробок.  Но юристам может не понадобиться открывать\n"
"каждую: как только они найдут нужную в каком-либо городе, им не\n"
"придётся больше в нём искать, потому что таких в каждом городе — не\n"
"более одной.  Осознать это значит сделать отсечение."

#: texi/node-22.texi:716
msgid ""
"What's cut is a portion of the search tree. For Chocoblobs, the search tree\n"
"exists physically: the root node is at the company's head office; the "
"children of this\n"
"node are the cities where the special boxes were sent; the children of those "
"nodes\n"
"are the stores in each city; and the children of each store represent the "
"boxes in"
msgstr ""
"/Отсекается/ часть исследуемого дерева.  Для нашей компании это дерево\n"
"существует физически: его корень - в главном офисе; дочерние узлы -\n"
"магазины в каждом городе; от них - коробки "

#: texi/node-22.texi:729
msgid ""
"@lisp\n"
"     (define (find-boxes)\n"
"       (set! *paths* ())\n"
"       (let ((city (choose '(la ny bos))))\n"
"         (newline)\n"
"         (let* ((store (choose '(1 2)))\n"
"                   (box (choose '(1 2))))\n"
"            (let ((triple (list city store box)))\n"
"               (display triple)\n"
"               (if (coin? triple)\n"
"                    (display 'c))\n"
"               (fail)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (define (find-boxes)\n"
"       (set! *paths* ())\n"
"       (let ((city (choose '(la ny bos))))\n"
"         (newline)\n"
"         (let* ((store (choose '(1 2)))\n"
"                   (box (choose '(1 2))))\n"
"            (let ((triple (list city store box)))\n"
"               (display triple)\n"
"               (if (coin? triple)\n"
"                    (display 'c))\n"
"               (fail)))))"

#: texi/node-22.texi:733
msgid ""
"     (define (coin? x)\n"
"       (member x '((la 1 2) (ny 1 1) (bos 2 2))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:735
msgid "                     Figure 22-8: Exhaustive Chocoblob search."
msgstr ""
"                     Рисунок 22-8: Исчерпывающий поиск Chocoblob.\n"
"@end cartouche"

#: texi/node-22.texi:741
msgid ""
"@noindent\n"
"that store. When the lawyers searching this tree find one of the boxes "
"containing\n"
"a coin, they can prune off all the unexplored branches descending from the "
"city\n"
"they're in now."
msgstr ""
"@noindent\n"
"в соответствующих магазинах.\n"
"Когда юристы находят одну из коробок с жетоном, они отрезают все\n"
"неисследованные ветви в том же городе."

#: texi/node-22.texi:748
msgid ""
"Cuts actually take two operations: you can do a cut when you know that part\n"
"of the search tree is useless, but first you have to mark the tree at the "
"point where\n"
"it can be cut. In the Chocoblob example, common sense tells us that the tree "
"is\n"
"marked as we enter each city. It's hard to describe in abstract terms what a "
"Prolog\n"
"cut does, because the marks are implicit. With an explicit mark operator, "
"the effect\n"
"of a cut will be more easily understood."
msgstr ""
"Отсечение в действительности совершается в две операции: да, требуется\n"
"знать бесполезную часть дерева, но сначала нужно /отметить/ точку\n"
"дерева, в которой можно произвести отсечение.  В примере с шоколадной\n"
"компанией здравый смысл подсказывает, что дерево отмечается по приходу\n"
"в город.  В абстрактных понятиях сложно объяснить, как работает\n"
"отсечение в Прологе, потому что отметки расставляются неявно.  С явным\n"
"же отмечающим оператором действие отсечения понять будет легче.\n"

#: texi/node-22.texi:752
msgid ""
"Figure 22-8 shows a program that nondeterministically searches a smaller\n"
"version of the Chocoblob tree. As each box is opened, the program displays a "
"list\n"
"of (city store box). If the box contains a coin, a c is printed after it:"
msgstr ""
"Программа на рисунке 22.8 недетерминированно ищет в уменьшенном\n"
"подобии дерева шоколадной компании.  При открывании каждой коробки она\n"
"отображает список (/город/ /магазин/ /коробка/).  Если в коробке\n"
"оказывается жетон, выводится =c=:\n"

#: texi/node-22.texi:760
msgid ""
"@example\n"
"> (find-boxes)\n"
"(LA 1 1)(LA 1 2)C(LA 2 1)(LA 2 2)\n"
"(NY 1 1)C(NY 1 2)(NY 2 1)(NY 2 2)\n"
"(BOS 1 1)(BOS 1 2)(BOS 2 1)(BOS 2 2)C\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-22.texi:766
msgid ""
"To implement the optimized search technique discovered by the Chocoblob\n"
"lawyers, we need two new operators: mark and cut. Figure 22-9 shows one way\n"
"to define them. Whereas nondeterminism itself can be understood "
"independently\n"
"of any particular implementation, pruning the search tree is an optimization "
"tech-\n"
"nique, and depends very much on how choose is implemented. The mark and"
msgstr ""
"Для реализации техники оптимизированного поиска, открытой юристами,\n"
"нужны два новых оператора: =mark= и =cut=.  Одна из возможных\n"
"реализаций представлена на рисунке 22.9.  Тогда как\n"
"недетерминированность сама по себе не зависит от реализации,\n"
"сокращение дерева поиска, будучи приёмом оптимизации, определяется\n"
"способом реализации =choose=.  Данные операторы =mark= и "

#: texi/node-22.texi:769
msgid ""
"@lisp\n"
" (define (mark) (set! *paths* (cons fail *paths*)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (mark) (set! *paths* (cons fail *paths*)))"

#: texi/node-22.texi:778
msgid ""
" (define (cut)\n"
"    (cond ((null? *paths*))\n"
"             ((equal? (car *paths*) fail)\n"
"               (set! *paths* (cdr *paths*)))\n"
"             (else\n"
"               (set! *paths* (cdr *paths*))\n"
"               (cut))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:780
msgid "                  Figure 22-9: Marking and pruning search trees."
msgstr ""
"                  Рисунок 22-9: Разметка и обрезка деревьев поиска.\n"
"@end cartouche"

#: texi/node-22.texi:796
msgid ""
"@lisp\n"
" (define (find-boxes)\n"
"    (set! *paths* ())\n"
"    (let ((city (choose '(la ny bos))))\n"
"        (mark)                                                                    ;\n"
"        (newline)\n"
"        (let* ((store (choose '(1 2)))\n"
"                  (box (choose '(1 2))))\n"
"          (let ((triple (list city store box)))\n"
"             (display triple)\n"
"             (if (coin? triple)\n"
"                   (begin (cut) (display "
"'c)))                                    ;\n"
"             (fail)))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (find-boxes)\n"
"    (set! *paths* ())\n"
"    (let ((city (choose '(la ny bos))))\n"
"        (mark)                                                                    ;\n"
"        (newline)\n"
"        (let* ((store (choose '(1 2)))\n"
"                  (box (choose '(1 2))))\n"
"          (let ((triple (list city store box)))\n"
"             (display triple)\n"
"             (if (coin? triple)\n"
"                   (begin (cut) (display "
"'c)))                                    ;\n"
"             (fail)))))\n"
"@end lisp"

#: texi/node-22.texi:798
msgid "                      Figure 22-10: Pruned Chocoblob search."
msgstr ""
"                      Рисунок 22-10: Сокращённый поиск Chocoblob.\n"
"@end cartouche"

#: texi/node-22.texi:803
msgid ""
"@noindent\n"
"cut defined in Figure 22-9 are suitable for use with the depth-first "
"implementation\n"
"of choose (Figure 22-4)."
msgstr ""
"@noindent\n"
"=cut=\n"
"подходят для =choose=, ищущего в глубину (рисунок 22.4)."

#: texi/node-22.texi:811
msgid ""
"The general idea is for mark to store markers in *paths*,the list of "
"unexplored\n"
"choice-points. Calling cut pops *paths* all the way down to the most recent\n"
"marker. What should we use as a marker? We could use e.g. the symbol m,but\n"
"that would require us to rewrite fail to ignore the ms when it encountered "
"them.\n"
"Fortunately, since functions are data objects too, there is at least one "
"marker that\n"
"will allow us to use fail as is: the function fail itself. Then if fail "
"happens\n"
"on a marker, it will just call itself."
msgstr ""
"Общая идея в том, что =mark= сохраняет маркеры в списке\n"
"неисследованных точек выбора =*paths*=.  Вызов =cut= вынимает из\n"
"=*paths*= элементы вплоть до маркера, положенного туда последним.  Что\n"
"бы использовать в качестве маркера?  Скажем, символ =m=; но тогда\n"
"пришлось бы переписать =fail=, чтобы он игнорировал встречающиеся\n"
"символы =m=.  К счастью, поскольку функции — тоже объекты данных, один\n"
"маркер позволит использовать =fail= без изменений: это сама функция\n"
"=fail=.  Тогда, если =fail= натолкнётся на маркер, она просто вызовет\n"
"саму себя.\n"

#: texi/node-22.texi:815
msgid ""
"Figure 22-10 shows how these operators would be used to prune the search\n"
"tree in the Chocoblob case. (Changed lines are indicated by semicolons.) We "
"call\n"
"mark upon choosing a city. At this point, *paths* contains one continuation,"
msgstr ""
"Рисунок 22.10 показывает использование этих операторов для сокращения\n"
"дерева поиска в случае шоколадной компании.  (Изменённые строки\n"
"отмечены точкой с запятой.)  =mark= вызывается по выбору города.  К\n"
"этому моменту =*paths*= содержит одно продолжение, "

#: texi/node-22.texi:832
msgid "                      Figure 22-11: A directed graph with a loop."
msgstr ""
"@cartouche\n"
"                      Рисунок 22-11: Направленный граф с циклами.\n"
"@end cartouche"

#: texi/node-22.texi:835
msgid ""
"@noindent\n"
"representing the search of the remaining cities."
msgstr ""
"@noindent\n"
"соответствующее поиску в оставшихся городах."

#: texi/node-22.texi:842
msgid ""
"If we find a box with a coin in it, we call cut, which sets *paths* back to "
"the\n"
"value it had at the time of the mark. The effects of the cut are not visible "
"until the\n"
"next call to fail. But when it comes, after the display, the next fail sends "
"the\n"
"search all the way up to the topmost choose, even if there would otherwise "
"have\n"
"been live choice-points lower in the search tree. The upshot is, as soon as "
"we find\n"
"a box with a coin in it, we resume the search at the next city:"
msgstr ""
"Когда находится коробка с жетоном, вызывается =cut=, возвращающий\n"
"=*paths*= к состоянию до вызова =mark=.  Результат отсечения не\n"
"проявляется до следующего вызова =fail=.  Но когда он, после вызова\n"
"=display=, наконец обнаруживает себя, следующий =fail= отбрасывает\n"
"поиск вплоть до самого первого =choose=, даже если ниже по дереву ещё\n"
"остались неисчерпанные точки выбора.  В результате, как только\n"
"находится коробка с жетоном, поиск продолжается со следующего города:\n"

#: texi/node-22.texi:850
msgid ""
"@example\n"
"> (find-boxes)\n"
"(LA 1 1)(LA 1 2)C\n"
"(NY 1 1)C\n"
"(BOS 1 1)(BOS 1 2)(BOS 2 1)(BOS 2 2)C\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-22.texi:852
msgid "In this case, we open seven boxes instead of twelve."
msgstr "Так, открытыми оказались семь коробок вместо двенадцати."

#: texi/node-22.texi:857
msgid ""
"@node 22-6 True Nondeterminism,  , 22-5 Cuts, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-6 True Nondeterminism\n"
"@cindex 22-6 True Nondeterminism"
msgstr ""
"@node 22-6 True Nondeterminism,  , 22-5 Cuts, 22 Nondeterminism\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 22-6 Настоящая недетерминированность\n"
"@cindex 22-6 True Nondeterminism"

#: texi/node-22.texi:865
msgid ""
"A deterministic graph-searching program would have to take explicit steps "
"to\n"
"avoid getting caught in a circular path. Figure 22-11 shows a directed "
"graph\n"
"containing a loop. A program searching for a path from node a to node e "
"risks\n"
"getting caught in the circular path  a, b, c . Unless a deterministic "
"searcher used\n"
"randomization, breadth-first search, or checked explicitly for circular "
"paths, the\n"
"search might never terminate. The implementation of path shown in Figure "
"22-12\n"
"avoids circular paths by searching breadth-first."
msgstr ""
"Детерминированной программе поиска по графу пришлось бы предпринимать\n"
"явные шаги, чтобы не застрять в циклическом пути.  Рисунок 22.11\n"
"изображает направленный граф, содержащий цикл.  Поиск пути между =a= и\n"
"=e= рискует попасться в круг =<a b c>=.  Без рандомизации, поиска в\n"
"ширину или отмечания циклических путей, детерминированная программа\n"
"может и не завершиться.  Реализация =path= на рисунке 22.12 избегает\n"
"зацикливания поиском в ширину."

#: texi/node-22.texi:870
msgid ""
"In principle, nondeterminism should save us the trouble of even considering\n"
"circular paths. The depth-first implementation of choose and fail given in "
"Sec-\n"
"tion 22-3 is vulnerable to the problem of circular paths, but if we were "
"being\n"
"picky, we would expect nondeterministic choose to be able to select an object"
msgstr ""
"В принципе, недетерминированность избавляет от всякого беспокойства о\n"
"циклических путях.  Да, реализация /выбора/ и /неудачи/ поиском в\n"
"глубину из раздела 22.3 уязвима для циклических путей, но, будучи\n"
"более требовательным, можно было бы ожидать, чтобы недетерминированный\n"
"/выбор/ отбирал объект,"

#: texi/node-22.texi:874
msgid ""
"@lisp\n"
" (define (path node1 node2)\n"
"    (bf-path node2 (list (list node1))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (path node1 node2)\n"
"    (bf-path node2 (list (list node1))))"

#: texi/node-22.texi:888
msgid ""
" (define (bf-path dest queue)\n"
"    (if (null? queue)\n"
"         '@\n"
"         (let* ((path (car queue))\n"
"                   (node (car path)))\n"
"            (if (eq? node dest)\n"
"                  (cdr (reverse path))\n"
"                  (bf-path dest\n"
"                             (append (cdr queue)\n"
"                                           (map (lambda (n)\n"
"                                                 (cons n path))\n"
"                                               (neighbors node))))))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:890
msgid "                      Figure 22-12: Deterministic search."
msgstr ""
"                      Рисунок 22-12: Детерминированный поиск.\n"
"@end cartouche"

#: texi/node-22.texi:899
msgid ""
"@lisp\n"
" (define (path node1 node2)\n"
"    (cond ((null? (neighbors node1)) (fail))\n"
"               ((memq node2 (neighbors node1)) (list node2))\n"
"               (else (let ((n (true-choose (neighbors node1))))\n"
"                      (cons n (path n node2))))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (path node1 node2)\n"
"    (cond ((null? (neighbors node1)) (fail))\n"
"               ((memq node2 (neighbors node1)) (list node2))\n"
"               (else (let ((n (true-choose (neighbors node1))))\n"
"                      (cons n (path n node2))))))\n"
"@end lisp"

#: texi/node-22.texi:901
msgid "                     Figure 22-13: Nondeterministic search."
msgstr ""
"                     Рисунок 22-13: Недетерминированный поиск.\n"
"@end cartouche"

#: texi/node-22.texi:905
msgid ""
"which meets any computable specification, and this case is no exception. "
"Using a\n"
"correct choose, we should be able to write the shorter and clearer version "
"of path\n"
"shown in Figure 22-13."
msgstr ""
" удовлетворяющей всякой вычислимой\n"
"спецификации, без исключения и в этом случае.  Корректный /выбор/\n"
"позволил бы написать =path= короче и яснее, как показано на рисунке\n"
"22.13.\n"

#: texi/node-22.texi:911
msgid ""
"This section shows how to implement versions choose and fail which are safe\n"
"even from circular paths. Figure 22-14 contains a Scheme implementation of "
"true\n"
"nondeterministic choose and fail. Programs which use these versions of "
"choose  \n"
"and fail should find solutions whenever the equivalent nondeterministic "
"algorithms\n"
"would, subject to hardware limitations."
msgstr ""
"Этот раздел показывает, как реализовать /выбор/ и /неудачу/,\n"
"безопасные от циклических путей.  По-настоящему недетерминированная\n"
"версия на Scheme показана на рисунке 22.14.  Программы, использующие\n"
"её, найдут решение для всякого недетерминированного алгоритма, лишь бы\n"
"хватило аппаратных ресурсов."

#: texi/node-22.texi:916
msgid ""
"The implementation of true-choose defined in Figure 22-14 works by treat-\n"
"ing the list of stored paths as a queue. Programs using true-choose will "
"search\n"
"their state-space breadth-first. When the program reaches a choice-point, "
"contin-\n"
"uations to follow each choice are appended to the end of the list of stored "
"paths."
msgstr ""
"Реализация =true-choose= на рисунке 22.14 работает со список\n"
"сохранённых путей как с очередью.  Программы, использующие\n"
"=true-choose=, будут искать свои пространства состояний в ширину.  При\n"
"достижении точки выбора, продолжения каждой альтернативы добавляются в\n"
"конец списка сохранённых путей. "

#: texi/node-22.texi:921
msgctxt "texi/node-22.texi:921"
msgid ""
"@lisp\n"
" (define *paths* ())\n"
" (define failsym '@@)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define *paths* ())\n"
" (define failsym '@@)"

#: texi/node-22.texi:930
msgid ""
" (define (true-choose choices)\n"
"       (call-with-current-continuation\n"
"         (lambda (cc)\n"
"            (set! *paths* (append *paths*\n"
"                                         (map (lambda (choice)\n"
"                                                  (lambda () (cc choice)))\n"
"                                                choices)))\n"
"            (fail))))"
msgstr ""

#: texi/node-22.texi:932
msgctxt "texi/node-22.texi:932"
msgid " (define fail)"
msgstr ""

#: texi/node-22.texi:943
msgid ""
" (call-with-current-continuation\n"
"       (lambda (cc)\n"
"         (set! fail\n"
"                 (lambda ()\n"
"                    (if (null? *paths*)\n"
"                         (cc failsym)\n"
"                         (let ((p1 (car *paths*)))\n"
"                            (set! *paths* (cdr *paths*))\n"
"                            (p1)))))))\n"
"@end lisp"
msgstr ""

#: texi/node-22.texi:945
msgid "                      Figure 22-14: Correct choose in Scheme."
msgstr ""
"                      Рисунок 22-14: Корректный choose на Scheme.\n"
"@end cartouche"

#: texi/node-22.texi:949
msgid ""
"(Scheme's map returns the same values as Common Lisp's mapcar.) After this\n"
"there is a call to fail, which is unchanged."
msgstr ""
" (=map= в Scheme возвращает то же, что\n"
"и =mapcar= в Common Lisp.)  После этого вызывается =fail=, определение\n"
"которой осталось тем же."

#: texi/node-22.texi:953
msgid ""
"This version of choose would allow the implementation of path defined in\n"
"Figure 22-13 to find a path-indeed, the shortest path-from a to e in the "
"graph\n"
"displayed in Figure 22-11."
msgstr ""
"Эта версия /выбора/ позволит реализации =path= на рисунке 22.13 найти\n"
"путь (причём кратчайший) от =a= до =e= на графе на рисунке 22.11."

#: texi/node-22.texi:963
msgid ""
"Although for the sake of completeness this chapter has provided correct "
"ver-\n"
"sions of choose and fail, the original implementations will usually suffice. "
"The\n"
"value of a programming language abstraction is not diminished just because "
"its\n"
"implementation isn't formally correct. In some languages we act as if we "
"had\n"
"access to all the integers, even though the largest one may be only 32767. "
"As\n"
"long as we know how far we can push the illusion, there is little danger to "
"it-\n"
"little enough, at least, to make the abstraction a bargain. The conciseness "
"of\n"
"the programs presented in the next two chapters is due largely to their use "
"of\n"
"nondeterministic choose and fail."
msgstr ""
"Хотя ради полноты здесь и была приведена корректная реализация\n"
"/выбора/ и /неудачи/, исходной обычно будет достаточно.  Ценность\n"
"языковой абстракции не уменьшается уже от того лишь, что её реализация\n"
"не является формально корректной: в некоторых языках мы поступаем так,\n"
"будто нам доступны все целые числа, тогда как наибольшим может быть\n"
"всего лишь 32767.  До тех, пока мы отдаём себе отчёт в том, сколь\n"
"долго можно предаваться иллюзии, в ней мало опасности; во всяком\n"
"случае, достаточно мало, чтобы абстракция оставалась выгодной.\n"
"Краткость программ в следующих двух главах в значительной мере\n"
"обусловлена использованием недетерминированных /выбора/ и /неудачи/."
