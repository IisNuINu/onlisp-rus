#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-05.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-05-16 10:35+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-05.texi:5
msgid ""
"@node 5 Returning Functions, 6 Functions as Representation, 4 Utility "
"Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 5 Returning Functions\n"
"@cindex 5 Returning Functions"
msgstr ""
"@node 5 Returning Functions, 6 Functions as Representation, 4 Utility "
"Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 5 Возврат Функций\n"
"@cindex 5 Returning Functions"

#: texi/node-05.texi:11
msgid ""
"The previous chapter showed how the ability to pass functions as arguments "
"leads\n"
"to greater possibilities for abstraction. The more we can do to functions, "
"the more\n"
"we can take advantage of these possibilities. By defining functions to build "
"and\n"
"return new functions, we can magnify the effect of utilities which take "
"functions\n"
"as arguments."
msgstr ""
"Предыдущая глава показала, как способность передавать функции в качестве "
"аргументов\n"
"приводит к большим возможностям для абстрагирования. Чем больше мы можем "
"использовать\n"
"функции, тем болье мы имеем возможностей. Определив функции для построения и "
"возврата\n"
"новых функций, мы можем увеличить эффект от утилит, которые принимают "
"функции как\n"
"аргументы."

#: texi/node-05.texi:18
msgid ""
"The utilities in this chapter operate on functions. It would be more "
"natural, at\n"
"least in Common Lisp, to write many of them to operate on expressions-that "
"is,\n"
"as macros. A layer of macros will be superimposed on some of these "
"operators\n"
"in Chapter 15. However, it is important to know what part of the task can "
"be\n"
"done with functions, even if we will eventually call these functions only "
"through\n"
"macros."
msgstr ""
"Утилиты в этой главе работают с функциями. Это было бы более естественно, "
"хотя бы\n"
"в  Common Lisp, чтобы написать множество из них для работы с выражениями, то "
"есть\n"
"как макросы. Слой макросов будет накладываться на некоторые из этих "
"операторов в\n"
"главе 15. Тем не менее, важно знать, какая часть задачи может быть сделана \n"
"функциями, даже если мы в конечном итоге будем вызывать эти функции только "
"через\n"
"макросы."

#: texi/node-05.texi:28
msgid ""
"@menu\n"
"* 5-1 Common Lisp Evolves::     \n"
"* 5-2 Orthogonality::           \n"
"* 5-3 Memoizing::               \n"
"* 5-4 Composing Functions::     \n"
"* 5-5 Recursion on Cdrs::       \n"
"* 5-6 Recursion on Subtrees::   \n"
"* 5-7 When to Build Functions::  \n"
"@end menu"
msgstr ""

#: texi/node-05.texi:33
msgid ""
"@node 5-1 Common Lisp Evolves, 5-2 Orthogonality, 5 Returning Functions, 5 "
"Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-1 Common Lisp Evolves\n"
"@cindex 5-1 Common Lisp Evolves"
msgstr ""
"@node 5-1 Common Lisp Evolves, 5-2 Orthogonality, 5 Returning Functions, 5 "
"Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-1 Common Lisp Развивается\n"
"@cindex 5-1 Common Lisp Evolves"

#: texi/node-05.texi:37
msgid ""
"Common Lisp originally provided several pairs of complementary functions. "
"The\n"
"functions remove-if and remove-if-not make one such pair. If pred is a\n"
"predicate of one argument, then"
msgstr ""
"Common Lisp изначально предоставлял несколько пар взаимодополняющих функцй. "
"Функции\n"
"remove-if и remove-if-not составляют одну такую пару. Если pred является "
"предикатом\n"
"одного аргумента, то"

#: texi/node-05.texi:41
msgctxt "texi/node-05.texi:41"
msgid ""
"@lisp\n"
"(remove-if-not #'pred lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:43
msgid "is equivalent to"
msgstr "является эквивалентным"

#: texi/node-05.texi:47
msgid ""
"@lisp\n"
"(remove-if #'(lambda (x) (not (pred x))) lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:53
msgid ""
"By varying the function given as an argument to one, we can duplicate the\n"
"effect of the other. In that case, why have both? CLTL2 includes a new "
"function\n"
"intended for cases like this: complement takes a predicate p and returns a "
"function\n"
"which always returns the opposite value. When p returns true, the "
"complement\n"
"returns false, and vice versa. Now we can replace"
msgstr ""
"Изменяя функцию, заданную в качестве аргумента, мы можем продублировать "
"эффект \n"
"другой функции. В таком случае, почему существуют две функции? CLTL2 "
"включает новую\n"
"функцию предназначенную для случаев, подобных этому: функция complement "
"принимает\n"
"предикат p и возвращает функцию, которая всегда возвращает проитвоположное "
"значение.\n"
"Когда p возвращает истину, complement возвращает ложь, и наоборот. Теперь мы "
"можем\n"
"заменить"

#: texi/node-05.texi:57
msgctxt "texi/node-05.texi:57"
msgid ""
"@lisp\n"
"(remove-if-not #'pred lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:59
msgid "with the equivalent"
msgstr "с эквивалентом"

#: texi/node-05.texi:63
msgid ""
"@lisp\n"
"(remove-if (complement #'pred) lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:69
msgid ""
"With complement, there is little justification for continuing to use\n"
"the -if-not functions. @footnote{Except perhaps remove-if-not, which\n"
"is used more often than remove-if.}Indeed, CLTL2 (p. 391) says that\n"
"their use is now deprecated. If they remain in Common Lisp, it will\n"
"only be for the sake of compatibility."
msgstr ""
"С complement, есть мало оснований для продолжения использования функций\n"
"-if-not. @footnote{За исключением, возможно remove-if-not, которая "
"используется\n"
"чаще чем remove-if.}Действительно, CLTL2 (стр. 391) говорит, что\n"
"их использование сейчас устарело. Если они остаются в Common Lisp, это "
"делается\n"
"только ради совместимости."

#: texi/node-05.texi:74
msgid ""
"The new complement operator is the tip of an important iceberg: functions\n"
"which return functions. This has long been an important part of the idiom "
"of\n"
"Scheme. Scheme was the first Lisp to make functions lexical closures, and it "
"is\n"
"this which makes it interesting to have functions as return values."
msgstr ""
"Новый оператор complement вершина важного айсберга: функций которые "
"возвращают\n"
"функции. Это давно стало важной частью идиом на Scheme. Scheme была первым "
"Lisp-ом\n"
"сделавшим функции лексическим замыканием, и это делает интересным "
"использование\n"
"функций в качестве возвращаемых значений."

#: texi/node-05.texi:77
msgid ""
"It's not that we couldn't return functions in a dynamically scoped Lisp. "
"The\n"
"following function would work the same under dynamic or lexical scope:"
msgstr ""
"Не то чтобы мы не могли возвращать функции в динамческом области охвата "
"связывания Lisp. \n"
"Следующая функция будет работать одинаково как с использованием динамической "
"области охвата,\n"
"так и с использованием лексического охвата связывания(контекта)."

#: texi/node-05.texi:84
msgid ""
"@lisp\n"
"(defun joiner (obj)\n"
"      (typecase obj\n"
"        (cons       #'append)\n"
"        (number #'+)))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:88
msgid ""
"It takes an object and, depending on its type, returns a function to add "
"such objects\n"
"together. We could use it to define a polymorphic join function that worked "
"for\n"
"numbers or lists:"
msgstr ""
"Она берет объект и в зависимости от его типа, возвращает функцию для "
"добавления таких\n"
"объектов. Мы могли бы использовать ее для определения полиморфной функции "
"соединения(join),\n"
"которая бы работала для чисел или списков:"

#: texi/node-05.texi:93
msgid ""
"@lisp\n"
"(defun join (&rest args)\n"
"      (apply (joiner (car args)) args))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:97
msgid ""
"However, returning constant functions is the limit of what we can do with "
"dynamic\n"
"scope. What we can't do (well) is build functions at runtime; joiner can "
"return\n"
"one of two functions, but the two choices are fixed."
msgstr ""
"Тем не менее, возврат постоянных функций является пределом того, что мы "
"можем сделать с\n"
"динамической областью охвата. Что мы не можем сделать(хорошо), так это "
"строить функции\n"
"во время выполнения; joiner может вернуть одну из двух функций, но оба "
"варианта фиксированные."

#: texi/node-05.texi:100
msgid ""
"On page 18 we saw another function for returning functions, which relied on\n"
"lexical scope:"
msgstr ""
"На странице 18 мы видели еще одну функцию для возврата функций, которая "
"основывалась\n"
"на лексической области  охвата(лексическом связывании):"

#: texi/node-05.texi:105
msgid ""
"@lisp\n"
"(defun make-adder (n)\n"
"      #'(lambda (x) (+ x n)))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:108
msgid ""
"Calling make-adder will yield a closure whose behavior depends on the value\n"
"originally given as an argument:"
msgstr ""
"Вызов make-adder приводит к созданию замыкания, поведение которого зависит "
"от значения\n"
"переданного как аргумент в функцию:"

#: texi/node-05.texi:115
msgid ""
"@example\n"
"> (setq add3 (make-adder 3))\n"
"#<Interpreted-Function BF1356>\n"
"> (funcall add3 2)\n"
"5\n"
"@end example"
msgstr ""

#: texi/node-05.texi:120
msgid ""
"Under lexical scope, instead of merely choosing among a group of constant "
"func-\n"
"tions, we can build new closures at runtime. With dynamic scope this "
"technique\n"
"is impossible.@footnote{Under dynamic scope, we could write something like "
"make-adder, but it would hardly ever work. The binding of n would be "
"determined by the environment in which the returned function was eventually "
"called, and we might not have any control over that.}  If we consider how "
"complement would be written, we see that it\n"
"too must return a closure:"
msgstr ""
"В лексическом контексте(лексической области охвата), вместо простого выбора "
"из группы константных\n"
"функций, мы можем создавать новые замыкания во время выполнения. С "
"динамической областью действия\n"
"привязок эта техника недоступна.@footnote{Под динамической областью, мы "
"могли бы написать что то\n"
"вроде make-adder, но вряд ли это работало. Привязка n будет определяться "
"средой, в которую будет \n"
"возвращена функция и мы не имеем никакого контроля над этим.}  Если мы "
"посмотрим, как написан\n"
"complement, мы увидим, что этот оператор возвращает замыкание:"

#: texi/node-05.texi:125
msgid ""
"@lisp\n"
"(defun complement (fn)\n"
"     #'(lambda (&rest args) (not (apply fn args))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:129
msgid ""
"The function returned by complement uses the value of the parameter fn when\n"
"complement was called. So instead of just choosing from a group of constant\n"
"functions, complement can custom-build the inverse of any function:"
msgstr ""
"Функция возвращаемая complement использует значение параметра fn, который "
"был\n"
"передан когда complement был вызван. Так что вместо того, чтобы просто "
"выбирать из\n"
"группы постоянных функций, complement может создавать обратные функции для "
"любой\n"
"переданной ей функции:"

#: texi/node-05.texi:134
msgid ""
"@example\n"
"> (remove-if (complement #'oddp) '(123456))\n"
"(135)\n"
"@end example"
msgstr ""

#: texi/node-05.texi:139
msgid ""
"Being able to pass functions as arguments is a powerful tool for "
"abstraction.\n"
"The ability to write functions which return functions allows us to make the "
"most\n"
"of it. The remaining sections present several examples of utilities which "
"return\n"
"functions."
msgstr ""
"Возможность передавать функции в качестве аргументов является мощным "
"инструментом для\n"
"абстракции. Возможность писать функции, которые возвращают функции, "
"позволяет нам\n"
"максимально использовать это. Остальные разделы представляют несколько "
"примеров утилит,\n"
"которые взвращают функции."

#: texi/node-05.texi:144
msgid ""
"@node 5-2 Orthogonality, 5-3 Memoizing, 5-1 Common Lisp Evolves, 5 Returning "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-2 Orthogonality\n"
"@cindex 5-2 Orthogonality"
msgstr ""
"@node 5-2 Orthogonality, 5-3 Memoizing, 5-1 Common Lisp Evolves, 5 Returning "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-2 Ортогональность\n"
"@cindex 5-2 Orthogonality"

#: texi/node-05.texi:151
msgid ""
"An orthogonal language is one in which you can express a lot by combining a "
"small\n"
"number of operators in a lot of different ways. Toy blocks are very "
"orthogonal; a\n"
"plastic model kit is hardly orthogonal at all. The main advantage of "
"complement\n"
"is that it makes a language more orthogonal. Before complement, Common\n"
"Lisp had pairs of functions like remove-if and remove-if-not, subst-if and\n"
"subst-if-not, and so on. With complement we can do without half of them."
msgstr ""
"Ортогональный язык это язык, в котором вы можете выразить много, комбинируя "
"маленькое\n"
"количество операторов во многими различными способами. Игрушечные блоки типа "
"лего, очень\n"
"ортогональны, пластмассовая модель практически не ортогональна. Основное "
"преимущество\n"
"complement в том, что он делает язык более ортогональным. До complement-а, "
"Common\n"
"Lisp были пары функций, такие как remove-if и remove-if-not, subst-if и\n"
"subst-if-not, и так далее. С complement половина из них становитсья не "
"нужной."

#: texi/node-05.texi:156
msgid ""
"The setf macro also improves Lisp's orthogonality. Earlier dialects of Lisp\n"
"would often have pairs of functions for reading and writing data. With "
"property-\n"
"lists, for example, there would be one function to establish properties and "
"another\n"
"function to ask about them. In Common Lisp, we have only the latter, get.To"
msgstr ""
"Макрос setf также улучшает ортогональность Lisp. Ранние диалекты Lisp часто "
"имели\n"
"пары функций для чтений и записи данных. Например, с property - "
"lists(списков свойств), \n"
"будет одна функция для установки свойств и другая для запроса о "
"нем(свойстве). В Common \n"
"Lisp, у нас есть только последняя, get. Чтобы"

#: texi/node-05.texi:159
msgid ""
"@lisp\n"
" (defvar *!equivs* (make-hash-table))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *!equivs* (make-hash-table))"

#: texi/node-05.texi:162
msgid ""
" (defun ! (fn)\n"
"      (or (gethash fn *!equivs*) fn))"
msgstr ""

#: texi/node-05.texi:166
msgid ""
" (defun def! (fn fn!)\n"
"      (setf (gethash fn *!equivs*) fn!))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:168
msgid "                   Figure 5-1: Returning destructive equivalents."
msgstr ""
"                   Рисунок 5-1: Возвращение деструктивных(разрушающих) "
"эквивалентов.\n"
"@end cartouche"

#: texi/node-05.texi:171
msgid "establish a property, we use get in combination with setf:"
msgstr "установить(set) свойство, мы использжуем get в сочетании с setf:"

#: texi/node-05.texi:175
msgid ""
"@lisp\n"
"(setf (get 'ball 'color) 'red)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:183
msgid ""
"We may not be able to make Common Lisp smaller, but we can do something\n"
"almost as good: use a smaller subset of it. Can we define any new operators "
"which\n"
"would, like complement and setf, help us toward this goal? There is at "
"least\n"
"one other way in which functions are grouped in pairs. Many functions also "
"come\n"
"in a destructive version: remove-if and delete-if, reverse and nreverse,\n"
"append and nconc. By defining an operator to return the destructive "
"counterpart\n"
"of a function, we would not have to refer to the destructive functions "
"directly."
msgstr ""
"Возможно, мы не сможем сделать Common Lisp меньше, но мы можем кое что "
"сделать\n"
"почти так же хорошо: использовать меньшее его подмножество. Можем ли мы "
"определить\n"
"новые операторы, которые смогут, подобно complement и setf, помочь нам в "
"достижении\n"
"этой цели? Есть хотя бы еще одно направление, по которому функции "
"сгруппированы\n"
"в пары. Для многих функций существуют их разрушающие(деструктивные) "
"версии: \n"
"remove-if и delete-if, reverse и nreverse, append и nconc. Определив "
"оператор,\n"
"чтоыбы возвращать разрушающий аналог функции, мы можем больше не обращаться "
"к\n"
"разрушающим функциям напрямую."

#: texi/node-05.texi:189
msgid ""
"Figure 5-1 contains code to support the notion of destructive counterparts.\n"
"The global hash-table *!equivs* maps functions to their destructive "
"equivalents;\n"
"! returns destructive equivalents; and def! sets them. The name of the ! "
"(bang)\n"
"operator comes from the Scheme convention of appending ! to the names of\n"
"functions with side-effects. Now once we have defined"
msgstr ""
"Рисунок 5-1 содержит код для поддержки понятия деструктивных аналогов.\n"
"Глобальная хеш-таблица *!equivs* отображает функции на их деструктивные "
"эквиваленты;\n"
"! возвращает деструктивный эквивалент; и def! устанавливает их. Имя "
"оператора ! (банг)\n"
"происходит из Scheme соглашения добавлять ! к имени функции имеющей "
"побочный(сторонний)\n"
"эффект. Теперь когда мы определили"

#: texi/node-05.texi:193
msgid ""
"@lisp\n"
"(def! #'remove-if #'delete-if)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:195
msgid "then instead of"
msgstr "тогда вместо"

#: texi/node-05.texi:199
msgid ""
"@lisp\n"
"(delete-if #'oddp lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:201
msgid "we would say"
msgstr "мы бы сказали"

#: texi/node-05.texi:205
msgid ""
"@lisp\n"
"(funcall (! #'remove-if) #'oddp lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:208
msgid ""
"Here the awkwardness of Common Lisp masks the basic elegance of the idea,\n"
"which would be more visible in Scheme:"
msgstr ""
"Здесь неловкость Common Lisp скрывает основную элегантность идеи, что было "
"бы более\n"
"заметно на Scheme:"

#: texi/node-05.texi:211
msgid ""
"@lisp\n"
"((! remove-if) oddp lst)"
msgstr ""
"@lisp\n"
"((! remove-if) oddp lst)\n"
"@end lisp"

#: texi/node-05.texi:222
msgid ""
"     (defun memoize (fn)\n"
"       (let ((cache (make-hash-table :test #'equal)))\n"
"          #'(lambda (&rest args)\n"
"               (multiple-value-bind (val win) (gethash args cache)\n"
"                  (if win\n"
"                       val\n"
"                       (setf (gethash args cache)\n"
"                                (apply fn args)))))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun memoize (fn)\n"
"       (let ((cache (make-hash-table :test #'equal)))\n"
"          #'(lambda (&rest args)\n"
"               (multiple-value-bind (val win) (gethash args cache)\n"
"                  (if win\n"
"                       val\n"
"                       (setf (gethash args cache)\n"
"                                (apply fn args)))))))\n"
"@end lisp"

#: texi/node-05.texi:224
msgid "                              Figure 5-2: Memoizing utility."
msgstr ""
"                              Рисунок 5-2: Утилита запоминания результатов "
"работы функции(Memoizing).\n"
"@end cartouche"

#: texi/node-05.texi:231
msgid ""
"As well as greater orthogonality, the ! operator brings a couple of other "
"bene-\n"
"fits. It makes programs clearer, because we can see immediately that (! "
"#'foo)\n"
"is the destructive equivalent of foo. Also, it gives destructive operations "
"a dis-\n"
"tinct, recognizable form in source code, which is good because they should "
"receive\n"
"special attention when we are searching for a bug."
msgstr ""
"Кроме великолепной ортогональности, оператор ! приносит пару других "
"преимуществ.\n"
"Он делает программы понятнее, потому что мы сразу видим, что (! #'foo) это "
"разрушающий\n"
"эквивалент foo. Кроме того, он придает разрушающим операциям отчетливую, "
"узнаваемую\n"
"форму в исходном коде, что хорошо, потому что они должны получить особое "
"внимание,\n"
"когда мы ищем ошибку."

#: texi/node-05.texi:235
msgid ""
"Since the relation between a function and its destructive counterpart will\n"
"usually be known before runtime, it would be most efficient to define ! as "
"a\n"
"macro, or even provide a read macro for it."
msgstr ""
"Поскольку связь между функцией и ее разрушающим аналогом будет как правило "
"известна\n"
"до выполнения программы, было бы наиболее эффективно определить (банг) ! как "
"макрос,\n"
"или даже предоставить макрос чтения для него."

#: texi/node-05.texi:240
msgid ""
"@node 5-3 Memoizing, 5-4 Composing Functions, 5-2 Orthogonality, 5 Returning "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-3 Memoizing\n"
"@cindex 5-3 Memoizing"
msgstr ""
"@node 5-3 Memoizing, 5-4 Composing Functions, 5-2 Orthogonality, 5 Returning "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-3 Memoizing(Запоминание предыдущих результатов)\n"
"@cindex 5-3 Memoizing"

#: texi/node-05.texi:245
msgid ""
"If some function is expensive to compute, and we expect sometimes to make "
"the\n"
"same call more than once, then it pays to memoize: to cache the return "
"values of\n"
"all the previous calls, and each time the function is about to be called, to "
"look first\n"
"in the cache to see if the value is already known."
msgstr ""
"Если какая-то функция является дорогой, в смысле вычилений,и мы ожидаем, что "
"иногда один\n"
"и тот же вызов более одного раза, то стоит запоминать результаты(memoize): "
"для кэширования\n"
"возвращаемых значений всех предыдущих значений, и каждый раз, когда функция "
"будет вызываться,\n"
"в первую очередь будет просматриваться кэш, чтобы найти уже известное "
"значение."

#: texi/node-05.texi:249
msgid ""
"Figure 5-2 contains a generalized memoizing utility. We give a function to\n"
"memoize, and it returns an equivalent memoized version-a closure containing "
"a\n"
"hash-table in which to store the results of previous calls."
msgstr ""
"Рисунок 5-2 содержит обобщенную утилиту memoizing. Мы передаем не "
"записывающую функцию,\n"
"в memoize, и она возвращает эквивалентную записыващую версию  - замыкание, "
"содержащее\n"
"хеш-таблицу для хранения результатов предыдущих вызовов."

#: texi/node-05.texi:259
msgid ""
"@example\n"
"> (setq slowid (memoize #'(lambda (x) (sleep 5) x)))\n"
"#<Interpreted-Function C38346>\n"
"> (time (funcall slowid 1))\n"
"Elapsed Time = 5-15 seconds\n"
"1> (time (funcall slowid 1))\n"
"Elapsed Time = 0-00 seconds\n"
"1\n"
"@end example"
msgstr ""

#: texi/node-05.texi:262
msgid ""
"With a memoized function, repeated calls are just hash-table lookups. There "
"is\n"
"of course the additional expense of a lookup on each initial call, but since "
"we"
msgstr ""
"С функцией memoize, повторный вызов это просто поиск в хеш-таблице. Есть "
"конечно\n"
"дополнительные затраты на поиск при каждом начальном вызове, но поскольку мы "

#: texi/node-05.texi:274
msgid ""
"@lisp\n"
"        (defun compose (&rest fns)\n"
"         (if fns\n"
"              (let ((fn1 (car (last fns)))\n"
"                      (fns (butlast fns)))\n"
"                #'(lambda (&rest args)\n"
"                      (reduce #'funcall fns\n"
"                                   :from-end t\n"
"                                   :initial-value (apply fn1 args))))\n"
"              #'identity))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"        (defun compose (&rest fns)\n"
"         (if fns\n"
"              (let ((fn1 (car (last fns)))\n"
"                      (fns (butlast fns)))\n"
"                #'(lambda (&rest args)\n"
"                      (reduce #'funcall fns\n"
"                                   :from-end t\n"
"                                   :initial-value (apply fn1 args))))\n"
"              #'identity))\n"
"@end lisp"

#: texi/node-05.texi:276
msgid "                    Figure 5-3: An operator for functional composition."
msgstr ""
"                    Рисунок 5-3: Оператор для композиции функций.\n"
"@end cartouche"

#: texi/node-05.texi:280
msgid ""
"would only memoize a function that was sufficiently expensive to compute, "
"it's\n"
"reasonable to assume that this cost is insignificant in comparison."
msgstr ""
"запоминаем только функцию, достаточно дорогую для вычисления, разумно "
"предположить,\n"
"что эти затраты сравнительно не велики."

#: texi/node-05.texi:285
msgid ""
"Though adequate for most uses, this implementation of memoize has several\n"
"limitations. It treats calls as identical if they have equal argument lists; "
"this could\n"
"be too strict if the function had keyword parameters. Also, it is intended "
"only for\n"
"single-valued functions, and cannot store or return multiple values."
msgstr ""
"Хотя это подходит для большинства применений, эта реализация memoize имеет "
"несколько\n"
"ограничений. Она обрабатывает вызовы как идентичные, если они имеют "
"одинаковые списки\n"
"аргументов; это может быть слишком строгим ограничением, если у функции есть "
"ключевые\n"
"параметры. Так же она предназначена для работы только с с однозначными "
"функциями и \n"
"не может хранить или возвращать множественные значения."

#: texi/node-05.texi:290
msgid ""
"@node 5-4 Composing Functions, 5-5 Recursion on Cdrs, 5-3 Memoizing, 5 "
"Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-4 Composing Functions\n"
"@cindex 5-4 Composing Functions"
msgstr ""
"@node 5-4 Composing Functions, 5-5 Recursion on Cdrs, 5-3 Memoizing, 5 "
"Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-4 Композиция Функций(составные функции)\n"
"@cindex 5-4 Composing Functions"

#: texi/node-05.texi:296
msgid ""
"The complement of a function f is denoted  f. Section 5-1 showed that "
"closures\n"
"make it possible to define   as a Lisp function. Another common operation "
"on\n"
"functions is composition, denoted by the operator  .Iff and g are functions, "
"then\n"
"f  g is also a function, and f  g(x)=f (g(x)). Closures also make it "
"possible to\n"
"define   as a Lisp function."
msgstr ""
"Дополнение(complement) к функции f обозначается ка  ~f. Раздел 5-1 показал, "
"что\n"
"что замыкания делают  определение ~ как функции Lisp-а. Еще одна "
"распространенная\n"
"операция над функциям это композиция(composition, составление функций), "
"обозначаемая\n"
"оператором *. Если f и g функции, тогда композиция функций f * g также "
"является \n"
"функцией, и f * g(x) =f * (g(x)). Замыканя также позволяют определеить * "
"как\n"
"функцию Лиспа."

#: texi/node-05.texi:299
msgid ""
"Figure 5-3 defines a compose function which takes any number of functions\n"
"and returns their composition. For example"
msgstr ""
"Рисунок 5-3 определяет функцию compose которая принимает любое количество "
"функций\n"
"и возвращает их композицию. Например"

#: texi/node-05.texi:303
msgid ""
"@lisp\n"
"(compose #'list #'1+)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:305
msgid "returns a function equivalent to"
msgstr "возвращает функцию, эквивалентную"

#: texi/node-05.texi:309
msgid ""
"@lisp\n"
"#'(lambda (x) (list (1+ x)))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:313
msgid ""
"All the functions given as arguments to compose must be functions of one "
"argu-\n"
"ent, except the last. On the last function there are no restrictions, and "
"whatever\n"
"arguments it takes, so will the function returned by compose:"
msgstr ""
"Все функции, приведенные в качестве аргументов для композиции, должно быть "
"функциями\n"
"одного аргумента, за исключением последней. На последнюю функцию ограничений "
"нет, и все\n"
"аргументы, которые она принимает, также принимает функция возвращаемая "
"compose:"

#: texi/node-05.texi:318
msgid ""
"@example\n"
"> (funcall (compose #'1+ #'find-if) #'oddp '(2 3 4))\n"
"4\n"
"@end example"
msgstr ""

#: texi/node-05.texi:325
msgid ""
"@lisp\n"
" (defun fif (if then &optional else)\n"
"       #'(lambda (x)\n"
"           (if (funcall if x)\n"
"                  (funcall then x)\n"
"                  (if else (funcall else x)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun fif (if then &optional else)\n"
"       #'(lambda (x)\n"
"           (if (funcall if x)\n"
"                  (funcall then x)\n"
"                  (if else (funcall else x)))))"

#: texi/node-05.texi:332
msgid ""
" (defun fint (fn &rest fns)\n"
"       (if (null fns)\n"
"           fn\n"
"           (let ((chain (apply #'fint fns)))\n"
"                 #'(lambda (x)\n"
"                    (and (funcall fn x) (funcall chain x))))))"
msgstr ""

#: texi/node-05.texi:340
msgid ""
" (defun fun (fn &rest fns)\n"
"       (if (null fns)\n"
"           fn\n"
"           (let ((chain (apply #'fun fns)))\n"
"                 #'(lambda (x)\n"
"                    (or (funcall fn x) (funcall chain x))))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:342
msgid "                         Figure 5-4: More function builders."
msgstr ""
"                         Рисунок 5-4: Еще построители функций.\n"
"@end cartouche"

#: texi/node-05.texi:346
msgid ""
"Since not is a Lisp function, complement is a special case of compose. It "
"could\n"
"be defined as:"
msgstr ""
"Поскольку это не Lisp функция, complement является частным случаем compose. "
"Она могла бы\n"
"быть определена как:"

#: texi/node-05.texi:351
msgid ""
"@lisp\n"
"(defun complement (pred)\n"
"  (compose #'not pred))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:354
msgid ""
"We can combine functions in other ways than by composing them. For\n"
"example, we often see expressions like"
msgstr ""
"Мы можем комбинировать функции другими способами, а не просто "
"составлять(composing) их.\n"
"Например, мы часто видим такие выражения как"

#: texi/node-05.texi:362
msgid ""
"@lisp\n"
"(mapcar #'(lambda (x)\n"
"                   (if (slave x)\n"
"                       (owner x)\n"
"                       (employer x)))\n"
"            people)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:365
msgid ""
"We could define an operator to build functions like this one automatically. "
"Using\n"
"fif from Figure 5-4, we could get the same effect with:"
msgstr ""
"Мы могли бы определить оператор для автоматического создания таких функций, "
"как эта.\n"
"Используя fif  из рисунка 5-4, мы моглли бы получить тот же эффект:"

#: texi/node-05.texi:370
msgid ""
"@lisp\n"
"(mapcar (fif #'slave #'owner #'employer)\n"
"            people)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:373
msgid ""
"Figure 5-4 contains several other constructors for commonly occurring types\n"
"of functions. The second, fint, is for cases like this:"
msgstr ""
"Рисунок 5-4 содержин несколько других конструкторов для часто встречающихся "
"типов\n"
"функций. Вторая, fint, для случаев подобных этому:"

#: texi/node-05.texi:379
msgid ""
"@lisp\n"
"(find-if #'(lambda (x)\n"
"                   (and (signed x) (sealed x) (delivered x)))\n"
"               docs)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:383
msgid ""
"The predicate given as the second argument to find-if defines the "
"intersection of\n"
"the three predicates called within it. With fint, whose name stands for "
"\"function\n"
"intersection,\" we can say:"
msgstr ""
"Предикат, переданный как второй аргумент в find-if определяет пересечение "
"трех\n"
"предикатов вызываемых в нем. С fint, чье имя означает \"пересечение "
"функций(function\n"
"intersection)\" мы можем сказать:"

#: texi/node-05.texi:387
msgid ""
"@lisp\n"
"(find-if (fint #'signed #'sealed #'delivered) docs)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:390
msgid ""
"We can define a similar operator to return the union of a set of predicates. "
"The\n"
"function fun is like fint but uses or instead of and."
msgstr ""
"Мы можем определить аналогичный оператор, чтобы вернуть объединение набора "
"предикатов.\n"
"Функция fun похожа на fint но исползует or вместо and."

#: texi/node-05.texi:395
msgid ""
"@node 5-5 Recursion on Cdrs, 5-6 Recursion on Subtrees, 5-4 Composing "
"Functions, 5 Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-5 Recursion on Cdrs\n"
"@cindex 5-5 Recursion on Cdrs"
msgstr ""
"@node 5-5 Recursion on Cdrs, 5-6 Recursion on Subtrees, 5-4 Composing "
"Functions, 5 Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-5 Рекурсия на Cdrs\n"
"@cindex 5-5 Recursion on Cdrs"

#: texi/node-05.texi:402
msgid ""
"Recursive functions are so important in Lisp programs that it would be "
"worth\n"
"having utilities to build them. This section and the next describe functions "
"which\n"
"build the two most common types. In Common Lisp, these functions are a "
"little\n"
"awkward to use. Once we get into the subject of macros, we will see how to\n"
"put a more elegant facade on this machinery. Macros for building recursers "
"are\n"
"discussed in Sections 15-2 and 15-3."
msgstr ""
"Рекурсивные функции настолько важны в программах на Lisp, что стоит иметь "
"утилиты для\n"
"их строительства. Этот раздел и следующий описывают функции, которые строят\n"
"функции для двух наиболее распространенных типов. В Common Lisp, эти функции "
"немного\n"
"неудобно использовать. Как только мы перейдем к теме макросов, мы увидим, "
"как поставить\n"
"более элегантный фасад для этого механизма. Макросы для построения рекурсий "
"обсуждаются\n"
"в разделах 15-2 и 15-3."

#: texi/node-05.texi:406
msgid ""
"Repeated patterns in a program are a sign that it could have been written at "
"a\n"
"higher level of abstraction. What pattern is more commonly seen in Lisp "
"programs\n"
"than a function like this:"
msgstr ""
"Повторяющиеся куски(образцы) кода в программе являются признаком того, что "
"они\n"
"могли быть написана на более высоком уровне абстракции. Какой кусок кода "
"чаще \n"
"всего встречается в программах на  Lisp чем подобная функция?:"

#: texi/node-05.texi:412
msgid ""
"@lisp\n"
"(defun our-length (lst)\n"
"      (if (null lst)\n"
"            0(1+ (our-length (cdr lst)))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:414
msgid "or this:"
msgstr "или такая:"

#: texi/node-05.texi:421
msgid ""
"@lisp\n"
"(defun our-every (fn lst)\n"
"      (if (null lst)\n"
"            t(and (funcall fn (car lst))\n"
"                 (our-every fn (cdr lst)))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:424
msgid ""
"Structurally these two functions have a lot in common. They both operate "
"recur-\n"
"sively on successive cdrs of a list, evaluating the same expression on each "
"step,"
msgstr ""
"Конструктивно эти две функции имеют много общего. Они обе работают "
"рекурсивно\n"
"поочередно на последовательных cdrs списка, вычисляя одно и то же выражение "
"на \n"
"каждом шаге,"

#: texi/node-05.texi:437
msgid ""
"@lisp\n"
" (defun lrec (rec &optional base)\n"
"       (labels ((self (lst)\n"
"                      (if (null lst)\n"
"                            (if (functionp base)\n"
"                                   (funcall base)\n"
"                                   base)\n"
"                            (funcall rec (car lst)\n"
"                                                 #'(lambda ()\n"
"                                                        (self (cdr "
"lst)))))))\n"
"          #'self))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun lrec (rec &optional base)\n"
"       (labels ((self (lst)\n"
"                      (if (null lst)\n"
"                            (if (functionp base)\n"
"                                   (funcall base)\n"
"                                   base)\n"
"                            (funcall rec (car lst)\n"
"                                                 #'(lambda ()\n"
"                                                        (self (cdr "
"lst)))))))\n"
"          #'self))\n"
"@end lisp"

#: texi/node-05.texi:439
msgid "                   Figure 5-5: Function to define flat list recursers."
msgstr ""
"                   Рисунок 5-5: Функция для определения рекурсивных функций "
"для плоских списков.\n"
"@end cartouche"

#: texi/node-05.texi:445
msgid ""
"except in the base case, where they return a distinct value. This pattern "
"appears\n"
"so frequently in Lisp programs that experienced programmers can read and "
"repro-\n"
"duce it without stopping to think. Indeed, the lesson is so quickly learned, "
"that\n"
"the question of how to package the pattern in a new abstraction does not "
"arise."
msgstr ""
"исключая базовый случай, когда они возвращают различные значения. Эта "
"картина появляется\n"
"так часто в программах на Лиспе, что опытные программисты могут читать и "
"воспроизводить,\n"
"не переставая думать. Действительно, урок настолько быстро усваивается, что\n"
"вопрос о том, как упаковать шаблон в новую абстракцию, не возникает."

#: texi/node-05.texi:450
msgid ""
"However, a pattern it is, all the same. Instead of writing these functions "
"out\n"
"by hand, we should be able to write a function which will generate them for "
"us.\n"
"Figure 5-5 contains a function-builder called lrec (\"list recurser\") which "
"should\n"
"be able to generate most functions that recurse on successive cdrs of a list."
msgstr ""
"Впрочем, это все таки, образец(шаблон/закономерность). И вместо того, чтобы "
"писать \n"
"эти функции вручную мы можем написать функцию, которая будет генерировать их "
"для нас.\n"
"Рисунок 5-5 содержит построитель функций с именем lrec (\"list recurser\"), "
"который \n"
"должен быть в состоянии сгенерировать большинство функций, которые "
"используются на последовательных окончаниях(cdrs) списка."

#: texi/node-05.texi:454
msgid ""
"The first argument to lrec must be a function of two arguments: the current\n"
"car of the list, and a function which can be called to continue the "
"recursion. Using\n"
"lrec we could express our-length as:"
msgstr ""
"Первый аргумент для lrec должен быть функцией двух аргументов: текущее\n"
"начало(car) списка и функция, которая может быть вызвана для продолжения \n"
"рекурсии. Используя lrec мы могли бы выразить our-length как:"

#: texi/node-05.texi:458
msgid ""
"@lisp\n"
"(lrec #'(lambda (x f) (1+ (funcall f))) 0)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:463
msgid ""
"To find the length of the list, we don't need to look at the elements, or "
"stop part-\n"
"way, so the object x is always ignored, and the function f always called. "
"However,\n"
"we need to take advantage of both possibilities to express our-every, for e."
"g.\n"
"oddp:@footnote{In one widely used Common Lisp, functionp erroneously returns "
"true for t and nil. In that implementation it won't work to give either as "
"the second argument to lrec.}"
msgstr ""
"Чтобы найти длину списка, нам не нужно смотреть на элементы или на часть "
"останавливающую рекурсию. Кстати, объект x всегда игнорируется, а функция f "
"всегда вызывается. Тем не мение,\n"
"нам нужно воспользоваться обеими параметрами, чтобы выразить нашу функцию "
"our-every, \n"
"например oddp:@footnote{В одном широко используемом Common Lisp, функция "
"ошибочно\n"
"возвращает истину для t и nil. В этой реализации он не будет работать в "
"качестве второго\n"
"аргумента для lrec.}"

#: texi/node-05.texi:467
msgid ""
"@lisp\n"
"(lrec #'(lambda (x f) (and (oddp x) (funcall f))) t)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:473
msgid ""
"The definition of lrec uses labels to build a local recursive function "
"called\n"
"self. In the recursive case the function rec is passed two arguments, the "
"current\n"
"car of the list, and a function embodying the recursive call. In functions "
"like\n"
"our-every, where the recursive case is an and, if the first argument returns "
"false\n"
"we want to stop right there. Which means that the argument passed in the "
"recursive"
msgstr ""
"Определение lrec использует labels для построения локальной рекурсивной "
"функции под названием self. В рекурсивый вариант функции rec передаются два "
"аргумента, текущий\n"
"car списка, и функция, воплощающая рекурсивный вызов. На функции, такой как\n"
"our-every, где рекурсивный случай представляет собой and, если первый "
"аргумент \n"
"возвращает false мы хотим остановиться прямо здесь. Это означает, что "
"аргумент \n"
"передается в рекурсивном случае, должен быть не значением, а функцией, "
"которую \n"
"мы могли бы вызвать(если хотим), чтобы получить значение.\n"

#: texi/node-05.texi:477
msgid ""
"@lisp\n"
" ; copy-list\n"
" (lrec #'(lambda (x f) (cons x (funcall f))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" ; copy-list\n"
" (lrec #'(lambda (x f) (cons x (funcall f))))"

#: texi/node-05.texi:480
msgid ""
" ; remove-duplicates\n"
" (lrec #'(lambda (x f) (adjoin x (funcall f))))"
msgstr ""

#: texi/node-05.texi:483
msgid ""
" ; find-if, for some function fn\n"
" (lrec #'(lambda (x f) (if (fn x) x (funcall f))))"
msgstr ""

#: texi/node-05.texi:487
msgid ""
" ; some, for some function fn\n"
" (lrec #'(lambda (x f) (or (fn x) (funcall f))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:489
msgid "                        Figure 5-6: Functions expressed with lrec."
msgstr ""
"                        Рисунок 5-6: Функции выраженные с помощью lrec.\n"
"@end cartouche"

#: texi/node-05.texi:493
msgid ""
"case must not be a value but a function, which we can call (if we want) in "
"order to\n"
"get a value."
msgstr ""

#: texi/node-05.texi:502
msgid ""
"Figure 5-6 shows some existing Common Lisp functions defined with\n"
"lrec.@footnote{In some implementations, you may have to set\n"
"*print-circle* to t before these functions can be displayed.}  Calling\n"
"lrec will not always yield the most efficient implementation of a\n"
"given function. Indeed, lrec and the other recurser generators to be\n"
"defined in this chapter tend to lead one away from tail-recursive\n"
"solutions. For this reason they are best suited for use in initial\n"
"versions of a program, or in parts where speed is not critical."
msgstr ""
"На рисунке 5.6 показаны некоторые функции существующие в Common Lisp, \n"
"определенные с помощью lrec. @footnote{В некоторых реализациях может \n"
"потребоваться установить *print-circle* в t перед отображением этих "
"функций} \n"
"Вызов lrec не всегда дает наиболее эффективную реализацию данного\n"
"функция. Действительно, lrec и другие генераторы рекурсивных функций \n"
"определеные в этой главе, как правило, уводит нас от хвостовых рекурсивных "
"решений. \n"
"По этой причине они лучше всего подходят для использования в начальных "
"версиях \n"
"программы или в частях, где скорость не критична."

#: texi/node-05.texi:507
msgid ""
"@node 5-6 Recursion on Subtrees, 5-7 When to Build Functions, 5-5 Recursion "
"on Cdrs, 5 Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-6 Recursion on Subtrees\n"
"@cindex 5-6 Recursion on Subtrees"
msgstr ""
"@node 5-6 Recursion on Subtrees, 5-7 When to Build Functions, 5-5 Recursion "
"on Cdrs, 5 Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-6 Рекурсия на под деревьях(Subtrees)\n"
"@cindex 5-6 Recursion on Subtrees"

#: texi/node-05.texi:511
msgid ""
"There is another recursive pattern commonly found in Lisp programs: "
"recursion\n"
"on subtrees. This pattern is seen in cases where you begin with a possibly "
"nested\n"
"list, and want to recurse down both its car and its cdr."
msgstr ""
"Существует еще один рекурсивный шаблон, обычно встречающийся в программах на "
"Лиспе: рекурсия\n"
"на поддеревьях. Эта картина наблюдается в тех случаях, когда вы начинаете с "
"возможно вложенного списка, и вам надо спуститься в его начало(car) и его "
"окончание(CDR)."

#: texi/node-05.texi:519
msgid ""
"The Lisp list is a versatile structure. Lists can represent, among other "
"things,\n"
"sequences, sets, mappings, arrays, and trees. There are several different "
"ways to\n"
"interpret a list as a tree. The most common is to regard the list as a "
"binary tree\n"
"whose left branch is the car and whose right branch is the cdr. (In fact, "
"this is\n"
"usually the internal representation of lists.) Figure 5-7 shows three "
"examples of\n"
"lists and the trees they represent. Each internal node in such a tree "
"corresponds\n"
"to a dot in the dotted-pair representation of the list, so the tree "
"structure may be"
msgstr ""
"Список Lisp - это универсальная структура. Списки могут представлять, помимо "
"прочего,\n"
"последовательности, множества, отображения, массивы и деревья. Есть "
"несколько разных способов интерпретировать список как дерево. Наиболее "
"распространенным является рассматривать список как двоичное дерево, чья "
"левая ветвь - car, и чья правая ветвь \n"
"- cdr. (На самом деле это обычно внутреннее представление списков.) На "
"рисунке 5-7 показаны три примера списков и деревья, которые они "
"представляют. Каждый внутренний узел в таком дереве соответствует точке в "
"представлении списка парой с точкой(a.b), поэтому древовидная структура "
"может быть"

#: texi/node-05.texi:523
msgid ""
"@lisp\n"
"       (a.b)                   (abc)                             (ab(cd))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"       (a.b)                   (abc)                             (ab(cd))\n"
"@end lisp"

#: texi/node-05.texi:525
msgid "                              Figure 5-7: Lists as trees."
msgstr ""
"                              Рисунок 5-7: Списки как деревья.\n"
"@end cartouche"

#: texi/node-05.texi:528
msgid "easier to interpret if the lists are considered in that form:"
msgstr "легче интерпретировать, если списки представлять в такой форме:"

#: texi/node-05.texi:533
msgid ""
"@lisp\n"
"       (a b c)           = (a . (b . (c . nil)))\n"
"       (a b (c d)) = (a . (b . ((c . (d . nil)) . nil)))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:538
msgid ""
"Any list can be interpreted as a binary tree. Hence the distinction between "
"pairs\n"
"of Common Lisp functions like copy-list and copy-tree. The former copies\n"
"a list as a sequence-if the list contains sublists, the sublists, being mere "
"elements\n"
"in the sequence, are not copied:"
msgstr ""
"Любой список можно интерпретировать как двоичное дерево. Отсюда и различие "
"между\n"
"парой функций из Common Lisp, таких как copy-list и copy-tree. Первый "
"копирует\n"
"список как последовательность, т.е если список содержит подсписки, которые \n"
"являют простыми элементами в последовательности, то они не копируются:"

#: texi/node-05.texi:546
msgid ""
"@example\n"
"> (setq x          '(a b)\n"
"           listx (list x 1))\n"
"((A B) 1)\n"
"> (eq x (car (copy-list listx)))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-05.texi:549
msgid ""
"In contrast, copy-tree copies a list as a tree-sublists are subtrees, and so "
"must\n"
"also be copied:"
msgstr ""
"Напротив, copy-tree копирует список как дерево подсписков, поскольку "
"подсписки дерева являются поддеревьями, и поэтому должны быть также "
"скопированными:"

#: texi/node-05.texi:554
msgid ""
"@example\n"
"> (eq x (car (copy-tree listx)))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-05.texi:556
msgid "We could define a version of copy-tree as follows:"
msgstr "Мы могли бы определить версию  copy-tree следующим образом:"

#: texi/node-05.texi:564
msgid ""
"@lisp\n"
"(defun our-copy-tree (tree)\n"
"      (if (atom tree)\n"
"          tree\n"
"          (cons (our-copy-tree (car tree))\n"
"                  (if (cdr tree) (our-copy-tree (cdr tree))))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:568
msgid ""
"This definition turns out to be one instance of a common pattern. (Some of "
"the\n"
"following functions are written a little oddly in order to make the pattern "
"obvious.)\n"
"Consider for example a utility to count the number of leaves in a tree:"
msgstr ""
"Это определение оказывается одним из примеров общего паттерна. (Некоторые "
"из\n"
"следующие функции написаны немного странно, чтобы сделать шаблон "
"очевидным.)\n"
"Рассмотрим, например, утилиту для подсчета количества листьев в дереве:"

#: texi/node-05.texi:576
msgid ""
"@lisp\n"
"(defun count-leaves (tree)\n"
"      (if (atom tree)\n"
"          1(+ (count-leaves (car tree))\n"
"             (or (if (cdr tree) (count-leaves (cdr tree)))\n"
"                   1))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:578
msgid ""
"A tree has more leaves than the atoms you can see when it is represented as "
"a list:"
msgstr ""
"Дерево имеет больше листьев, чем атомов, что вы можете видеть, когда оно "
"представлено в виде списка:"

#: texi/node-05.texi:583
msgid ""
"@example\n"
"> (count-leaves '((a b (c d)) (e) f))\n"
"10\n"
"@end example"
msgstr ""

#: texi/node-05.texi:588
msgid ""
"The leaves of a tree are all the atoms you can see when you look at the tree "
"in\n"
"its dotted-pair representation. In dotted-pair notation, ((a b (c d)) (e) "
"f)\n"
"would have four nils that aren't visible in the list representation (one for "
"each\n"
"pair of parentheses) so count-leaves returns 10."
msgstr ""
"Листья дерева - это все атомы, которые вы можете видеть, когда вы смотрите "
"на дерево в\n"
"его представлении в виде пар с точкой. В записи в виде пар с точкой список\n"
" ((a b (c d)) (e) f) будет иметь четыре nils, которые не видны при "
"представлении \n"
"в виде списка (по одному для каждой пары круглых скобок), поэтому count-"
"leaf \n"
"возвращает 10."

#: texi/node-05.texi:593
msgid ""
"In the last chapter we defined several utilities which operate on trees. "
"For\n"
"example, flatten (page 47) takes a tree and returns a list of all the atoms "
"in it.\n"
"That is, if you give flatten a nested list, you'll get back a list that "
"looks the same\n"
"except that it's missing all but the outermost pair of parentheses:"
msgstr ""
"В последней главе мы определили несколько утилит, которые работают на "
"деревьях. \n"
"Например, flatten (стр. 47) берет дерево и возвращает список всех атомов в "
"нем.\n"
"То есть, если вы укажете вложенный список, вы получите  назад список, "
"который выглядит \n"
"так же за исключением того, что в нём отсутствуют скобки, кроме внешней пары "
"скобок:"

#: texi/node-05.texi:598
msgid ""
"@example\n"
"> (flatten '((a b (c d)) (e) f ()))\n"
"(ABCDEF)\n"
"@end example"
msgstr ""

#: texi/node-05.texi:600
msgid ""
"This function could also be defined (somewhat inefficiently) as follows:"
msgstr ""
"Эта функция также может быть определена (несколько неэффективно) следующим "
"образом:"

#: texi/node-05.texi:608
msgid ""
"@lisp\n"
"(defun flatten (tree)\n"
"      (if (atom tree)\n"
"          (mklist tree)\n"
"          (nconc (flatten (car tree))\n"
"                   (if (cdr tree) (flatten (cdr tree))))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:611
msgid ""
"Finally, consider rfind-if, a recursive version of find-if which works on\n"
"trees as well as flat lists:"
msgstr ""
"Наконец, рассмотрим rfind-if, рекурсивную версию find-i, которая работает\n"
"на деревьях, а также на плоских списках:"

#: texi/node-05.texi:619
msgid ""
"@lisp\n"
"(defun rfind-if (fn tree)\n"
"     (if (atom tree)\n"
"           (and (funcall fn tree) tree)\n"
"           (or (rfind-if fn (car tree))\n"
"                 (if (cdr tree) (rfind-if fn (cdr tree))))))\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:624
msgid ""
"To generalize find-if for trees, we have to decide whether we want to "
"search\n"
"for just leaves, or for whole subtrees. Our rfind-if takes the former "
"approach,  \n"
"so the caller can assume that the function given as the first argument will "
"only be\n"
"called on atoms:"
msgstr ""
"Чтобы обобщить find-if для деревьев, мы должны решить, хотим ли мы искать "
"только\n"
"для листьев, или еще для поддеревьев. Наш метод rfind-if использует первый "
"подход,\n"
"поэтому вызывающая сторона может предположить, что функция, указанная в "
"качестве \n"
"первого аргумента, будет вызываться для атомов:"

#: texi/node-05.texi:629
msgid ""
"@example\n"
"> (rfind-if (fint #'numberp #'oddp) '(2 (3 4) 5))\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-05.texi:635
msgid ""
"How similar in form are these four functions, copy-tree, count-leaves,\n"
"flatten, and rfind-if. Indeed, they're all instances of an archetypal "
"function\n"
"for recursion on subtrees. As with recursion on cdrs, we need not leave "
"this\n"
"archetype to float vaguely in the background-we can write a function to "
"generate\n"
"instances of it."
msgstr ""
"Сейчас можно видеть насколько похожи эти четыре функции, copy-tree, count-"
"leaves,\n"
"flatten, и rfind-if. Действительно, все они являются примерами "
"архетипической \n"
"функции для рекурсии на поддеревьях. Как и в случае рекурсии на cdrs(плоских "
"списках),\n"
"нам не нужно предоставлять этот архетип, который может быть неопределенно "
"изменчивым,\n"
"мы можем написать функцию для генерации экземпляров рекурсивных функций для "
"него."

#: texi/node-05.texi:638
msgid ""
"To get at the archetype itself, let's look at these functions and see what's "
"not\n"
"pattern. Essentially our-copy-tree is two facts:"
msgstr ""
"Чтобы получить сам архетип, давайте посмотрим на эти функции и увидим что не "
"входит\n"
"шаблоном. По сути  our-copy-tree это два факта:"

#: texi/node-05.texi:646
msgid ""
"@enumerate\n"
"@item\n"
"In the base case it returns its argument.\n"
"@item\n"
"In the recursive case, it applies cons to the recursions down the left \n"
"(car) and right (cdr) subtrees.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"В базовом случае она возвращает свой аргумент.\n"
"@item\n"
"В рекурсивном случае, она применяет cons к рекурсиям нижних поддеревьев "
"левого(car) \n"
"и правого (cdr).\n"
"@end enumerate"

#: texi/node-05.texi:648
msgid ""
"We should thus be able to express it as a call to a builder with two "
"arguments:"
msgstr ""
"Таким образом, мы должны иметь возможность выразить это как вызвов "
"построителя\n"
"с двумя аргументами:"

#: texi/node-05.texi:652
msgid ""
"@lisp\n"
"(ttrav #'cons #'identity)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:658
msgid ""
"A definition of ttrav (\"tree traverser\") is shown in Figure 5-8. Instead "
"of\n"
"passing one value in the recursive case, we pass two, one for the left "
"subtree and\n"
"one for the right. If the base argument is a function it will be called on "
"the current\n"
"leaf. In flat list recursion, the base case is always nil, but in tree "
"recursion the\n"
"base case could be an interesting value, and we might want to use it."
msgstr ""
"Определение ttrav (\"обходчик деревьев(tree traverser)\") показано на "
"рисунке 5-8. Вместо\n"
"перечачи одного значения в рекурсивном случае, мы передаем два, одно для "
"левого поддерева\n"
"и одно для правого. Если базовый аргумент является функцией, она будет "
"вызвана для текущего\n"
"листа. В рекурсии на плоском списке, базовый случай всегда nil, но рекурсии "
"по дереву базовый\n"
"случай может быть интересным значением, и мы можем захотеть его использовать."

#: texi/node-05.texi:666
msgid ""
"With ttrav we could express all the preceding functions except rfind-if.\n"
"(They are shown in Figure 5-9.) To define rfind-if we need a more general "
"tree\n"
"recursion builder which gives us control over when, and if, the recursive "
"calls are\n"
"made. As the first argument to ttrav we gave a function which took the "
"results of\n"
"the recursive calls. For the general case, we want to use instead a function "
"which\n"
"takes two closures representing the calls themselves. Then we can write "
"recursers\n"
"which only traverse as much of the tree as they want to."
msgstr ""
"С помощью ttrav мы можем выразить все предыдущие функции, кроме rfind-if.\n"
"(Они показаны на рисунке 5-9.) Чтобы определить rfind-if нам нужен более "
"общий\n"
"конструктор рекурсии по дереву, который даст нам контроль когда, и если, "
"делать\n"
"рекурсивные вызовы. В качестве первого аргумента ttrav мы дали функцию, "
"которая\n"
"берет результаты рекусивных вызовов. В общем случае, мы хотим использовать "
"вместо\n"
"этого функцию, которая принимает два замыкания, представляющие сами "
"вызовы. \n"
"Тогда мы сможем написать рекурсеры, которые проходят по стольким деревьям, "
"сколько им\n"
"будет надо."

#: texi/node-05.texi:679
msgid ""
"@lisp\n"
" (defun ttrav (rec &optional (base #'identity))\n"
"      (labels ((self (tree)\n"
"                     (if (atom tree)\n"
"                          (if (functionp base)\n"
"                                (funcall base tree)\n"
"                                base)\n"
"                          (funcall rec (self (car tree))\n"
"                                            (if (cdr tree)\n"
"                                                  (self (cdr tree)))))))\n"
"         #'self))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun ttrav (rec &optional (base #'identity))\n"
"      (labels ((self (tree)\n"
"                     (if (atom tree)\n"
"                          (if (functionp base)\n"
"                                (funcall base tree)\n"
"                                base)\n"
"                          (funcall rec (self (car tree))\n"
"                                            (if (cdr tree)\n"
"                                                  (self (cdr tree)))))))\n"
"         #'self))\n"
"@end lisp"

#: texi/node-05.texi:681
msgid "                     Figure 5-8: Function for recursion on trees."
msgstr ""
"                     Рисунок 5-8: Функция для рекурсии на деревьях.\n"
"@end cartouche"

#: texi/node-05.texi:686
msgid ""
"@lisp\n"
" ; our-copy-tree\n"
" (ttrav #'cons)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" ; our-copy-tree\n"
" (ttrav #'cons)"

#: texi/node-05.texi:689
msgid ""
" ; count-leaves\n"
" (ttrav #'(lambda (l r) (+ l (or r 1))) 1)"
msgstr ""

#: texi/node-05.texi:693
msgid ""
" ; flatten\n"
" (ttrav #'nconc #'mklist)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:695
msgid "                     Figure 5-9: Functions expressed with ttrav."
msgstr ""
"                     Рисунок 5-9: Функции выраженные с помощью ttrav.\n"
"@end cartouche"

#: texi/node-05.texi:703
msgid ""
"Functions built by ttrav always traverse a whole tree. That's fine for "
"functions\n"
"like count-leaves or flatten, which have to traverse the whole tree anyway.\n"
"But we want rfind-if to stop searching as soon as it finds what it's looking "
"for.\n"
"It must be built by the more general trec, shown in Figure 5-10. The second "
"arg\n"
"to trec should be a function of three arguments: the current object and the "
"two\n"
"recursers. The latter two will be closures representing the recursions down "
"the\n"
"left and right subtrees. With trec we would define flatten as:"
msgstr ""
"Функции, построенные  ttrav всегда проходят по всему дереву. Это хорошо "
"для \n"
"функций подобных подсчету листьев(count-leaves) или flatten(создающих "
"плоский \n"
"список), которые все равно должны проходить по всему дереву.\n"
"Но мы хотим, чтобы rfind-if останавливало поиск, как только она найдет то, "
"что\n"
"ищет. Она должна быть построена по более общей схеме, показанной на рисунке "
"5-10. \n"
"Второй аргумент trec должен быть функцией трех аргументов: текущего объектиа "
"и\n"
"двух рекурсеров. Последние два будут замыканиями, представляющими рекурсии "
"по\n"
"левому и правому поддервьям. С помощью  trec мы можем определить flatten как:"

#: texi/node-05.texi:708
msgid ""
"@lisp\n"
"(trec #'(lambda (o l r) (nconc (funcall l) (funcall r)))\n"
"          #'mklist)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:710
msgid "Now we can also express rfind-if for e.g. oddp as:"
msgstr "Теперь мы можем так же выразить rfind-if например для oddp как:"

#: texi/node-05.texi:714
msgid ""
"@lisp\n"
"(trec #'(lambda (o l r) (or (funcall l) (funcall r)))\n"
"          #'(lambda (tree) (and (oddp tree) tree)))"
msgstr ""
"@lisp\n"
"(trec #'(lambda (o l r) (or (funcall l) (funcall r)))\n"
"          #'(lambda (tree) (and (oddp tree) tree)))\n"
"@end lisp"

#: texi/node-05.texi:731
msgid ""
" (defun trec (rec &optional (base #'identity))\n"
"       (labels\n"
"         ((self (tree)\n"
"             (if (atom tree)\n"
"                   (if (functionp base)\n"
"                        (funcall base tree)\n"
"                        base)\n"
"                   (funcall rec tree\n"
"                                     #'(lambda ()\n"
"                                         (self (car tree)))\n"
"                                     #'(lambda ()\n"
"                                         (if (cdr tree)\n"
"                                              (self (cdr tree))))))))\n"
"         #'self))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun trec (rec &optional (base #'identity))\n"
"       (labels\n"
"         ((self (tree)\n"
"             (if (atom tree)\n"
"                   (if (functionp base)\n"
"                        (funcall base tree)\n"
"                        base)\n"
"                   (funcall rec tree\n"
"                                     #'(lambda ()\n"
"                                         (self (car tree)))\n"
"                                     #'(lambda ()\n"
"                                         (if (cdr tree)\n"
"                                              (self (cdr tree))))))))\n"
"         #'self))\n"
"@end lisp"

#: texi/node-05.texi:733
msgid "                     Figure 5-10: Function for recursion on trees."
msgstr ""
"                     Рисунок 5-10: Функция для рекурсии по деревьям.\n"
"@end cartouche"

#: texi/node-05.texi:738
msgid ""
"@node 5-7 When to Build Functions,  , 5-6 Recursion on Subtrees, 5 Returning "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-7 When to Build Functions\n"
"@cindex 5-7 When to Build Functions"
msgstr ""
"@node 5-7 When to Build Functions,  , 5-6 Recursion on Subtrees, 5 Returning "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 5-7 Когда создавать функции\n"
"@cindex 5-7 When to Build Functions"

#: texi/node-05.texi:748
msgid ""
"Expressing functions by calls to constructors instead of sharp-quoted "
"lambda-\n"
"expressions could, unfortunately, entail unnecessary work at runtime. A "
"sharp-\n"
"quoted lambda-expression is a constant, but a call to a constructor function "
"will be\n"
"evaluated at runtime. If we really have to make this call at runtime, it "
"might not\n"
"be worth using constructor functions. However, at least some of the time we "
"can\n"
"call the constructor beforehand. By using #., the sharp-dot read macro, we "
"can\n"
"have the new functions built at read-time. So long as compose and its "
"arguments\n"
"are defined when this expression is read, we could say, for example,"
msgstr ""
"Выражение функций через вызовы конструкторов вместо шарп-квотированных('#) "
"лямбда\n"
"выражений, к сожалению, может повлечь за собой ненужную работу во время "
"выполнения.\n"
"шарп-квотированные лямбда выражения являются константами, но вызов функции "
"конструктора\n"
"будет вычисляться во время выполнения программы. Если нам действительно "
"нужно сделать\n"
"этот вызов во время выполнения, он может не стоить выполнения функции "
"конструктора. \n"
"Тем не менее, по крайней мере, иногда, мы можем вызвать конструктор "
"заранее. \n"
"Используя макрос чтения: #.(знак решетку совместно со знаком точка), мы "
"можем \n"
"создавать новые функции построенные во время ЧТЕНИЯ программы.  Например, мы "
"можем\n"
"сказать, что пока читается это выражение определяются compose и ее аргументы:"

#: texi/node-05.texi:752
msgid ""
"@lisp\n"
"(find-if #.(compose #'oddp #'truncate) lst)\n"
"@end lisp"
msgstr ""

#: texi/node-05.texi:757
msgid ""
"Then the call to compose would be evaluated by the reader, and the "
"resulting\n"
"function inserted as a constant into our code. Since both oddp and truncate "
"are\n"
"built-in, it would safe to assume that we can evaluate the compose at read-"
"time,\n"
"so long as compose itself were already loaded."
msgstr ""
"Тогда вызов compose будет вычислен читателем, и результирующая функция будет "
"вставлена\n"
"как константа(постоянная) в наш код. Поскольку обе функции oddp и truncate "
"являются\n"
"встроенными, можно с уверенностью предположить, что мы можем вычислить "
"compose во\n"
"время чтения, до тех пор, пока compose уже будет загружена."

#: texi/node-05.texi:762
msgid ""
"In general, composing and combining functions is more easily and "
"efficiently\n"
"done with macros. This is particularly true in Common Lisp, with its "
"separate\n"
"name-space for functions. After introducing macros, we will in Chapter 15 "
"cover\n"
"much of the ground we covered here, but in a more luxurious vehicle."
msgstr ""
"В вобщем, составление и объединени функций проще и эффективнее сделать "
"макросами.\n"
"Это особенно верно в Common Lisp, с его отдельным пространством имен для "
"функций.\n"
"После введения макросов, мы рассмотрим в главе 15 большую часть описанного "
"здесь\n"
"материала, но с использоавнием более роскошных инструментов."
