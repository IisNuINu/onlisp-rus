#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-12.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-05-16 12:17+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-12.texi:5
msgid ""
"@node 12 Generalized Variables, 13 Computation at Compile-Time, 11 Classic "
"Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 12 Generalized Variables\n"
"@cindex 12 Generalized Variables"
msgstr ""
"@node 12 Generalized Variables, 13 Computation at Compile-Time, 11 Classic "
"Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 12 Обобщенные переменные\n"
"@cindex 12 Generalized Variables"

#: texi/node-12.texi:10
msgid ""
"Chapter 8 mentioned that one of the advantages of macros is their ability "
"to\n"
"transform their arguments. One macro of this sort is setf. This chapter "
"looks at\n"
"the implications of setf, and then shows some examples of macros which can "
"be\n"
"built upon it."
msgstr ""
"В главеr 8 упоминалось, что одним из преимуществ макросов является их "
"способность\n"
"преобразовывать свои аргументы. Одним из макросов такого рода является setf. "
"Эта\n"
"глава рассматривает смысл(подтекст) setf, и затем показывает некотоыре "
"примеры\n"
"макросов, которые могут быть построены на подобном принципе."

#: texi/node-12.texi:23
msgid ""
"Writing correct macros on setf is surprisingly difficult. To introduce the\n"
"topic, the first section will provide a simple example which is slightly "
"incorrect.\n"
"The next section will explain what's wrong with this macro, and show how to "
"fix\n"
"it. The third and fourth sections present examples of utilities built on "
"setf, and\n"
"the final section explains how to define your own setf inversions.\n"
"@menu\n"
"* 12-1 The Concept::            \n"
"* 12-2 The Multiple Evaluation Problem::  \n"
"* 12-3 New Utilities::          \n"
"* 12-4 More Complex Utilities::  \n"
"* 12-5 Defining Inversions::    \n"
"@end menu"
msgstr ""
"Написание правильных макросов на setf удивительно сложно. Чтобы вникнуть в "
"тему,\n"
"в первом разделе приведен простой пример, который немного неверен. В "
"следующем\n"
"разделе объясняется, что не так с этим макросом, и показывается как "
"исправить это.\n"
"В третьем и четвертом разделах представлены примеры утилит, основанных на "
"setf, и\n"
"в последнем разделе объясняется как определить ваши собственные инверсии "
"setf.\n"
"@menu\n"
"* 12-1 The Concept::            \n"
"* 12-2 The Multiple Evaluation Problem::  \n"
"* 12-3 New Utilities::          \n"
"* 12-4 More Complex Utilities::  \n"
"* 12-5 Defining Inversions::    \n"
"@end menu"

#: texi/node-12.texi:28
msgid ""
"@node 12-1 The Concept, 12-2 The Multiple Evaluation Problem, 12 Generalized "
"Variables, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-1 The Concept\n"
"@cindex 12-1 The Concept"
msgstr ""
"@node 12-1 The Concept, 12-2 The Multiple Evaluation Problem, 12 Generalized "
"Variables, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-1 Концепция(Идея)\n"
"@cindex 12-1 The Concept"

#: texi/node-12.texi:31
msgid ""
"The built-in macro setf is a generalization of setq. The first argument to "
"setf\n"
"can be a call instead of just a variable:"
msgstr ""
"Встроенный макрос setf является обобщением setq. Первый аргумент для setf "
"может\n"
"быть вызовом, представляющим собой запрос на определение значения переменной "
"в \n"
"некоторой структуре данных(например в списке), а не простой переменной:"

#: texi/node-12.texi:40
msgid ""
"@example\n"
"> (setq lst '(a b c))\n"
"(ABC)\n"
"> (setf (car lst) 480)\n"
"480\n"
"> lst\n"
"(480 B C)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:47
msgid ""
"In general (setf xy) can be understood as saying \"see to it that x "
"evaluates to\n"
"y.\" As a macro, setf can look inside its arguments to see what needs to be "
"done\n"
"to make such a statement true. If the first argument (after macroexpansion) "
"is a\n"
"symbol, the setf just expands into a setq. But if the first argument is a "
"query,\n"
"the setf expands into the corresponding assertion. Since the second argument "
"is\n"
"a constant, the preceding example could expand into:"
msgstr ""
"В общем (setf x y) можно понимать как высказывание \"смотри чтобы этот x "
"имел значение\n"
"равное y.\" Как макрос setf может заглянуть внутрь своих аргументов, чтобы "
"увидеть,\n"
"что нужно сделать, чтобы сделать это утверждение правдой. Если первый "
"аргумент\n"
"(после расширения макроса) является символом, setf просто расширяется в "
"setq. Но если\n"
"аргумент является запросом, setf расширяется в соответствующее утверждение.  "
"Поскольку\n"
"второй аргумент это константа, предыдущий пример может расшириться до:"

#: texi/node-12.texi:51
msgid ""
"@lisp\n"
"(progn (rplaca lst 480) 480)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:56
msgid ""
"This transformation from query to assertion is called inversion. All the "
"most\n"
"frequently used Common Lisp access functions have predefined inversions, "
"in-\n"
"cluding car, cdr, nth, aref, get, gethash, and the access functions created "
"by\n"
"defstruct. (The full list is in CLTL2, p. 125.)"
msgstr ""
"Это преобразование из запроса в утверждение называется инверсией. Все самые\n"
"часто используемые функции доступа Common Lisp имеют предопределенные "
"инверсии,\n"
"включаяя car, cdr, nth, aref, get, gethash, и функции доступа, созданные \n"
"defstruct. (Полный список приведен в CLTL2, стр. 125.)"

#: texi/node-12.texi:61
msgid ""
"An expression which can serve as the first argument to setf is called a\n"
"generalized variable. Generalized variables have turned out to be a "
"powerful\n"
"abstraction. A macro call resembles a generalized variable in that any macro "
"call\n"
"which expands into an invertible reference will itself be invertible."
msgstr ""
"Выражение, которое может служить первым аргументом для setf называется\n"
"обобщенной переменной. Обобщенные переменные оказались мощной абстракцией. \n"
"Вызов макроса напоминает обобщенную переменную тем, что любой вызов "
"макроса,\n"
"который расширяется в обратимую ссылку, сам будет обратимым."

#: texi/node-12.texi:65
msgid ""
"When we also write our own macros on top of setf, the combination leads to\n"
"noticeably cleaner programs. One of the macros we can define on top of setf "
"is\n"
"toggle,@footnote{This definition is not correct, as the following section "
"will explain.}"
msgstr ""
"Когда мы также пишем наши собственные макросы поверх setf, эта комбинация "
"приводит к\n"
"заметному улучшению ясности программы. Одним из макросов, которые мы можем "
"определить\n"
"поверх setf является toggle(переключатель),@footnote{Это определение не "
"является\n"
"правильным, почему объясняется в следующем разделе.}"

#: texi/node-12.texi:70
msgid ""
"@lisp\n"
"(defmacro toggle "
"(obj)                                                       ; wrong\n"
"  `(setf ,obj (not ,obj)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:73
msgid ""
"@noindent\n"
"which toggles the value of a generalized variable:"
msgstr ""
"@noindent\n"
"который переключает (логическое) значение обобщенной переменной:"

#: texi/node-12.texi:80
msgid ""
"@example\n"
"> (let ((lst '(a b c)))\n"
"        (toggle (car lst))\n"
"        lst)\n"
"(NIL B C)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:85
msgid ""
"Now consider the following sample application. Suppose someone-a soap-\n"
"opera writer, energetic busybody, or party official-wants to maintain a "
"database\n"
"of all the relations between the inhabitants of a small town. Among the "
"tables\n"
"required is one which records people's friends:"
msgstr ""
"Теперь рассмотрим следующий пример приложения. Предположим, кто-то - "
"писатель мыльных\n"
"опер, энергичный занятый человек, или партийный чиновник - хочет вести базу "
"данных\n"
"из всех отношений между жителями небольшого города. В числе требуемых "
"таблиц, необходима\n"
"та, в которой записываются друзья людей:"

#: texi/node-12.texi:89
msgid ""
"@lisp\n"
"(defvar *friends* (make-hash-table))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:92
msgid ""
"The entries in this hash-table are themselves hash-tables, in which names "
"of\n"
"potential friends are mapped to t or nil:"
msgstr ""
"Записи в этой хеш-таблице сами являются хеш-таблицами, в которых имена "
"потенциальных\n"
"друзей отображаются в  t или nil:"

#: texi/node-12.texi:96
msgid ""
"@lisp\n"
"(setf (gethash 'mary *friends*) (make-hash-table))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:99
msgid ""
"@noindent\n"
"To make John the friend of Mary, we would say:"
msgstr ""
"@noindent\n"
"Чтобы записать John другом Mary, мы могли бы сказать:"

#: texi/node-12.texi:103
msgid ""
"@lisp\n"
"(setf (gethash 'john (gethash 'mary *friends*)) t)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:108
msgid ""
"The town is divided between two factions. As factions are wont to do, each\n"
"says \"anyone who is not with us is against us,\" so everyone in town has "
"been\n"
"compelled to join one side or the other. Thus when someone switches sides, "
"all\n"
"his friends become enemies and all his enemies become friends."
msgstr ""
"Город разделен между двумя фракциями. Как обычно делают фракции, каждая "
"говорит\n"
"\"кто не с нами, тот против нас\", поэтому все в городе вынуждены "
"присоединиться\n"
"к той или иной стороне. Таким образом, когда кто то переходит на другую "
"сторону,\n"
"все его друзья становяться врагами, а все его враги становяться друзьями."

#: texi/node-12.texi:111
msgid ""
"To toggle whether x is the friend of y using only built-in operators, we "
"have\n"
"to say:"
msgstr ""
"Чтобы переключить(toggle), что x является другом y используя только "
"встроенные операторы,\n"
"мы можем сказать:"

#: texi/node-12.texi:116
msgid ""
"@lisp\n"
"(setf (gethash x (gethash y *friends*))\n"
"           (not (gethash x (gethash y *friends*))))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:120
msgid ""
"which is a rather complicated expression, though much simpler than it would\n"
"have been without setf. If we had defined an access macro upon the database "
"as\n"
"follows:"
msgstr ""
"это довольно сложное выражение, хотя гораздо проще, чем без использования "
"setf. \n"
"Если мы определим макрос доступа к базе данных следующим образом:"

#: texi/node-12.texi:125
msgid ""
"@lisp\n"
"(defmacro friend-of (p q)\n"
"  `(gethash ,p (gethash ,q *friends*)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:129
msgid ""
"then between this macro and toggle, we would have been better equipped to "
"deal\n"
"with changes to the database. The previous update could have been expressed "
"as\n"
"simply:"
msgstr ""
"тогда с этим макросом и toggle, мы были бы лучше подготовлены к изменениям в "
"базе\n"
"данных. Предыдущее обновление могло бы быть выражено просто как:"

#: texi/node-12.texi:133
msgid ""
"@lisp\n"
"(toggle (friend-of x y))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:139
msgid ""
"Generalized variables are like a health food that tastes good. They yield\n"
"programs which are virtuously modular, and yet beautifully elegant. If you\n"
"provide access to your data structures through macros or invertible "
"functions,\n"
"other modules can use setf to modify your data structures without having to\n"
"know the details of their representation."
msgstr ""
"Обобщенные переменные похожи на здоровую пищу, которая имеет приятный вкус. "
"Они\n"
"дают программам виртуозную модульность, и все же элегантно красивы. Если вы\n"
"предоставляете доступ к вашим структурам данных с помощью макросов или "
"обратимых\n"
"функций, другие модули могут использовать setf для изменения ваших струкутр\n"
"данных, без необходимости знать подробности их представления."

#: texi/node-12.texi:144
msgid ""
"@node 12-2 The Multiple Evaluation Problem, 12-3 New Utilities, 12-1 The "
"Concept, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-2 The Multiple Evaluation Problem\n"
"@cindex 12-2 The Multiple Evaluation Problem"
msgstr ""
"@node 12-2 The Multiple Evaluation Problem, 12-3 New Utilities, 12-1 The "
"Concept, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-2 Проблема Многократнрых Вычислений\n"
"@cindex 12-2 The Multiple Evaluation Problem"

#: texi/node-12.texi:146
msgid ""
"The previous section warned that our initial definition of toggle was "
"incorrect:"
msgstr ""
"Предыдущий раздел предупреждал, что наше первоначальное определение toggle "
"было\n"
"неверным:"

#: texi/node-12.texi:151
msgid ""
"@lisp\n"
"(defmacro toggle (obj)                                                   ; "
"wrong\n"
"  `(setf ,obj (not ,obj)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:155
msgid ""
"It is subject to the problem described in Section 10-1, multiple evaluation. "
"Trouble\n"
"arises when its argument has side-effects. For example, if lst is a list of "
"objects,\n"
"and we write:"
msgstr ""
"Он подвержен проблеме, описанной в разделе 10-1, множественное вычисление. "
"Проблема\n"
"возникает когда его аргумент имеет побочные эффекты. Наример, если lst это "
"список\n"
"объектов мы пишем:"

#: texi/node-12.texi:159
msgid ""
"@lisp\n"
"(toggle (nth (incf i) lst))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:162
msgid ""
"then we would expect to be toggling the (i+1)th element. However, with the\n"
"current definition of toggle this call will expand into:"
msgstr ""
"тогда мы ожидаем переключения(toggling) (i+1)-го элемента. Однако, с "
"текущим\n"
"определением toggle этот вызов расширяется в:"

#: texi/node-12.texi:167
msgid ""
"@lisp\n"
"(setf (nth (incf i) lst)\n"
"           (not (nth (incf i) lst)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:170
msgid ""
"This increments i twice, and sets the (i+1)th element to the opposite of "
"the\n"
"(i+2)th element. So in this example"
msgstr ""
"Здесь i увеличивается дважды, и устанавливается (i+1)й элемент "
"противоположностью\n"
"от (i+2)го элемента. Так что в этом примере"

#: texi/node-12.texi:179
msgid ""
"@example\n"
"> (let ((lst '(t nil t))\n"
"             (i -1))\n"
"        (toggle (nth (incf i) lst))\n"
"        lst)\n"
"(T NIL T)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:182
msgid ""
"@noindent\n"
"the call to toggle seems to have no effect."
msgstr ""
"@noindent\n"
"вызов toggle, кажеться, не имеет никакого эффекта."

#: texi/node-12.texi:188
msgid ""
"It is not enough just to take the expression given as an argument to toggle\n"
"and insert it as the first argument to setf. We have to look inside the "
"expression to\n"
"see what it does: if it contains subforms, we have to break them apart and "
"evaluate\n"
"them separately, in case they have side effects. In general, this is a "
"complicated\n"
"business."
msgstr ""
"Не достаточно просто взять выражение, передаваемое в качестве аргумента "
"toggle\n"
"и вставить его как первый аргумент для setf. Мы можем заглянуть внутрь "
"выражения\n"
"и посмотреть, что оно делает: если оно содержит подчиненные формы, мы "
"должны\n"
"разбить их на части и вычислить их отдельно, в случае если они имеют "
"побочные\n"
"эффекты. В общем, это сложное дело."

#: texi/node-12.texi:194
msgid ""
"To make it easier, Common Lisp provides a macro which automatically defines\n"
"a limited class of macros on setf. This macro is called define-modify-"
"macro,\n"
"and it takes three arguments: the name of the macro, its additional "
"parameters\n"
"(after the generalized variable), and the name of the function @footnote{A "
"function name in the general sense: either 1+ or (lambda (x) (+ x 1)).} "
"which yields the\n"
"new value for the generalized variable."
msgstr ""
"Чтобы сделать это проще, Common Lisp предоставлялет макрос, который "
"автоматически\n"
"определяет ограниченный класс макросов для setf. Этот марос называется \n"
"define-modify-macro и он принимает три аргумента: имя макроса, его "
"дополнительные\n"
"параметры(после обобщенной переменной),и имя функции@footnote{Имя функции в\n"
"общем смысле: или 1+ или (lambda (x) (+ x 1)).} которая дает новое значение\n"
"для обобщенной переменной."

#: texi/node-12.texi:196
msgid "Using define-modify-macro, we could define toggle as follows:"
msgstr ""
"Используя define-modify-macro, мы можем определить toggle следующим образом:"

#: texi/node-12.texi:200
msgid ""
"@lisp\n"
"(define-modify-macro toggle () not)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:204
msgid ""
"Paraphrased, this says \"to evaluate an expression of the form (toggle "
"place),\n"
"find the location specified by place, and if the value stored there is val, "
"replace it\n"
"with the value of (not val).\" Here is the new macro used in the same "
"example:"
msgstr ""
"Перефразируя, тут говориться \"чтобы вычислить выражение формы (toggle "
"place),\n"
"найдите место, указанное в place, и если в нем храниться значение val, "
"замените\n"
"его на значение (not val).\" Здесь новый макрос используется в том же "
"самом \n"
"примере:"

#: texi/node-12.texi:213
msgid ""
"@example\n"
"> (let ((lst '(t nil t))\n"
"             (i -1))\n"
"        (toggle (nth (incf i) lst))\n"
"        lst)\n"
"(NIL NIL T)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:218
msgid ""
"This version gives the correct result, but it could be made more general. "
"Since\n"
"setf and setq can take an arbitrary number of arguments, so should toggle.\n"
"We can add this capability by defining another macro on top of the modify-"
"macro,\n"
"as in Figure 12-1."
msgstr ""
"Эта версия дает правильный результат, но его можно сделать более общим. "
"Поскольку\n"
"setf и setq могут принимать произвольное количество аргументов, то же можно "
"делать\n"
"и toggle. Мы можем добавить эту возможность, определив другой макрос поверх\n"
"modify-macro, как на рисунке 12-1."

#: texi/node-12.texi:225
msgid ""
"@lisp\n"
" (defmacro allf (val &rest args)\n"
"        (with-gensyms (gval)\n"
"         `(let ((,gval ,val))\n"
"            (setf ,@@(mapcan #'(lambda (a) (list a gval))\n"
"                                  args)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro allf (val &rest args)\n"
"        (with-gensyms (gval)\n"
"         `(let ((,gval ,val))\n"
"            (setf ,@@(mapcan #'(lambda (a) (list a gval))\n"
"                                  args)))))"

#: texi/node-12.texi:227
msgid " (defmacro nilf (&rest args) `(allf nil ,@@args))"
msgstr ""

#: texi/node-12.texi:229
msgid " (defmacro tf (&rest args) `(allf t ,@@args))"
msgstr ""

#: texi/node-12.texi:234
msgid ""
" (defmacro toggle (&rest args)\n"
"        `(progn\n"
"          ,@@(mapcar #'(lambda (a) `(toggle2 ,a))\n"
"                       args)))"
msgstr ""

#: texi/node-12.texi:237
msgid ""
" (define-modify-macro toggle2 () not)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:239
msgid "            Figure 12-1: Macros which operate on generalized variables."
msgstr ""
"            Рисунок 12-1: Макросы которые оперируют обобщенными "
"переменными.\n"
"@end cartouche"

#: texi/node-12.texi:244
msgid ""
"@node 12-3 New Utilities, 12-4 More Complex Utilities, 12-2 The Multiple "
"Evaluation Problem, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-3 New Utilities\n"
"@cindex 12-3 New Utilities"
msgstr ""
"@node 12-3 New Utilities, 12-4 More Complex Utilities, 12-2 The Multiple "
"Evaluation Problem, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-3 Новые Утилиты\n"
"@cindex 12-3 New Utilities"

#: texi/node-12.texi:247
msgid ""
"This section gives some examples of new utilities which operate on "
"generalized\n"
"variables. They must be macros in order to pass their arguments intact to "
"setf."
msgstr ""
"В этом разделе приведены некоторые примеры новых утилит, которые работают с\n"
"обобщенными переменными. Они должны быть макросами, чтобы передать свои\n"
"аргументы без изменений в setf."

#: texi/node-12.texi:252
msgid ""
"Figure 12-1 shows four new macros built upon setf. The first, allf, is for\n"
"setting a number of generalized variables to the same value. Upon it are "
"built\n"
"nilf and tf, which set their arguments to nil and t, respectively. These "
"macros\n"
"are simple, but they make a difference."
msgstr ""
"На рисуноке 12-1 показаны четыре новых макроса построенных на основе setf. "
"Первый\n"
"allf, предназначен для устновки нескольких обобщенных переменных в одно и "
"тоже\n"
"значение. На нем построены nilf и tf, которые устанавливают свои аргументы в "
"nil\n"
"и t, соответственно. Эти макросы просты, но они имеют значение."

#: texi/node-12.texi:255
msgid ""
"Like setq, setf can take multiple arguments-alternating variables and val-\n"
"ues:"
msgstr ""
"Как и setq, setf может принимать несколько аргументов - перемежающиеся "
"переменные\n"
"и значения:"

#: texi/node-12.texi:259
msgid ""
"@lisp\n"
"(setf x1y2)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:262
msgid ""
"So can these new utilities, but you can skip giving half the arguments. If "
"you want\n"
"to initialize a number of variables to nil, instead of"
msgstr ""
"Как и эти новые утилиты, но вы можете пропустить половину этих аргументов. "
"Если вы хотите,\n"
"инициализировать несколько переменых в nil, вместо"

#: texi/node-12.texi:266
msgid ""
"@lisp\n"
"(setf x nil y nil z nil)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:268
msgid "you can say just"
msgstr "вы можете просто сказать"

#: texi/node-12.texi:272
msgid ""
"@lisp\n"
"(nilf x y z)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:279
msgid ""
"@lisp\n"
" (define-modify-macro concf (obj) nconc)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define-modify-macro concf (obj) nconc)"

#: texi/node-12.texi:283
msgid ""
" (define-modify-macro conc1f (obj)\n"
"       (lambda (place obj)\n"
"          (nconc place (list obj))))"
msgstr ""

#: texi/node-12.texi:289
msgid ""
" (define-modify-macro concnew (obj &rest args)\n"
"       (lambda (place obj &rest args)\n"
"          (unless (apply #'member obj place args)\n"
"            (nconc place (list obj)))))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:291
msgid "                 Figure 12-2: List operations on generalized variables."
msgstr ""
"                 Рисунок 12-2: Списковые операции с обобщенными перменными.\n"
"@end cartouche"

#: texi/node-12.texi:295
msgid ""
"The last macro, toggle, was described in the previous section: it is like "
"nilf,\n"
"but gives each of its arguments the opposite truth value."
msgstr ""
"Последний макрос, toggle, описанный в предыдущем разделе: он похож на  "
"nilf,\n"
"но придает каждому из своих аргументов противоположное логическое значение."

#: texi/node-12.texi:301
msgid ""
"These four macros illustrate an important point about operators for "
"assignment.\n"
"Even if we only intend to use an operator on ordinary variables, it's worth "
"writing\n"
"it to expand into a setf instead of a setq. If the first argument is a "
"symbol, the\n"
"setf will expand into a setq anyway. Since we can have the generality of "
"setf\n"
"at no extra cost, it is rarely desirable to use setq in a macroexpansion."
msgstr ""
"Эти четыре макроса иллюстрируют важный момент о операторах присваивания.\n"
"Даже если мы намереваемся использовать оператор только для обычных "
"переменных,\n"
"стоит написать его расширяющимся в setf, а не в setq. Если первый аргумент \n"
"является символом setf будет расширяться в setq в любом случае. Так мы\n"
"сможем получить обобщение в setf без дополнительных затрат, и очень редко\n"
"необходимо использвать setq в расширениях макроса."

#: texi/node-12.texi:304
msgid ""
"Figure 12-2 contains three macros for destructively modifying the ends of "
"lists.\n"
"Section 3-1 mentioned that it is unsafe to rely on"
msgstr ""
"Рисунок 12-2 содержит три макроса для деструктивного изменения концов "
"списков.\n"
"В разделе 3-1 упоминается, что не безопасно полагаться на побочные эффекты"

#: texi/node-12.texi:308
msgid ""
"@lisp\n"
"(nconc x y)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:310
msgid "for side-effects, and that one must write instead"
msgstr "и что вместо этого, нужно писать"

#: texi/node-12.texi:314
msgid ""
"@lisp\n"
"(setq x (nconc x y))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:319
msgid ""
"This idiom is embodied in concf. The more specialized conc1f and concnew\n"
"are like push and pushnew for the other end of the list: conc1f adds one "
"element\n"
"to the end of a list, and concnew does the same, but only if the element is "
"not\n"
"already a member."
msgstr ""
"Эта идиома воплощена в concf. Более специализированные conc1f и concnew\n"
"похожи на push и pushnew для другого конца списка: conc1f добавляет один\n"
"элемент в конец списка, и concnew делает тоже самое, но только если элемент\n"
"уже не является членом списка."

#: texi/node-12.texi:324
msgid ""
"Section 2-2 mentioned that the name of a function can be a lambda-"
"expression\n"
"as well as a symbol. Thus it is fine to give a whole lambda-expression as "
"the\n"
"third argument to define-modify-macro, as in the definition of conc1f. "
"Using\n"
"conc1 from page 45, this macro could also have been written:"
msgstr ""
"В разделе 2-2 упоминается, что имя функции может быть лямбда-выражением,\n"
"а также символом. Таким образом, можно передать целое лямбда-выражение в\n"
"качестве третьего аргумента для define-modify-macro, как в определении \n"
"conc1f. С помощью conc1 со страницы 45, этот макрос мог быть написан так:"

#: texi/node-12.texi:328
msgid ""
"@lisp\n"
"(define-modify-macro conc1f (obj) conc1)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:335
msgid ""
"The macros in Figure 12-2 should be used with one reservation. If you're\n"
"planning to build a list by adding elements to the end, it may be preferable "
"to use\n"
"push, and then nreverse the list. It is cheaper to do something to the front "
"of a\n"
"list than to the end, because to do something to the end you have to get "
"there first.\n"
"It is probably to encourage efficient programming that Common Lisp has many\n"
"operators for the former and few for the latter."
msgstr ""
"Макросы на Рисунке 12-2 должны использоваться с одной оговоркой. Если вы "
"планируете\n"
"построить список путем добавления элементов в конец, может быть "
"предпочтительнее\n"
"использовать push, и затем развернуть с помощью nreverse список. Дешевле "
"сделать \n"
"что то с началом списка, чем с его концом, потому что прежде чем чтото "
"делать в конце\n"
"списка, вначале вы должны до него добраться. Вероятно, для поощрения "
"эффективного\n"
"программирования в Common Lisp есть много операторов для первого и лишь "
"немного для\n"
"второго."

#: texi/node-12.texi:340
msgid ""
"@node 12-4 More Complex Utilities, 12-5 Defining Inversions, 12-3 New "
"Utilities, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-4 More Complex Utilities\n"
"@cindex 12-4 More Complex Utilities"
msgstr ""
"@node 12-4 More Complex Utilities, 12-5 Defining Inversions, 12-3 New "
"Utilities, 12 Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-4 Более Сложные Утилиты\n"
"@cindex 12-4 More Complex Utilities"

#: texi/node-12.texi:345
msgid ""
"Not all macros on setf can be defined with define-modify-macro. Suppose,\n"
"for example, that we want to define a macro f for applying a function "
"destructively\n"
"to a generalized variable. The built-in macro incf is an abbreviation for "
"setf of\n"
"+. Instead of"
msgstr ""
"Не все макросы в setf могут быть определены с помощью define-modify-macro. "
"Например\n"
"предположим, что мы хотим определить макрос f для применения деструктивной "
"функции\n"
"к обобщенной переменной. Встроенный макрос incf это сокращенная аббревиатура "
"для setf \n"
"для +. Вместо"

#: texi/node-12.texi:349
msgid ""
"@lisp\n"
"(setf x (+ x y))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:352
msgid ""
"@noindent\n"
"we say just"
msgstr ""
"@noindent\n"
"мы просто скажем"

#: texi/node-12.texi:356
msgid ""
"@lisp\n"
"(incf x y)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:360
msgid ""
"The new f is to be a generalization of this idea: while incf expands into a "
"call\n"
"to +, f will expand into a call to the operator given as the first argument. "
"For\n"
"example, in the definition of scale-objs on page 115, we had to write"
msgstr ""
"Новый f должен быть обобщением этой идеи: в то время как incf расширяется в "
"вызов\n"
"+ f рассширяется в вызов оператора указанного в качестве первого аргумента. "
"Например,\n"
"в определении scale-objs на странице 115, нам пришлось написать"

#: texi/node-12.texi:364
msgid ""
"@lisp\n"
"(setf (obj-dx o) (* (obj-dx o) factor))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:366
msgid "With f this will become"
msgstr "С f эта запись станет:"

#: texi/node-12.texi:370
msgid ""
"@lisp\n"
"(_f * (obj-dx o) factor)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:372
msgid "The incorrect way to write f would be:"
msgstr "Неправильным способом написать f будет:"

#: texi/node-12.texi:377
msgid ""
"@lisp\n"
"(defmacro _f (op place &rest args)                                        ; "
"wrong\n"
"  `(setf ,place (,op ,place ,@@args)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:380
msgid ""
"Unfortunately, we can't define a correct f with define-modify-macro,because\n"
"the operator to be applied to the generalized variable is given as an "
"argument."
msgstr ""
"К сожалению, мы не можем определить правильный f с помощьюw define-modify-"
"macro,\n"
"поскольку оператор, который будет применен к обобщенной переменной, задан "
"в \n"
"качестве аргумента."

#: texi/node-12.texi:386
msgid ""
"More complex macros like this one have to be written by hand. To make such\n"
"macros easier to write, Common Lisp provides the function get-setf-method,\n"
"which takes a generalized variable and returns all the information necessary "
"to\n"
"retrieve or set its value. We will see how to use this information by hand-"
"generating\n"
"an expansion for:"
msgstr ""
"Более сложные макросы, подобные этому, должны быть написаны в ручную. Чтобы\n"
"такие макросы было легче писать, Common Lisp предоставляет функци get-setf-"
"method,\n"
"которая принимает обобщенную переменную и возвращает всю информацию, "
"необходимую для\n"
"получения или установки её значения. Мы увидим, как использовать эту "
"информацию\n"
"генерируя в ручную расширение для:"

#: texi/node-12.texi:390
msgid ""
"@lisp\n"
"(incf (aref a (incf i)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:393
msgid ""
"When we call get-setf-method on the generalized variable, we get five\n"
"values intended for use as ingredients in the macroexpansion:"
msgstr ""
"Когда мы вызываем get-setf-method для обобщенной переменной, мы получаем\n"
"пять значений предназначенных для использования в качестве ингредиентов\n"
"в расширении макроса:"

#: texi/node-12.texi:402
msgid ""
"@example\n"
"> (get-setf-method '(aref a (incf i)))\n"
"(#:G4 #:G5)\n"
"(A (INCF I))\n"
"(#:G6)\n"
"(SYSTEM:SET-AREF #:G6 #:G4 #:G5)\n"
"(AREF #:G4 #:G5)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:405
msgid ""
"The first two values are lists of temporary variables and the values that "
"should be\n"
"assigned to them. So we can begin the expansion with:"
msgstr ""
"Первые два значения это списки временных переменных и значений, которые "
"должны им\n"
"присвоены. Итак мы можем начать расширение с:"

#: texi/node-12.texi:411
msgid ""
"@lisp\n"
"(let* ((#:g4 a)\n"
"            (#:g5 (incf i)))\n"
"   ...)\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(let* ((#:g4 a)\n"
"       (#:g5 (incf i)))\n"
"   ...)\n"
"@end lisp"

#: texi/node-12.texi:416
msgid ""
"These bindings should be created in a let* because in the general case the "
"value\n"
"forms can refer to earlier variables. The third@footnote{The third value is "
"currently always a list of one element. It is returned as a list to provide "
"the (so far unconsummated) potential to store multiple values in generalized "
"variables.} \n"
"and fifth values are another temporary variable and the form that will "
"return the original value of the generalized\n"
"variable. Since we want to add 1 to this value, we wrap the latter in a call "
"to 1+:"
msgstr ""
"Эти привязки должны быть созданы в let*, потому что в общем случае значения "
"форм могут \n"
"ссылаться на более ранние переменные. Третье@footnote{Третье значение в "
"настоящее время\n"
"является списком из одного элемента. Оно возвращается в виде списка, чтобы "
"предоставить\n"
"(таким образом это еще далеко не всё) возможность для хранения нескольких "
"значений в\n"
"обобщенных переменных.} и пятое значения являются еще одними временными "
"переменными и\n"
"формой, которая будет возвращать исходное значение обобщенной переменной. "
"Поскольку мы\n"
"хотим добавить 1 к этому значению, мы заключаем последнюю в вызов 1+:"

#: texi/node-12.texi:423
msgid ""
"@lisp\n"
"(let* ((#:g4 a)\n"
"            (#:g5 (incf i))\n"
"            (#:g6 (1+ (aref #:g4 #:g5))))\n"
"   ...)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:426
msgid ""
"Finally, the fourth value returned by get-setf-method is the assignment "
"that\n"
"must be made within the scope of the new bindings:"
msgstr ""
"Наконец, четвертое значение, возвращаемое get-setf-method это присваивание,\n"
"которое мы должны сделать в рамках новых привязок:"

#: texi/node-12.texi:433
msgid ""
"@lisp\n"
"(let* ((#:g4 a)\n"
"            (#:g5 (incf i))\n"
"            (#:g6 (1+ (aref #:g4 #:g5))))\n"
"   (system:set-aref #:g6 #:g4 #:g5))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:439
msgid ""
"More often than not, this form will refer to internal functions which are "
"not part\n"
"of Common Lisp. Usually setf masks the presence of these functions, but "
"they\n"
"have to exist somewhere. Everything about them is implementation-dependent,\n"
"so portable code should use forms returned by get-setf-method, rather than\n"
"referring directly to functions like system:set-aref."
msgstr ""
"Чаще всего эта форма будет ссылаться на внутренние функции, которые  не "
"являются \n"
"частью Common Lisp. Обычно setf прячет наличие этих функций, но они должны "
"гдето\n"
"существовать. Все они зависят от реализации, поэтому переносимый код должен\n"
"использовать формы возвращаемые get-setf-method, а не ссылаться на такие "
"функции,\n"
"например как system:set-aref, на прямую."

#: texi/node-12.texi:444
msgid ""
"Now to implement f we write a macro which does almost exactly what we did\n"
"when expanding incf by hand. The only difference is that, instead of "
"wrapping\n"
"the last form in the let* in a call to 1+, we wrap it in an expression made "
"from\n"
"the arguments to f. The definition of f is shown in Figure 12-3."
msgstr ""
"Теперь для реализации _f мы пишем макрос, которые делает почти то же, что "
"делали мы,\n"
"когда расширяли incf в ручную. Разница лишь в том, что вместо оборачивания "
"последней\n"
"формы в let* в вызове 1+, мы оборачиваем ее выражение из аргументов "
"передаваемых _f. \n"
"Определение f показано на Риснуке 12-3."

#: texi/node-12.texi:452
msgid ""
"@lisp\n"
" (defmacro _f (op place &rest args)\n"
"   (multiple-value-bind (vars forms var set access)\n"
"                             (get-setf-method place)\n"
"        `(let* (,@@(mapcar #'list vars forms)\n"
"               (,(car var) (,op ,access ,@@args)))\n"
"          ,set)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro _f (op place &rest args)\n"
"   (multiple-value-bind (vars forms var set access)\n"
"                             (get-setf-method place)\n"
"        `(let* (,@@(mapcar #'list vars forms)\n"
"               (,(car var) (,op ,access ,@@args)))\n"
"          ,set)))"

#: texi/node-12.texi:461
msgid ""
" (defmacro pull (obj place &rest args)\n"
"   (multiple-value-bind (vars forms var set access)\n"
"                             (get-setf-method place)\n"
"        (let ((g (gensym)))\n"
"         `(let* ((,g ,obj)\n"
"                 ,@@(mapcar #'list vars forms)\n"
"                 (,(car var) (delete ,g ,access ,@@args)))\n"
"            ,set))))"
msgstr ""

#: texi/node-12.texi:470
msgid ""
" (defmacro pull-if (test place &rest args)\n"
"   (multiple-value-bind (vars forms var set access)\n"
"                             (get-setf-method place)\n"
"        (let ((g (gensym)))\n"
"         `(let* ((,g ,test)\n"
"                 ,@@(mapcar #'list vars forms)\n"
"                 (,(car var) (delete-if ,g ,access ,@@args)))\n"
"            ,set))))"
msgstr ""

#: texi/node-12.texi:482
msgid ""
" (defmacro popn (n place)\n"
"   (multiple-value-bind (vars forms var set access)\n"
"                             (get-setf-method place)\n"
"        (with-gensyms (gn glst)\n"
"         `(let* ((,gn ,n)\n"
"                 ,@@(mapcar #'list vars forms)\n"
"                 (,glst ,access)\n"
"                 (,(car var) (nthcdr ,gn ,glst)))\n"
"            (prog1 (subseq ,glst 0 ,gn)\n"
"                     ,set)))))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:484
msgid "                Figure 12-3: More complex macros on setf."
msgstr ""
"                Рисунок 12-3: Более сложный макрос setf.\n"
"@end cartouche"

#: texi/node-12.texi:488
msgid ""
"This utility is quite a useful one. Now that we have it, for example, we "
"can\n"
"easily replace any named function with a memoized (Section 5-3) equivalent."
"@footnote{Built-in functions should not be memoized in this way, though. "
"Common Lisp forbids the redefinition of built-in functions.} To\n"
"memoize foo we would say:"
msgstr ""
"Эта утилита довольно полезна. Теперь когда у нас она есть, мы легко можем, "
"например, заменить\n"
"любую именованную функцию с запомнинаием(memoized) (Разел 5-3) эквивалентом."
"@footnote{Встроенные \n"
"функции не долны запоминаться таким образом. Common Lisp запрещает "
"переопределение встроенных функций.}\n"
"для запоминания(memoize) foo мы бы сказали:"

#: texi/node-12.texi:492
msgid ""
"@lisp\n"
"(_f memoize (symbol-function 'foo))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:495
msgid ""
"Having f also makes it easy to define other macros on setf. For example,\n"
"we could now define conc1f (Figure 12-2) as:"
msgstr ""
"Наличие _f также облегчает определение других макросов в setf. Нампример, "
"теперь мы\n"
"можем определить conc1f (Рисунок 12-2) как:"

#: texi/node-12.texi:500
msgid ""
"@lisp\n"
"(defmacro conc1f (lst obj)\n"
"   `(_f nconc ,lst (list ,obj)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:507
msgid ""
"Figure 12-3 contains some other useful macros on setf. The next, pull,\n"
"is intended as a complement to the built-in pushnew. The pair are like more\n"
"discerning versions of push and pop; pushnew pushes a new element onto a "
"list\n"
"if it is not already a member, and pull destructively removes selected "
"elements\n"
"from a list. The &rest parameter in pull's definition makes pull able to "
"accept\n"
"all the same keyword parameters as delete:"
msgstr ""
"Рисунок 12-3 cодержит другие полезные макросы для setf. Следующий, pull,\n"
"предназначен в качестве дополнения к встроенному pushnew. Эта пара более\n"
"различающая аргументы подобна паре push и pop; pushnew помещает новый "
"элемент\n"
"в список, если он не являетися уже членом списка, и pull разрушающе удалят "
"выделенный\n"
"элемент из списка. Параметр &rest в определении pull делает pull способным "
"принимать\n"
"все те же параметры ключевый слова как и в delete:"

#: texi/node-12.texi:518
msgid ""
"@example\n"
"> (setq x '(1 2 (a b) 3))\n"
"(12(AB)3)\n"
"> (pull 2 x)\n"
"(1 (A B) 3)\n"
"> (pull '(a b) x :test #'equal)\n"
"(1 3)\n"
">x\n"
"(1 3)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:520
msgid "You could almost think of this macro as if it were defined:"
msgstr "Вы могли бы думать об этом макросе как если был определен как:"

#: texi/node-12.texi:525
msgid ""
"@lisp\n"
"(defmacro pull (obj seq &rest "
"args)                                           ; wrong\n"
"   `(setf ,seq (delete ,obj ,seq ,@@args)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:530
msgid ""
"@noindent\n"
"though if it really were defined that way, it would be subject to problems "
"with both\n"
"order and number of evaluations. We could define a version of pull as a "
"simple\n"
"modify-macro:"
msgstr ""
"@noindent\n"
"хотя, если это действительно было бы определено таким образом, оно было бы "
"связано с\n"
"проблемами как по порядку, так и по количеству вычилений. Мы могли бы "
"определить версию\n"
"pull как простой modify-macro:"

#: texi/node-12.texi:536
msgid ""
"@lisp\n"
"(define-modify-macro pull (obj &rest args)\n"
"   (lambda (seq obj &rest args)\n"
"        (apply #'delete obj seq args)))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:540
msgid ""
"but since modify-macros must take the generalized variable as their first "
"argument,\n"
"we would have to give the first two arguments in reverse order, which would "
"be\n"
"less intuitive."
msgstr ""
"но так как modify-macros должен принимать обобщенную переменную, в качестве "
"первого\n"
"аргумента, мы должны были бы передать первые два аргумента в обратном "
"порядке, что\n"
"будет менее интуитивно понятно."

#: texi/node-12.texi:543
msgid ""
"The more general pull-if takes an initial function argument, and expands\n"
"into a delete-if instead of a delete:"
msgstr ""
"Более общий pull-if принимает начальный аргумент функции, и расширяется\n"
"в delete-if вместо delete:"

#: texi/node-12.texi:551
msgid ""
"@example\n"
"> (let ((lst '(1 23456)))\n"
"        (pull-if #'oddp lst)\n"
"        lst)\n"
"(246)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:555
msgid ""
"These two macros illustrate another general point. If the underlying "
"function takes\n"
"optional arguments, so should the macro built upon it. Both pull and pull-"
"if\n"
"pass optional arguments on to their deletes."
msgstr ""
"Эти два макроса иллюстрируют еще один общий момент. Если основная функция "
"принимает\n"
"необязательные аргументы, то и макрос должен основываться на них. Оба, и "
"pull и pull-if\n"
"передают необзательные аргументы своим функциям удаления."

#: texi/node-12.texi:559
msgid ""
"The final macro in Figure 12-3, popn, is a generalization of pop. Instead "
"of\n"
"popping just one element of a list, it pops and returns a subsequence of "
"arbitrary\n"
"length:"
msgstr ""
"Последний макрос на рисунке 12-3, popn, является обобщением pop. Вместо "
"простого\n"
"выталкивания по одному элементу из списка, он выталкивает и возвращает \n"
"подпоследовательность произвольной длины:"

#: texi/node-12.texi:569
msgid ""
"@example\n"
"> (setq x '(a b c d e f))\n"
"(ABCDEF)\n"
"> (popn 3 x)\n"
"(ABC)\n"
">x\n"
"(DEF)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:573
msgid ""
"Figure 12-4 contains a macro which sorts its arguments. If x and y are "
"variables\n"
"and we want to ensure that x does not have the lower of the two values, we "
"can\n"
"write:"
msgstr ""
"Рисунок 12-4 содержит макрос, который сортирует свои аргументы. Если x и y "
"являются\n"
"переменными и мы хотим убедиться, что x не является меньшим из двух "
"значений, мы можем\n"
"написать:"

#: texi/node-12.texi:577
msgid ""
"@lisp\n"
"(if (> y x) (rotatef x y))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:583
msgid ""
"But if we want to do this for three or more variables, the code required "
"grows\n"
"rapidly. Instead of writing it by hand, we can have sortf write it for us. "
"This\n"
"macro takes a comparison operator plus any number of generalized variables, "
"and\n"
"swaps their values until they are in the order dictated by the operator. In "
"the\n"
"simplest case, the arguments could be ordinary variables:"
msgstr ""
"Но если мы хотим сделать это для трех и более переменных, требуемый код "
"растет\n"
"очень быстро. Вместо, того, чтобы писать его в ручную, мы можем сделать так, "
"чтобы\n"
"sortf писал его за нас. Этот макрос принимает оператор сравнения пюст любое "
"количество\n"
"обобщенных переменных, и меняет их значения до тех пор, пока они не будут в "
"порядке\n"
"определяемом оператором. В простейшем случае аргументы могут быть обычными "
"переменными:"

#: texi/node-12.texi:591
msgid ""
"@example\n"
"> (setq x1y2z3)\n"
"3> (sortf > x y z)\n"
"3> (list x y z)\n"
"(321)\n"
"@end example"
msgstr ""

#: texi/node-12.texi:617
msgid ""
"@lisp\n"
" (defmacro sortf (op &rest places)\n"
"       (let* ((meths (mapcar #'(lambda (p)\n"
"                                         (multiple-value-list\n"
"                                           (get-setf-method p)))\n"
"                                    places))\n"
"                (temps (apply #'append (mapcar #'third meths))))\n"
"          `(let* ,(mapcar #'list\n"
"                              (mapcan #'(lambda (m)\n"
"                                              (append (first m)\n"
"                                                        (third m)))\n"
"                                         meths)\n"
"                              (mapcan #'(lambda (m)\n"
"                                              (append (second m)\n"
"                                                        (list (fifth m))))\n"
"                                         meths))\n"
"             ,@@(mapcon #'(lambda (rest)\n"
"                                (mapcar\n"
"                                  #'(lambda (arg)\n"
"                                       `(unless (,op ,(car rest) ,arg)\n"
"                                           (rotatef ,(car rest) ,arg)))\n"
"                                  (cdr rest)))\n"
"                          temps)\n"
"             ,@@(mapcar #'fourth meths))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro sortf (op &rest places)\n"
"       (let* ((meths (mapcar #'(lambda (p)\n"
"                                         (multiple-value-list\n"
"                                           (get-setf-method p)))\n"
"                                    places))\n"
"                (temps (apply #'append (mapcar #'third meths))))\n"
"          `(let* ,(mapcar #'list\n"
"                              (mapcan #'(lambda (m)\n"
"                                              (append (first m)\n"
"                                                        (third m)))\n"
"                                         meths)\n"
"                              (mapcan #'(lambda (m)\n"
"                                              (append (second m)\n"
"                                                        (list (fifth m))))\n"
"                                         meths))\n"
"             ,@@(mapcon #'(lambda (rest)\n"
"                                (mapcar\n"
"                                  #'(lambda (arg)\n"
"                                       `(unless (,op ,(car rest) ,arg)\n"
"                                           (rotatef ,(car rest) ,arg)))\n"
"                                  (cdr rest)))\n"
"                          temps)\n"
"             ,@@(mapcar #'fourth meths))))\n"
"@end lisp"

#: texi/node-12.texi:619
msgid "                   Figure 12-4: A macro which sorts its arguments."
msgstr ""
"                   Рисунок 12-4: Макрос который сортирует свои аргументы.\n"
"@end cartouche"

#: texi/node-12.texi:626
msgid ""
"In general, they could be any invertible expressions. Suppose cake is an "
"invertible\n"
"function which returns someone's piece of cake, and bigger is a comparison\n"
"function defined on pieces of cake. If we want to enforce the rule that the "
"cake\n"
"of moe is no less than the cake of larry, which is no less than that of "
"curly,we\n"
"write:"
msgstr ""
"В общем, это могут быть любые обратимые выражения. Предположим, что cake "
"является \n"
"обратимой функцией и которая возвращает чей либо кусочек пирога, а bigger "
"функция\n"
"сравнения определенная на кусочках пирога. Если мы хотим применить правило, "
"что\n"
"торт moe не меньше, чем торт larry, который не меньше чем торт curly, мы "
"запишем:"

#: texi/node-12.texi:630
msgid ""
"@lisp\n"
"(sortf bigger (cake 'moe) (cake 'larry) (cake 'curly))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:637
msgid ""
"The definition of sortf is similar in outline to that of f. It begins with "
"a\n"
"let* in which the temporary variables returned by get-setf-method are bound\n"
"to the initial values of the generalized variables. The core of sortf is the "
"central\n"
"mapcon expression, which generates code to sort these temporary variables. "
"The\n"
"code generated by this portion of the macro grows exponentially with the "
"number\n"
"of arguments. After sorting, the generalized variables are reassigned using "
"the"
msgstr ""
"Определение sortf в общих чертах аналогично определению _f. Оно начинается "
"с\n"
"let* в котором связываются временные переменные возвращаемые get-setf-"
"method \n"
"и связваются начальные значения обобщенных переменных. Ядром sortf является\n"
"центральное выражение mapcon, которое генерирует код сортирующий эти "
"временные\n"
"переменные. Код, сгенерированный этой частью макроса, растет "
"экспотенциально \n"
"вместе с числом аргументов. После сортировки, обобщенные переменные "
"переприсваиваются\n"
"с помощью"

#: texi/node-12.texi:641
msgid ""
"@lisp\n"
" (sortf > x (aref ar (incf i)) (car lst))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (sortf > x (aref ar (incf i)) (car lst))\n"
"@end lisp"

#: texi/node-12.texi:644
msgid ""
"@noindent\n"
"expands (in one possible implementation) into:"
msgstr ""
"@noindent\n"
"расширяется (в одной из возможных реализаций) в:"

#: texi/node-12.texi:662
msgid ""
"@lisp\n"
" (let* ((#:g1 x)\n"
"            (#:g4 ar)\n"
"            (#:g3 (incf i))\n"
"            (#:g2 (aref #:g4 #:g3))\n"
"            (#:g6 lst)\n"
"            (#:g5 (car #:g6)))\n"
"    (unless (> #:g1 #:g2)\n"
"        (rotatef #:g1 #:g2))\n"
"    (unless (> #:g1 #:g5)\n"
"        (rotatef #:g1 #:g5))\n"
"    (unless (> #:g2 #:g5)\n"
"        (rotatef #:g2 #:g5))\n"
"    (setq x #:g1)\n"
"    (system:set-aref #:g2 #:g4 #:g3)\n"
"    (system:set-car #:g6 #:g5))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:664
msgid "                    Figure 12-5: Expansion of a call to sortf."
msgstr ""
"                    Рисунок 12-5: Расширение вызова sortf.\n"
"@end cartouche"

#: texi/node-12.texi:668
msgid ""
"forms returned by get-setf-method. The algorithm used is the O(n2) bubble-\n"
"sort, but this macro is not intended to be called with huge numbers of "
"arguments."
msgstr ""
"форм, возвращаемых get-setf-method. Используемый алгоритм представляет "
"собой\n"
"сортировку пузыкрьком O(n2), но этот макрос не предназначен для вызова с "
"большим\n"
"количеством аргументов."

#: texi/node-12.texi:676
msgid ""
"Figure 12-5 shows the expansion of a call to sortf. In the initial let*, "
"the\n"
"arguments and their subforms are carefully evaluated in left-to-right order. "
"Then\n"
"appear three expressions which compare and possibly swap the values of the\n"
"temporary variables: the first is compared to the second, then the first to "
"the third,\n"
"then the second to the third. Finally the the generalized variables are "
"reassigned\n"
"left-to-right. Although the issue rarely arises, macro arguments should "
"usually be\n"
"assigned left-to-right, as well as being evaluated in this order."
msgstr ""
"На Рисунке 12-5 показано расширение вызова sortf. В начальномl let*, "
"аргументы и\n"
"их подформы тщательно вычисляются в порядке слева на право. Затем появляются "
"три\n"
"выражения, которые сравнивают, и возможно заменяют значения временных "
"переменных: \n"
"первый сравниватся со вторым, затем первый с третьим, затем второй с "
"третьим. Наконец,\n"
"обобщенные переменные переприсваиваются в порядке с лева на право. Хотя "
"проблема\n"
"возникает редко, аргументы макроса должны присваиваться слева на право, а "
"также \n"
"вычисляться в том же порядке."

#: texi/node-12.texi:683
msgid ""
"Operators like f and sortf bear a certain resemblance to functions that\n"
"take functional arguments. It should be understood that they are something "
"quite\n"
"different. A function like find-if takes a function and calls it; a macro "
"like f\n"
"takes a name, and makes it the car of an expression. Both f and sortf could\n"
"have been written to take functional arguments. For example, f could have "
"been\n"
"written:"
msgstr ""
"Операторы типа _f и sortf имеют определенное сходство с функциями, которые "
"принимают\n"
"функциональные аргументы. Следует понимать, что они имеют воплне очевидное "
"различие.\n"
"Функция подобная find-if получает функцию и вызывает её; а макрос подобный "
"_f\n"
"получает имя, и делает его началом(car) выражения. Оба и _f и sortf могут "
"быть\n"
"написаны , чтобы принимать функциональные аргументы. Например, _f может "
"быть\n"
"написан:"

#: texi/node-12.texi:694
msgid ""
"@lisp\n"
"(defmacro _f (op place &rest args)\n"
"     (let ((g (gensym)))\n"
"        (multiple-value-bind (vars forms var set access)\n"
"                                   (get-setf-method place)\n"
"        `(let* ((,g ,op)\n"
"                  ,@@(mapcar #'list vars forms)\n"
"                  (,(car var) (funcall ,g ,access ,@@args)))\n"
"              ,set))))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:699
msgid ""
"@noindent\n"
"and called ( f #'+ x 1). But the original version of f can do anything this "
"one\n"
"could, and since it deals in names, it can also take the name of a macro or "
"special\n"
"form. As well as +, you could call, for example, nif (page 150):"
msgstr ""
"@noindent\n"
"и вызываться ( f #'+ x 1). Но оригинальная версия _f может сделать, что "
"угодно, и \n"
"так как она имеет дело с именами, она также может принять имя макроса или \n"
"специальной формы. Например, кроме +, вы можете вызвать nif (стр. 150):"

#: texi/node-12.texi:706
msgid ""
"@example\n"
"> (let ((x 2))\n"
"        (_f nif x 'p 'z 'n)\n"
"        x)\n"
"P\n"
"@end example"
msgstr ""

#: texi/node-12.texi:711
msgid ""
"@node 12-5 Defining Inversions,  , 12-4 More Complex Utilities, 12 "
"Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-5 Defining Inversions\n"
"@cindex 12-5 Defining Inversions"
msgstr ""
"@node 12-5 Defining Inversions,  , 12-4 More Complex Utilities, 12 "
"Generalized Variables\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 12-5 Определение Инверсий\n"
"@cindex 12-5 Defining Inversions"

#: texi/node-12.texi:716
msgid ""
"Section 12-1 explained that any macro call which expands into an invertible\n"
"reference will itself be invertible. You don't have to define operators as "
"macros\n"
"just to make them invertible, though. By using defsetf you can tell Lisp how "
"to\n"
"invert any function or macro call."
msgstr ""
"Раздел 12-1 объяснил, что любой вызов макроса, который расширяется в "
"обратимую\n"
"ссылку, сам по себе, будет обратимым. Вам не нужно определять операторы как "
"макросы,\n"
"только для того чтобы сделать их обратимыми. Используя defsetf вы можете "
"указать\n"
"Lisp, как инвертировать любую функцию или вызов макроса."

#: texi/node-12.texi:719
msgid ""
"This macro can be used in two ways. In the simplest case, its arguments are\n"
"two symbols:"
msgstr ""
"Этот макрос можно использовать двумя способами. В простейшем случае его "
"аргументы\n"
"это два символа:"

#: texi/node-12.texi:723
msgid ""
"@lisp\n"
"(defsetf symbol-value set)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:727
msgid ""
"In the more complicated form, a call to defsetf is like a call to defmacro, "
"with\n"
"an additional parameter for the updated value form. For example, this would\n"
"define a possible inversion for car:"
msgstr ""
"В более сложной форме, вызов defsetf подобен вызову defmacro, с "
"дополнительным\n"
"параметром для обновления значения формы. Например, определим возможную "
"инверсию\n"
"формы для car:"

#: texi/node-12.texi:733
msgid ""
"@lisp\n"
"(defsetf car (lst) (new-car)\n"
"     `(progn (rplaca ,lst ,new-car)\n"
"                ,new-car))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:736
msgid ""
"There is one important difference between defmacro and defsetf: the latter\n"
"automatically creates gensyms for its arguments. With the definition given "
"above,"
msgstr ""
"Между defmacro и defsetf есть одно очень важное отличие: последнее "
"автоматически создает\n"
"идентификаторы gensyms для своих аргументов. С определением данным выше,"

#: texi/node-12.texi:743
msgid ""
"@lisp\n"
"(setf (car x) y) would expand into:\n"
"(let* ((#:g2 x)\n"
"              (#:g1 y))\n"
"     (progn (rplaca #:g2 #:g1)\n"
"               #:g1))"
msgstr ""
"@lisp\n"
"(setf (car x) y) расшириться до:\n"
"(let* ((#:g2 x)\n"
"              (#:g1 y))\n"
"     (progn (rplaca #:g2 #:g1)\n"
"               #:g1))\n"
"@end lisp"

#: texi/node-12.texi:745
msgid " (defvar *cache* (make-hash-table))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *cache* (make-hash-table))"

#: texi/node-12.texi:750
msgid ""
" (defun retrieve (key)\n"
"    (multiple-value-bind (x y) (gethash key *cache*)\n"
"        (if y(values x y)\n"
"            (cdr (assoc key *world*)))))"
msgstr ""

#: texi/node-12.texi:754
msgid ""
" (defsetf retrieve (key) (val)\n"
"    `(setf (gethash ,key *cache*) ,val))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:756
msgid "                      Figure 12-6: An asymmetric inversion."
msgstr ""
"                      Рисунок 12-6: Асиментричная инверсия.\n"
"@end cartouche"

#: texi/node-12.texi:760
msgid ""
"Thus we can write defsetf expanders without having to worry about variable\n"
"capture, or number or order of evaluations."
msgstr ""
"Таким образом, мы можем писать расширители  defsetf не беспокоясь о захвате\n"
"переменных, или числе и порядке вычислений."

#: texi/node-12.texi:763
msgid ""
"In CLTL2 Common Lisp, it is possible to define setf inversions directly "
"with\n"
"defun, so the previous example could also be written:"
msgstr ""
"В CLTL2 Common Lisp можно задавать инверсии setf непосредственно используя\n"
"defun, поэтому предыдущий пример также может быть записан, как:"

#: texi/node-12.texi:769
msgid ""
"@lisp\n"
"(defun (setf car) (new-car lst)\n"
"  (rplaca lst new-car)\n"
"  new-car)\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:772
msgid ""
"The updated value should be the first parameter in such a function. It is "
"also\n"
"conventional to return this value as the value of the function."
msgstr ""
"Обновленное значение должно быть первым параметром в такой функции. Она "
"также,\n"
"по соглашению, должна возвращать это значение как значение функции."

#: texi/node-12.texi:780
msgid ""
"The examples so far have suggested that generalized variables are supposed\n"
"to refer to a place in a data structure. The villain carries his hostage "
"down to\n"
"the dungeon, and the rescuing hero carries her back up again; they both "
"follow\n"
"the same path, but in different directions. It's not surprising if people "
"have the\n"
"impression that setf must work this way, because all the predefined "
"inversions\n"
"seem to be of this form; indeed, place is the conventional name for a "
"parameter\n"
"which is to be inverted."
msgstr ""
"До сих пор примеры показывали, что обобщенные переменные предположительно\n"
"ссылаются на место в структуре данных. Злодей уносит свою заложницу в "
"темницу,\n"
"а спасающий герой поднимает ее обратно; они оба следуют одному и тому же "
"пути, но\n"
"в разных направлениях. Не удивительно, если у людей есть представление, что "
"setf \n"
"должен работать таким образом, поскольку все предопределенные инверсии, "
"кажеться,\n"
"имеют эту форму; действительно, место - это условное название параметра, "
"который \n"
"должен быть перевернут(инвертирован)."

#: texi/node-12.texi:786
msgid ""
"In principle, setf is more general: an access form and its inversion need "
"not\n"
"even operate on the same data structure. Suppose that in some application "
"we\n"
"want to cache database updates. This could be necessary, for example, if it "
"were\n"
"not efficient to do real updates on the fly, or if all the updates had to be "
"verified\n"
"for consistency before committing to them."
msgstr ""
"В принципе, setf является более общим: форма доступа и её инверсия не должны "
"работать\n"
"на той же структуре данных. Предположим, что в каком то, приложении мы хотим "
"кешировать\n"
"обновления базы данных. Это может быть необходимо, например, если бы "
"реальные обновления\n"
"на лету делать не эффективно, или если все обновления должны быть сверены "
"для согласованности\n"
"перед их совершением(принятием)."

#: texi/node-12.texi:790
msgid ""
"Suppose that *world* is the actual database. For simplicity, we will make "
"it\n"
"an assoc-list whose elements are of the form (key . val). Figure 12-6 shows "
"a\n"
"lookup function called retrieve.If*world* is"
msgstr ""
"Предположим, что *world* является фактической базой данных. Для простоты, мы "
"сделаем\n"
"её ассоциативным списком, элементы которого имеют форму (key . val). Рисунок "
"12-6 \n"
"показывает функцию поиска назваемую retrieve. Если *world* это"

#: texi/node-12.texi:794
msgid ""
"@lisp\n"
"((a . 2) (b . 16) (c . 50) (d . 20) (f . 12))\n"
"@end lisp"
msgstr ""

#: texi/node-12.texi:797
msgid ""
"@noindent\n"
"then"
msgstr ""
"@noindent\n"
"тогда"

#: texi/node-12.texi:802
msgid ""
"@example\n"
"  > (retrieve 'c)\n"
"  50\n"
"@end example"
msgstr ""

#: texi/node-12.texi:806
msgid ""
"Unlike a call to car, a call to retrieve does not refer to a specific place "
"in a data\n"
"structure. The return value could come from one of two places. And the "
"inversion\n"
"of retrieve, also defined in Figure 12-6, only refers to one of them:"
msgstr ""
"В отличии от вызова car, вызов retrieve не ссылается к конкретному месту "
"структуры данных.\n"
"Возвращаемое значение может придти от одного из двух мест. И инверсия "
"retrieve, также\n"
"определенная на рисунке 12-6, относиться только к одному из них:"

#: texi/node-12.texi:814
msgid ""
"@example\n"
"> (setf (retrieve 'n) 77)\n"
"77\n"
"> (retrieve 'n)\n"
"77\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-12.texi:817
msgid ""
"This lookup returns a second value of t, indicating that the answer was "
"found in\n"
"the cache."
msgstr ""
"Этот поиск возвращает вторым значением t, указывающим, что ответ был найден "
"в кеше."

#: texi/node-12.texi:824
msgid ""
"Like macros themselves, generalized variables are an abstraction of "
"remarkable\n"
"power. There is probably more to be discovered here. Certainly individual "
"users\n"
"are likely to discover ways in which the use of generalized variables could "
"lead\n"
"to more elegant or more powerful programs. But it may also be possible to\n"
"use setf inversion in new ways, or to discover other classes of similarly "
"useful\n"
"transformations."
msgstr ""
"Как и сами макросы, обобщенные переменные являются абстракцией "
"замечательной \n"
"мощности. Здесь, вероятно, еще многое предстоит открыть. Конечно, "
"индивидуальные\n"
"пользователи, вероятно, обнаружат способы, которыми использование "
"обобщенных\n"
"переменных может привести к более элегантным и более мощным программам. Но "
"также \n"
"возможно использовать инверсии setf новыми способами, или открыть другие "
"классы,\n"
"аналогичных полезных преобразований(трансформаций)."
