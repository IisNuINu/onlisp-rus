@node 21 Multiple Processes, 22 Nondeterminism, 20 Continuations, Top
@comment  node-name,  next,  previous,  up
@chapter 21 Множество Процессов(многопроцессность/Многозадачность)
@cindex 21 Multiple Processes

В предыдущей главе показано, как продолжения позволяют работающей программе получить
свое собственное состояние и сохранить его для последующего перезапуска. В этой главе
рассматривается модель вычислений, в которой компьютер запускает не одну отдельную
программу, а набор независимых процессов. Концепция процесса(задачи) тесно соответствует
с нашей конецепцией состояния программы. Написав дополнительный слой макросов поверх тех,
что были описаны в предыдущей главе, мы можем встроить многозадачность в программы 
Common Lisp.

@menu
* 21-1 The Process Abstraction::  
* 21-2 Implementation::         
* 21-3 The Less-than-Rapid Prototype::  
@end menu

@node 21-1 The Process Abstraction, 21-2 Implementation, 21 Multiple Processes, 21 Multiple Processes
@comment  node-name,  next,  previous,  up
@section 21-1 Абстракция Процесса/Задачи
@cindex 21-1 The Process Abstraction

Много Процессность/Задачность - это удобный способ выражения программ, которые должны
выполнять несколько действий одновременно. Традиционный процессор выполняет одну
инструкцию за раз. Сказать что несколько процессов выполняются одновременно, это не
значит, что они каким-то образом преодолевают это аппаратное ограничение: это означает,
что они позволяют нам мыслить на уровне абстракции, на котором нам не нужно точно 
указывать, что делает компьютер в некоторый момент времени. Точно также как виртуальная
память позволяет нам действовать так, как если бы у компьютера было больше памяти, чем
на самом деле, понятие процесса/задачи позволяет нам действовать так, как если бы
компьютер мог запускать более одной программы одновременно.

Изучение процессов традиционно относиться к области операционных систем. Но полезность
процессов как абстракции не ограничивается операционными системами. Они одинаково
полезны и в других приложениях реального времени, и в симуляциях.

Большая часть работы, проделываемой по управлению несколькими процессами, была
посвящена предотвращению определенных типов проблем. Тупик(Deadlock) - это одна
классическая проблема для нескольких процессов: два процесса ждут, пока другой
что-то сделает, подобно двум людям, каждый из которых отказывается переступить
порог прежде чем другой это сделает. Другая проблема - это запрос, который ловит
систему в несогласованном состоянии, скажем, запрос баланса, который поступает,
когда система переводит средства с одного счета на другой. В этой главе рассматривается
только сама абстракция процесса/задачи; код, представленный здесь, может быть использован
для тестирования алгоритмов предотвращаения тупиковых или несогласованных состояний, но
сам по себе он не обеспечивает никакой защиты от этих проблем.

Реализация в этой главе следует правилу, неявному во всех программах этой книги:
как можно меньше нарушать Lisp. По сути, программа должна быть как можно больше
похожа на модификацию языка, а не на отдельное приложение написанное на нем.
Создание программ согласованных с Lisp делает их более надежными, как машины,
чьи части хорошо сочетаются друг с другом. Это также экономит усилия;
иногда вы можете заставить Lisp сделать для вас удивительное количество работы.

Цель этой главы - создать язык, который поддерживает несколько процессов. 
Наша стратегия состоит в том, чтобы превратить Lisp в такой язык, добавив
несколько новых операторов. Основные элементы нашего языка будут следующими:

Функции будут определяться с помощью макросов =defun или =lambda из 
предыдущей главы.

Процессы будут создадваться из вызовов функций. Нет ограничений на количество
активных процессов или количество процессов, созданных из какой-либо одной 
функции. Каждый процесс будет иметь приоритет, изначально заданный в качестве
аргумента при его создании.

Выражения ожидания(Wait) могут возникать внутри функций. Выражение ожидания 
будет принимать переменную, тестовое выражение и тело кода. Если процесс
встречает команду ожидать(wait), процесс будет приостановлен в этой точке,
до тех пор пока тестовое выражение не вернет истину. Как только процесс
перезапустится, будет вычислено тело кода с переменной, связанной со значением
тестового выражения. Тестовые выражения, обычно, не должны иметь побочных 
эффектов, потому что нет никаких гарантий относительно того, когда и как часто
они будут вычисляться.

Планирование(Scheduling) будет сделано по приоритету. Из всех процессов, которые 
могут быть перезапущены, система будет запускать процесс с наивысшим приоритетом.

Процесс по умолчанию будет запущен, если никакой другой процесс запустить нельзя.
Это будет процесс REPL (read-eval-print loop).

Создание и удаление большинства объектов будет возможно на лету. Из запущенных
процессов можно будет определять новые функции, а также создавать и уничтожать
процессы.

@cartouche
@lisp

 (defstruct proc pri state wait)

 (proclaim '(special *procs* *proc*))

 (defvar *halt* (gensym))

 (defvar *default-proc*
              (make-proc :state #'(lambda (x)
                                           (format t "~%>> ")
                                           (princ (eval (read)))
                                           (pick-process))))

 (defmacro fork (expr pri)
    `(prog1 ',expr
               (push (make-proc
                           :state #'(lambda (,(gensym))
                                          ,expr
                                          (pick-process))
                           :pri      ,pri)
                        *procs*)))

 (defmacro program (name args &body body)
    `(=defun ,name ,args
        (setq *procs* nil)
        ,@@body
        (catch *halt* (loop (pick-process)))))
@end lisp

                  Рисунок 21-1: Структура процесса и его создание.
@end cartouche

Продолжения позволяют сохранять состояние программы Lisp. Возможность хранить
несколько состояний одновременно не так уж далеко стоит от реализации 
многопроцессности. Начиная с макросов, определенных в предыдущей главе, нам нужно
менее  60 строк кода для реализации многопроцессности.

@node 21-2 Implementation, 21-3 The Less-than-Rapid Prototype, 21-1 The Process Abstraction, 21 Multiple Processes
@comment  node-name,  next,  previous,  up
@section 21-2 Реализация
@cindex 21-2 Implementation

Рисунки 21-1 и 21-2 содержат весь код, необходимый для поддержки многопроцессности.
Рисунок 21-1 содержит код для основных структур данных, процесса по умолчанию, 
инициализации и создания процессов. Процессы или procs, имеют следующую структуру:

    pri является приоритетом процесса, который должен быть положительным числом.

    state является продолжением, представляющим состояние приостановленного процесса.
        Процесс перезапускается путем вызова как функции(funcalling) этого состояния.

    wait - это обычно функция, которая должна возвращать истину для перезапуска процесса,
        но вначале  wait для вновь созданного процесса равен nil. Процесс с wait равным
        nil всегда можно перезапустить.

Программа использует три глобальные переменные: *procs*, список приостановленных 
процессов; *proc*, текущий запущеный процесс; и *default-proc*, процесс
по умолчанию.

Процесс по умолчанию выполняется только тогда, когда нет другого готового к выполнению
процесса. Он имитирует верхний уровень Lisp. В этом цикле, пользователь может остановить
программу, или ввести выражение, позволяющее перезапустить приостановленные процессы.
Обратите внимание, что процесс по умолчанию явно вызывает eval. Эта одна из немногих
ситуаций, в которых это допустимо. Обычно не рекомендуется вызывать eval во время выполнения
по двум причинам:

@enumerate
@item
Это не эффективно: eval работает с необработанным(сырым) списком, и он должен
либо скомпилировать его на месте, либо вычислить в интерпретаторе. В любом
случае  это медленнее, чем предварительно скомпилировать код и потом просто
вызвать его.

@item
Это менее мощно, потому что выражение вычисляется без лексического контекста.
Среди прочего, это означает, что вы не можете ссылаться на обычные переменные,
видимые снаружи вычисляемого выражения.
@end enumerate

Обычно, вызывать eval это все равно что покупать что-то в сувенирном магазине в
аэропорту. Дождавшись последнего момента, вы должны заплатить высокую цену за
ограниченный выбор второсортных товаров.

Случаи подобные этому, являются редкими случаями, когда ни один из двух предыдущих
аргументов не применим. Мы не могли составить выражение заранее. Мы только сейчас
читаем их; их ранее не было. Аналогично, выражение не может ссылаться на окружающие
лексические переменные, потому что выражения, набранные на верхнем уровне, находятся
в нулевой лексической среде. Фактически, определение этой функции отражает ее
английское описание: она читает и вычисляет, то что вводит пользователь.

Макрос fork создает экземпляр процесса вызывая функцию. Функции
определяются обычно с помощью =defun:

@lisp
(=defun foo (x)
  (format t "Foo was called with ~A.~%" x)
  (=values (1+ x)))
@end lisp

Теперь когда мы вызваем fork с вызовом функции и номером приоритета:

@lisp
(fork (foo 2) 25)
@end lisp

@noindent
новый процесс помещается в *procs*. Новый процесс имеет приоритет равный 25, а
процедура wait равна nil, поскольку она еще не была запущена, а процедура 
state состоит из вызова foo с аргументом 2.

Макрос program позволяет нам создать группу процессов и запустить их
вместе. Определение:

@lisp
(program two-foos (a b)
  (fork (foo a) 99)
  (fork (foo b) 99))
@end lisp

@noindent
макрорасширяется в два выражени fork, зажатых между кодом который очищает 
приостановленные процессы, и другим кодом, который повторясь выбирает процесс
для запуска. Вне этого цикла, макрос устанавливает тег, в который можно добавить
элемент управления для завершения программы. Как gensym, этот тег не будет
конфликтовать с тегами, установленными пользовательским кодом. Группа процессов,
определенных как program, не возвращает никакого конкретного значения и предназначена
только для вызоыва с верхнего уровня.

После того, как процессы созданы, код планирования процссов вступает в управление
над ними. Этот код показан на Рисунке 21-2. Функция pick-process выбирает и 
запускает процесс с наивысшим приоритетом, который может быть перезапущен. Выбор
этого процесса является задачей most-urgent-process. Приостановленный процесс
может быть запущен, если у него нет функции ожидания, или его функция ожидания
wait возвращает истину. Среди приемлимых процессов выбирается тот, который имеет
наивысший приоритет. Выигравший процесс и значение возвращаемое его функцией wait
(если она есть) возвращаются в pick-process. Всегда будет какой-нибудь выигрышный
процесс, потому что процесс по умолчанию всегда хочет запуститься.

Оставшаяся часть кода на рисунке 21-2 определяет операторы используемые для
переключения управления между процессами. Стандартное выражение wait, как оно
используется в функции pedestrian на Рисунке 21-3. В этом примере, процесс
ждет, пока что-то не появиться в списке *open-doors*, а затем печатает
сообщение:

@example
> (ped)
>> (push 'door2 *open-doors*)
Entering DOOR2
>> (halt)
NIL
@end example

Ожидание(wait) по духу аналогично =bind (стр 267), и имеет те же ограничения, что
и последняя ее вычисление. Все, что мы хотим, чтобы произошло после  wait, должно
быть помещено в ее тело. Таким образом, если мы хотим, чтобы процесс ожидал несколько
раз, выражения ожидания должны быть вложенными. Утверждая факты предназначенные друг
для друга, процессы могут сотрудничать в достижении некоторой цели, как показано
на рисунке 21-4.

@cartouche
@lisp
 (defun pick-process ()
       (multiple-value-bind (p val) (most-urgent-process)
        (setq *proc* p
                  *procs* (delete p *procs*))
        (funcall (proc-state p) val)))

 (defun most-urgent-process ()
       (let ((proc1 *default-proc*) (max -1) (val1 t))
        (dolist (p *procs*)
          (let ((pri (proc-pri p)))
             (if (> pri max)
                   (let ((val (or (not (proc-wait p))
                                      (funcall (proc-wait p)))))
                     (when val
                       (setq proc1 p
                               max     pri
                               val1 val))))))
        (values proc1 val1)))

 (defun arbitrator (test cont)
       (setf (proc-state *proc*) cont
             (proc-wait *proc*) test)
       (push *proc* *procs*)
       (pick-process))

 (defmacro wait (parm test &body body)
       `(arbitrator #'(lambda () ,test)
                      #'(lambda (,parm) ,@@body)))

 (defmacro yield (&body body)
       `(arbitrator nil #'(lambda (,(gensym)) ,@@body)))

 (defun setpri (n) (setf (proc-pri *proc*) n))

 (defun halt (&optional val) (throw *halt* val))

 (defun kill (&optional obj &rest args)
       (if obj
          (setq *procs* (apply #'delete obj *procs* args))
          (pick-process)))
@end lisp

                         Рисунок 21-2: Планирование Процессов.
@end cartouche

@cartouche
@lisp
 (defvar *open-doors* nil)

 (=defun pedestrian ()
      (wait d (car *open-doors*)
        (format t "Entering ~A~%" d)))

 (program ped ()
      (fork (pedestrian) 1))
@end lisp

                      Рисунок 21-3: Один процесс с одним wait.
@end cartouche

Процессы, созданные из visitor(посетитель) и host(хоста), если им представлена одна
и та же дверь(door), обменяются управлением через сообщения на blackboard(черной доске):

@example
> (ballet)
Approach DOOR2. Open DOOR2. Enter DOOR2. Close DOOR2.
Approach DOOR1. Open DOOR1. Enter DOOR1. Close DOOR1.
>>
@end example

Существует еще один, более простой тип выражения ожидания(wait): yield, единственная
цель которого - дать возможноть другим процессам с более высоким приоритетом, работать.
Процесс может захотеть выполнить yield после выполнения выражения setpri, которое 
сбрасывает приоритет текущего процесса. Как и в случае wait, любой код, который будет
выполнен после выхода, должен быть помещен в его тело.

Программа на Рисунке 21-5 иллюстрирует, как два оператора работают вместе.
Изначально, у варваров(barbarians) было две цели: заватить(capture) Рим(Rome) и
разграбить(plunder) его. Зхват города имеет (немного) более высокий приоритет и
поэтому будет выполняться первым. Однако после захвата города приоритет 
процесса захвата уменьшается до 1. Затем происходит голосование, и стартует
процесс разрграбления(plunder), как процесс с наивысшим приоритетом.

@example
> (barbarians)
Liberating ROME.
Nationalizing ROME.
Refinancing ROME.
Rebuilding ROME.
>>
@end example

Только после того, как варвары(barbarians) разграбили римские дворцы и освободили
за выкуп патрициев, процесс захвата возобновляется, и варвары начинают укреплять
свои позиции.

В основе выражений wait лежит более общий арбитр(arbitrator). Эта функция
сохраняет текущий процесс, а затем вызывает  процесс выбора(pick-process)
для того чтобы запустить какой-либо процесс

@cartouche
@lisp
 (defvar *bboard* nil)

 (defun claim          (&rest f) (push f *bboard*))

 (defun unclaim (&rest f) (pull f *bboard* :test #'equal))

 (defun check          (&rest f) (find f *bboard* :test #'equal))

 (=defun visitor (door)
       (format t "Approach ~A. " door)
       (claim 'knock door)
       (wait d (check 'open door)
         (format t "Enter ~A. " door)
         (unclaim 'knock door)
         (claim 'inside door)))

 (=defun host (door)
       (wait k (check 'knock door)
         (format t "Open ~A. " door)
         (claim 'open door)
         (wait g (check 'inside door)
            (format t "Close ~A.~%" door)
            (unclaim 'open door))))

 (program ballet ()
       (fork (visitor 'door1) 1)
       (fork (host 'door1) 1)
       (fork (visitor 'door2) 1)
       (fork (host 'door2) 1))
@end lisp

                  Рисунок 21-4: Синхронизация с черной доской.
@end cartouche

@noindent
(возможно тот же самый) запускает снова. Ему передаются два аргумента: тестовая
функция и продолжение. Первый будет сохранен как процедура ожидания wait процесса,
который будет приостановлен, и  будет вызвана позже , чтобы определить, можно
ли его перезапустить. Последний станет состоянием процесса proc-state, и его
вызов перезапустит приостановленный процесс.

Макросы wait и yield создают продолжение этой функции, просто заключив ее в 
тело в лямбда выражение. Например,

@lisp
(wait d (car *bboard*) (=values d))
@end lisp

@cartouche
@lisp
 (=defun capture (city)
    (take city)
    (setpri 1)
    (yield
        (fortify city)))

 (=defun plunder (city)
    (loot city)
    (ransom city))

 (defun take (c)           (format t "Liberating ~A.~%" c))
 (defun fortify (c) (format t "Rebuilding ~A.~%" c))
 (defun loot (c)           (format t "Nationalizing ~A.~%" c))
 (defun ransom (c) (format t "Refinancing ~A.~%" c))

 (program barbarians ()
    (fork (capture 'rome) 100)
    (fork (plunder 'rome) 98))
@end lisp

                    Рисунок 21-5: Влияние изменения приоритетов.
@end cartouche

@noindent
расширяется в:

@lisp
(arbitrator #'(lambda () (car *bboard*))
                 #'(lambda (d) (=values d)))
@end lisp

Если код подчиняется ограниченям, перечисленным на Рисунке 20-5, созданное замыкание
тела ожидания(wait) сохранит все  текущие продолжения. Вместе с его расширением 
=values второй аргумент становиться:

@lisp
#'(lambda (d) (funcall *cont* d))
@end lisp

Поскольку замыкание содержит ссылку на *cont*, приостановленный процесс с этой
функцией ожидания будет иметь указатель того, куда он направлялся во время
приостановки.

Оператор остановки(halt) останавливает всю программу, возвращая управление обратно
тегу установленному расширением program. Он принимает необязательный аргумент, 
который будет возвращаен в качестве значения program. Поскольку процесс по умолчанию
всегда готов к запуску, единственный способ завершить программу явный вызов halt. 
Неважно, какой код следует за halt, поскольку он никогда не будет вычисляться.

Отдельные процессы можно убивать вызвав kill. Если нет аргументов, этот оператор
убивает текущий процесс. В этолм случае, kill напоминает выражение wait, которое
игнорирует сохранение текущего процесса. Если заданы аргументы для kill, они 
становяться аргументами для  удаления(delete) в списке процессов. В текущем коде,
мало что можно сказать о выражении kill, поскольку процессы не имеют можества 
свойств, на которые можно ссылаться. Однако более сложная система будет ассоциировать
больше информации с процессами - отметки времени, владельцы и так далее. Процесс по
умолчанию не может быть уничтожен, поскольку он не сохраняется в списке *procs*.

@node 21-3 The Less-than-Rapid Prototype,  , 21-2 Implementation, 21 Multiple Processes
@comment  node-name,  next,  previous,  up
@section 21-3 Меньше чем быстрый прототип
@cindex 21-3 The Less-than-Rapid Prototype

Процессы, смоделированные с продожениями, не будут столь же эффективны. как процессы
реальной операционной системы. Какая польза от программ, подобных той, что приведена
в этой главе?

Такие программы полезны так же, как эскизы(наброски). В исследовательском 
программировании или быстром прототипировании, программа является не самоцелью,
а средством выражения(реализации) свой идей. Во многих других областях, то что служит
этой цели называется эскизом. Архитектор, в принципе, мог бы спроектировать целое
здание в своей голове. Тем не менее, большинство архитекторов, кажется думают лучше
с карандашами в руках: дизайн здания обычно разрабатывается в виде серии предварительных
набросков.

Быстрое прототипирование - это набросок программы. Как и первые наброски архитектора,
программные прототипы, как правило, рисуются несколькими быстрыми штрихами. Соображения
стоимости и эффективности вначале игнорируются до разработки идеи в полной мере.
Результатом, на этом этапе может стать невыстраиваемое здание или безнадежно неэффективная
часть программы. Но эскизы все равно ценны,потому что

@enumerate
@item
Они излагают информацию кратко.
@item
Они предлагают возможность поэксперементировать.
@end enumerate

Программа описанная в этой главе, как и в последующих главах, представляет собой
эскиз. Он передает очертания много процессной обработки в нескольких широких
штихах. И хотя он будет достаточно эффективным для использования в производственном
программном обеспечении, он может быть весьма полезен для экспериментов с другими
аспектами много процессности, такими как алгоритмы планирования.

В главах 22-­24 представлены другие применения продолжений. Ни одно из них не является
достаточно эффективным для использования в производстве программного обеспечения.
Поскольку  Lisp и быстрое проттипрование развивались вместе, Lisp включает в себя
множество функций, специально предназначенных для проттипирования: неэффективных
но удобных функций, таких как списки свойств(property lists), параметры ключевые слова,
и в этом отношении списки. Продолжения, вероятно, относяться к этой категории. Они
сохраняют больше состояния чем требуется программе. Так что наша реализация Prolog, 
например, является хорошим способом понимания языка, но не эффективным способом 
его реализации.

Эта книга больше посвящена тем типам абстракций, которе можно построить на Lisp,
чем вопросам эффективности. Тем не менее, важно понимать, что Lisp это язык
для написания производственных программ, а также язык для написания прототипов.
Если Lisp и имеет репутацию медленного языка, то это во многом потому, что
что многие программисты останавливаются на прототипе. Это просто писать на
Lisp быстрые программы. К сожалению, еще легче писать на нем медленные.
Начальная версия программы Lisp похожа на бриллиант: маленькая, чистая и 
очень дорогая. Может быть великим искушением оставить ее в этом состоянии.

В других языках, как только вы преуспеете в трудной задаче, заставить вашу программу
работать, она уже может быть приемлемо эффективной. Если вы выложите пол плиткой
размером с ноготь вашего большого пальца, ваши отходы будут небольшими. Кто-то
привыкший к разработке программного обеспечения по этому принципу, может столкнуться
с трудностями при преодолении идеи, что когда программа работает, она закончена. 
"В Lisp вы можете писать программы в кратчайшие сроки," - может подумать он - "но они
медленные.". На самом деле, это не так.  Вы можете получить быстрые программы, но вы
должны работать для этого. В этом отношении, использование Lisp похоже жизни
в богатой стране, а не в бедной: может показаться прискорбным, что нужно работать
чтобы остаться худым, но конечно это лучше, чем работать чтобы остаться в живых, и
конечно быть худым, как само собо разумещееся.

В менее абстрактных языках вы работаете над функциональностью. В Lisp вы работаете
над скоростью. К счастью, работать над скоростью проще: у большинства программ есть
только несколько критических разделов, в которых скорость имеет значение.