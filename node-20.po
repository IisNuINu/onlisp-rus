#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-20.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 12:14+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-20.texi:5
msgid ""
"@node 20 Continuations, 21 Multiple Processes, 19 A Query Compiler, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 20 Continuations\n"
"@cindex 20 Continuations"
msgstr ""
"@node 20 Continuations, 21 Multiple Processes, 19 A Query Compiler, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 20 Продолжения\n"
"@cindex 20 Continuations"

#: texi/node-20.texi:13
msgid ""
"A continuation is a program frozen in action: a single functional object "
"containing\n"
"the state of a computation. When the object is evaluated, the stored "
"computation\n"
"is restarted where it left off. In solving certain types of problems it can "
"be\n"
"a great help to be able to save the state of a program and restart it later. "
"In\n"
"multiprocessing, for example, a continuation conveniently represents a "
"suspended\n"
"process. In nondeterministic search programs, a continuation can represent a "
"node\n"
"in the search tree."
msgstr ""
"Продолжение - это программа, замороженная в действии: единый/отдельный "
"функциональный объект\n"
"содержащий состояние вычисления. Когда объект вычисляется, сохраненное\n"
"вычисление перезапускается с того места, где оно было остановлено. При "
"решении\n"
"определенных типов проблем может быть полезно сохранить состояние программы "
"и \n"
"перезапустить её позже. Например в многопроцессной обработке продолжение\n"
"представляет собой приостановленный процесс. В недетерминированных "
"программах\n"
"поиска продолжение может представлять собой узел в дереве поиска."

#: texi/node-20.texi:20
msgid ""
"Continuations can be difficult to understand. This chapter approaches the\n"
"topic in two steps. The first part of the chapter looks at the use of "
"continuations in\n"
"Scheme, which has built-in support for them. Once the behavior of "
"continuations\n"
"has been explained, the second part shows how to use macros to build "
"continuations\n"
"in Common Lisp programs. Chapters 21­24 will all make use of the macros\n"
"defined here."
msgstr ""
"Продолжения могут быть трудными для понимания. Эта глава подходит к теме в "
"два этапа.\n"
"В первой части главы рассматривается использование продолжений в  Scheme, в "
"которую\n"
"встроена их поддержка. После объяснения поведения продолжений, во второй "
"части показано,\n"
"как использовать макросы для создания продолжений в программах Common Lisp. "
"Главы 21-­24\n"
"используют макросы определенные здесь."

#: texi/node-20.texi:26
msgid ""
"@menu\n"
"* 20-1 Scheme Continuations::   \n"
"* 20-2 Continuation-Passing Macros::  \n"
"* 20-3 Code-Walkers and CPS Conversion::  \n"
"@end menu"
msgstr ""

#: texi/node-20.texi:31
msgid ""
"@node 20-1 Scheme Continuations, 20-2 Continuation-Passing Macros, 20 "
"Continuations, 20 Continuations\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 20-1 Scheme Continuations\n"
"@cindex 20-1 Scheme Continuations"
msgstr ""
"@node 20-1 Scheme Continuations, 20-2 Continuation-Passing Macros, 20 "
"Continuations, 20 Continuations\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 20-1 Продолжения Scheme\n"
"@cindex 20-1 Scheme Continuations"

#: texi/node-20.texi:36
msgid ""
"One of the principal ways in which Scheme differs from Common Lisp is its\n"
"explicit support for continuations. This section shows how continuations "
"work in\n"
"Scheme. (Figure 20-1 lists some other differences between Scheme and Common\n"
"Lisp.)"
msgstr ""
"Одним из основных отличий Scheme от Common Lisp является явная поддержка "
"продлжений.\n"
"В этом разделе показано, как работают продолжения в Scheme. (На Рисунке 20-1 "
"перечислены\n"
"некоторые другие различия между Scheme и Common Lisp.)"

#: texi/node-20.texi:40
msgid ""
"A continuation is a function representing the future of a computation. "
"When-\n"
"ever an expression is evaluated, something is waiting for the value it will "
"return.\n"
"For example, in"
msgstr ""
"Продолжение это функция, представляющая будущее вычислений. Всякий раз, "
"когда выражение\n"
"вычисляется, что-то(другое выражение) ждет значения, которое оно вернет.\n"

#: texi/node-20.texi:47
msgid ""
"@enumerate\n"
"@item\n"
"Scheme makes no distinction between what Common Lisp calls the symbol-value "
"and\n"
"symbol-function of a symbol. In Scheme, a variable has a single value, which "
"can\n"
"be either a function or some other sort of object. Thus there is no need "
"for\n"
"sharp-quote or funcall in Scheme. The Common Lisp:"
msgstr ""
"@cartouche\n"
"@enumerate\n"
"@item\n"
"Scheme не делает различий между тем, что Common Lisp называет символ-"
"значение и\n"
"символ-функция символа. В Scheme, переменная имеет единственное значение, "
"которое\n"
"может быть либо функцией или каким-либо другим видом объекта. Таким образом, "
"в\n"
"Scheme нет необходимости использовать решётку с кавычкой(#') или funcall. \n"
"Common Lisp:"

#: texi/node-20.texi:52
msgid ""
"@lisp\n"
" (let ((f #'(lambda (x) (1+ x))))\n"
"   (funcall f 2))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:55
msgid ""
"@noindent\n"
"would be in Scheme:"
msgstr ""
"@noindent\n"
"будет на Scheme:"

#: texi/node-20.texi:60
msgid ""
"@lisp\n"
" (let ((f (lambda (x) (1+ x))))\n"
"   (f 2))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:70
msgid ""
"@item\n"
"Since Scheme has only one name-space, it doesn't need separate operators\n"
"(e.g. defun and setq) for assignments in each. Instead it has define, which\n"
"is roughly equivalent to defvar, and set!, which takes the place of setq.\n"
"Global variables must be created with define before they can be set with\n"
"set!.\n"
"@item\n"
"In Scheme, named functions are usually defined with define, which takes\n"
"the place of defun as well as defvar. The Common Lisp:"
msgstr ""
"@item\n"
"Поскольку у Scheme есть только одно пространство имен, ей не нужны "
"отдельные\n"
"операторы (например defun и setq) для присваивания значений в случае "
"функции\n"
"или переменной. Вместо этого она имеет определение, которое примерно "
"эквивалентно\n"
"defvar, и set! - которое заменяет setq.\n"
"Глобальные переменные должны быть созданы с помощью define, прежде чем они "
"могут\n"
"быть установлены с помощью set!.\n"
"@item\n"
"В Scheme, именованные функции обычно определяются с помощью define, который "
"заменяет\n"
"defun и defvar. Common Lisp:"

#: texi/node-20.texi:74
msgid ""
"@lisp\n"
" (defun foo (x) (1+ x))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:77
msgid ""
"@noindent\n"
"has two possible Scheme translations:"
msgstr ""
"@noindent\n"
"Scheme имеет два возможных варианта:"

#: texi/node-20.texi:82
msgid ""
"@lisp\n"
" (define foo (lambda (x) (1+ x)))\n"
" (define (foo x) (1+ x))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:98
msgid ""
"@item\n"
"In Common Lisp, the arguments to a function are evaluated left-to-right. In\n"
"Scheme, the order of evaluation is deliberately unspecified. (And "
"implementors\n"
"delight in surprising those who forget this.)\n"
"@item\n"
"Instead of t and nil, Scheme has #t and #f. The empty list, (), is true in\n"
"some implementations and false in others.\n"
"@item\n"
"The default clause in cond and case expressions has the key else in\n"
"Scheme, instead of t as in Common Lisp.\n"
"@item\n"
"Several built-in operators have different names: consp is pair?, null is\n"
"null?, mapcar is (almost) map, and so on. Ordinarily these should be "
"obvious\n"
"from the context.\n"
"@end enumerate"
msgstr ""
"@item\n"
"В Common Lisp, аргументы функции вычисляются слева на право. В Scheme, "
"порядок\n"
"вычисления намеренно не указан. (И разработчики радуются удивлению тех, кто "
"про\n"
"это забывает.)\n"
"@item\n"
"Вместо t и nil, в Scheme есть #t и #f. Пустой списокt, (), в некоторых "
"реализациях\n"
"имеет значение истина, а в других ложь.\n"
"@item\n"
"Предложение по умолчанию в выражениях cond и case имеет ключ else в Scheme, "
"а\n"
"не t как в Common Lisp.\n"
"@item\n"
"Несколько встроенных операторов имеют разные имена: consp это pair?, null "
"это\n"
"null?, mapcar это (почти) map, и так далее. Обычно это должно быть очевидно\n"
"из контекста.\n"
"@end enumerate"

#: texi/node-20.texi:100
msgid "        Figure 20-1: Some differences between Scheme and Common Lisp."
msgstr ""
"        Рисунок 20-1: Несколько отличий между Scheme и Common Lisp.\n"
"@end cartouche"

#: texi/node-20.texi:104
msgid ""
"@lisp\n"
"(/ (- x 1) 2)\n"
"@end lisp"
msgstr ""
"  Например, в\n"
"\n"
"@lisp\n"
"(/ (- x 1) 2)\n"
"@end lisp"

#: texi/node-20.texi:108
msgid ""
"when (-x1)is evaluated, the outer / expression is waiting for the value, "
"and\n"
"something else is waiting for its value, and so on and so on, all the way "
"back to\n"
"the toplevel-where print is waiting."
msgstr ""
"когда (- x 1) вычисляется, внешнее выражение / ожидает его значения, а что-"
"то еще\n"
"ожидает значения выражения / и так далее, и так далее, вплоть до верхнего "
"уровня-\n"
"где ожидает print(в цикле REPL)."

#: texi/node-20.texi:112
msgid ""
"We can think of the continuation at any given time as a function of one\n"
"argument. If the previous expression were typed into the toplevel, then when "
"the\n"
"subexpression (-x1)was evaluated, the continuation would be:"
msgstr ""
"Мы можем думать о продолжении в любой момент времени как о фунции одного "
"аргумента.\n"
"Если предыдущее выражение было введено на верхнем уровне, то при вычислении\n"
"подвыражения (- x 1), продолжение будет:"

#: texi/node-20.texi:116
msgid ""
"@lisp\n"
"(lambda (val) (/ val 2))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:120
msgid ""
"That is, the remainder of the computation could be duplicated by calling "
"this\n"
"function on the return value. If instead the expression occurred in the "
"following\n"
"context"
msgstr ""
"То есть, оставшаяся часть вычисления может быть продублирована путем вызова "
"этой\n"
"функции для возвращаемого значения. Если вместо выражения встречающегося в\n"
"следующем контексте"

#: texi/node-20.texi:125
msgid ""
"@lisp\n"
"(define (f1 w)\n"
"  (let ((y (f2 w)))\n"
"        (if (integer? y) (list 'a y) 'b)))"
msgstr ""

#: texi/node-20.texi:129
msgid ""
"(define (f2 x)\n"
"  (/ (- x 1) 2))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:132
msgid ""
"and f1 were called from the toplevel, then when (- x 1) was evaluated, the\n"
"continuation would be equivalent to"
msgstr ""
"и f1 был вызван из верхнего уровня, тогда когда (- x 1) был вычислен, \n"
"продолжение будет эквивалентно"

#: texi/node-20.texi:138
msgid ""
"@lisp\n"
"(lambda (val)\n"
"  (let ((y (/ val 2)))\n"
"        (if (integer? y) (list 'a y) 'b)))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:144
msgid ""
"In Scheme, continuations are first-class objects, just like functions. You "
"can\n"
"ask Scheme for the current continuation, and it will make you a function of "
"one\n"
"argument representing the future of the computation. You can save this "
"object for\n"
"as long as you like, and when you call it, it will restart the computation "
"that was\n"
"taking place when it was created."
msgstr ""
"В Scheme, продолжения яляются объектами первого класса, как и функции. Вы "
"можете\n"
"запросить у Scheme текущее продолжение, и она создаст вам функцию от одного "
"аргумента,\n"
"представляющую будущие вычисления. Вы можете хранить этот объект так долго, "
"как захотите,\n"
"и при вызове он перезапустит вычисление, которое имело место при его "
"создании."

#: texi/node-20.texi:151
msgid ""
"Continuations can be understood as a generalization of closures. A closure "
"is\n"
"a function plus pointers to the lexical variables visible at the time it was "
"created.\n"
"A continuation is a function plus a pointer to the whole stack pending at "
"the time\n"
"it was created. When a continuation is evaluated, it returns a value using "
"its own\n"
"copy of the stack, ignoring the current one. If a continuation is created at "
"T 1 and\n"
"evaluated at T2, it will be evaluated with the stack that was pending at T1."
msgstr ""
"Продолжение можно понимать как обобщение замыканий. Замыкание это функция "
"плюс указатели\n"
"на лексические переменные, видимые во время его создания. Продолжение "
"является функцией\n"
"плсю указатель на весь стек, ожидающий ее в момент создания. Когда "
"продолжение вычисляется,\n"
"оно возвращает значение, используя собственную копию стека, игнорируя "
"текущий стек. Если\n"
"продолжение создано в момент T1 и вычисляется в момент T2, оно будет "
"вычисляться с помощью \n"
"стека, ожидающего в момент T1."

#: texi/node-20.texi:155
msgid ""
"Scheme programs have access to the current continuation via the built-in\n"
"operator call-with-current-continuation (call/cc for short). When a\n"
"program calls call/cc on a function of one argument:"
msgstr ""
"Программы Scheme имеют доступ к текущему продолжению через встроенный "
"оператор\n"
"call-with-current-continuation (call/cc для краткости). Когда программа "
"вызывает\n"
"call/cc для функции с одним аргументом:"

#: texi/node-20.texi:163
msgid ""
"@lisp\n"
"(call-with-current-continuation\n"
"  (lambda (cc)\n"
"        ...))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:167
msgid ""
"the function will be passed another function representing the current "
"continuation.\n"
"By storing the value of cc somewhere, we save the state of the computation "
"at the\n"
"point of the call/cc."
msgstr ""
"функции будет передана другая функция, представляющая текущее продолжение.\n"
"Сохраняя где-то значение cc, мы сохраняем состояние вычисления в точке\n"
"call/cc."

#: texi/node-20.texi:170
msgid ""
"In this example, we append together a list whose last element is the value\n"
"returned by a call/cc expression:"
msgstr ""
"В этом примере, мы добавляем список, последним элементом которого является\n"
"значение, возвращаемое выражением call/cc:"

#: texi/node-20.texi:181
msgid ""
"@example\n"
"> (define frozen)\n"
"FROZEN\n"
"> (append '(the call/cc returned)\n"
"                 (list (call-with-current-continuation\n"
"                         (lambda (cc)\n"
"                           (set! frozen cc)\n"
"                           'a))))\n"
"(THE CALL/CC RETURNED A)\n"
"@end example"
msgstr ""

#: texi/node-20.texi:184
msgid ""
"The call/cc returns a, but first saves the continuation in the global "
"variable\n"
"frozen."
msgstr ""
"call/cc возвращает символ a, но сначала сохраняет продолжение в глобальной \n"
"переменной frozen."

#: texi/node-20.texi:187
msgid ""
"Calling frozen will restart the old computation at the point of the call/"
"cc.\n"
"Whatever value we pass to frozen will be returned as the value of the call/"
"cc:"
msgstr ""
"Вызов frozen перезапустит старое вычисление в точке call/cc. Какое бы "
"значение\n"
"мы не передали frozen оно будет возвращено как значение call/cc:"

#: texi/node-20.texi:192
msgid ""
"@example\n"
"> (frozen 'again)\n"
"(THE CALL/CC RETURNED AGAIN)\n"
"@end example"
msgstr ""

#: texi/node-20.texi:195
msgid ""
"Continuations aren't used up by being evaluated. They can be called "
"repeatedly,\n"
"just like any other functional object:"
msgstr ""
"Продолжения не исчерпываются(заканчиваютс) вычислением. Их можно вызывать "
"повторно, \n"
"как и любой другой функциональный объект:"

#: texi/node-20.texi:202
msgid ""
"@example\n"
"> (frozen 'thrice)\n"
"(THE CALL/CC RETURNED THRICE)\n"
"@end example\n"
"   When we call a continuation within some other computation, we see more\n"
"clearly what it means to return back up the old stack:"
msgstr ""
"@example\n"
"> (frozen 'thrice)\n"
"(THE CALL/CC RETURNED THRICE)\n"
"@end example\n"
"   Когда мы вызываем продолжение в каком-то другом вычислении, мы более\n"
"ясно видим, что значит вернуть обратно старый стек:"

#: texi/node-20.texi:207
msgid ""
"@example\n"
"> (+ 1 (frozen 'safely))\n"
"(THE CALL/CC RETURNED SAFELY)\n"
"@end example"
msgstr ""

#: texi/node-20.texi:212
msgid ""
"Here, the pending + is ignored when frozen is called. The latter returns up\n"
"the stack that was pending at the time it was first created: through list, "
"then\n"
"append, to the toplevel. If frozen returned a value like a normal function "
"call,\n"
"the expression above would have yielded an error when + tried to add 1 to a "
"list."
msgstr ""
"Здесь, ожидающий \"+\" игнорируется, когда вызывается frozen. Последний "
"возвращает\n"
"стек, который находился в состоянии ожидания в момент его создания: через "
"list, \n"
"затем append, и на верхний уровень, к печати результата. Если бы значение "
"frozen\n"
"венулось, как при обычном вызове функции, вышепреведенная операция привела "
"бы\n"
"к возникновению ошибки, когда + попробовал бы сложить 1 со списком."

#: texi/node-20.texi:216
msgid ""
"Continuations do not get unique copies of the stack. They may share "
"variables\n"
"with other continuations, or with the computation currently in progress. In "
"this\n"
"example, two continuations share the same stack:"
msgstr ""
"Продолжения не получают уникальной копии стека. Они могут разделять "
"переменные с \n"
"другими продолжениями или с текущими вычислениями. В этом примере два "
"продолжения\n"
"используют один и тот же стек:"

#: texi/node-20.texi:235
msgid ""
"@example\n"
"> (define froz1)\n"
"FROZ1\n"
"> (define froz2)\n"
"FROZ2\n"
"> (let ((x 0))\n"
"        (call-with-current-continuation\n"
"              (lambda (cc)\n"
"               (set! froz1 cc)\n"
"               (set! froz2 cc)))\n"
"        (set! x (1+ x))\n"
"        x)\n"
"1\n"
"@end example"
msgstr ""

#: texi/node-20.texi:237
msgid "so calls to either will return successive integers:"
msgstr ""
"поэтому вызов любого из них будет возвращать последовательные\n"
"целые числа:"

#: texi/node-20.texi:244
msgid ""
"@example\n"
"> (froz2 ())\n"
"2> (froz1 ())\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-20.texi:247
msgid ""
"Since the value of the call/cc expression will be discarded, it doesn't "
"matter\n"
"what argument we give to froz1 and froz2."
msgstr ""
"Так как значение выражения call/cc будет отброшено, не имеет значения какой "
"аргумент\n"
"мы дадим froz1 и froz2."

#: texi/node-20.texi:253
msgid ""
"Now that we can store the state of a computation, what do we do with it?\n"
"Chapters 21­24 are devoted to applications which use continuations. Here we\n"
"will consider a simple example which conveys well the flavor of programming\n"
"with saved states: we have a set of trees, and we want to generate lists "
"containing\n"
"one element from each tree, until we get a combination satisfying some "
"condition."
msgstr ""
"Теперь, когда мы можем сохранять состояние вычислений, что нам с ними "
"делать?\n"
"Главы 21-­24 посвящены приложениям, в которых используются продолжения. Здесь "
"мы \n"
"рассмотрим простой пример, который хорошо передает вкус программирования с "
"сохраненными\n"
"состояниями: у нас есть набор деревьев и мы хотим генерировать списки, "
"содержащие один\n"
"элемент из каждого дерева, пока мы не получим комбинацию, удовлетворяющую "
"некоторому\n"
"условию."

#: texi/node-20.texi:260
msgid ""
"Trees can be represented as nested lists. Page 70 described a way to "
"represent\n"
"one kind of tree as a list. Here we use another, which allows interior nodes "
"to have\n"
"(atomic) values, and any number of children. In this representation, an "
"interior\n"
"node becomes a list; its car contains the value stored at the node, and its "
"cdr\n"
"contains the representations of the node's children. For example, the two "
"trees\n"
"shown in Figure 20-2 can be represented:"
msgstr ""
"Деревья могут быть представлены в виде вложенных списков. На странице 70 "
"описан\n"
"способ представленя одного вида деревьев в виде списка. Здесь мы используем "
"другой,\n"
"который позволяет внутренним узлам иметь (атомарные) значения и любое "
"количество\n"
"дочерних элементов. В этом представлении внутренний узел становится списком, "
"его\n"
"начало(car) содержит значение, хранящееся в узле(node) и его хвост(cdr) "
"содержит\n"
"представления дочерних узлов. Например, два дерева, показанные на рисунке "
"20-2 \n"
"могут быть представлены как:"

#: texi/node-20.texi:265
msgid ""
"@lisp\n"
"(define t1 '(a (b (d h)) (c e (f i) g)))\n"
"(define t2 '(1 (2 (3 6 7) 4 5)))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:270
msgid ""
"Figure 20-3 contains functions which do depth-first traversals on such "
"trees. In\n"
"a real program we would want to do something with the nodes as we "
"encountered\n"
"them. Here we just print them. The function dft, given for comparison, does "
"an\n"
"ordinary depth-first traversal:"
msgstr ""
"На Рисунке 20-3 показаны функции, которые выполняют обход в глубину на "
"таких \n"
"деревьях. В реальной программе мы хотели бы что-то сделать с узлами, когда "
"мы\n"
"встречаемся с ними. Здесь мы просто печатаем их. Функция dft, приведенная "
"для\n"
"сравнения, выполняет обычный обход в глубину:"

#: texi/node-20.texi:276
msgid ""
"@example\n"
"> (dft t1)\n"
"ABDHCEFIG()\n"
"@end example"
msgstr ""

#: texi/node-20.texi:292
msgid "                                Figure 20-2: Two Trees."
msgstr ""
"@cartouche\n"
"\n"
"\n"
"\n"
"                                Рисунок 20-2: Два Дерева.\n"
"@end cartouche"

#: texi/node-20.texi:297
msgid ""
"The function dft-node follows the same path through the tree, but deals out\n"
"nodes one at a time. When dft-node reaches a node, it follows the car of "
"the\n"
"node, and pushes onto *saved* a continuation to explore the cdr."
msgstr ""
"Функция dft-node следует тому же пути через дерево, но обрабатывает узлы по\n"
"одному за раз. Когда dft-node достигает узла, она следует за началом(car) "
"узла,\n"
"и заталкивает в *saved* продолжение для исследования хвоста узла(cdr)."

#: texi/node-20.texi:302
msgid ""
"@example\n"
"> (dft-node t1)\n"
"A\n"
"@end example"
msgstr ""

#: texi/node-20.texi:305
msgid ""
"Calling restart continues the traversal, by popping the most recently saved\n"
"continuation and calling it."
msgstr ""
"Вызов перезапуска(restart) продолжает обход, выдавая последнее сохраненное\n"
"продолжение и вызывая его."

#: texi/node-20.texi:311
msgid ""
"@example\n"
"> (restart)\n"
"B\n"
"@end example"
msgstr ""

#: texi/node-20.texi:314
msgid ""
"Eventually there will be no saved states left, a fact which restart signals "
"by\n"
"returning done:"
msgstr ""
"В конечном итоге не останется ни одного сохраненного состояния, условие "
"которое\n"
"давало сигнал перезапуска продолжений вернет done:"

#: texi/node-20.texi:321
msgid ""
"@example\n"
"...> (restart)\n"
"G> (restart)\n"
"DONE\n"
"@end example"
msgstr ""

#: texi/node-20.texi:323
msgid "Finally, the function dft2 neatly packages up what we just did by hand:"
msgstr ""
"Наконец, функция dft2 аккуратно упаковывает то, что мы только что сделали\n"
"в ручную:"

#: texi/node-20.texi:329
msgid ""
"@example\n"
"> (dft2 t1)\n"
"ABDHCEFIG()\n"
"@end example"
msgstr ""

#: texi/node-20.texi:340
msgid ""
"@lisp\n"
" (define (dft tree)\n"
"       (cond ((null? tree) ())\n"
"               ((not (pair? tree)) (write tree))\n"
"               (else (dft (car tree))\n"
"                        (dft (cdr tree)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (define (dft tree)\n"
"       (cond ((null? tree) ())\n"
"               ((not (pair? tree)) (write tree))\n"
"               (else (dft (car tree))\n"
"                        (dft (cdr tree)))))"

#: texi/node-20.texi:342
msgid " (define *saved* ())"
msgstr ""

#: texi/node-20.texi:353
msgid ""
" (define (dft-node tree)\n"
"       (cond ((null? tree) (restart))\n"
"               ((not (pair? tree)) tree)\n"
"               (else (call-with-current-continuation\n"
"                           (lambda (cc)\n"
"                             (set! *saved*\n"
"                                     (cons (lambda ()\n"
"                                                (cc (dft-node (cdr tree))))\n"
"                                             *saved*))\n"
"                             (dft-node (car tree)))))))"
msgstr ""

#: texi/node-20.texi:360
msgid ""
" (define (restart)\n"
"       (if (null? *saved*)\n"
"            'done\n"
"            (let ((cont (car *saved*)))\n"
"               (set! *saved* (cdr *saved*))\n"
"               (cont))))"
msgstr ""

#: texi/node-20.texi:368
msgid ""
" (define (dft2 tree)\n"
"       (set! *saved* ())\n"
"       (let ((node (dft-node tree)))\n"
"         (cond ((eq? node 'done) ())\n"
"                 (else (write node)\n"
"                           (restart)))))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:370
msgid "                     Figure 20-3: Tree traversal using continuations."
msgstr ""
"                     Рисунок 20-3: Проход по Дереву используя продолжения.\n"
"@end cartouche"

#: texi/node-20.texi:375
msgid ""
"Notice that there is no explicit recursion or iteration in the definition of "
"dft2: suc-\n"
"cessive nodes are printed because the continuations invoked by restart "
"always\n"
"return back through the same cond clause in dft-node."
msgstr ""
"Обратите внимание, что в определении dft2 нет явной рекурсии или итерации: "
"печатаются\n"
"последовательные узлы, потому что продолжения вызываемые restart всегда "
"возвращаются\n"
"через одно и тоже условие cond в dft-node."

#: texi/node-20.texi:383
msgid ""
"This kind of program works like a mine. It digs the initial shaft by "
"calling\n"
"dft-node. So long as the value returned is not done, the code following the "
"call\n"
"to dft-node will call restart, which sends control back down the stack "
"again.\n"
"This process continues until the return value signals that the mine is "
"empty. Instead\n"
"of printing this value, dft2 returns #f. Search with continuations "
"represents a\n"
"novel way of thinking about programs: put the right code in the stack, and "
"get the\n"
"result by repeatedly returning up through it."
msgstr ""
"Такая программа работает как рудник. Она копает начальную шахту вызывая\n"
"dft-node. Пока возвращаемое значение не будет done, код следующий за "
"вызовом\n"
"dft-node будет вызывать restart, который снова возвращает управление "
"обратно\n"
"в стек.\n"
"Этот процесс продолжается, пока возвращаемое значение не сигнализирует, что\n"
"рудник пуст. Вместо печати этого значения, dft2 возвращает #f. Поиск с "
"продолжениями\n"
"представляет собой новый способ мышления о программах: поместите правильный "
"код\n"
"в стек и получите результат, многократно возвращаясь к нему."

#: texi/node-20.texi:388
msgid ""
"If we only want to traverse one tree at a time, as in dft2, then there is "
"no\n"
"reason to bother using this technique. The advantage of dft-node is that we "
"can\n"
"have several instances of it going at once. Suppose we have two trees, and "
"we\n"
"want to generate, in depth-first order, the cross-product of their elements."
msgstr ""
"Если мы хотим проходить только одно дерево за раз, как в dft2, то нет "
"смысла \n"
"использовать эту технику. Преимущество dft-node в том, что у нас может быть\n"
"несколько экземпляров одновременно. Предположим, у нас есть два дерева, и "
"мы\n"
"хотим сгенерировать, в порядке поиска в глубину, перекрестное произведение\n"
"их элементов."

#: texi/node-20.texi:404
msgid ""
"@example\n"
"> (set! *saved* ())\n"
"()\n"
"> (let ((node1 (dft-node t1)))\n"
"        (if (eq? node1 'done)\n"
"             'done\n"
"             (list node1 (dft-node t2))))\n"
"(A 1)\n"
"> (restart)\n"
"(A 2)\n"
"...> (restart)\n"
"(B 1)\n"
"@end example\n"
"..."
msgstr ""

#: texi/node-20.texi:414
msgid ""
"Using normal techniques, we would have had to take explicit steps to save "
"our\n"
"place in the two trees. With continuations, the state of the two ongoing "
"traversals\n"
"is maintained automatically. In a simple case like this one, saving our "
"place in\n"
"the tree would not be so difficult. The trees are permanent data structures, "
"so at\n"
"least we have some way of getting hold of \"our place\" in the tree. The "
"great thing\n"
"about continuations is that they can just as easily save our place in the "
"middle of\n"
"any computation, even if there are no permanent data structures associated "
"with\n"
"it. The computation need not even have a finite number of states, so long as "
"we\n"
"only want to restart a finite number of them."
msgstr ""
"Используя обыные методы, нам пришлось бы предпринять явные шаги, чтобы "
"сохранять\n"
"наше положение на двух деревьях. С продолжениями состояние двух текущих "
"обходов\n"
"поддерживается автоматически. В таком простом случае, как этот, сохранить "
"наше \n"
"место на дереве не так уж и сложно. Деревья являются постоянными структурами "
"данных,\n"
"поэтому, по крайней мере, у нас есть какой-то способ получить \"наше место\" "
"на дереве.\n"
"Самое замечательное в продолжениях заключается в том, что они могут так же "
"легко,\n"
"сохранить наше местоположение в середине любого вычисления, даже если с ним "
"не\n"
"связаны постоянные структуры данных. Вычислениея не должны даже иметь "
"конечного\n"
"числа состояний, если мы только хотим перезапустить конечное число из них."

#: texi/node-20.texi:421
msgid ""
"As Chapter 24 will show, both of these considerations turn out to be "
"important\n"
"in the implementation of Prolog. In Prolog programs, the \"search trees\" "
"are not\n"
"real data structures, but are implicit in the way the program generates "
"results. And\n"
"the trees are often infinite, in which case we cannot hope to search the "
"whole of\n"
"one before searching the next; we have no choice but to save our place, one "
"way\n"
"or another."
msgstr ""
"Как будет показано в главе 24, оба эти соображения оказываются важными для "
"реализации\n"
"Пролога. В программах на Прологе, \"деревья поиска\" не являются реальными "
"струкурами\n"
"данных, но подразумемвают это, когда программа генерирует результаты. И "
"часто, деревья\n"
"бесконечны, и в этом случае мы не можем надеяться обыскать одно, прежде чем\n"
"искать в следующем; у нас нет выбора, кроме как сохранить наше место, так "
"или \n"
"иначе."

#: texi/node-20.texi:426
msgid ""
"@node 20-2 Continuation-Passing Macros, 20-3 Code-Walkers and CPS "
"Conversion, 20-1 Scheme Continuations, 20 Continuations\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 20-2 Continuation-Passing Macros\n"
"@cindex 20-2 Continuation-Passing Macros"
msgstr ""
"@node 20-2 Continuation-Passing Macros, 20-3 Code-Walkers and CPS "
"Conversion, 20-1 Scheme Continuations, 20 Continuations\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 20-2 Макросы Передачи Продолжений\n"
"@cindex 20-2 Continuation-Passing Macros"

#: texi/node-20.texi:431
msgid ""
"Common Lisp doesn't provide call/cc, but with a little extra effort we can "
"do\n"
"the same things as we can in Scheme. This section shows how to use macros "
"to\n"
"build continuations in Common Lisp programs. Scheme continuations gave us\n"
"two things:"
msgstr ""
"Common Lisp не предоставляет call/cc, но с небольшими дополнительными "
"усилиями\n"
"мы можем сделать тоже самое, что и в  Scheme. В этом разделе показано, как "
"использовать\n"
"макросы для построения продолжений в программан на Common Lisp. Продолжения\n"
"Scheme дают нам две вещи:"

#: texi/node-20.texi:438
msgid ""
"@enumerate\n"
"@item\n"
"The bindings of all variables at the time the continuation was made.\n"
"@item\n"
"The state of the computation-what was going to happen from then on.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Привязки всех переменных, во то время когда было создано продолжение.\n"
"@item\n"
"Состояние вычислений - что должно было произойти с тех пор.\n"
"@end enumerate"

#: texi/node-20.texi:442
msgid ""
"In a lexically scoped Lisp, closures give us the first of these. It turns "
"out that we can\n"
"also use closures to maintain the second, by storing the state of the "
"computation\n"
"in variable bindings as well."
msgstr ""
"В лексически ограниченном Lisp, замыкания дают перове из них. Оказывается, "
"что мы можем\n"
"использовать замыкания и для поддержки второго, сохраняя состояние "
"вычислений, так же\n"
"в привязках переменных."

#: texi/node-20.texi:446
msgid ""
"The macros shown in Figure 20-4 make it possible to do function calls while\n"
"preserving continuations. These macros replace the built-in Common Lisp "
"forms\n"
"for defining functions, calling them, and returning values."
msgstr ""
"Макросы, показанные на рисунке 20-4, позволяют выполнять вызовы функций, "
"сохраняя \n"
"продолжения. Эти макросы заменяют встроенные формы Common Lisp для "
"определения \n"
"функций, их вызова и возврата значений."

#: texi/node-20.texi:455
msgid ""
"Functions which want to use continuations (or call functions which do) "
"should\n"
"be defined with =defun instead of defun. The syntax of =defun is the same "
"as\n"
"that of defun, but its effect is subtly different. Instead of defining just "
"a function,\n"
"=defun defines a function and a macro which expands into a call to it. (The "
"macro\n"
"must be defined first, in case the function calls itself.) The function will "
"have the\n"
"body that was passed to =defun, but will have an additional parameter, "
"*cont*,\n"
"consed onto its parameter list. In the expansion of the macro, this function "
"will\n"
"receive *cont* along with its other arguments. So"
msgstr ""
"Функции, которые хотят использовать продолжения (или вызывают функции, "
"которые\n"
"это делают), должны быть определены с =defun вместо defun. Синтаксис "
"=defun \n"
"такой же, как и у defun, но его эффект несколько отличается. Вместо "
"определения \n"
"просто функции, = defun определяет функцию и макрос, который расширяется до "
"ее вызова.\n"
"(Макрос должен быть определен первым в случае, если функция вызывает себя "
"сама.) \n"
"Функция будет иметь тело, которое было передано в =defun, но будет иметь \n"
"дополнительный параметр *cont*, состоящий из списка своих параметров. В "
"расширении \n"
"макроса эта функция получит *cont* вместе с другими аргументами. Так"

#: texi/node-20.texi:458
msgid ""
"@lisp\n"
"   (=defun add1 (x) (=values (1+ x)))"
msgstr ""

#: texi/node-20.texi:465
msgid ""
"   macroexpands into\n"
"   (progn (defmacro add1 (x)\n"
"                  `(=add1 *cont* ,x))\n"
"               (defun =add1 (*cont* x)\n"
"                  (=values (1+ x))))\n"
"@end lisp"
msgstr ""
"   расширяет макрос в\n"
"   (progn (defmacro add1 (x)\n"
"                  `(=add1 *cont* ,x))\n"
"               (defun =add1 (*cont* x)\n"
"                  (=values (1+ x))))\n"
"@end lisp"

#: texi/node-20.texi:475
msgid ""
"When we call add1, we are actually calling not a function but a\n"
"macro. The macro expands into a function call,@footnote{Functions\n"
"created by =defun are deliberately given interned names, to make it\n"
"possible to trace them. If tracing were never necessary, it would be\n"
"safer to gensym the names.} but with one extra parameter: *cont*.So\n"
"the current value of *cont* is always passed implicitly in a call to\n"
"an operator defined with =defun."
msgstr ""
"Когда мы вызываем add1, мы фактически вызываем не функцию, а макрос. \n"
"Макрос расширяется до вызова функции, @footnote{Функциям, созданным "
"=defun, \n"
"преднамеренно присваиваются интернированные имена, чтобы их можно было \n"
"отследить. Если бы в трассировке не было необходимости, было бы безопаснее \n"
"использовать gensym имена.}, Но с одним дополнительным параметром: *cont*. \n"
"Таким образом, текущее значение *cont* всегда неявно передается при вызове \n"
"оператора, определенного с помощью =defun."

#: texi/node-20.texi:480
msgid ""
"What is *cont* for? It will be bound to the current continuation. The\n"
"definition of =values shows how this continuation will be used. Any\n"
"function defined using =defun must return with =values, or call some\n"
"other function"
msgstr ""
"Для чего нужен *cont*? Он будет связан с текущим продолжением. \n"
"Определение =values показывает, как будет использоваться это продолжение. \n"
"Любая функция, определенная с помощью =defun, должна возвращать с\n"
"помощью =values или вызывать какую-то другую функцию, которая делает это."

#: texi/node-20.texi:483
msgid ""
"@lisp\n"
" (setq *cont* #'identity)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (setq *cont* #'identity)"

#: texi/node-20.texi:486
msgid ""
" (defmacro =lambda (parms &body body)\n"
"    `#'(lambda (*cont* ,@@parms) ,@@body))"
msgstr ""

#: texi/node-20.texi:494
msgid ""
" (defmacro =defun (name parms &body body)\n"
"    (let ((f (intern (concatenate 'string\n"
"                                           \"=\" (symbol-name name)))))\n"
"        `(progn\n"
"             (defmacro ,name ,parms\n"
"                `(,',f *cont* ,,@@parms))\n"
"             (defun ,f (*cont* ,@@parms) ,@@body))))"
msgstr ""

#: texi/node-20.texi:497
msgid ""
" (defmacro =bind (parms expr &body body)\n"
"    `(let ((*cont* #'(lambda ,parms ,@@body))) ,expr))"
msgstr ""

#: texi/node-20.texi:500
msgid ""
" (defmacro =values (&rest retvals)\n"
"    `(funcall *cont* ,@@retvals))"
msgstr ""

#: texi/node-20.texi:503
msgid ""
" (defmacro =funcall (fn &rest args)\n"
"    `(funcall ,fn *cont* ,@@args))"
msgstr ""

#: texi/node-20.texi:507
msgid ""
" (defmacro =apply (fn &rest args)\n"
"    `(apply ,fn *cont* ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:509
msgid "                    Figure 20-4: Continuation-passing macros."
msgstr ""
"                    Рисунок 20-4: Макросы передающие продолжения.\n"
"@end cartouche"

#: texi/node-20.texi:515
msgid ""
"which does so. The syntax of =values is the same as that of the Common Lisp\n"
"form values. It can return multiple values if there is an =bind with the "
"same\n"
"number of arguments waiting for them, but can't return multiple values to "
"the\n"
"toplevel.                                                                         "
msgstr ""
"Синтаксис =values такой же, как и у той же формы Common Lisp. Он может "
"возвращать \n"
"несколько значений, если существует =bind с тем же числом аргументов, "
"ожидающий их,\n"
"но не может возвращать несколько значений на верхний уровень."

#: texi/node-20.texi:519
msgid ""
"The parameter *cont* tells a function defined with =defun what to do with\n"
"its return value. When =values is macroexpanded it will capture *cont*, and\n"
"use it to simulate returning from the function. The expression"
msgstr ""
"Параметр *cont* сообщает функции, определенной  =defun, что делать с "
"возвращаемым\n"
"значением. Когда =values макро расширяется, он будет захватывать *cont* и \n"
"использовать его для имитации возврата из функции. Выражение"

#: texi/node-20.texi:523
msgid ""
"@example\n"
"> (=values (1+ n))\n"
"@end example"
msgstr ""

#: texi/node-20.texi:525
msgid "expands into"
msgstr "расширяется в"

#: texi/node-20.texi:529
msgid ""
"@lisp\n"
"(funcall *cont* (1+ n))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:533
msgid ""
"At the toplevel, the value of *cont* is identity, which just returns "
"whatever is\n"
"passed to it. When we call (add1 2) from the toplevel, the call gets "
"macroex-\n"
"panded into the equivalent of"
msgstr ""
"На верхнем уровне значение *cont* является тождеством, которое просто "
"возвращает то,\n"
"что ему передано. Когда мы вызываем (add1 2) с верхнего уровня, вызов "
"получает\n"
"макрорасширение эквивалентное"

#: texi/node-20.texi:537
msgid ""
"@lisp\n"
"(funcall #'(lambda (*cont* n) (=values (1+ n))) *cont* 2)\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:540
msgid ""
"The reference to *cont* will in this case get the global binding. The "
"=values\n"
"expression will thus macroexpand into the equivalent of:"
msgstr ""
"Ссылка *cont* в этом случае получит глобальную привязку. Таким образом, "
"выражение \n"
"=values будет макрорасширяться в эквивалент:"

#: texi/node-20.texi:544
msgid ""
"@lisp\n"
"(funcall #'identity (1+ n))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:546
msgid "which just adds 1 to n and returns the result."
msgstr "который просто добавляет 1 к n и возвращает результат."

#: texi/node-20.texi:549
msgid ""
"In functions like add1, we go through all this trouble just to simulate "
"what\n"
"Lisp function call and return do anyway:"
msgstr ""
"В таких функциях, как add1, мы проходим через все эти проблемы только для "
"того, \n"
"чтобы имитировать, что делают, в любом случае, вызов функции Lisp и возврат:"

#: texi/node-20.texi:557
msgid ""
"@example\n"
"> (=defun bar (x)\n"
"        (=values (list 'a (add1 x))))\n"
"BAR\n"
"> (bar 5)\n"
"(A 6)\n"
"@end example"
msgstr ""

#: texi/node-20.texi:560
msgid ""
"The point is, we have now brought function call and return under our own "
"control,\n"
"and can do other things if we wish."
msgstr ""
"Дело в том, что теперь мы взяли вызов функции и ее возврат под свой "
"собственный \n"
"контроль и можем сделать другие вещи, если захотим."

#: texi/node-20.texi:568
msgid ""
"It is by manipulating *cont* that we will get the effect of continuations.\n"
"Although *cont* has a global value, this will rarely be the one used: *cont* "
"will\n"
"nearly always be a parameter, captured by =values and the macros defined by\n"
"=defun. Within the body of add1, for example, *cont* is a parameter and not "
"the\n"
"global variable. This distinction is important because these macros wouldn't "
"work\n"
"if *cont* were not a local variable. That's why *cont* is given its initial "
"value\n"
"in a setq instead of a defvar: the latter would also proclaim it to be "
"special."
msgstr ""
"Именно манипулируя *cont*, мы получим эффект продолжений.\n"
"Хотя *cont* является глобальным значением, оно редко будет использоваться: "
"*cont* \n"
"почти всегда будет параметром, захватываемым =values и макросами, "
"определенными \n"
"=defun. Например, в теле add1 *cont* является параметром, а не глобальной "
"переменной.\n"
"Это различие важно, потому что эти макросы не работали бы, если бы *cont* не "
"была \n"
"локальной переменной. Вот почему *cont* получает свое начальное значение в "
"setq \n"
"вместо defvar: последний также объявит его специальным."

#: texi/node-20.texi:575
msgid ""
"The third macro in Figure 20-4, =bind, is intended to be used in the same "
"way\n"
"as multiple-value-bind. It takes a list of parameters, an expression, and a\n"
"body of code: the parameters are bound to the values returned by the "
"expression,\n"
"and the code body is evaluated with those bindings. This macro should be "
"used\n"
"whenever additional expressions have to be evaluated after calling a "
"function\n"
"defined with =defun."
msgstr ""
"Третий макрос на рис. 20-4, =bind, предназначен для использования так же, "
"как и\n"
"multiple-value-bind(множественное связывание). Он принимает список "
"параметров, \n"
"выражение и тело кода: параметры привязываются к значениям, возвращаемым "
"выражением, \n"
"и тело кода вычисляется с помощью этих привязок. Этот макрос должен "
"использоваться \n"
"всякий раз, когда дополнительные выражения должны вычисляться после вызова "
"функции, \n"
"определенной с помощью =defun."

#: texi/node-20.texi:580
msgid ""
"@example\n"
"> (=defun message ()\n"
"        (=values 'hello 'there))\n"
"MESSAGE"
msgstr ""

#: texi/node-20.texi:590
msgid ""
"> (=defun baz ()\n"
"        (=bind (m n) (message)\n"
"          (=values (list m n))))\n"
"BAZ\n"
"> (baz)\n"
"(HELLO THERE)\n"
"@end example"
msgstr ""

#: texi/node-20.texi:593
msgid ""
"Notice that the expansion of an =bind creates a new variable called *cont*. "
"The\n"
"body of baz macroexpands into:"
msgstr ""
"Обратите внимание, что расширение =bind создает новую переменную с именем "
"*cont*. \n"
"Тело baz макроса расширяется в:"

#: texi/node-20.texi:599
msgid ""
"@lisp\n"
"(let ((*cont* #'(lambda (m n)\n"
"                          (=values (list m n)))))\n"
"  (message))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:602
msgid ""
"@noindent\n"
"which in turn becomes:"
msgstr ""
"@noindent\n"
"который в свою очередь становится:"

#: texi/node-20.texi:608
msgid ""
"@lisp\n"
"(let ((*cont* #'(lambda (m n)\n"
"                          (funcall *cont* (list m n)))))\n"
"  (=message *cont*))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:612
msgid ""
"The new value of *cont* is the body of the =bind expression, so when "
"message\n"
"\"returns\" by funcalling *cont*, the result will be to evaluate the body of "
"code.\n"
"However (and this is the key point), within the body of the =bind:"
msgstr ""
"Новое значение *cont* является телом выражения =bind, поэтому, когда "
"message\n"
"«возвращается» с помощью функции *cont*, результатом будет вычисление тела "
"кода. \n"
"Однако (и это ключевой момент) в теле =bind:"

#: texi/node-20.texi:617
msgid ""
"@example\n"
"#'(lambda (m n)\n"
"        (funcall *cont* (list m n)))\n"
"@end example"
msgstr ""

#: texi/node-20.texi:623
msgid ""
"the *cont* that was passed as an argument to =baz is still visible, so when "
"the\n"
"body of code in turn evaluates an =values, it will be able to return to the "
"original\n"
"calling function. The closures are knitted together: each binding of *cont* "
"is a\n"
"closure containing the previous binding of *cont*, forming a chain which "
"leads\n"
"all the way back up to the global value."
msgstr ""
"*cont*, который был передан в качестве аргумента =baz, все еще виден, "
"поэтому, \n"
"когда тело кода в свою очередь вычисляет =values, оно будет иметь "
"возможность \n"
"вернуться к исходной вызывающей функции. Замыкания связаны между собой: "
"каждая\n"
"привязка *cont* является замыканием, содержащим предыдущую привязку "
"*cont*, \n"
"образуя цепочку, которая ведет обратно к глобальному значению."

#: texi/node-20.texi:625
msgid "   We can see the same phenomenon on a smaller scale here:"
msgstr "  Мы можем увидеть тот же эффект, но в меньшем масштабе, здесь:"

#: texi/node-20.texi:634
msgid ""
"@example\n"
"> (let ((f #'identity))\n"
"        (let ((g #'(lambda (x) (funcall f (list 'a x)))))\n"
"          #'(lambda (x) (funcall g (list 'b x)))))\n"
"#<Interpreted-Function BF6326>\n"
"> (funcall * 2)\n"
"(A (B 2))\n"
"@end example"
msgstr ""

#: texi/node-20.texi:638
msgid ""
"This example creates a function which is a closure containing a reference to "
"g,\n"
"which is itself a closure containing a reference to f. Similar chains of "
"closures\n"
"were built by the network compiler on page 80."
msgstr ""
"В этом примере создается функция, которая является замыканием, содержащим "
"ссылку на g, \n"
"которая сама является замыканием, содержащим ссылку на f. Подобные цепочки "
"замыканий \n"
"были построены компилятором сетей на стр. 80."

#: texi/node-20.texi:655
msgid ""
"@enumerate\n"
"@item\n"
"The parameter list of a function defined with =defun must consist solely\n"
" of parameter names.\n"
"@item\n"
"Functions which make use of continuations, or call other functions which\n"
" do, must be defined with =lambda or =defun.\n"
"@item\n"
"Such functions must terminate either by returning values with =values,or\n"
" by calling another function which obeys this restriction.\n"
"@item\n"
"If an =bind, =values, =apply,or=funcall expression occurs in a segment of \n"
"code, it must be a tail call. Any code to be evaluated after an =bind\n"
"should be put in its body. So if we want to have several =binds one after\n"
"another, they must be nested:\n"
"@end enumerate"
msgstr ""
"@cartouche\n"
"@enumerate\n"
"@item\n"
"Список параметров функции, определенной с помощью =defun, должен состоять\n"
"исключительно из имен параметров.\n"
"@item\n"
"Функции, использующие продолжения или вызывающие другие функции, которые "
"это\n"
"делают, должны быть определены с помощью =lambda или =defun.\n"
"@item\n"
"Такие функции должны завершаться, либо путем возврата значений с "
"использованием\n"
"=values, или вызовом другой функции, которая подчиняется этому ограничению.\n"
"@item\n"
"Если в сегменте кода встречается выражение =bind, =values, =apply, или "
"=funcall,\n"
"это должен быть хвостовой вызов. Любой код, который будет вычисляться после "
"=bind,\n"
"должен быть помещен в его тело.  Поэтому, если мы хотим иметь несколько "
"привязок\n"
"=binds следующих друг за другом, они должны быть вложенными:\n"
"@end enumerate"

#: texi/node-20.texi:664
msgid ""
"@lisp\n"
" (=defun foo (x)\n"
"       (=bind (y) (bar x)\n"
"         (format t \"Ho \")\n"
"         (=bind (z) (baz x)\n"
"            (format t \"Hum.\")\n"
"            (=values x y z))))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:666
msgid "              Figure 20-5: Restrictions on continuation-passing macros."
msgstr ""
"              Рисунок 20-5: Ограничения накладываемые на макросы передающие "
"продолжения.\n"
"@end cartouche"

#: texi/node-20.texi:673
msgid ""
"The remaining macros, =apply and =funcall, are for use with functions\n"
"defined by =lambda. Note that \"functions\" defined with =defun, because "
"they\n"
"are actually macros, cannot be given as arguments to apply or funcall. The\n"
"way around this problem is analogous to the trick mentioned on page 110. It "
"is to\n"
"package up the call inside another =lambda:"
msgstr ""
"Остальные макросы, =apply и =funcall, предназначены для использования с "
"функциями,\n"
"определенными =lambda. Обратите внимние, что \"функции\" определенные с "
"помощью =defun,\n"
"поскольку на самом деле они являются макросами, не могут быть заданы в "
"качестве\n"
"аргументов для apply или funcall. Обход этой проблемы аналогичен уловке "
"упомянутой\n"
"на стр. 110. Она заключается в том, чтобы упаковать вызов в другую =lambda:"

#: texi/node-20.texi:683
msgid ""
"@example\n"
"> (=defun add1 (x)\n"
"        (=values (1+ x)))\n"
"ADD1\n"
"> (let ((fn (=lambda (n) (add1 n))))\n"
"        (=bind (y) (=funcall fn 9)\n"
"           (format nil \"9 + 1 = ~A\" y)))\n"
"\"9+1=10\"\n"
"@end example"
msgstr ""

#: texi/node-20.texi:688
msgid ""
"Figure 20-5 summarizes all the restrictions imposed by the continuation-\n"
"passing macros. Functions which neither save continuations, nor call other "
"func-\n"
"tions which do, need not use these special macros. Built-in functions like "
"list,\n"
"for example, are exempt."
msgstr ""
"На рисунке 20-5 обобщены все ограничения, накладываемые на макросы "
"передающие \n"
"продолжения. Функции, которые ни сохраняют продолжения, ни вызывают другие "
"функции,\n"
"которые это делают, не должны использовать эти специальные макросы. "
"Например,\n"
"исключаются встроенные функции, такие как list."

#: texi/node-20.texi:691
msgid ""
"Figure 20-6 contains the code from Figure 20-3, translated from Scheme into\n"
"Common Lisp, and using the continuation-passing macros instead of Scheme"
msgstr ""
"Рисунок 20-6 содержит код из Рисунка 20-3, переведенный со Scheme на "
"Common \n"
"Lisp, и использующий макросы передающие продолжения вместо продолжений "
"Scheme."

#: texi/node-20.texi:698
msgid ""
"@lisp\n"
" (defun dft (tree)\n"
"       (cond ((null tree) nil)\n"
"             ((atom tree) (princ tree))\n"
"             (t (dft (car tree))\n"
"                (dft (cdr tree)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun dft (tree)\n"
"       (cond ((null tree) nil)\n"
"             ((atom tree) (princ tree))\n"
"             (t (dft (car tree))\n"
"                (dft (cdr tree)))))"

#: texi/node-20.texi:700
msgid " (setq *saved* nil)"
msgstr ""

#: texi/node-20.texi:707
msgid ""
" (=defun dft-node (tree)\n"
"       (cond ((null tree) (restart))\n"
"             ((atom tree) (=values tree))\n"
"             (t (push #'(lambda () (dft-node (cdr tree)))\n"
"                         *saved*)\n"
"                (dft-node (car tree)))))"
msgstr ""

#: texi/node-20.texi:712
msgid ""
" (=defun restart ()\n"
"       (if *saved*\n"
"          (funcall (pop *saved*))\n"
"          (=values 'done)))"
msgstr ""

#: texi/node-20.texi:720
msgid ""
" (=defun dft2 (tree)\n"
"       (setq *saved* nil)\n"
"       (=bind (node) (dft-node tree)\n"
"        (cond ((eq node 'done) (=values nil))\n"
"               (t (princ node)\n"
"                   (restart)))))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:722
msgid ""
"          Figure 20-6: Tree traversal using continuation-passing macros."
msgstr ""
"          Рисунок 20-6: Обход дерева с использованием макросов передающих "
"продолжения.\n"
"@end cartouche"

#: texi/node-20.texi:725
msgid "continuations. With the same example tree, dft2 works just as before:"
msgstr "С тем же примером дерева, dft2 работает также как и раньше:"

#: texi/node-20.texi:735
msgid ""
"@example\n"
"> (setq t1 '(a (b (d h)) (c e (f i) g))\n"
"           t2 '(1 (2 (3 6 7) 4 5)))\n"
"(1 (2 (3 6 7) 4 5))\n"
"> (dft2 t1)\n"
"ABDHCEFIG\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-20.texi:738
msgid ""
"Saving states of multiple traversals also works as in Scheme, though the "
"example\n"
"becomes a bit longer:"
msgstr ""
"Сохранение состояний нескольких обходов также работает как в Scheme, хотя "
"пример\n"
"становитсья немного длиннее:"

#: texi/node-20.texi:752
msgid ""
"@example\n"
"> (=bind (node1) (dft-node t1)\n"
"        (if (eq node1 'done)\n"
"             'done\n"
"             (=bind (node2) (dft-node t2)\n"
"               (list node1 node2))))\n"
"(A 1)\n"
"> (restart)\n"
"(A 2)\n"
"...> (restart)\n"
"(B 1)\n"
"...\n"
"@end example"
msgstr ""

#: texi/node-20.texi:757
msgid ""
"By knitting together a chain of lexical closures, Common Lisp programs can\n"
"build their own continuations. Fortunately, the closures are knitted "
"together by\n"
"the macros in the sweatshop of Figure 20-4, and the user can have the "
"finished\n"
"garment without giving a thought to its origins."
msgstr ""
"Связывая вместе в цепочку лексические замыкания, программы Common Lisp "
"могут \n"
"создавать свои собственные продолжения. К счастью, замыкания связываются "
"вместе\n"
"внутри макросов представленных на Рисунке 20-4, и пользователь может "
"получить\n"
"эффект использования продолжений, не задумываясь о его происхождении."

#: texi/node-20.texi:763
msgid ""
"Chapters 21­24 all rely on continuations in some way. These chapters will\n"
"show that continuations are an abstraction of unusual power. They may not "
"be\n"
"overly fast, especially when implemented on top of the language as macros, "
"but\n"
"the abstractions we can build upon them make certain programs much faster "
"to\n"
"write, and there is a place for that kind of speed too."
msgstr ""
"Все главы 21-­24 так или иначе опираются на продолжения. Эти главы покажут, "
"что\n"
"продолжения это абстракция необычной силы.  Они могут быть не слишком "
"быстрыми,\n"
"особенно когда они реализованы поверх языка в виде макросов, но абстракции,\n"
"которые мы можем строить на их основе, делают создание некоторых программ\n"
"намного быстрее, и ускорение этой работы также очень важно."

#: texi/node-20.texi:768
msgid ""
"@node 20-3 Code-Walkers and CPS Conversion,  , 20-2 Continuation-Passing "
"Macros, 20 Continuations\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 20-3 Code-Walkers and CPS Conversion\n"
"@cindex 20-3 Code-Walkers and CPS Conversion"
msgstr ""
"@node 20-3 Code-Walkers and CPS Conversion,  , 20-2 Continuation-Passing "
"Macros, 20 Continuations\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 20-3 Code-Walkers(Путешественник по Коду) и преобразование к "
"CPS(стилю передачи продолжений)\n"
"@cindex 20-3 Code-Walkers and CPS Conversion"

#: texi/node-20.texi:772
msgid ""
"The macros described in the previous section represent a compromise. They "
"give\n"
"us the power of continuations, but only if we write our programs in a "
"certain way.\n"
"Rule 4 in Figure 20-5 means that we always have to write"
msgstr ""
"Макросы описанные в предыдущем разделе, представляют собой компромисс. Они "
"дают нам\n"
"силу продолжений, но только если мы напишем наши программы опредленным "
"образом.\n"
"Правило 4 на Рисунке 20-5 означает, что мы должны написать"

#: texi/node-20.texi:777
msgid ""
"@lisp\n"
"(=bind (x) (fn y)\n"
"       (list 'a x))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:780
msgid ""
"@noindent\n"
"rather than"
msgstr ""
"@noindent\n"
"скорее чем"

#: texi/node-20.texi:785
msgid ""
"@lisp\n"
"(list 'a                                                                ; "
"wrong\n"
"           (=bind (x) (fn y) x))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:790
msgid ""
"A true call/cc imposes no such restrictions on the programmer. A call/cc "
"can\n"
"grab the continuation at any point in a program of any shape. We could "
"implement\n"
"an operator with the full power of call/cc, but it would be a lot more work. "
"This\n"
"section outlines how it could be done."
msgstr ""
"Настоящий call/cc не накладывает таких ограничений на программиста. call/cc "
"может\n"
"получить продолжение в любой точке программы любой формы. Мы могли бы "
"реализовать\n"
"оператор имеющий всю мощь call/cc, но это потребовало бы намного больше "
"работы.\n"
"В этом разделе описывается как это можно сделать."

#: texi/node-20.texi:795
msgid ""
"A Lisp program can be transformed into a form called \"continuation-passing\n"
"style.\" Programs which have undergone complete CPS conversion are "
"impossible\n"
"to read, but one can grasp the spirit of this process by looking at code "
"which has\n"
"been partially transformed. The following function to reverse "
"lists:                     "
msgstr ""
"Программа на Lisp может быть преобразована в форму называемую \"стиль "
"передачи\n"
"продолжений\"(continuation-passing style). Программы прошедшие полное "
"преобразование\n"
"CPS, невозоможно читать, но можно понять дух этого процесса, взглянув на "
"код, который\n"
"был частично преобразован. Следующая функция для реверсирования "
"списков:                     "

#: texi/node-20.texi:802
msgid ""
"@lisp\n"
"(defun rev (x)\n"
"  (if (null x)\n"
"          nil\n"
"          (append (rev (cdr x)) (list (car x)))))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:805
msgid ""
"@noindent\n"
"yields an equivalent continuation-passing version:"
msgstr ""
"@noindent\n"
"имеет эквивалентную версию написанную в стиле передачи продолжений:"

#: texi/node-20.texi:809
msgid ""
"@lisp\n"
"(defun rev2 (x)\n"
"  (revc x #'identity))"
msgstr ""

#: texi/node-20.texi:817
msgid ""
"(defun revc (x k)\n"
"  (if (null x)\n"
"          (funcall k nil)\n"
"          (revc (cdr x)\n"
"                  #'(lambda (w)\n"
"                         (funcall k (append w (list (car x))))))))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:824
msgid ""
"In the continuation-passing style,functions get an additional parameter "
"(here k)\n"
"whose value will be the continuation. The continuation is a closure "
"representing\n"
"what should be done with the current value of the function. On the first "
"recursion,\n"
"the continuation is identity; what should be done is that the function "
"should\n"
"just return its current value. On the second recursion, the continuation "
"will be\n"
"equivalent to:"
msgstr ""
"При использовании стиля передачи продолжений, функции получают "
"дополнительный параметр\n"
"(здесь k), значением которого будет продолжение. Продожение является "
"замыканием,\n"
"представляющим то, что должно быть сделано с текущим значением функции. В "
"первой\n"
"рекурсси продожением является identity; т.е то что должно быть сделано, это "
"то, что\n"
"функция дожна просто вернуть значение своего аргумента. На второй рекурсии "
"продолжение\n"
"будет эквивалентно:"

#: texi/node-20.texi:829
msgid ""
"@lisp\n"
"#'(lambda (w)\n"
"        (identity (append w (list (car x)))))\n"
"@end lisp"
msgstr ""

#: texi/node-20.texi:832
msgid ""
"which says that what should be done is to append the car of the list to the "
"current\n"
"value, and return it."
msgstr ""
"что говорит о том, что нужно сделать, это добавить начало(car) списка к "
"текущему значению\n"
"и вернуть результат."

#: texi/node-20.texi:837
msgid ""
"Once you can do CPS conversion, it is easy to write call/cc. In a program\n"
"which has undergone CPS conversion, the entire current continuation is "
"always\n"
"present, and call/cc can be implemented as a simple macro which calls some\n"
"function with it as an argument."
msgstr ""
"Как только вы сможете выполнить преобразование CPS, становиться легко "
"написать \n"
"call/cc. В программе, которая подверглась преобразованию CPS, всегда "
"присутствуют\n"
"все текущие продожения, и  call/cc может быть реализован как простой макрос, "
"который\n"
"вызывается с некоторой функцией в качестве его аргумента."

#: texi/node-20.texi:846
msgid ""
"To do CPS conversion we need a code-walker, a program that traverses the\n"
"trees representing the source code of a program. Writing a code-walker for\n"
"Common Lisp is a serious undertaking. To be useful, a code-walker has to "
"do  \n"
"more than simply traverse expressions. It also has to know a fair amount "
"about\n"
"what the expressions mean. A code-walker can't just think in terms of "
"symbols,\n"
"for example. A symbol could represent, among other things, itself, a "
"function, a\n"
"variable, a block name, or a tag for go. The code-walker has to use the "
"context to\n"
"distinguish one kind of symbol from another, and act accordingly."
msgstr ""
"Для преобразования кода в CPS нам понадобиться программа-обходчик(code-"
"walker), \n"
"которая обходит дерево, представляющее исходный код программы. Написание "
"code-walker\n"
"для Common Lisp это серьёзная задача. Чтобы быть полезным, code-walker "
"должен делать\n"
"больше, чем просто обходить выражения. Он также должен знать много о том, "
"что\n"
"означают эти выражения. Например, code-walker не может просто мыслить в "
"терминах\n"
"символов. Символ может представлять собой, помимо прочего, функцию, "
"переменную, имя\n"
"блока или тег для перехода. code-walker должен использовать контекст, чтобы "
"отличать\n"
"одно от другого, и действовать соответственно."

#: texi/node-20.texi:855
msgid ""
"Since writing a code-walker would be beyond the scope of this book, the\n"
"macros described in this chapter are the most practical alternative. The "
"macros\n"
"in this chapter split the work of building continuations with the user. If "
"the user\n"
"writes programs in something sufficiently close to CPS, the macros can do "
"the\n"
"rest. That's what rule 4 really amounts to: if everything following an "
"=bind\n"
"expression is within its body, then between the value of *cont* and the "
"code\n"
"in the body of the =bind, the program has enough information to construct "
"the\n"
"current continuation."
msgstr ""
"Поскольку написание code-walker выходит за рамки этой книги, макросы "
"описанные в\n"
"этой главе, являются наиболее практичной альтернативой. Макросы в этой "
"главе\n"
"разделяют работу по созданию продолжений вместе с пользователем. Если "
"пользователь\n"
"пишет программы в чем-то достаточно близком к CPS, макросы будут делать все "
"остальное.\n"
"Вот чем на самом деле является правило  4: если все, что следует за "
"выражением =bind,\n"
"находиться внутри его тела, затем между значением *cont* и кодом в теле "
"=bind, \n"
"программа имеет достаточно инофрмации для создания текущего продолжения."

#: texi/node-20.texi:859
msgid ""
"The =bind macro is deliberately written to make this style of programming\n"
"feel natural. In practice the restrictions imposed by the continuation-"
"passing\n"
"macros are bearable."
msgstr ""
"Макрос =bind специально написан, чтобы сделать этот стиль программирования\n"
"наиболее естественным. На практике ограничения, накладываемые макросами\n"
"передающими продолжения, терпимы."
