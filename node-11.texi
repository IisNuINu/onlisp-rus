@node 11 Classic Macros, 12 Generalized Variables, 10 Other Macro Pitfalls, Top
@comment  node-name,  next,  previous,  up
@chapter 11 Классические Макросы
@cindex 11 Classic Macros

В этой главе показано, как определить наиболее часто используемые типы макросов.
Они деляться на три категории - с большим количеством пересечений. Первой группой
являются макросы, которые создают контекст. Любой оператор, который вычисляет свои
аргументы в новом контексте, вероятно должен быть определен как макрос. Первые 
два раздела описывыают два основных типа контекста и показывают, как определять
макросы для каждого из них.

В следующих трех разделах описаны макросы для условных и повторных вычислений.
Оператор, аргументы которого должны вычисляться менее одного раза, или более
чем один раз, также должен быть определен как макрос. Там нет четкого различия
между операторами для условных и повторных вычислений: некоторые примеры в этой
главе делают оба вида вычислений(а также связывание). Последний раздел объясняет
другое сходство между условными и повторяющимися вычислениями: в некоторых случаях
можно выполнять оба типа вычислений используя функции.

@menu
* 11-1 Creating Context::       
* 11-2 The with- Macro::        
* 11-3 Conditional Evaluation::  
* 11-4 Iteration::              
* 11-5 Iteration with Multiple Values::  
* 11-6 Need for Macros::        
@end menu

@node 11-1 Creating Context, 11-2 The with- Macro, 11 Classic Macros, 11 Classic Macros
@comment  node-name,  next,  previous,  up
@section 11-1 Создание контекста
@cindex 11-1 Creating Context

Контекст здесь имеет два смысла. Одним из видов контекста является лексическое
окружение(среда). Специальная форма let создает новое лексическое окружение; 
выражения в теле let будут вычисляться в окружении, которое может содержать
новые переменные.
Если x установлен в a на верхнем уровне, то

@lisp
(let ((x 'b)) (list x))
@end lisp

@noindent
выражение вернет все же (b), поскольку вызов list будет сделан в окружении, содержащим
новый x, чьим значением является b.

@cartouche
@lisp
 (defmacro our-let (binds &body body)
       `((lambda ,(mapcar #'(lambda (x)
                                     (if (consp x) (car x) x))
                                binds)
            ,@@body)
         ,@@(mapcar #'(lambda (x)
                            (if (consp x) (cadr x) nil))
                       binds)))
@end lisp

                     Рисунок 11-1: Реализация макроса let.
@end cartouche

Оператор, который должен иметь тело выражений, обычно должен быть определен как
макрос. За исключением случаев, таких как prog1 и progn, цель такого оператора,
обычно в том, чтобы вызвать вычисление тела в каком то новом контексте. Марос должен
будет обернуть вокруг тела кода, создаваемый контекст, даже если этот контекст не 
включает новые лексические переменные.

Рисунок 11-1 показывает, как let может быть определен через макрос использующий
lambda. our-let расширяется в применение функции лямбда функции:

@lisp
(our-let ((x 1) (y 2))
  (+ x y))
@end lisp

@noindent
расширяется в

@lisp
((lambda (x y) (+ x y)) 1 2)
@end lisp

Рисунок 11-2 содержит три новых макроса, которые устанавливают лексическое
окружение. Раздел 7-5 использовал when-bind в качестве примера деструктуризации
списка параметров, поэтому этот макрос уже был описан на странице 94. Более
общий when-bind* принимает список пар вида (symbol expression) - той же формы,
что и первый аргумент let. Если какое либо выражение возвращает nil, всё выражение
when-bind* вернет nil. В противном случае его тело будет вычисляться, как будто 
каждый символ связан с помощью let*:

@example

> (when-bind* ((x (find-if #'consp '(a (1 2) b)))
               (y (find-if #'oddp  x)))
        (+ y 10))
11
@end example

Наконец, макрос with-gensyms сам по себе используется для написания макросов.
Много определений макросов начинаются с создания символов с помощью gensyms,
иногда их количество очень больше. Макрос with-redraw (стр. 115) должен был создать
пять:

@cartouche
@lisp
 (defmacro when-bind ((var expr) &body body)
    `(let ((,var ,expr))
          (when ,var
            ,@@body)))

 (defmacro when-bind* (binds &body body)
    (if (null binds)
           `(progn ,@@body)
           `(let (,(car binds))
                 (if ,(caar binds)
                    (when-bind* ,(cdr binds) ,@@body)))))

 (defmacro with-gensyms (syms &body body)
    `(let ,(mapcar #'(lambda (s)
                               `(,s (gensym)))
                          syms)
          ,@@body))
@end lisp

                      Рисунок 11-2: Макросы которые связывают переменные.
@end cartouche

@lisp
(defmacro with-redraw ((var objs) &body body)
  (let ((gob (gensym))
        (x0  (gensym)) (y0 (gensym))
        (x1  (gensym)) (y1 (gensym)))
     ...))
@end lisp

Такие определения гораздо проще с with-gensyms, который связывет целый список
переменных со символами генерируемыми gensym. С новым макросом мы могли бы
просто записать:

@lisp
(defmacro with-redraw ((var objs) &body body)
  (with-gensyms (gob x0 y0 x1 y1)
        ...))
@end lisp

Этот новый макрос будет использоваться в оставшихся главах.

Если мы хотим связать некоторые переменные, а затем в зависимости от некоторых 
условий, вычислить одно из набора выражений, мы просто используем условное 
выражение в let:

@lisp
(let ((sun-place 'park) (rain-place 'library))
  (if (sunny)
          (visit sun-place)
          (visit rain-place)))
@end lisp

@cartouche
@lisp
 (defmacro condlet (clauses &body body)
       (let ((bodfn (gensym))
             (vars (mapcar #'(lambda (v) (cons v (gensym)))
                               (remove-duplicates
                                  (mapcar #'car
                                          (mappend #'cdr clauses))))))
         `(labels ((,bodfn ,(mapcar #'car vars)
                       ,@@body))
             (cond ,@@(mapcar #'(lambda (cl)
                                   (condlet-clause vars cl bodfn))
                              clauses)))))

 (defun condlet-clause (vars cl bodfn)
       `(,(car cl) 
           (let ,(mapcar #'cdr vars)
               (let ,(condlet-binds vars cl)
                    (,bodfn ,@@(mapcar #'cdr vars))))))

 (defun condlet-binds (vars cl)
       (mapcar #'(lambda (bindform)
                     (if (consp bindform)
                         (cons (cdr (assoc (car bindform) vars))
                               (cdr bindform))))
               (cdr cl)))
@end lisp

                    Рисунок 11-3: Комбинация cond и let.
@end cartouche

К сожалению, нет удобной идиомы для противоположной ситуации, когда мы хотим
всегда вычислить один и тот же код, но где привязки должны отличаться в зависимости
от некоторых условий.

Рисунок 11-3 содержит макрос предназначеный для таких ситуаций. Назаченное ему
имя, предполагает, что condlet ведет себя как потомок cond и let. Он требует
в качестве аргументов список связывающих предложений, за которым следует
тело кода. Каждое из связывающих предложений защищено тестовым выражением; тело
кода будет вычислено с привязками указанными предложением, чье тестовое выражение
первым вернет истинное значение. Переменные, которые встречаются в одних предложениях
и отсутствуют в других будут связанаы с nil, если в успешном предложении привязки для них 
не указаны:

@example
> (condlet (((= 1 2) (x (princ 'a)) (y (princ 'b)))
            ((= 1 1) (y (princ 'c)) (x (princ 'd)))
            (t       (x (princ 'e)) (z (princ 'f))))
        (list x y z))
CD
(D C NIL)
@end example

Определение condlet можно понимать как обобщение определения our-let. Последний,
превращает свое тело в функцию, которая применяется к результатам вычислений
инициирующих значений форм. condlet расширяется в код, которые определяет
локальную функцию используя labels; в нем предложение cond определяет, какой
набором форм инициализирующих значения будет выполнен и передан в функцию.

Обратите внимание, что расширитель использует mappend вместо mapcan для извлечения
имен переменных из связывающих предложений. Это сделано потому, что mapcan является
деструктивной функций, а как указано в Разделе 10-3, опасно изменять структуру
списка параметров.

@node 11-2 The with- Macro, 11-3 Conditional Evaluation, 11-1 Creating Context, 11 Classic Macros
@comment  node-name,  next,  previous,  up
@section 11-2 Макрос with-
@cindex 11-2 The with- Macro

Существует еще один вид контекста помимо лексического окружения. В более широком
смысле, контекст - это состояние мира, в том числе значений специальных переменных,
содержимое структур данных и состояние снаружи Lisp. Операторы, которые создают
этот вид контекста, также должны быть определены как макросы, если только их тело
кода не должно быть упаковано в замыкание.

Имена макросов создающих контекст часто начинаются с префикса with-. 
Большинство обычно используемых макросов этого типа, вероятно  
with-open-file. Его тело вычисляется в контексте вновь открытого файла,
привязанного к определяемой пользователем переменной:

@lisp
(with-open-file (s "dump" :direction :output)
  (princ 99 s))
@end lisp

После вычисления этого выражения файл "dump" автоматически закроется, и его
содержимое будет состоять из двух знаков "99".

Этот оператор должен быть явно определен как макрос, поскольку он связывает
переменную s. Тем не менее, операторы, которые вызывают вычисление форм в новом
контексте, в любом случае должны быть определены как макросы. Макрос ignore-errors
новый в CLTL2, вызывает вычисление своих аргументов как будто они выполняются в 
progn. Если в некоторый момент возникает ошибка, вся форма  ignore-errors просто
возвращет nil. (это было бы полезно, например при чтении набираемых пользователем
символьных знаков). Хотя ignore-errors не создает переменных, он все равно должен 
быть определен как макрос, потому что его аргументы вычисляются в новом контексте.

Обычно макросы, которые создают контекст, расширяются в блок кода; дополнительные
выражения могут быть помещены перед телом, после него или по обоим его сторонам.
Если код появляется после тела, его цель может состоять в том, чтобы оставить систему
в устойчивом состоянии - убрать, чтото уже не нужное. Например, with-open-file должен 
закрыть открытый им файл. В таких ситуациях обычно макрос создающий контекст, 
расширяется в unwind-protect.

Цель unwind-protect состоит в том, чтобы гарантировать, что определенные выражения
вычислятся, даже если выполнение будет прервано. Он принимает один или более аргументов,
которые вычисляются по порядку. Если все пойдет гладко, он вернёт значение первого 
аргумента, как prog1. Разница в том, что остальные аргументы будут вычислены даже
если ошибка или исключение прервет вычисление первого аргумента.

@example
> (setq x 'a)
A> (unwind-protect
        (progn (princ "What error?")
                 (error "This error."))
        (setq x 'b))
What error?
>>Error: This error.
@end example

Форма unwind-protect в целом выдает ошибку. Однако, после возвращения на верхний
уровень, мы замечаем, что второй аргумент все же был вычислен:

@example
>x
B
@end example

Поскольку with-open-file расширяется в форму unwind-protect, открываемый файл
обычно будет закрыт, даже если во время вычисления его тела произойдет ошибка.

Макросы создающие контекст в основном пишуться для конкретных приложений. Так
например, предположим , что мы пишем программу, которая работает с несколькими
базам данных. Одновренменно программа общается только с одной базой данных,
указанной в переменной *db*. Перед использованием базы данных мы должны 
заблокировать её, чтобы никто другой не смог использовать ее одновременно с нами.
Когда мы закончим, мы должны снять блокировку. Если мы хотим получить значение
запроса q в базе данных db, мы можем сказать что то вроде:

@lisp
(let ((temp *db*))
   (setq *db* db)
   (lock *db*)
   (prog1 (eval-query q)
          (release *db*)
          (setq *db* temp)))
@end lisp

С помощью макрса мы можем скрыть всю эту бухгалтерию. Рисунок 11-4 определяет макрос,
который позволит нам иметь дело с базами данных н а более высоком уровне абстракции.
С помощью with-db, мы бы просто сказали:

@cartouche
Чистый макрос:

@lisp
 (defmacro with-db (db &body body)
    (let ((temp (gensym)))
        `(let ((,temp *db*))
          (unwind-protect
             (progn
                  (setq *db* ,db)
                  (lock *db*)
                  ,@@body)
             (progn
                  (release *db*)
                  (setq *db* ,temp))))))
@end lisp

@noindent
Комбинация макроса и функции:

@lisp
 (defmacro with-db (db &body body)
    (let ((gbod (gensym)))
        `(let ((,gbod #'(lambda () ,@@body)))
          (declare (dynamic-extent ,gbod))
          (with-db-fn *db* ,db ,gbod))))

 (defun with-db-fn (old-db new-db body)
    (unwind-protect
        (progn
         (setq *db* new-db)
         (lock *db*)
         (funcall body))
        (progn
         (release *db*)
         (setq *db* old-db))))
@end lisp

                       Рисунок 11-4: Типичный макрос with-.
@end cartouche

@lisp
(with-db db
  (eval-query q))
@end lisp

Вызов with-db также безопаснее, поскольку он разворачивается в unwind-protect
вместо простого prog1.

Два определения with-db на рисунке 11-4 илюстрируют два возможных пути написания
этого макроса. Первый чистый макрос, второй комбинация макроса и функции. Второй
подход становиться более практичным, так как

@cartouche
@lisp
 (defmacro if3 (test t-case nil-case ?-case)
       `(case ,test
           ((nil) ,nil-case)
           (?       ,?-case)
           (t       ,t-case)))

 (defmacro nif (expr pos zero neg)
       (let ((g (gensym)))
         `(let ((,g ,expr))
             (cond ((plusp ,g) ,pos)
                   ((zerop ,g) ,zero)
                   (t          ,neg)))))
@end lisp

                    Рисунок 11-5: Макрос для условных вычислений.
@end cartouche

@noindent
у искомого макроса with- возрастает сложность.

В CLTL2 Common Lisp, объявление dynamic-extent позволяет замыканию содержащему
тело более эффективно его размещать (в реализации CLTL1 оно будет игнорироваться).
Нам нужно это замкание только на время вызова with-db-fn, и объявление говорит о
том же, позволяя компилятору выделить для него место в стеке. Это пространство
будет автоматически восстановлено(возвращено) при выходе из выражения let,
вместо того, чтобы быть восстановленым позже с помощью сборщика мусора.

@node 11-3 Conditional Evaluation, 11-4 Iteration, 11-2 The with- Macro, 11 Classic Macros
@comment  node-name,  next,  previous,  up
@section 11-3 Условное Вычисление
@cindex 11-3 Conditional Evaluation

Иногда мы хотим, чтобы аргумент в вызове макроса вычислялся только при выполнении
определенного условия. Это находиться за пределами возможностей функции, которые 
всегда вычисляют свои аргументы. Встроенные операторы, такие как if, and, и cond 
защищают некоторые из своих аргументов от вычислений, если другие аргументы
не возвращают определенных значений. Например, в этом выражении

@lisp
(if t
    'phew
    (/ x 0))
@end lisp

третий аргумент вызвал бы ошибку деления на ноль, если бы был вычислен. Но поскольку
только первые два аргумента будут когда либо вычислены, этот if в целом будет всегда
безопасно возвращать phew.

Мы можем создавать новые операторы такого рода, написав макросы, которые расширяются
в вызовы существующих макросов.  Два макроса на рисунке 11-5 являются двумя из многих
возможных варинтов if. Определение if3 показывает, как мы можем опредилить условие
для трех значной логики. Вместо того. чтобы рассматривать nil как ложь и все остальное
как истину, этот макрос рассматривате три категории истин: истина(true), ложь(false) и
неопределенность(uncertain), представленную как ?. Это может быть использовано в
следующем описании поведения пятилетнего ребенка:

@lisp
(while (not sick)
  (if3 (cake-permitted)
       (eat-cake)
       (throw 'tantrum nil)
       (plead-insistently)))
(пока (не болен)
  (if3 (торт-разрешен)
       (ем-торт)
       (выброшу 'истерику nil)
       (настойчиво-умоляю)))
@end lisp

Новое условие расширяется в case. (ключ nil должен быть заключен в список, 
поскольку в одиночку ключ nil будет неоднознаным.) Только один из последних
трех аргументов будет вычислен, в зависимости от значения первого аргумента.

Имя nif означает "числовой(numeric) if." Другая реализация этого макроса 
представлена на странице 86. Он принимает числовое выражение в качестве 
первого аргумента и в зависимости от его знака вычисляется один из трех
оставшихся аргументов.

@example
> (mapcar #'(lambda (x)
              (nif x 'p 'z 'n))
          '(0 1 -1))
(Z P N)
@end example

Рисунок 11-6 содержит еще несколько макросов, которые используют условные
вычисления. Макрос in должен эффективно проверять членство в наборе. Когда вы
хотите проверить, является ли объект одним из множества альтернатив, вы можете
выразить запрос как дизъюнкцию:

@lisp
(let ((x (foo)))
  (or (eql x (bar)) (eql x (baz))))
@end lisp

@noindent
или вы можете выразить это в терминах членства в множестве:

@lisp
(member (foo) (list (bar) (baz)))
@end lisp

Последнее более абстрактнро, но менее эффективно. Выражение member привлекает
неэффективность из двух источников. Это создание списка(conse), поскольку он
должен собрать альтернативы в список для функции поиска члена(member). И все
альтернативные формы в списке должны быть вычислены, хотя некоторые значения,
возможно, никогда нам не понадобяться.  Если значение (foo) равно значению
(bar), тогда нет необходимости вычслять значение (baz). Безотносительно его
концептуальных преимуществ, использовать member далеко не лучший способ. 
Мы можем получить ту же абстракцию более эффективно с помощью макроса:
сочетающего абстракцию member с эффективностью or. Эквиваленое выражение in

@cartouche
@lisp
 (defmacro in (obj &rest choices)
       (let ((insym (gensym)))
        `(let ((,insym ,obj))
           (or ,@@(mapcar #'(lambda (c) `(eql ,insym ,c))
                            choices)))))

 (defmacro inq (obj &rest args)
       `(in ,obj ,@@(mapcar #'(lambda (a)
                                  `',a)
                              args)))

 (defmacro in-if (fn &rest choices)
       (let ((fnsym (gensym)))
        `(let ((,fnsym ,fn))
           (or ,@@(mapcar #'(lambda (c)
                                 `(funcall ,fnsym ,c))
                            choices)))))

 (defmacro >case (expr &rest clauses)
       (let ((g (gensym)))
        `(let ((,g ,expr))
           (cond ,@@(mapcar #'(lambda (cl) (>casex g cl))
                               clauses)))))

 (defun >casex (g cl)
       (let ((key (car cl)) (rest (cdr cl)))
        (cond ((consp key) `((in ,g ,@@key) ,@@rest))
              ((inq key t otherwise) `(t ,@@rest))
              (t (error "bad >case clause")))))
@end lisp

                Рисунок 11-6: Макросы для условных вычислений.
@end cartouche

@lisp
(in (foo) (bar) (baz))
@end lisp

@noindent
имеет ту же форму, что и выражение member, но расширяется в

@lisp
(let ((#:g25 (foo)))
  (or (eql #:g25 (bar))
      (eql #:g25 (baz))))
@end lisp

Как это часто бывает, когда сталкиваешся с выбором между ясностью выражения и
эффективностью, мы получаем неразрешимую дилему, написав макрос мы получаем
первое и второе, одновременно.

inq это квотирующий(добавляющий кавычку) вариант in, произноситься как "в очереди(in queue)", 
так же как setq использует set. Выражение

@lisp
(inq operator + - *)
@end lisp

расширяется в

@lisp
(in operator '+ '- '*)
@end lisp

Как и member по умолчанию, in и inq используют eql для проверки на равенство.
Когда вы захотите использовать какую то другую проверку test-or или любую 
другую функцию от одного аргумента - вы можете использовать более общий
in-if. Как in соответствует member, так in-if соответствует some. 
Выражение

@lisp
(member x (list a b) :test #'equal)
@end lisp

@noindent
может быть продублировано, как

@lisp
(in-if #'(lambda (y) (equal x y)) a b)
@end lisp

@noindent
и

@lisp
(some #'oddp (list a b))
@end lisp

@noindent
становиться

@lisp
(in-if #'oddp a b)
@end lisp

Используя комбинацию cond и in, мы можем определить полезный варинат case.
Макрос Common Lisp case предполагает, что его ключи становятся константами. 
Иногда нам может потребоваться поведение выражения case, но с ключами, которые
вычисляются. Для таких ситуаций мы определяем >case, такой же как case за 
исключением того, что ключи которые охраняют каждое предложение, вычисляются перед
сравнением. (Знак > в названии предназначен для предложения обозначения стрелки,
используемое для представления вычислений.) Поскольку >case использует in,
он вычисляет не больше ключей, чем нужно.

Поскольку ключи могут быть выражениями Lisp, невозможно определить является ли
(x y) вызовом или списком из двух ключей. Чтобы избежать двусмысленности, ключи
(кроме t и других) должны всегда указваться в списке, даже если есть только один
из них. В выражениях case, nil не может выступать в качестве начала(car) предложения
из за двусмысленности. В выражении >case, nil больше не является двусмысленным, как
и начало(car) предложения, но оно означает, что остальная часть предложения никогда
не будет вычислена.

Для ясности, код который генерирует расширение для каждого предложения >case
определяется как отдельная функция, >casex. Обратите внимание, чтоt >casex 
сама использует inq.

@cartouche
@lisp
 (defmacro while (test &body body)
       `(do ()
             ((not ,test))
          ,@@body))

 (defmacro till (test &body body)
       `(do ()
             (,test)
          ,@@body))

 (defmacro for ((var start stop) &body body)
       (let ((gstop (gensym)))
         `(do ((,var ,start (1+ ,var))
               (,gstop ,stop))
              ((> ,var ,gstop))
            ,@@body)))
@end lisp

                        Рисунок 11-7: Простые макросы итерации(повторения).
@end cartouche

@node 11-4 Iteration, 11-5 Iteration with Multiple Values, 11-3 Conditional Evaluation, 11 Classic Macros
@comment  node-name,  next,  previous,  up
@section 11-4 Итерации(Повторения)
@cindex 11-4 Iteration

Иногда проблема с функциями возникает не в том, что их аргументы всегда вычисляются,
а в том что они вычисляются только один раз. Поскольку каждый аргумент функции будет
вычислен ровно один раз, если мы хотим определить оператор который получает тело
выражений и повторяет их вычисление, нам нужно определить его как макрос.

Простейшим примером будет макрос, который последовательно вычисляет свои 
аргументы forever:

@lisp
(defmacro forever (&body body)
  `(do ()
       (nil)
       ,@@body))
@end lisp

Это именно то, что делает встроенный макрос цикла loops, если вы не даете ему
ключевых слов цикла. Может показаться, что у такого цикла нет будущего (или
слишком много будущего) т.к он представляет бесконечный цикл. Но в сочетании
с block и return-from, этот вид макроса становиться наиболее естественным
способом выразить циклы, где завершение цикла, по своей природе, это чрезвычайная
ситуация.

Некоторые из простейших макросов для итерации показаны на рисунке 11-7. Мы уже
видели while (на стр. 91), чье тело будет вычисляться пока тестовое выражение
возвращает истину. Обратное ему till, которое делает тоже самое пока тестовое 
выражение возвращает ложь. Наконец for, также показанное раньше (стр. 129), 
выполняет итерации для диапазона чисел.

По определению эти макросы расширяются в do, мы делаем доступным использование go и
return в их телах. Как do наследует эти права от block и tagbody, так и while, till
и for наследует их от do. Как объяснено на странице 131, метка nil неявного block 
обернутого вокруг do будет захвачена определенными на Рисунке 11-7. Это скорее
особенность, чем ошибка, но об этом следует явно упомянуть.

Макросы необходимы когда нам нужно определить более мощную конструкцию для 
итерации. Рисунок 11-8 содержит два обобщения dolist; оба вычисляют свои тела
с набором(tuple) переменных, связанных с последовательными подпоследовательностями
списка(list). Например, если заданы два параметра do-tuples/o будет итерировать
по парам:

@example
> (do-tuples/o (x y) '(a b c d)
         (princ (list x y)))
(A B)(B C)(C D)
NIL
@end example

@noindent
С теми же аргументами, do-tuples/c сделает тоже самое, а затем завернёт
на начало списка, для получения недостающих аргументов:

@example
> (do-tuples/c (x y) '(a b c d)
         (princ (list x y)))
(A B)(B C)(C D)(D A)
NIL
@end example

Оба макроса возвращают nil, если в теле нет явного возврата return.

Этот вид итерации часто необходим в программах, которые имеют дело с некоторыми
представлениями пути. Суфиксы /o и /c предполагают две версии перемещения по
открытым и замкнутым путям, соответственно. Например, если точки это список
точек и (drawline x y) рисует линию между x и y, а затем рисует путь от
первой точки к последней мы напишем.

@lisp
(do-tuples/o (x y) points (drawline x y))
@end lisp

@noindent
тогда как, если точки это список вершин многоугольника, мы рисуем его периметр
написав

@lisp
(do-tuples/c (x y) points (drawline x y))
@end lisp

Список аргументов, указанных в качестве первого аргумента, может быть любой 
длины, и итерация будет продолжаться кортежами этой же длины. Если задан только
один параметр, оба

@cartouche
@lisp
 (defmacro do-tuples/o (parms source &body body)
       (if parms
          (let ((src (gensym)))
            `(prog ((,src ,source))
                (mapc #'(lambda ,parms ,@@body)
                        ,@@(map0-n #'(lambda (n)
                                         `(nthcdr ,n ,src))
                                      (1- (length parms))))))))

 (defmacro do-tuples/c (parms source &body body)
       (if parms
          (with-gensyms (src rest bodfn)
            (let ((len (length parms)))
              `(let ((,src ,source))
                    (when (nthcdr ,(1- len) ,src)
                      (labels ((,bodfn ,parms ,@@body))
                        (do ((,rest ,src (cdr ,rest)))
                             ((not (nthcdr ,(1- len) ,rest))
                              ,@@(mapcar #'(lambda (args)
                                                  `(,bodfn ,@@args))
                                           (dt-args len rest src))
                              nil)
                          (,bodfn ,@@(map1-n #'(lambda (n)
                                                      `(nth ,(1- n)
                                                              ,rest))
                                                   len))))))))))

 (defun dt-args (len rest src)
       (map0-n #'(lambda (m)
                     (map1-n #'(lambda (n)
                                   (let ((x (+ m n)))
                                       (if (>= x len)
                                           `(nth ,(- x len) ,src)
                                           `(nth ,(1- x) ,rest))))
                              len))
              (- len 2)))
@end lisp

               Рисунок 11-8: Макросы для итерации на подпоследовательностях.
@end cartouche

@cartouche
@lisp
 (do-tuples/c (x y z) '(a b c d)
       (princ (list x y z)))
@end lisp

@noindent
расширяется в:

@lisp
 (let ((#:g2 '(a b c d)))
       (when (nthcdr 2 #:g2)
         (labels ((#:g4 (x y z)
                       (princ (list x y z))))
           (do ((#:g3 #:g2 (cdr #:g3)))
               ((not (nthcdr 2 #:g3))
                  (#:g4 (nth 0 #:g3)
                          (nth 1 #:g3)
                          (nth 0 #:g2))
                  (#:g4 (nth 1 #:g3)
                          (nth 0 #:g2)
                          (nth 1 #:g2))
                  nil)
             (#:g4 (nth 0 #:g3)
                      (nth 1 #:g3)
                      (nth 2 #:g3))))))
@end lisp

                  Рисунок 11-9: Expansion of a call to do-tuples/c.
@end cartouche

@noindent
вырождаются в dolist:

@example
> (do-tuples/o (x) '(a b c) (princ x))
ABC
NIL
> (do-tuples/c (x) '(a b c) (princ x))
ABC
NIL
@end example

Определение do-tuples/c является более сложным, чем определение do-tuples/o,
поскольку он должен заворачивать по достижении конца списка. Если есть n
параметров do-tuples/c должен выполнить еще n-1 итераций перед возвратом:

@example
> (do-tuples/c (x y z) '(abcd)
        (princ (list x y z)))
(A B C)(B C D)(C D A)(D A B)
NIL

> (do-tuples/c (wxyz)'(abcd)
           (princ (list w x y z)))
   (A B C D)(B C D A)(C D A B)(D A B C)
   NIL
@end example

Расширение предшествующего вызова do-tuples/c показано на рисунке 11-9. Сложная
часть для генерации  - это последовательность вызовов представляющих переход
на начало списка. Эти вызовы (в данном случае два из них) генерируются  dt-args.

@node 11-5 Iteration with Multiple Values, 11-6 Need for Macros, 11-4 Iteration, 11 Classic Macros
@comment  node-name,  next,  previous,  up
@section 11-5 Итерация с Множественными Значениями
@cindex 11-5 Iteration with Multiple Values

Встроенные макросы do существуют дольше, чем возврат множественных значений.
К счастью do может развиваться в соответствии с новой ситуацией, поскольку эволюция
Lisp находиться в руках программиста. Рисунок 11-10 содержит версию do* приспособленную
для работы с множественными значениями. С mvdo*, каждое начальное предложение может 
связать больше чем одну переменную:

@example
   > (mvdo* ((x 1 (1+ x))
                    ((y z) (values 0 0) (values z x)))
                  ((> x 5) (list x y z))
           (princ (list x y z)))
   (1 0 0)(2 0 2)(3 2 3)(4 3 4)(5 4 5)
   (656)
@end example

Этот вид итерации полезен, например, в интерактивных графических программах,
которые часто имеют дело с несколькими величинами, таким как координаты и
регионы(области).

Предположим, что мы хотим написать простую интерактивную игру, в которой объект,
должен избежать зажатия между двумя преследующими его объектами. Если два преследователя
оба ударят вас одновременно, вы проиграете; если они столкнутья друг с другом первыми,
вы виграете. На рисунке 11-11 показано, как можно написать основной цикл этой игры,
используя mvdo*.

Также возможно написать mvdo, которая связывает свои локальные переменные параллельно:

@example
   > (mvdo ((x 1 (1+ x))
                  ((y z) (values 0 0) (values z x)))
                 ((> x 5) (list x y z))
           (princ (list x y z)))
   (1 0 0)(2 0 1)(3 1 2)(4 2 3)(5 3 4)
   (645)
@end example

Необходимый для psetq в определении do был описан на странице 96. Чтобы определить
mvdo нам необходима версия psetq поддерживающая множественные значения. Поскольку
Common Lisp такой не имеет, мы дожны сами ее написать, как на рисунке 11-12. Новый
макрос работает следующим образом:

@cartouche
@lisp
 (defmacro mvdo* (parm-cl test-cl &body body)
    (mvdo-gen parm-cl parm-cl test-cl body))

 (defun mvdo-gen (binds rebinds test body)
    (if (null binds)
           (let ((label (gensym)))
             `(prog nil
                ,label
                (if ,(car test)
                     (return (progn ,@@(cdr test))))
                ,@@body
                ,@@(mvdo-rebind-gen rebinds)
                (go ,label)))
           (let ((rec (mvdo-gen (cdr binds) rebinds test body)))
             (let ((var/s (caar binds)) (expr (cadar binds)))
               (if (atom var/s)
                    `(let ((,var/s ,expr)) ,rec)
                    `(multiple-value-bind ,var/s ,expr ,rec))))))

 (defun mvdo-rebind-gen (rebinds)
    (cond ((null rebinds) nil)
             ((< (length (car rebinds)) 3)
              (mvdo-rebind-gen (cdr rebinds)))
             (t(cons (list (if (atom (caar rebinds))
                                   'setq
                                   'multiple-value-setq)
                              (caar rebinds)
                              (third (car rebinds)))
                     (mvdo-rebind-gen (cdr rebinds))))))
@end lisp

              Рисунок 11-10: Связывающая множественные значения версия do*.
@end cartouche

@example
> (let ((w 0) (x 1) (y 2) (z 3))
        (mvpsetq (w x) (values 'a 'b) (y z) (values w x))
        (list wxyz))
(AB01)
@end example

Определение mvpsetq опирается на три служебные функции: mklist (стр 45),
group (стр 47), и shuffle, определеннуюю здесь, которая смешивает два
списка:

@cartouche
@lisp
 (mvdo* (((px py) (pos player)               (move player mx my))
              ((x1 y1) (pos obj1)            (move obj1 (- px x1)
                                                            (- py y1)))
              ((x2 y2) (pos obj2)            (move obj2 (- px x2)
                                                            (- py y2)))
              ((mx my) (mouse-vector) (mouse-vector))
              (win       nil                 (touch obj1 obj2))
              (lose      nil                 (and (touch obj1 player)
                                                   (touch obj2 player))))
             ((or win lose) (if win 'win 'lose))
       (clear)
       (draw obj1)
       (draw obj2)
       (draw player))
@end lisp

 (pos obj) возвращает два значения x,y представляющих позицию объекта obj. Первоначально
три объекта имеют случайное положение.

 (move obj dx dy) перемещает объект obj в зависимости от его типа и вектора
  dx,dy . Возвращает два значения x,y указывающих на новыую позицию.

 (mouse-vector) возвращает два значения dx,dy указывающих на текущее
перемещение мыши.

 (touch obj1 obj2) возвращает истину если obj1 и obj2 соприкасаются.

 (clear) очищает игровой регион.

 (draw obj) рисует obj в его текущей позиции.

                        Рисунок 11-11: Игра в мяч.
@end cartouche

@example
> (shuffle '(a b c) '(1 2 3 4))
(A1B2C34)
@end example

С помощью mvpsetq, мы можем определить mvdo как показано на Рисунке 11-13. Подобно condlet, 
этот макрос использует mappend вместо mapcar чтобы избежать изменения исходного вызова
макроса. Идиома mappend-mklist сглаживает у дерева один уровень:

@example
> (mappend #'mklist '((a b c) d (e (f g) h) ((i)) j))
(ABCDE(FG)H(I)J)
@end example

@cartouche
@lisp
 (defmacro mvpsetq (&rest args)
    (let* ((pairs (group args 2))
              (syms (mapcar #'(lambda (p)
                                      (mapcar #'(lambda (x) (gensym))
                                                 (mklist (car p))))
                                 pairs)))
        (labels ((rec (ps ss)
                     (if (null ps)
                          `(setq
                              ,@@(mapcan #'(lambda (p s)
                                               (shuffle (mklist (car p))
                                                           s))
                                          pairs syms))
                          (let ((body (rec (cdr ps) (cdr ss))))
                              (let ((var/s (caar ps))
                                     (expr (cadar ps)))
                               (if (consp var/s)
                                     `(multiple-value-bind ,(car ss)
                                                                   ,expr
                                         ,body)
                                     `(let ((,@@(car ss) ,expr))
                                         ,body)))))))
         (rec pairs syms))))

 (defun shuffle (x y)
    (cond ((null x) y)
              ((null y) x)
              (t (list* (car x) (car y)
                         (shuffle (cdr x) (cdr y))))))
@end lisp

                Рисунок 11-12: Версия работющего с Множественным значением psetq.
@end cartouche

Чтобы понять этот довольно большой макрос. на рисунке 11-14 приведен пример
его расширения.

@node 11-6 Need for Macros,  , 11-5 Iteration with Multiple Values, 11 Classic Macros
@comment  node-name,  next,  previous,  up
@section 11-6 Потребность в Макросах
@cindex 11-6 Need for Macros

Макрос это не единственный способ защитить аргументы от вычисления. Другой, заключается
в том чтобы обернуть их в замыкание. Условные и повторяющиеся вычисления похожи, потому
что ни одна проблема по своей сути не требует макросов. Например, мы могли бы написать
версию

@cartouche
@lisp
 (defmacro mvdo (binds (test &rest result) &body body)
       (let ((label (gensym))
            (temps (mapcar #'(lambda (b)
                                       (if (listp (car b))
                                            (mapcar #'(lambda (x)
                                                            (gensym))
                                                        (car b))
                                            (gensym)))
                                  binds)))
        `(let ,(mappend #'mklist temps)
           (mvpsetq ,@@(mapcan #'(lambda (b var)
                                           (list var (cadr b)))
                                      binds
                                      temps))
           (prog ,(mapcar #'(lambda (b var) (list b var))
                               (mappend #'mklist (mapcar #'car binds))
                               (mappend #'mklist temps))
                 ,label
                 (if ,test
                     (return (progn ,@@result)))
                 ,@@body
                 (mvpsetq ,@@(mapcan #'(lambda (b)
                                               (if (third b)
                                                     (list (car b)
                                                          (third b))))
                                        binds))
                 (go ,label)))))
@end lisp

                 Рисунок 11-13: Версия do связывающая множественные значения.
@end cartouche

@noindent
 if как функцию:

@lisp
(defun fnif (test then &optional else)
  (if test
         (funcall then)
         (if else (funcall else))))
@end lisp

Мы бы защитили аргументы then и else, выражая их как замыкания,
так вместо

@lisp
(if (rich) (go-sailing) (rob-bank))
@end lisp
@cartouche
@lisp
 (mvdo ((x 1 (1+ x))
             ((y z) (values 0 0) (values z x)))
           ((> x 5) (list x y z))
     (princ (list x y z)))
@end lisp

@noindent
Расширяется в:

@lisp
 (let (#:g2 #:g3 #:g4)
     (mvpsetq #:g2 1
                   (#:g3 #:g4) (values 0 0))
     (prog ((x #:g2) (y #:g3) (z #:g4))
          #:g1
          (if (> x 5)
                (return (progn (list x y z))))
          (princ (list x y z))
          (mvpsetq x (1+ x)
                        (y z) (values z x))
          (go #:g1)))
@end lisp

                       Рисунок 11-14: Расширение вызова mvdo.
@end cartouche

@noindent
мы бы сказали

@lisp
(fnif (rich)
         #'(lambda () (go-sailing))
         #'(lambda () (rob-bank)))
@end lisp

Если все, что нам нужно, это условные вычисления, макросы не являются абсолютно 
необходмыми. Они просто делают программы яснее. Тем не менее, макросы необходмы, когда
мы хотим разобрать аргументы формы, или связывать переменные передаваемые в качестве
аргументов.

Тоже самое отностся к макросам для итерации. Хотя макросы предлагают
естественный способ определить итерационную конструкцию, за которой
может следовать тело выражений, можно выполнить итерацию с использованием
функций, если тело цикла само упаковано в функцию.@footnote{Возможно
написать итерационную функцию, которая не нуждается в аргументах,
обернутых в функцию. Мы могли бы написать функцию, которая вызывала бы
eval для выражений переданных ей в качестве аргументов. Для объяснения
того, почему обычно плохо вызывать eval, смотри стр. 278.} Например, 
встроенная функция mapc, это функциональный аналог dolist. 
Выражение

@lisp
(dolist (b bananas)
   (peel b)
   (eat b))
@end lisp

@noindent
имеет те же побочные эффекты, что и

@lisp
(mapc #'(lambda (b)
                (peel b)
                (eat b))
           bananas)
@end lisp

@noindent
(хотя первый возвращает nil, а последующий возвращает список бананов). Мы могли бы
аналогично реализовать forever как функцию,

@lisp
(defun forever (fn)
  (do ()
           (nil)
        (funcall fn)))
@end lisp

@noindent
если бы мы были готовы передать это как замыкание вместо тела выражений.

Тем не менее, итерационные конструкции обычно хотят делать больше, чем просто
итерацию, как это forever делает: они обычно хотят сделать комбинацию связвания и
итерации. С использованием функций, перспективы связывания ограничены. Если вы хотите
связать переменные для последовательности элементов списков, вы можете использовать
одну из функций отображения(mapping). Но если требования усложняются, вам придется
писать макрос.