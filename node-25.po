#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-25.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-07-03 12:40+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-25.texi:5
msgid ""
"@node 25 Object-Oriented Lisp, Appendix Packages, 24 Prolog, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 25 Object-Oriented Lisp\n"
"@cindex 25 Object-Oriented Lisp"
msgstr ""
"@node 25 Object-Oriented Lisp, Appendix Packages, 24 Prolog, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 25 Объектно Ориентированный Lisp\n"
"@cindex 25 Object-Oriented Lisp"

#: texi/node-25.texi:12
msgid ""
"This chapter discusses object-oriented programming in Lisp. Common Lisp\n"
"includes a set of operators for writing object-oriented programs. "
"Collectively they\n"
"are called the Common Lisp Object System, or CLOS. Here we consider CLOS "
"not\n"
"just as a way of writing object-oriented programs, but as a Lisp program "
"itself.\n"
"Seeing CLOS in this light is the key to understanding the relation between "
"Lisp and\n"
"object-oriented programming."
msgstr ""
"В этой главе обсуждается объектно-ориентированное программирование на Lisp. "
"Common Lisp\n"
"включает в себя набор операторов для написания объектно-ориентриованных "
"программ. В\n"
"совокупности они называются Common Lisp Object System, или CLOS. Здесь мы "
"рассматриваем\n"
"CLOS не просто как способ написания объектно ориентированных программ, а как "
"саму\n"
"программу на Lisp. Видение CLOS в этом свете является ключом к пониманию "
"связи между\n"
"Lisp и объектно ориентированным программированием."

#: texi/node-25.texi:21
msgid ""
"@menu\n"
"* 25-1 Plus ça Change::         \n"
"* 25-2 Objects in Plain Lisp::  \n"
"* 25-3 Classes and Instances::  \n"
"* 25-4 Methods::                \n"
"* 25-5 Auxiliary Methods and Combination::  \n"
"* 25-7 When to Object::         \n"
"@end menu"
msgstr ""

#: texi/node-25.texi:26
msgid ""
"@node 25-1 Plus ça Change, 25-2 Objects in Plain Lisp, 25 Object-Oriented "
"Lisp, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-1 Plus ça Change\n"
"@cindex 25-1 Plus ça Change"
msgstr ""
"@node 25-1 Plus ça Change, 25-2 Objects in Plain Lisp, 25 Object-Oriented "
"Lisp, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-1 Plus ça Change\n"
"@cindex 25-1 Plus ça Change"

#: texi/node-25.texi:34
msgid ""
"Object-oriented programming means a change in the way programs are "
"organized.\n"
"This change is analogous to the one that has taken place in the distribution "
"of\n"
"processor power. In 1970, a multi-user computer system meant one or two big\n"
"mainframes connected to a large number of dumb terminals. Now it is more "
"likely\n"
"to mean a large number of workstations connected to one another by a "
"network.\n"
"The processing power of the system is now distributed among individual "
"users\n"
"instead of centralized in one big computer."
msgstr ""
"Объектно-ориентированное программирование означает изменение способа "
"организации\n"
"программ. Это изменение аналогично тому, какое имело место при "
"распределении\n"
"мощности процессора. В 1970, многопользовательская компьютерная система "
"означала\n"
"один или два больших мэйн фрейма, подключенных к большому количеству \"глупых"
"\"(dumb)\n"
"терминалов. Теперь это скорее всего означает большое количество рабочих "
"станций,\n"
"соединенных друг с другом сетью. Теперь вычислительная мощность системы "
"распределяется\n"
"между отдельными пользователями, а не централизованно на одном большом "
"компьютере."

#: texi/node-25.texi:39
msgid ""
"Object-oriented programming breaks up traditional programs in much the\n"
"same way: instead of having a single program which operates on an inert "
"mass\n"
"of data, the data itself is told how to behave, and the program is implicit "
"in the\n"
"interactions of these new data \"objects.\""
msgstr ""
"Объектно-ориентированное программирование разбивает традиционные программы "
"почти\n"
"таким же образом: вместо единой программы, которая работает с инертной "
"массой данных,\n"
"самим данным сообщается, как себя вести, и программа является неявным "
"взаимодействием\n"
"этих новых \"объектов\" данных."

#: texi/node-25.texi:43
msgid ""
"For example, suppose we want to write a program to find the areas of\n"
"two-dimensional shapes. One way to do this would be to write a single "
"function\n"
"which looked at the type of its argument and behaved accordingly:"
msgstr ""
"Например, предположим, что мы хотим написать программу для поиска площадей\n"
"двумерных фигур. Одним из способов сделать это было бы написать функцию,\n"
"которая смотрела бы на тип свого аргумента и вела бы себя соответственно:"

#: texi/node-25.texi:49
msgid ""
"@lisp\n"
"(defun area (x)\n"
"  (cond ((rectangle-p x) (* (height x) (width x)))\n"
"           ((circle-p x) (* pi (expt (radius x) 2)))))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:53
msgid ""
"The object-oriented approach is to make each object able to calculate its "
"own area.\n"
"The area function is broken apart and each clause distributed to the "
"appropriate\n"
"class of object; the area method of the rectangle class might be"
msgstr ""
"Объектно-ориентированный подход заключается в том, чтобы каждый объект мог "
"сам\n"
"рассчитывать свою собственную площадь. Функция area разбита на части и "
"каждое\n"
"предложение распространяется на соответствующий класс объекта; метод area "
"класса\n"
"прямоугольника(rectangle) может быть"

#: texi/node-25.texi:57
msgid ""
"@lisp\n"
"#'(lambda (x) (* (height x) (width x)))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:60
msgid ""
"@noindent\n"
"and for the circle class,"
msgstr ""
"@noindent\n"
"и для класса круга(circle),"

#: texi/node-25.texi:64
msgid ""
"@lisp\n"
"#'(lambda (x) (* pi (expt (radius x) 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:67
msgid ""
"In this model, we ask an object what its area is, and it responds according "
"to the\n"
"method provided for its class."
msgstr ""
"В этой модели, мы спрашиваем объект, какова его площадь, и он отвечает в "
"соответствии\n"
"с методом, предоставленным для его класса."

#: texi/node-25.texi:75
msgid ""
"The arrival of CLOS might seem a sign that Lisp is changing to embrace the\n"
"object-oriented paradigm. Actually, it would be more accurate to say that "
"Lisp\n"
"is staying the same to embrace the object-oriented paradigm. But the "
"principles\n"
"underlying Lisp don't have a name, and object-oriented programming does, "
"so  \n"
"there is a tendency now to describe Lisp as an object-oriented language. It "
"would\n"
"be closer to the truth to say that Lisp is an extensible language in which "
"constructs\n"
"for object-oriented programming can easily be written."
msgstr ""
"Появление CLOS может показаться признаком того, что Lisp меняется, чтобы "
"принять\n"
"объектно-ориентированную парадигму. На самом деле, было бы точнее сказать, "
"что Lisp\n"
"остается неизменным, чтобы принять объектно-ориентированную парадигму. Но "
"принципы\n"
"лежащие в основе Lisp не имеют названия, как у объектно-ориентированного "
"программирования,\n"
"поэтому сейчас существует тенденция описывать Lisp как объектно-"
"ориентированный язык. \n"
"Но было бы ближе к правде сказть, что Lisp является расширяемым языком, на "
"котором легко\n"
"могут быть написаны конструкции для объектно-ориентированного "
"программирования."

#: texi/node-25.texi:82
msgid ""
"Since CLOS comes pre-written, it is not false advertising to describe Lisp "
"as\n"
"an object-oriented language. However, it would be limiting to see Lisp as "
"merely\n"
"that. Lisp is an object-oriented language, yes, but not because it has "
"adopted\n"
"the object-oriented model. Rather, that model turns out to be just one more\n"
"permutation of the abstractions underlying Lisp. And to prove it we have "
"CLOS,a\n"
"program written in Lisp, which makes Lisp an object-oriented language."
msgstr ""
"Поскольку CLOS поставляется предварительно написанным, описание Lisp как "
"объектно-\n"
"ориентированного языка не является ложной рекламой. Однако было бы "
"ограничением\n"
"смотреть так на Lisp. Да, Lisp это объектно-ориентированный язык, но не "
"потому,\n"
"что он принял объектно ориентированную модель. Скроее, эта модель "
"оказывается\n"
"еще одной перестановкой абстракций, лежащих в основе Lisp. И чтобы доказть "
"это, у\n"
"нас есть CLOS, программа написанная на Lisp, которая делает Lisp объектно-\n"
"ориентированным языком."

#: texi/node-25.texi:90
msgid ""
"The aim of this chapter is to bring out the connection between Lisp and\n"
"object-oriented programming by studying CLOS as an example of an embedded\n"
"language. This is also a good way to understand CLOS itself: in the end, "
"nothing\n"
"explains a language feature more effectively than a sketch of its "
"implementation.\n"
"In Section 7-6, macros were explained this way. The next section gives a "
"similar\n"
"sketch of how to build object-oriented abstractions on top of Lisp. This "
"program\n"
"provides a reference point from which to describe CLOS in Sections 25-3­25-6."
msgstr ""
"Цель этой главы - выявить связь между Lisp и объектно-ориентированным "
"программированием,\n"
"изучая CLOS как пример встроенного языка. Это также хороший способ понять "
"сам CLOS:\n"
"в конце концов, ничто не объясняет языковую функцию более эффективно, ем "
"набросок её\n"
"реализации. В разделе 7-6, таким образом объяснялись макросы. В следующем "
"разделе\n"
"дается аналогичный эскиз того, как создавать объектно-ориентированные "
"абстракции поверх\n"
"Lisp. Эта программа обеспечивает ориентир для описания CLOS в Разделах 25.3 "
"- ­25-6."

#: texi/node-25.texi:95
msgid ""
"@node 25-2 Objects in Plain Lisp, 25-3 Classes and Instances, 25-1 Plus ça "
"Change, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-2 Objects in Plain Lisp\n"
"@cindex 25-2 Objects in Plain Lisp"
msgstr ""
"@node 25-2 Objects in Plain Lisp, 25-3 Classes and Instances, 25-1 Plus ça "
"Change, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-2 Объекты в простом/чистом Lisp\n"
"@cindex 25-2 Objects in Plain Lisp"

#: texi/node-25.texi:104
msgid ""
"We can mold Lisp into many different kinds of languages. There is a "
"particularly\n"
"direct mapping between the concepts of object-oriented programming and the\n"
"fundamental abstractions of Lisp. The size of CLOS tends to obscure this "
"fact. So\n"
"before looking at what we can do with CLOS, let's see what we can do with "
"plain\n"
"Lisp.Much of what we want from object-orientedprogramming, we have already\n"
"in Lisp. We can get the rest with surprisingly little code. In this section, "
"we will\n"
"define an object system sufficient for many real applications in two pages "
"of code.\n"
"Object-oriented programming, at a minimum, implies"
msgstr ""
"Мы можем лепить из Lisp множество видов языков. Существует прямое "
"соответствие\n"
"между концепциями объектно-ориентированного программирования и "
"фундаментальными\n"
"абстракциями Lisp. Размер CLOS имеет тенденцию скрывать этот факт. Итак, "
"прежде\n"
"чем посмотреть, что мы можем сделать с CLOS, давайте посмотрим, что мы "
"можем \n"
"сделать с простым Lisp. \n"
"  Многое из того, что мы хотем от объектно-ориентированного "
"программирования, \n"
"уже есть в Lisp. И мы можем получить остальное с удивительно небольшим "
"кодом. \n"
"В этом разделе мы определим объектную систему, достаточную для многих "
"реальных\n"
"приложений, на двух страницах кода.\n"
"  Объектно ориентированное программирование, как минимум, подразумевает"

#: texi/node-25.texi:113
msgid ""
"@enumerate\n"
"@item\n"
"objects which have properties\n"
"@item\n"
"and respond to messages,\n"
"@item\n"
"and which inherit properties and methods from their parents.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"объекты, которые имеют свойства\n"
"@item\n"
"и отвечают на сообщения,\n"
"@item\n"
"и которые наследуют свойства и методы от своих родителей.\n"
"@end enumerate"

#: texi/node-25.texi:118
msgid ""
"In Lisp, there are already several ways to store collections of properties.\n"
"One way would be to represent objects as hash-tables, and store their "
"properties\n"
"as entries within them. We then have access to individual properties "
"through\n"
"gethash:"
msgstr ""
"В Lisp уже есть несколько способов хранения коллекций свойств.\n"
"Один из способов - представить объекты в виде хеш-таблиц и сохранить их "
"свойства\n"
"в виде записепй внутри них. Затем у нас есть доступ к отдельным свойствам "
"через\n"
"gethash:"

#: texi/node-25.texi:122
msgid ""
"@lisp\n"
"(gethash 'color obj)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:126
msgid ""
"Since functions are data objects, we can store them as properties too. This "
"means\n"
"that we can also have methods; to invoke a given method of an object is to "
"funcall\n"
"the property of that name:"
msgstr ""
"Поскольку функции являются объектами данных, мы также можем хранить их как "
"свойства.\n"
"Это означает, что у нас также могут быть методы; Вызов данного метода "
"объекета означает\n"
"передачу funcall свойства с этим именем:"

#: texi/node-25.texi:130
msgid ""
"@lisp\n"
"(funcall (gethash 'move obj) obj 10)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:132
msgid "We can define a Smalltalk style message-passing syntax upon this idea:"
msgstr ""
"Основываясь на этой идее мы можем определить Smalltalk стиль передачи "
"сообщений:"

#: texi/node-25.texi:137
msgid ""
"@lisp\n"
"(defun tell (obj message &rest args)\n"
"  (apply (gethash message obj) obj args))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:140
msgid ""
"@noindent\n"
"so that to tell obj to move 10 we can say"
msgstr ""
"@noindent\n"
"так чтобы указать obj, чтобы он переместился на 10 мы можем сказать:"

#: texi/node-25.texi:144
msgid ""
"@lisp\n"
"(tell obj 'move 10)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:148
msgid ""
"In fact, the only ingredient plain Lisp lacks is inheritance, and we can "
"provide\n"
"a rudimentary version of that in six lines of code, by defining a recursive "
"version\n"
"of gethash:"
msgstr ""
"Фактически, единственный компонент отсутствующий в простом Lisp это "
"наследование, и мы\n"
"можем предоставить его элементарную версию в шести строках кода, "
"определяющих рекурсивную\n"
"версию gethash:"

#: texi/node-25.texi:156
msgid ""
"@lisp\n"
"(defun rget (obj prop)\n"
"  (multiple-value-bind (val win) (gethash prop obj)\n"
"        (if win\n"
"              (values val win)\n"
"              (let ((par (gethash 'parent obj)))\n"
"                (and par (rget par prop))))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"(defun rget (obj prop)\n"
"  (multiple-value-bind (val win) (gethash prop obj)\n"
"        (if win\n"
"              (values val win)\n"
"              (let ((par (gethash 'parent obj)))\n"
"                (and par (rget par prop))))))"

#: texi/node-25.texi:163
msgid ""
" (defun rget (obj prop)\n"
"    (some2 #'(lambda (a) (gethash prop a))\n"
"             (get-ancestors obj)))"
msgstr ""

#: texi/node-25.texi:172
msgid ""
" (defun get-ancestors (obj)\n"
"    (labels ((getall (x)\n"
"                   (append (list x)\n"
"                             (mapcan #'getall\n"
"                                        (gethash 'parents x)))))\n"
"        (stable-sort (delete-duplicates (getall obj))\n"
"                        #'(lambda (x y)\n"
"                             (member y (gethash 'parents x))))))"
msgstr ""

#: texi/node-25.texi:181
msgid ""
" (defun some2 (fn lst)\n"
"    (if (atom lst)\n"
"         nil\n"
"         (multiple-value-bind (val win) (funcall fn (car lst))\n"
"            (if (or val win)\n"
"                 (values val win)\n"
"                 (some2 fn (cdr lst))))))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:183
msgid "                       Figure 25-1: Multiple inheritance."
msgstr ""
"                       Рисунок 25-1: Множественное наследование.\n"
"@end cartouche"

#: texi/node-25.texi:187
msgid ""
"If we just use rget in place of gethash, we will get inherited properties "
"and\n"
"methods. We specify an object's parent thus:"
msgstr ""
"Если мы просто используем rget вместо gethash, мы получим наследование\n"
"свойств и методов. Мы указываем объект-родитель следующим образом:"

#: texi/node-25.texi:189
msgid "(setf (gethash 'parent obj) obj2)"
msgstr ""

#: texi/node-25.texi:202
msgid ""
"So far we have only single inheritance-an object can only have one parent.\n"
"But we can have multiple inheritance by making the parent property a list, "
"and\n"
"defining rget as in Figure 25-1.\n"
"   With single inheritance, when we wanted to retrieve some property of an\n"
"object, we just searched recursively up its ancestors. If the object itself "
"had no\n"
"information about the property we wanted, we looked at its parent, and so "
"on.\n"
"With multiple inheritance we want to perform the same kind of search, but "
"our job\n"
"is complicated by the fact that an object's ancestors can form a graph "
"instead of a\n"
"simple list. We can't just search this graph depth-first. With multiple "
"parents we\n"
"can have the hierarchy shown in Figure 25-2: a is descended from b and c, "
"which\n"
"are both descended from d. A depth-first (or rather, height-first) traversal "
"would\n"
"go a, b, d, c, d. If the desired property were present in both d and c, we "
"would"
msgstr ""
"Поскольку у нас только одно наследование у объекта может быть только один "
"родитель(parent).\n"
"НО мы можем иметь множественное наследование, сделав свойство parent "
"списком, и\n"
"определивg rget как показано на Рисунке 25-1.\n"
"   При одиночном наследовании, когда мы хотели получить какое-либо свойство "
"объекта,\n"
"мы просто рекурсивно искали его предков. Если сам объект не имел информации "
"о\n"
"желаемом свойстве, мы смотрели на его родителя и так далее.\n"
"   При множественном наследовании мы хотим выполнять поиск того же рода, но "
"наша работа\n"
"осложняется тем фактом, что предки объекта могут формировать граф, вместо "
"простого\n"
"списка. Мы не можем просто искать в этом графе в глубину. С множественным "
"наследованием\n"
"мы можем иметь иерархию показанную на Рисунке 25-2: a происходит от b и c, "
"которые оба\n"
"происходят от d. Обход в глубину (точнее, в высоту), будет идти по a, b, d, "
"c, d. Если\n"
"бы желаемое свойство присутствовало как в d, так и  c, мы бы"

#: texi/node-25.texi:205
msgid "   352                               OBJECT-ORIENTED LISP"
msgstr " "

#: texi/node-25.texi:219
msgid "                         Figure 25-2: Multiple paths to a superclass."
msgstr ""
"@cartouche\n"
"                         Figure 25-2: Multiple paths to a superclass.\n"
"@end cartouche"

#: texi/node-25.texi:240
msgid ""
"   get the value stored in d, not the one stored in c. This would violate "
"the principle\n"
"   that subclasses override the default values provided by their parents.\n"
"          If we want to implement the usual idea of inheritance,we should "
"never examine\n"
"   an object before one of its descendants. In this case, the proper search "
"order would\n"
"   be a, b, c, d. How can we ensure that the search always tries descendants "
"first?\n"
"   The simplest way is to assemble a list of all the ancestors of the "
"original object,\n"
"   sort the list so that no object appears before one of its descendants, "
"and then look\n"
"   at each element in turn.\n"
"          This strategy is used by get-ancestors,which returns a properly "
"ordered list\n"
"  of an object and its ancestors. To sort the list, get-ancestors calls "
"stable-sort\n"
"   instead of sort, to avoid the possibility of reordering parallel "
"ancestors. Once the\n"
"   list is sorted, rget merely searches for the first object with the "
"desired property.\n"
"   (The utility some2 is a version of some for use with functions like "
"gethash that\n"
"   indicate success or failure in the second return value.)\n"
"          The list of an object's ancestors goes from most specific to least "
"specific: if\n"
"   orange is a child of citrus, which is a child of fruit, then the list "
"will go\n"
"   (orange citrus fruit).\n"
"          When an object has multiple parents, their precedence goes left-to-"
"right. That\n"
"   is, if we say"
msgstr ""
"   получили значение хранящееся в d, а не то, которое хранится в c. Это "
"нарушило бы\n"
"принцип, согласно которому подклассы переопределяют значения по умолчанию, "
"предоставленные\n"
"их родителями.\n"
"   Если мы хотим реализовать обычную идею наследования, мы никогда не должны "
"исследовать \n"
"объект прежде исследования его потомков. В этом случае правильный порядок "
"поиска будет:\n"
"a, b, c, d. Как мы можем гарантировать, что поиск всегда вначале проверяет "
"потомков?\n"
"Самый простой способ - собрать всех предков исходного объекта, отсортировать "
"этот список \n"
"так,  чтобы ни один объект не появился перед одним из своих потомков, а "
"затем посмотреть\n"
"на каждый элемент по очереди.\n"
"    Эта стратегия используется get-ancestors, которая возвращает правильно "
"упорядоченный\n"
"список объекта и его предков. Чтобы отсортировать список, get-ancestors "
"вызывает \n"
"stable-sort, а не  sort, чтобы избежать возможного переупорядочивания "
"параллельных\n"
"предков. Как только список отсортирован,  rget просто ищет первый объект с "
"желаемым\n"
"свойством.\n"
"(Утилита some2 это версия some для использования с такими функциями как "
"gethash, которые\n"
"указывают на успех или неудачу во втором возвращаемом значении.)\n"
"    Список предков объекта проходит от наиболее специфического к наименее "
"конкретному: \n"
"если апельсин это плод цитрусовых, которыйй является фруктом, тогда список "
"будет иметь\n"
"порядок (orange citrus fruit).\n"
"    Когда у объекта несколько родителей, их приоритет идет слева направо. То "
"есть если\n"
"мы скажем"

#: texi/node-25.texi:242
msgid "   (setf (gethash 'parents x) (list y z))"
msgstr ""

#: texi/node-25.texi:246
msgid ""
"   then y will be considered before z when we look for an inherited "
"property. For\n"
"   example, we can say that a patriotic scoundrel is a scoundrel first and a "
"patriot\n"
"   second:"
msgstr ""
"тогда y будет рассматриваться перед z когда мы будем искать унаследованное "
"свойство.\n"
"Например, мы можем сказать что  патриот-негодяй(patriotic scoundrel) это "
"сначала негодяй\n"
"(scoundrel), а потом патриот(patriot):"

#: texi/node-25.texi:251
msgid ""
"   > (setq scoundrel (make-hash-table)\n"
"                patriot (make-hash-table)\n"
"                patriotic-scoundrel (make-hash-table))\n"
"   #<Hash-Table C4219E>"
msgstr ""
"   > (setq scoundrel (make-hash-table)\n"
"           patriot   (make-hash-table)\n"
"           patriotic-scoundrel (make-hash-table))\n"
"   #<Hash-Table C4219E>"

#: texi/node-25.texi:260
msgid ""
"     (defun obj (&rest parents)\n"
"      (let ((obj (make-hash-table)))\n"
"         (setf (gethash 'parents obj) parents)\n"
"         (ancestors obj)\n"
"         obj))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun obj (&rest parents)\n"
"      (let ((obj (make-hash-table)))\n"
"         (setf (gethash 'parents obj) parents)\n"
"         (ancestors obj)\n"
"         obj))"

#: texi/node-25.texi:264
msgid ""
"     (defun ancestors (obj)\n"
"      (or (gethash 'ancestors obj)\n"
"           (setf (gethash 'ancestors obj) (get-ancestors obj))))"
msgstr ""

#: texi/node-25.texi:268
msgid ""
"     (defun rget (obj prop)\n"
"      (some2 #'(lambda (a) (gethash prop a))\n"
"               (ancestors obj)))"
msgstr ""
"     (defun rget (obj prop)\n"
"      (some2 #'(lambda (a) (gethash prop a))\n"
"               (ancestors obj)))\n"
"@end lisp"

#: texi/node-25.texi:270
msgid "                      Figure 25-3: A function to create objects."
msgstr ""
"                      Рисунок 25-3: Функции для создания объектов.\n"
"@end cartouche"

#: texi/node-25.texi:282
msgid ""
"@example\n"
"> (setf (gethash 'serves scoundrel) 'self\n"
"            (gethash 'serves patriot)             'country\n"
"            (gethash 'parents patriotic-scoundrel)\n"
"                         (list scoundrel patriot))\n"
"(#<Hash-Table C41C7E> #<Hash-Table C41F0E>)\n"
"> (rget patriotic-scoundrel 'serves)\n"
"SELF\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-25.texi:289
msgid ""
"      Let's make some improvements to this skeletal system. We could begin "
"with a\n"
"function to create objects. This function should build a list of an object's "
"ancestors\n"
"at the time the object is created. The current code builds these lists when "
"queries\n"
"are made, but there is no reason not to do it earlier. Figure 25-3 defines a "
"function\n"
"called obj which creates a new object, storing within it a list of its "
"ancestors. To\n"
"take advantage of stored ancestors, we also redefine rget."
msgstr ""
"      Давайте внесем некоторые улучшения в эту скелетную систему. Мы могли "
"бы начать с\n"
"функции для создания объектов. Эта функция должна составлять список предков "
"объекта во\n"
"время создания объекта. Текущий код строит эти списки при выполнении "
"запросов, но нет\n"
"никаких причин не сделать это раньше. На рисунке 25-3 определена функция с "
"именем obj,\n"
"которая создает новый объект, сохраняя в нем список его предков. Чтобы "
"воспользоваться\n"
"преимуществами хранимых предков, мы также переопределяем rget."

#: texi/node-25.texi:294
msgid ""
"      Another place for improvement is the syntax of message calls. The tell "
"itself\n"
"is unnecessary clutter, and because it makes verbs come second, it means "
"that our\n"
"programs can no longer be read like normal Lisp prefix expressions:\n"
"(tell (tell obj 'find-owner) 'find-owner)"
msgstr ""
"      Другое место для улучшения - это синтаксис вызовов сообщений. Само по "
"себе\n"
"сообщение(tell) является ненужным беспорядком, поскольку оно заставляет "
"глаголы\n"
"стоять на втором месте, а это означает, что наши программы больше не могут "
"читаться\n"
"как обычные префиксные выражения Lisp:\n"
"(tell (tell obj 'find-owner) 'find-owner)"

#: texi/node-25.texi:300
msgid ""
"      We can get rid of the tell syntax by defining each property name as a "
"function,\n"
"as in Figure 25-4. The optional argument meth?, if true, signals that this "
"property\n"
"should be treated as a method. Otherwise it will be treated as a slot, and "
"the value\n"
"retrieved by rget will simply be returned. Once we have defined the name of\n"
"either kind of property,"
msgstr ""
"      Мы можем избавиться от синтаксиса tell, определив каждое имя свойства "
"как функцию,\n"
"как показано на рисунке 25-4. Необязательный аргумент meth?, если "
"истина(true), означает,\n"
"что это свойство следует рассматривать как метод. В противном случае оно "
"будет рассматриваться\n"
"как слот, а значение, полученное с помощью rge, будет просто возвращено. "
"После того, как мы\n"
"определили название любого вида свойств,"

#: texi/node-25.texi:310
msgid ""
"@lisp\n"
"     (defmacro defprop (name &optional meth?)\n"
"       `(progn\n"
"           (defun ,name (obj &rest args)\n"
"             ,(if meth?\n"
"                   `(run-methods obj ',name args)\n"
"                   `(rget obj ',name)))\n"
"           (defsetf ,name (obj) (val)\n"
"             `(setf (gethash ',',name ,obj) ,val))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defmacro defprop (name &optional meth?)\n"
"       `(progn\n"
"           (defun ,name (obj &rest args)\n"
"             ,(if meth?\n"
"                   `(run-methods obj ',name args)\n"
"                   `(rget obj ',name)))\n"
"           (defsetf ,name (obj) (val)\n"
"             `(setf (gethash ',',name ,obj) ,val))))"

#: texi/node-25.texi:316
msgid ""
"     (defun run-methods (obj name args)\n"
"       (let ((meth (rget obj name)))\n"
"         (if meth\n"
"              (apply meth obj args)\n"
"              (error \"No ~A method for ~A.\" name obj))))"
msgstr ""

#: texi/node-25.texi:319
msgid ""
"@end lisp\n"
"                           Figure 25-4: Functional syntax."
msgstr ""
"@end lisp\n"
"                           Рисунок 25-4: Функциональный синтаксис.\n"
"@end cartouche"

#: texi/node-25.texi:324
msgid ""
"@lisp\n"
"(defprop find-owner t)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:326
msgid ""
"we can refer to it with a function call, and our code will read like Lisp "
"again:"
msgstr ""
"мы можем обратиться к нему с помощью вызова функции, и наш код снова будет "
"выглядеть\n"
"как Lisp:"

#: texi/node-25.texi:330
msgid ""
"@lisp\n"
"(find-owner (find-owner obj))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:332
msgid "Our previous example now becomes somewhat more readable:"
msgstr "Наш предыдущий пример теперь стал более читабельным:"

#: texi/node-25.texi:345
msgid ""
"@example\n"
"> (progn\n"
"        (setq scoundrel (obj))\n"
"        (setq patriot (obj))\n"
"        (setq patriotic-scoundrel (obj scoundrel patriot))\n"
"        (defprop serves)\n"
"        (setf (serves scoundrel) 'self)\n"
"        (setf (serves patriot) 'country)\n"
"        (serves patriotic-scoundrel))\n"
"SELF\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-25.texi:352
msgid ""
"       In the current implementation, an object can have at most one method "
"of a\n"
"given name. An object either has its own method, or inherits one. It would "
"be\n"
"convenient to have more flexibility on this point, so that we could combine "
"local\n"
"and inherited methods. For example, we might want the move method of some\n"
"object to be the move method of its parent, but with some extra code run "
"before\n"
"or afterwards."
msgstr ""
"       В текущей реализации объект может иметь не более одного метода для "
"определенного\n"
"имени. У объекта либо есть собственный метод, либо он наследуется. Было бы "
"удобно иметь\n"
"больше гибкости в этом вопросе, чтобы мы могли соединять локальный и "
"унаследованный\n"
"методы. Например, мы могли бы захотеть, чтобы метод move некоторых объектов, "
"был методом move его родителя, но с некоторым дополнительным кодом, "
"выполняемым до него, или после."

#: texi/node-25.texi:372
msgid ""
"   To allow for such possibilities, we will modify our program to include "
"before-,\n"
"after-, and around-methods. Before-methods allow us to say \"But first, do "
"this.\"\n"
"They are called, most specific first, as a prelude to the rest of the method "
"call.\n"
"After-methods allow us to say \"P.S. Do this too.\" They are called, most "
"specific\n"
"last, as an epilogue to the method call. Between them, we run what used to "
"be the\n"
"whole method, and is now called the primary method. The value of this call "
"is the\n"
"one returned, even if after-methods are called later.\n"
"   Before- and after-methods allow us to wrap new behavior around the call "
"to\n"
"the primary method. Around-methods provide a more drastic way of doing the\n"
"same thing. If an around-method exists, it will be called instead of the "
"primary\n"
"method. Then, at its own discretion, the around-method may itself invoke "
"the\n"
"primary method (via call-next, which will be provided in Figure 25-7).\n"
"   To allow auxiliary methods, we modify run-methods and rget as in Fig-\n"
"ures 25-5 and 25-6. In the previous version, when we ran some method of an\n"
"object, we ran just one function: the most specific primary method. We ran "
"the\n"
"first method we encountered when searching the list of ancestors. With "
"auxiliary\n"
"methods, the calling sequence now goes as follows:"
msgstr ""
"   Чтобы предоставить такие возможности, мы изменим нашу программу, включив "
"в неё\n"
"методы before-, after- и around- . Before- методы позволяют нам сказать \"Но "
"сначала,\n"
"сделаете это.\". Они вызываются впереди всех, как прелюдия к остальной части "
"вызова\n"
"метода. After- методы позволяют нам сказать \"P.S. Сделай то тоже.\" Они "
"вызываются,\n"
"позже всех, как эпилог вызова метода. Между ними, мы запускаем то, что "
"раньше было\n"
"методом, и теперь называется первичным методом. Значение вызова этого метода "
"будет\n"
"возвращаеться, даже если after- методы будут вызваны позже.\n"
"   Before- и after-методы позволяют нам обернуть новое поведение вокруг "
"вызова \n"
"первичного метода. Around-методы обеспечивают более радикальный способ "
"сделать\n"
"тоже самое. Если существует метод around-, он будет вызываться вместо "
"первичного\n"
"метода. Затем, по своему усмотрению, метод around- может сам вызвать "
"первичный\n"
"метод (через call-next, который будет представлен на Рисунке 25-7).\n"
"   Чтобы разрешить вспомогательные методы, мы изменим run-методы и  rget "
"как\n"
"на Рисунках 25-5 и 25-6. В предыдущей версии, когда мы запускали какой-то\n"
"метод объекта, мы просто запускали одну функцию: наиболее конкретный "
"первичный\n"
"метод. Мы запускали первый метод, с которым мы сталкивались при поиске по\n"
"списку предков. С вспомогательными методами, вызывающая последовательность \n"
"теперь выглядит следующим образом:"

#: texi/node-25.texi:374
msgctxt "texi/node-25.texi:374"
msgid "   1. The most specific around-method, if there is one."
msgstr "   1. Наиболее конкретный метод around- если он есть."

#: texi/node-25.texi:376
msgctxt "texi/node-25.texi:376"
msgid "   2. Otherwise, in order:"
msgstr "   2. Otherwise, in order:"

#: texi/node-25.texi:380
msgid ""
"           (a) All before-methods, from most specific to least specific.\n"
"           (b) The most specific primary method (what we used to call).\n"
"           (c) All after-methods, from least specific to most specific."
msgstr ""
"           (a) Все методы before-, от наиболее конкртетных до наименее "
"конкретных.\n"
"           (b) Наиболее конкретный первичный метод (то что мы привыкли "
"вызывать).\n"
"           (c) Все методы after-, от наименее конкретных до наиболее "
"конкретных."

#: texi/node-25.texi:383
msgid ""
"   Notice also that instead of being a single function, a method becomes a "
"four-\n"
"part structure. To define a (primary) method, instead of saying:"
msgstr ""
"   Обратите внимание, что вместо того, чтобы быть единой функцией, метод "
"становиться\n"
"структурой из четырех частей. Чтобы определить (основной/первичный) метод, "
"вместо того\n"
"чтобы сказать:"

#: texi/node-25.texi:385
msgid "(setf (gethash 'move obj) #'(lambda ...))"
msgstr ""

#: texi/node-25.texi:387
msgid "we say:"
msgstr "мы скажем:"

#: texi/node-25.texi:389
msgid "(setf (meth-primary (gethash 'move obj)) #'(lambda ...))"
msgstr ""

#: texi/node-25.texi:397
msgid ""
"For this and other reasons, our next step should be to define a macro for "
"defining\n"
"methods.\n"
"   Figure 25-7 shows the definition of such a macro. The bulk of this code "
"is\n"
"taken up with implementing two functions that methods can use to refer to "
"other\n"
"methods. Around- and primary methods can use call-next to invoke the next\n"
"method, which is the code that would have run if the current method didn't "
"exist.\n"
"For example, if the currently running method is the only around-method, the "
"next"
msgstr ""
"По этой и другим причинам, нашим следующим шагом должно стать определение "
"макроса\n"
"для определения методов.\n"
"   На Рисунке 25-7 показано определение такого макроса. Большая часть этого "
"кода\n"
"занята реализацией двух функций, которые методы могут использовать для "
"ссылки на\n"
"другие методы. Методы around- и primary могут использовать call-next для "
"вызова\n"
"следующего метода, который должен был бы выполниться, если бы текущего "
"метода\n"
"не существовало. Например, если текущий запущенный метод является "
"единственным\n"
"around- методом,"

#: texi/node-25.texi:401
msgid " (defstruct meth around before primary after)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defstruct meth around before primary after)"

#: texi/node-25.texi:407
msgid ""
" (defmacro meth- (field obj)\n"
"       (let ((gobj (gensym)))\n"
"        `(let ((,gobj ,obj))\n"
"           (and (meth-p ,gobj)\n"
"                   (,(symb 'meth- field) ,gobj)))))"
msgstr ""

#: texi/node-25.texi:416
msgid ""
" (defun run-methods (obj name args)\n"
"       (let ((pri (rget obj name :primary)))\n"
"        (if pri\n"
"             (let ((ar (rget obj name :around)))\n"
"              (if ar\n"
"                    (apply ar obj args)\n"
"                    (run-core-methods obj name args pri)))\n"
"             (error \"No primary ~A method for ~A.\" name obj))))"
msgstr ""

#: texi/node-25.texi:423
msgid ""
" (defun run-core-methods (obj name args &optional pri)\n"
"       (multiple-value-prog1\n"
"        (progn (run-befores obj name args)\n"
"               (apply (or pri (rget obj name :primary))\n"
"                        obj args))\n"
"        (run-afters obj name args)))"
msgstr ""

#: texi/node-25.texi:432
msgid ""
" (defun rget (obj prop &optional meth (skip 0))\n"
"       (some2 #'(lambda (a)\n"
"                   (multiple-value-bind (val win) (gethash prop a)\n"
"                     (if win\n"
"                          (case meth (:around (meth- around val))\n"
"                                        (:primary (meth- primary val))\n"
"                                        (t (values val win))))))\n"
"             (nthcdr skip (ancestors obj))))"
msgstr ""

#: texi/node-25.texi:434
msgid "                        Figure 25-5: Auxiliary methods."
msgstr ""
"@end lisp\n"
"                        Рисунок 25-5: Вспомогательные методы.\n"
"@end cartouche"

#: texi/node-25.texi:441
msgid ""
"method would be the usual sandwich of before-, most specific primary, and "
"after-\n"
"methods. Within the most specific primary method, the next method would be "
"the\n"
"second most specific primary method. Since the behavior of call-next "
"depends\n"
"on where it is called, it is never defined globally with a defun, but is "
"defined\n"
"locally within each method defined by defmeth."
msgstr ""
"следующим методом будет сендвич(набор следующих друг за другом) из before- "
"методов, \n"
"наиболее конкретного первичного метода и методов after-. В пределах "
"наиболее\n"
"конкретного метода, следующий метод будет вторым наиболее конкретным "
"методом. \n"
"Поскольку поведение call-next зависит от того, где он вызывается, он никогда "
"не\n"
"определяется глобально с помощью defun, а определяется локально в каждом "
"методе,\n"
"определённом с помощью defmeth."

#: texi/node-25.texi:447
msgid ""
"     (defun run-befores (obj prop args)\n"
"      (dolist (a (ancestors obj))\n"
"         (let ((bm (meth- before (gethash prop a))))\n"
"            (if bm (apply bm obj args)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun run-befores (obj prop args)\n"
"      (dolist (a (ancestors obj))\n"
"         (let ((bm (meth- before (gethash prop a))))\n"
"            (if bm (apply bm obj args)))))"

#: texi/node-25.texi:456
msgid ""
"     (defun run-afters (obj prop args)\n"
"      (labels ((rec (lst)\n"
"                    (when lst\n"
"                       (rec (cdr lst))\n"
"                       (let ((am (meth- after\n"
"                                              (gethash prop (car lst)))))\n"
"                         (if am (apply am (car lst) args))))))\n"
"         (rec (ancestors obj))))"
msgstr ""

#: texi/node-25.texi:458
msgid "                    Figure 25-6: Auxiliary methods (continued)."
msgstr ""
"@end lisp\n"
"                    Рисунок 25-6: Вспомогательные методы (продолжение).\n"
"@end cartouche"

#: texi/node-25.texi:468
msgid ""
"      An around- or primary method can use next-p to check whether there is "
"a\n"
"next method. If the current method is the primary method of an object with "
"no\n"
"parents, for example, there would be no next method. Since call-next yields\n"
"an error when there is no next method, next-p should usually be called to "
"test\n"
"the waters first. Like call-next, next-p is defined locally within "
"individual\n"
"methods.\n"
"      The new macro defmeth is used as follows. If we just want to define "
"the area\n"
"method of the rectangle object, we say"
msgstr ""
"      Метод around- или primary может использовать next-p, чтобы "
"проверить, \n"
"существует ли следующий метод. Например, если текущий метод является "
"первичным\n"
"методом объекта не имеющим родителей, то следующего метода не будет. Так "
"как \n"
"call-next выдает ошибку, когда нет следующего метода, обычно следует "
"вызвать \n"
"next-p чтобы проверить его наличие. Как и call-next, next-p определяется "
"локально\n"
"в отдельных методах.\n"
"      Новый макрос defmeth используется следующим образом. Если мы просто "
"хотим\n"
"определить метод area объекта rectangle, мы скажем"

#: texi/node-25.texi:474
msgid ""
"(setq rectangle (obj))\n"
"(defprop height)\n"
"(defprop width)\n"
"(defmeth (area) rectangle (r)\n"
"     (* (height r) (width r)))"
msgstr ""

#: texi/node-25.texi:476
msgid ""
"Now the area of an instance is calculated according to the method of the "
"class:"
msgstr "Теперь площадь(area) экземпляра рассчитывается как метод класса:"

#: texi/node-25.texi:482
msgid ""
"> (let ((myrec (obj rectangle)))\n"
"        (setf (height myrec) 2\n"
"               (width myrec) 3)\n"
"        (area myrec))\n"
"6"
msgstr ""

#: texi/node-25.texi:493
msgid ""
" (defmacro defmeth ((name &optional (type :primary))\n"
"                          obj parms &body body)\n"
"       (let ((gobj (gensym)))\n"
"        `(let ((,gobj ,obj))\n"
"           (defprop ,name t)\n"
"           (unless (meth-p (gethash ',name ,gobj))\n"
"             (setf (gethash ',name ,gobj) (make-meth)))\n"
"           (setf (,(symb 'meth- type) (gethash ',name ,gobj))\n"
"                     ,(build-meth name type gobj parms body)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro defmeth ((name &optional (type :primary))\n"
"                          obj parms &body body)\n"
"       (let ((gobj (gensym)))\n"
"        `(let ((,gobj ,obj))\n"
"           (defprop ,name t)\n"
"           (unless (meth-p (gethash ',name ,gobj))\n"
"             (setf (gethash ',name ,gobj) (make-meth)))\n"
"           (setf (,(symb 'meth- type) (gethash ',name ,gobj))\n"
"                     ,(build-meth name type gobj parms body)))))"

#: texi/node-25.texi:512
msgid ""
" (defun build-meth (name type gobj parms body)\n"
"       (let ((gargs (gensym)))\n"
"        `#'(lambda (&rest ,gargs)\n"
"              (labels\n"
"                ((call-next ()\n"
"                       ,(if (or (eq type :primary)\n"
"                                   (eq type :around))\n"
"                            `(cnm ,gobj ',name (cdr ,gargs) ,type)\n"
"                            '(error \"Illegal call-next.\")))\n"
"                     (next-p ()\n"
"                       ,(case type\n"
"                         (:around\n"
"                          `(or (rget ,gobj ',name :around 1)\n"
"                                   (rget ,gobj ',name :primary)))\n"
"                         (:primary\n"
"                          `(rget ,gobj ',name :primary 1))\n"
"                         (t nil))))\n"
"                (apply #'(lambda ,parms ,@@body) ,gargs)))))"
msgstr ""

#: texi/node-25.texi:523
msgid ""
" (defun cnm (obj name args type)\n"
"       (case type\n"
"        (:around (let ((ar (rget obj name :around 1)))\n"
"                       (if ar\n"
"                            (apply ar obj args)\n"
"                            (run-core-methods obj name args))))\n"
"        (:primary (let ((pri (rget obj name :primary 1)))\n"
"                       (if pri\n"
"                            (apply pri obj args)\n"
"                            (error \"No next method.\"))))))"
msgstr ""

#: texi/node-25.texi:525
msgid "                         Figure 25-7: Defining methods."
msgstr ""
"@end lisp\n"
"                         Рисунок 25-7: Определение методов.\n"
"@end cartouche"

#: texi/node-25.texi:530
msgid ""
" (defmacro undefmeth ((name &optional (type :primary)) obj)\n"
"    `(setf (,(symb 'meth- type) (gethash ',name ,obj))\n"
"             nil))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro undefmeth ((name &optional (type :primary)) obj)\n"
"    `(setf (,(symb 'meth- type) (gethash ',name ,obj))\n"
"             nil))\n"
"@end lisp"

#: texi/node-25.texi:532
msgid "                        Figure 25-8: Removing methods."
msgstr ""
"                        Рисунок 25-8: Удаление методов.\n"
"@end cartouche"

#: texi/node-25.texi:536
msgid ""
"In a more complicated example, suppose we have defined a backup method for\n"
"the filesystem object:"
msgstr ""
"В более сложном примере предположим, что мы определили метод backup для\n"
"объекта filesystem:"

#: texi/node-25.texi:545
msgid ""
"(setq filesystem (obj))\n"
"(defmeth (backup :before) filesystem (fs)\n"
"  (format t \"Remember to mount the tape.~%\"))\n"
"(defmeth (backup) filesystem (fs)\n"
"  (format t \"Oops, deleted all your files.~%\")\n"
"  'done)\n"
"(defmeth (backup :after) filesystem (fs)\n"
"  (format t \"Well, that was easy.~%\"))"
msgstr ""

#: texi/node-25.texi:547
msgid "The normal sequence of calls will be as follows:"
msgstr "Обычная последовательность вызовов будет следующей:"

#: texi/node-25.texi:553
msgid ""
"> (backup (obj filesystem))\n"
"Remember to mount the tape.\n"
"Oops, deleted all your files.\n"
"Well, that was easy.\n"
"DONE"
msgstr ""

#: texi/node-25.texi:556
msgid ""
"Later we want to know how long backups take, so we define the following "
"around-\n"
"method:"
msgstr ""
"Позднее мы хотим узнать, сколько времени занимает выполнения "
"резервирования(backup), \n"
"поэтому определим следующий метод:"

#: texi/node-25.texi:559
msgid ""
"(defmeth (backup :around) filesystem (fs)\n"
"  (time (call-next)))"
msgstr ""

#: texi/node-25.texi:564
msgid ""
"Now whenever backup is called on a child of filesystem (unless more "
"specific\n"
"around-methods intervene) our around-method will be called. It calls the "
"code\n"
"that would ordinarily run in a call to backup, but within a call to time. "
"The value\n"
"returned by time will be returned as the value of the call to backup:"
msgstr ""
"Теперь, всякий раз, когда вызвается backup для потомка filesystem (если не "
"вмешиваются\n"
"более конкретные around-методы), будет вызываться наш метод around-. Он "
"вызовет код\n"
"который обычно запускается при вызове backup, но в вызове time. Значение "
"возвращаемое\n"
"time, будет возвращено как значение вызова backup:"

#: texi/node-25.texi:571
msgid ""
"> (backup (obj filesystem))\n"
"Remember to mount the tape.\n"
"Oops, deleted all your files.\n"
"Well, that was easy.\n"
"Elapsed Time = .01 seconds\n"
"DONE"
msgstr ""

#: texi/node-25.texi:576
msgid ""
"Once we are finished timing the backups, we will want to remove the around-\n"
"method. That can be done by calling undefmeth (Figure 25-8), which takes "
"the\n"
"same first two arguments as defmeth:"
msgstr ""
"Как только мы закончим подсчитывать время выполнения метода backup, мы "
"захотим\n"
"удалить метод around-. Это можно сделать, вызвав undefmeth (Рисунокe 25-8), "
"который\n"
"принимает те же первые два аргумента, что и defmeth:"

#: texi/node-25.texi:578
msgid "(undefmeth (backup :around) filesystem)"
msgstr ""

#: texi/node-25.texi:597
msgid ""
"       Another thing we might want to alter is an object's list of parents. "
"But after\n"
"any such change, we should also update the list of ancestors of the object "
"and all\n"
"its children. So far, we have no way of getting from an object to its "
"children, so\n"
"we must also add a children property.\n"
"       Figure 25-9 contains code for operating on objects' parents and "
"children.\n"
"Instead of getting at parents and children via gethash, we use the "
"operators\n"
"parents and children. The latter is a macro, and therefore transparent to\n"
"setf. The former is a function whose inversion is defined by defsetf to be\n"
"set-parents, which does everything needed to maintain consistency in the "
"new\n"
"doubly-linked world.\n"
"       To update the ancestors of all the objects in a subtree, set-parents "
"calls\n"
"maphier, which is like a mapc for inheritance hierarchies. As mapc calls a\n"
"function on every element of a list, maphier calls a function on an object "
"and\n"
"all its descendants. Unless they form a proper tree, the function could get "
"called\n"
"more than once on some objects. Here this is harmless, because get-"
"ancestors\n"
"does the same thing when called multiple times.\n"
"       Now we can alter the inheritance hierarchy just by using setf on an "
"object's\n"
"parents:"
msgstr ""
"       Еще одна вещь, которую мы могли бы изменить - это список родителей "
"объекта.\n"
"Но после любого такого изменения мы должны также обновить список предков "
"объекта и\n"
"всех его потомков. Пока что у нас нет возможности получить из объекта его "
"потомков,\n"
"поэтому мы также должны добавить свойство children(потомки).\n"
"       На рисунке 25-9 приведен код для работы с родителями и потомками. "
"Вместо того,\n"
"чтобы получать родителей и детей через gethash, мы используем операторы "
"parents и \n"
"children. Последний является макросом и поэтому прозрачен для setf. Первый "
"это\n"
"функция, инверсия которой определяется defsetf как set-parents, которая "
"делает\n"
"все необходимое для поддержания согласованности в новом двусвязном мире.\n"
"       Чтобы обновить предков всех объектов в поддереве, set-parents "
"вызывает\n"
"maphier, который похож на mapc для иерархий наследования. Как и mapc "
"вызывает\n"
"функцию для каждого элемента списка, maphier вызывает функцию для объекта и\n"
"всех его потомков. Если они не образуют правильное дерево, функция может "
"вызываться\n"
"несколько раз для некоторых объектов. Здесь это безвредно, потому что get-"
"ancestors\n"
"делает тоже самое, когда вызывается несколько раз.\n"
"       Теперь мы можем изменить иерархию наследования, просто используя setf "
"для \n"
"родителей объекта:"

#: texi/node-25.texi:602
msgid ""
"> (progn (pop (parents patriotic-scoundrel))\n"
"               (serves patriotic-scoundrel))\n"
"COUNTRY\n"
"T"
msgstr ""

#: texi/node-25.texi:616
msgid ""
"When the hierarchy is modified, affected lists of children and ancestors "
"will be\n"
"updated automatically. (The children are not meant to be manipulated "
"directly,\n"
"but they could be if we defined a set-children analogous to set-parents.)\n"
"The last function in Figure 25-9 is obj redefined to use the new code.\n"
"       As a final improvement to our system, we will make it possible to "
"specify\n"
"new ways of combining methods. Currently, the only primary method that gets\n"
"called is the most specific (though it can call others via call-next). "
"Instead we\n"
"might like to be able to combine the results of the primary methods of each "
"of an\n"
"object's ancestors. For example, suppose that my-orange is a child of "
"orange,\n"
"which is a child of citrus. If the props method returns (round acidic) for\n"
"citrus, (orange sweet) for orange, and (dented) for my-orange, it would\n"
"be convenient to be able to make (props my-orange) return the union of all\n"
"these values: (dented orange sweet round acidic)."
msgstr ""
"Когда иерархия изменена, затронутые списки потомков и предков будут "
"обновлены\n"
"автоматически. (Свойство потомки(children) не предназначено для прямого "
"манипулирования,\n"
"но оно бы могло быть, если бы мы определили set-children аналогично set-"
"parents.)\n"
"Последняя функция на рисунке 25-9 это obj переопределенная для использования "
"нового кода.\n"
"       В качестве окончательного усовершенствования нашей системы, мы дадим "
"возможность\n"
"указать новые способы объединения методов. В настоящее время, единственный "
"первичный\n"
"метод, является наиболее конкретным(хотя он может вызвать другие используя "
"call-next). \n"
"Вместо этого нам может потребоваться объединить результаты первичных методов "
"каждого\n"
"из предков объекта. Например, предположим, что my-orange это потомок "
"orange,\n"
"который является потомком citrus. Если метод props возвращает (round acidic) "
"для\n"
"citrus и (orange sweet) для orange, и (dented) для my-orange, было бы "
"удобно\n"
"иметь возможность (props my-orange) возвращать  объединение всех этих "
"значений:\n"
"(dented orange sweet round acidic)."

#: texi/node-25.texi:620
msgid ""
" (defmacro children (obj)\n"
"    `(gethash 'children ,obj))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro children (obj)\n"
"    `(gethash 'children ,obj))"

#: texi/node-25.texi:623
msgid ""
" (defun parents (obj)\n"
"    (gethash 'parents obj))"
msgstr ""

#: texi/node-25.texi:636
msgid ""
" (defun set-parents (obj pars)\n"
"    (dolist (p (parents obj))\n"
"        (setf (children p)\n"
"                 (delete obj (children p))))\n"
"    (setf (gethash 'parents obj) pars)\n"
"    (dolist (p pars)\n"
"        (pushnew obj (children p)))\n"
"    (maphier #'(lambda (obj)\n"
"                       (setf (gethash 'ancestors obj)\n"
"                              (get-ancestors obj)))\n"
"                 obj)\n"
"    pars)"
msgstr ""

#: texi/node-25.texi:638
msgid " (defsetf parents set-parents)"
msgstr ""

#: texi/node-25.texi:643
msgid ""
" (defun maphier (fn obj)\n"
"    (funcall fn obj)\n"
"    (dolist (c (children obj))\n"
"        (maphier fn c)))"
msgstr ""

#: texi/node-25.texi:648
msgid ""
" (defun obj (&rest parents)\n"
"    (let ((obj (make-hash-table)))\n"
"        (setf (parents obj) parents)\n"
"        obj))"
msgstr ""

#: texi/node-25.texi:650
msgid "                  Figure 25-9: Maintaining parent and child links."
msgstr ""
"@end lisp\n"
"                  Рисунок 25-9: Поддержание родительских и дочерних ссылок.\n"
"@end cartouche"

#: texi/node-25.texi:659
msgid ""
"   We could have this if we allowed methods to apply some function to the "
"values\n"
"of all the primary methods, instead of just returning the value of the most "
"specific.\n"
"Figure 25-10 contains a macro which allows us to define the way methods are\n"
"combined, and a new version of run-core-methods which can perform method\n"
"combination.\n"
"   We define the form of combination for a method via defcomb, which takes\n"
"a method name and a second argument describing the desired combination. Or-"
msgstr ""
"   Мы могли бы иметь это, если бы позволили методам применять некоторую "
"функцию\n"
"к значениям своих первичных методов, вместо того, чтобы просто возвращать \n"
"значение наиболее конкретного метода.\n"
"Рисунок 25-10 содержит макрос, который позволяет нам определить способ \n"
"объединения методов и новую версию run-core-methods, которые могут "
"выполнять\n"
"объединение методов.\n"
"   Мы определяем форму комбинации для метода через defcomb, который "
"принимает\n"
"имя метода и второй аргумент, описывающий желаемую комбинацию."

#: texi/node-25.texi:670
msgid ""
" (defmacro defcomb (name op)\n"
"       `(progn\n"
"         (defprop ,name t)\n"
"         (setf (get ',name 'mcombine)\n"
"                  ,(case op\n"
"                      (:standard nil)\n"
"                      (:progn '#'(lambda (&rest args)\n"
"                                     (car (last args))))\n"
"                      (t op)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro defcomb (name op)\n"
"       `(progn\n"
"         (defprop ,name t)\n"
"         (setf (get ',name 'mcombine)\n"
"                  ,(case op\n"
"                      (:standard nil)\n"
"                      (:progn '#'(lambda (&rest args)\n"
"                                     (car (last args))))\n"
"                      (t op)))))"

#: texi/node-25.texi:684
msgid ""
" (defun run-core-methods (obj name args &optional pri)\n"
"       (let ((comb (get name 'mcombine)))\n"
"        (if comb\n"
"            (if (symbolp comb)\n"
"                   (funcall (case comb (:and #'comb-and)\n"
"                                            (:or #'comb-or))\n"
"                               obj name args (ancestors obj))\n"
"                   (comb-normal comb obj name args))\n"
"            (multiple-value-prog1\n"
"                  (progn (run-befores obj name args)\n"
"                         (apply (or pri (rget obj name :primary))\n"
"                                 obj args))\n"
"                  (run-afters obj name args)))))"
msgstr ""

#: texi/node-25.texi:694
msgid ""
" (defun comb-normal (comb obj name args)\n"
"       (apply comb\n"
"             (mapcan #'(lambda (a)\n"
"                               (let* ((pm (meth- primary\n"
"                                                       (gethash name a)))\n"
"                                      (val (if pm\n"
"                                                  (apply pm obj args))))\n"
"                                 (if val (list val))))\n"
"                         (ancestors obj))))"
msgstr ""

#: texi/node-25.texi:696
msgid "                       Figure 25-10: Method combination."
msgstr ""
"@end lisp\n"
"                       Рисунок 25-10: Комбинация Методов.\n"
"@end cartouche"

#: texi/node-25.texi:702
msgid ""
"dinarily this second argument should be a function. However, it can also be "
"one\n"
"of :progn, :and, :or,or:standard. With the former three, primary meth-\n"
"ods will be combined as though according to the corresponding operator, "
"while\n"
":standard indicates that we want the traditional way of running methods."
msgstr ""
"Обычно этот второй аргумент должен быть функцией. Тем не менее, он также "
"может\n"
"быть одним из :progn, :and, :or или :standard. С первыми тремя первичные "
"методы\n"
"будут объединены как будто согласно согласно соответствующим оператором, "
"тогда \n"
"как :standard указывает, что мы хотим традиционный способ выполнения "
"операторов."

#: texi/node-25.texi:713
msgid ""
"     (defun comb-and (obj name args ancs &optional (last t))\n"
"      (if (null ancs)\n"
"             last\n"
"             (let ((pm (meth- primary (gethash name (car ancs)))))\n"
"                (if pm\n"
"                      (let ((new (apply pm obj args)))\n"
"                         (and new\n"
"                                 (comb-and obj name args (cdr ancs) new)))\n"
"                      (comb-and obj name args (cdr ancs) last)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun comb-and (obj name args ancs &optional (last t))\n"
"      (if (null ancs)\n"
"             last\n"
"             (let ((pm (meth- primary (gethash name (car ancs)))))\n"
"                (if pm\n"
"                      (let ((new (apply pm obj args)))\n"
"                         (and new\n"
"                                 (comb-and obj name args (cdr ancs) new)))\n"
"                      (comb-and obj name args (cdr ancs) last)))))"

#: texi/node-25.texi:719
msgid ""
"     (defun comb-or (obj name args ancs)\n"
"      (and ancs\n"
"              (let ((pm (meth- primary (gethash name (car ancs)))))\n"
"                 (or (and pm (apply pm obj args))\n"
"                        (comb-or obj name args (cdr ancs))))))"
msgstr ""

#: texi/node-25.texi:721
msgid "                     Figure 25-11: Method combination (continued)."
msgstr ""
"@end lisp\n"
"                     Рисунок 25-11: Комбинация методов (продолжение).\n"
"@end cartouche"

#: texi/node-25.texi:729
msgid ""
"      The central function in Figure 25-10 is the new run-core-methods. If "
"the\n"
"method being called has no mcombine property, then the method call proceeds "
"as\n"
"before. Otherwise the mcombine of the method is either a function (like "
"+)ora\n"
"keyword (like :or). In the former case, the function is just applied to a "
"list of\n"
"the values returned by all the primary methods.@footnote{A more "
"sophisticated version of this code could use reduce to avoid consing here.} "
"In the latter, we use the function\n"
"associated with the keyword to iterate over the primary methods."
msgstr ""
"      Центральной функцией на рисунке 25-10 является новый run-core-methods. "
"Если\n"
"вызываемый метод не имеет свойства mcombine, то вызов метода продолжается "
"как и\n"
"раньше. В противном случае mcombine метода это либо функция (такая как +) "
"или\n"
"ключевое слово (такое как :or). В перовм случае функция просто применяется "
"к\n"
"списку значений возвращенных всеми первичными методами.@footnote{Более "
"сложная версия\n"
"этого кода может использовать reduce чтобы избежать создания "
"списка(consingа) здесь.} \n"
"Во втором случае, мы используем функцию связанную с ключевым словом, для "
"итерации\n"
"по первичным методам."

#: texi/node-25.texi:733
msgid ""
"      The operators and and or have to be treated specially, as in Figure "
"25-11.\n"
"They get special treatment not just because they are special forms, but "
"because\n"
"they short-circuit evaluation:"
msgstr ""
"      Операторы and и or должны обрабатываться специальнго, как показано на "
"рисунке 25-11.\n"
"Они получают специальное обращение не только потому, что они являются "
"специальными\n"
"формами, но и потому что они  вычисляются по укороченной схеме.:"

#: texi/node-25.texi:736
msgid ""
"> (or 1 (princ \"wahoo\"))\n"
"1"
msgstr ""

#: texi/node-25.texi:742
msgid ""
"Here nothing is printed because the or returns as soon as it sees a non-nil "
"argument.\n"
"Similarly, a primary method subject to or combination should never get "
"called if\n"
"a more specific method returns true. To provide such short-circuiting for "
"and and\n"
"or, we use the distinct functions comb-and and comb-or.\n"
"      To implement our previous example, we would write:"
msgstr ""
"Здесь ничего не печатается, потому что  or возвращается как только оно видит "
"не\n"
"нулевой(не nil) аргумент.\n"
"Точно так же первичный метод или комбинация не будут вызваны, если более "
"конкретный\n"
"метод вернет истину(true). Чтобы обеспечить такую укороченную схему для and "
"и\n"
"or, мы используем различные функции comb-and и comb-or.\n"
"      Чтобы реализовать наш предыдущий пример, мы бы написали:"

#: texi/node-25.texi:746
msgid ""
"@lisp\n"
"(setq citrus (obj))\n"
"(setq orange (obj citrus))"
msgstr ""

#: texi/node-25.texi:749
msgid "(setq my-orange (obj orange))"
msgstr ""

#: texi/node-25.texi:753
msgid ""
"(defmeth (props) citrus (c) '(round acidic))\n"
"(defmeth (props) orange (o) '(orange sweet))\n"
"(defmeth (props) my-orange (m) '(dented))"
msgstr ""

#: texi/node-25.texi:756
msgid ""
"(defcomb props #'(lambda (&rest args) (reduce #'union args)))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:758
msgid ""
"after which props would return the union of all the primary method values: "
"@footnote{Since the combination function for props calls union, the list "
"elements will not necessarily be in this order.}"
msgstr ""
"после чего props будет возвращать объединение всех значений первичных "
"методов: \n"
"@footnote{Так как объединение функций для props вызывает union, элементы "
"списка\n"
"не обязательно будут идти в этом порядке.}"

#: texi/node-25.texi:763
msgid ""
"@example\n"
"> (props my-orange)\n"
"(DENTED ORANGE SWEET ROUND ACIDIC)\n"
"@end example"
msgstr ""

#: texi/node-25.texi:766
msgid ""
"Incidentally, this example suggests a choice that you only have when doing "
"object-\n"
"oriented programming in Lisp: whether to store information in slots or "
"methods."
msgstr ""
"Между прочим, этот пример предлалгает выбор, который вы имеете только при\n"
"объектно-ориентированном программировании на Lisp: хранить информацию в\n"
"слотах или методах."

#: texi/node-25.texi:769
msgid ""
"       Afterward, if we wanted the props method to return to the default "
"behavior,\n"
"we just set the method combination back to standard:"
msgstr ""
"       Впоследствии, если мыхотим, чтобы метод props вернулся к повдению по "
"умолчанию,\n"
"мы просто установим комбинацию методов обратно в standard:"

#: texi/node-25.texi:776
msgid ""
"@example\n"
"> (defcomb props :standard)\n"
"NIL\n"
"> (props my-orange)\n"
"(DENTED)\n"
"@end example"
msgstr ""

#: texi/node-25.texi:779
msgid ""
"Note that before- and after-methods only run in standard method "
"combination.\n"
"However, around-methods work the same as before."
msgstr ""
"Обратите внимание, что методы before- и after- выполняются только в "
"стандартной\n"
"комбинации методов. Однако, методы around- работают так же, как и раньше."

#: texi/node-25.texi:786
msgid ""
"       The program presented in this section is intended as a model, not as "
"a real\n"
"foundation for object-oriented programming. It was written for brevity "
"rather\n"
"than efficiency. However, it is at least a working model, and so could be "
"used for\n"
"experiments and prototypes. If you do want to use the program for such "
"purposes,\n"
"one minor change would make it much more efficient: don't calculate or "
"store\n"
"ancestor lists for objects with only one parent."
msgstr ""
"       Программа, представленная в этом разделе, задумана как модель, а не "
"как реальная\n"
"основа для объектно-ориентированного программирования. Этот код был написан "
"для\n"
"краткости, а не для эффективности. Тем не менее, это по крайней мере рабочая "
"модель,\n"
"и поэтому может быть использован для экспериментов и прототипов. Если вы "
"захотите\n"
"использовать программу для этих целей, одно небольшое изменение сделает её "
"гораздо\n"
"более эффективной: не вычисляйте и не сохраняйте списки предков для объектов "
"с\n"
"одним родителем."

#: texi/node-25.texi:791
msgid ""
"@node 25-3 Classes and Instances, 25-4 Methods, 25-2 Objects in Plain Lisp, "
"25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-3 Classes and Instances\n"
"@cindex 25-3 Classes and Instances"
msgstr ""
"@node 25-3 Classes and Instances, 25-4 Methods, 25-2 Objects in Plain Lisp, "
"25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-3 Классы и Экземпляры\n"
"@cindex 25-3 Classes and Instances"

#: texi/node-25.texi:795
msgid ""
"The program in the previous section was written to resemble CLOS as closely "
"as\n"
"such a small program could. By understanding it we are already a fair way "
"towards\n"
"understanding CLOS. In the next few sections we will examine CLOS itself."
msgstr ""
"Программа в предыдущем разделе была написана так, чтобы походить на CLOS на "
"столько\n"
"близко, насколько могла бы такая маленькая программа. Поняв её, мы уже "
"продвинулись\n"
"к пониманию CLOS. В следующих нескольких разделах мы рассмотрим сам CLOS."

#: texi/node-25.texi:799
msgid ""
"       In our sketch, we made no syntactic distinction between classes and "
"instances,\n"
"or between slots and methods. In CLOS, we use the defclass macro to define "
"a\n"
"class, and we declare the slots in a list at the same time:"
msgstr ""
"       В нашем наброске мы не делали синтаксического различия между классами "
"и\n"
"экземплярами или между слотами и методами. В CLOS, мы используем макрос "
"defclass\n"
"для определения класса и одновременно объявляем слоты в списке:"

#: texi/node-25.texi:801
msgid "2"
msgstr ""

#: texi/node-25.texi:805
msgid ""
"(defclass circle ()\n"
"     (radius center))"
msgstr ""

#: texi/node-25.texi:808
msgid ""
"This expression says that the circle class has no superclasses, and two "
"slots,\n"
"radius and center. We can make an instance of the circle class by saying:"
msgstr ""
"Это выражение говорит о том, что у класса circle нет суперклассов, а есть "
"два\n"
"слота, radius и center. Мы можем создать экземпляр класса circle сказав:"

#: texi/node-25.texi:810
msgid "(make-instance 'circle)"
msgstr ""

#: texi/node-25.texi:814
msgid ""
"Unfortunately, we have defined no way of referring to the slots of a circle,"
"so\n"
"any instance we make is going to be rather inert. To get at a slot we define "
"an\n"
"accessor function for it:"
msgstr ""
"К сожалению мы не определили способ обращаения к слотам circle, поэтому "
"любой\n"
"созданный нами экземпляр будет довольно инертным. Чтобы получить слот мы "
"определяем\n"
"функцию доступа для него:"

#: texi/node-25.texi:818
msgid ""
"(defclass circle ()\n"
"     ((radius :accessor circle-radius)\n"
"      (center :accessor circle-center)))"
msgstr ""

#: texi/node-25.texi:821
msgid ""
"Now if we make an instance of a circle, we can set its radius and center "
"slots\n"
"by using setf with the corresponding accessor functions:"
msgstr ""
"Теперь если мы создаем экзепляр circle, мы можем установить его слоты radius "
"и center\n"
"исползуя setf с соответствующими функциями доступа:"

#: texi/node-25.texi:824
msgid ""
"> (setf (circle-radius (make-instance 'circle)) 2)\n"
"2"
msgstr ""

#: texi/node-25.texi:827
msgid ""
"We can do this kind of initialization right in the call to make-instance if "
"we\n"
"define the slots to allow it:"
msgstr ""
"Мы можем выполнить этот тип инициализации прямо в вызове make-instance "
"слоты\n"
"позволяющие это:"

#: texi/node-25.texi:831
msgid ""
"(defclass circle ()\n"
"     ((radius :accessor circle-radius :initarg :radius)\n"
"      (center :accessor circle-center :initarg :center)))"
msgstr ""

#: texi/node-25.texi:835
msgid ""
"The :initarg keyword in a slot definition says that the following argument "
"should\n"
"become a keyword parameter in make-instance. The value of the keyword\n"
"parameter will become the initial value of the slot:"
msgstr ""
"Ключевое слово :initarg в определении слота говорит, что следующий аргумент "
"должен\n"
"стать ключевым параметром в make-instance. Значение параметра ключевого "
"слова станет\n"
"начальным значением слота:"

#: texi/node-25.texi:840
msgid ""
"> (circle-radius (make-instance 'circle\n"
"                             :radius 2\n"
"                             :center '(0 . 0)))\n"
"2"
msgstr ""

#: texi/node-25.texi:843
msgid ""
"     By declaring an :initform, we can also define slots which initialize "
"them-\n"
"selves. The visible slot of the shape class"
msgstr ""
"     Объявляя :initform, мы также можем определить слоты, которые "
"инициализируются\n"
"сами. Видимый слот класса shape"

#: texi/node-25.texi:848
msgid ""
"(defclass shape ()\n"
"     ((color     :accessor shape-color           :initarg :color)\n"
"      (visible :accessor shape-visible :initarg :visible\n"
"                 :initform t)))"
msgstr ""

#: texi/node-25.texi:886
msgid ""
"will be set to t by default:\n"
"> (shape-visible (make-instance 'shape))\n"
"T\n"
"If a slot has both an initarg and an initform, the initarg takes precedence "
"when it\n"
"is specified:\n"
"> (shape-visible (make-instance 'shape :visible nil))\n"
"NIL\n"
"       Slots are inherited by instances and subclasses. If a class has more "
"than\n"
"one superclass, it inherits the union of their slots. So if we define the "
"class\n"
"screen-circle to be a subclass of both circle and shape,\n"
"(defclass screen-circle (circle shape)\n"
"     nil)\n"
"then instances of screen-circle will have four slots, two inherited from "
"each\n"
"grandparent. Note that a class does not have to create any new slots of its "
"own; this\n"
"class exists just to provide something instantiable that inherits from both "
"circle\n"
"and shape.\n"
"       The accessors and initargs work for instances of screen-circle just "
"as they\n"
"would for instances of circle or shape:\n"
"> (shape-color (make-instance 'screen-circle\n"
"                                          :color 'red :radius 3))\n"
"RED\n"
"We can cause every screen-circle to have some default initial color by\n"
"specifying an initform for this slot in the defclass:\n"
"(defclass screen-circle (circle shape)\n"
"     ((color :initform 'purple)))\n"
"Now instances of screen-circle will be purple by default,\n"
"> (shape-color (make-instance 'screen-circle))\n"
"PURPLE\n"
"though it is still possible to initialize the slot otherwise by giving an "
"explicit\n"
":color initarg.\n"
"       In our sketch of object-oriented programming, instances inherited "
"values di-\n"
"rectly from the slots in their parent classes. In CLOS, instances do not "
"have slots\n"
"in the same way that classes do. We define an inherited default for "
"instances by\n"
"defining an initform in the parent class. In a way, this is more flexible, "
"because as\n"
"well as being a constant, an initform can be an expression that returns a "
"different\n"
"value each time it is evaluated:"
msgstr ""
"по умолчанию будет установлено значение t:\n"
"> (shape-visible (make-instance 'shape))\n"
"T\n"
"Если в слоте есть и initarg, и initform, initarg имеет приоритет, если он "
"указан:\n"
"> (shape-visible (make-instance 'shape :visible nil))\n"
"NIL\n"
"       Слоты наследуются экземплярами и подклассами. Если класс имеет более "
"одного\n"
"суперкласса, он наследует объединение из их слотов. Так что, если мы "
"определим\n"
"класс screen-circle как подкласс circle и shape,\n"
"(defclass screen-circle (circle shape)\n"
"     nil)\n"
"тогда экземпляры screen-circle будут иметь четыре слота, по два "
"унаследованых от\n"
"каждого родителя. Обратите внимание, что этот класс не должен создавать "
"никаких\n"
"новых собственных слотов; этот класс существует только для того, чтобы "
"обеспечить\n"
"создания того, что наследует как от circle, так и от shape.\n"
"       Функция доступа и initargs работают для экземпляров screen-circle "
"точно так же,\n"
"как и для экземпляров circle или shape:\n"
"> (shape-color (make-instance 'screen-circle\n"
"                                          :color 'red :radius 3))\n"
"RED\n"
"Мы можем заставить каждый screen-circle иметь некоторый начальны цвет по "
"умолчанию, указав\n"
"initform для этого слота в определении класса defclass:\n"
"(defclass screen-circle (circle shape)\n"
"     ((color :initform 'purple)))\n"
"Теперь экземпляры screen-circle будут purple по умолчанию,\n"
"> (shape-color (make-instance 'screen-circle))\n"
"PURPLE\n"
"хотя все еще возможно инициализировать слот, в противном случае, задав явный "
"ицинцализирующий\n"
"аргумент :color initarg.\n"
"       В нашем наброске объектно-ориентированного программирования, "
"экземпляры наследовали\n"
"значения непсредственно из слотов в своих же родительстких классах. В  CLOS, "
"экземпляры не\n"
"имеют слотов таких же как классы. Мы определяем наследуемое значение по "
"умолчанию для экземпляров,\n"
"определяя initform в родительском классе. В некотором смысле, это более "
"гибко, потому что\n"
"initform может быть не только константой, но и выражением, которое "
"возвращает разное значение при\n"
"каждом его вычислении:"

#: texi/node-25.texi:891
msgid ""
"(defclass random-dot ()\n"
"     ((x :accessor dot-x :initform (random 100))\n"
"      (y :accessor dot-y :initform (random 100))))"
msgstr ""

#: texi/node-25.texi:894
msgid ""
"Each time we make an instance of a random-dot its x- and y-position will be "
"a\n"
"random integer between 0 and 99:"
msgstr ""
"Каждый раз, когда мы создаем экземпляр случайной точки, её координаты x и "
"y \n"
"будут случайным целым числом от 0 до 99:"

#: texi/node-25.texi:900
msgid ""
"> (mapcar #'(lambda (name)\n"
"                   (let ((rd (make-instance 'random-dot)))\n"
"                      (list name (dot-x rd) (dot-y rd))))\n"
"              '(first second third))\n"
"((FIRST 25 8) (SECOND 26 15) (THIRD 75 59))"
msgstr ""

#: texi/node-25.texi:909
msgid ""
"     In our sketch, we also made no distinction between slots whose values "
"were\n"
"to vary from instance to instance, and those which were to be constant "
"across the\n"
"whole class. In CLOS we can specify that some slots are to be shared-that "
"is,\n"
"their value is the same for every instance. We do this by declaring the slot "
"to\n"
"have :allocation :class. (The alternative is for a slot to have :allocation\n"
":instance, but since this is the default there is no need to say so "
"explicitly.) For\n"
"example, if all owls are nocturnal, then we can make the nocturnal slot of "
"the\n"
"owl class a shared slot, and give it the initial value t:"
msgstr ""
"     В нашем наброске мы также не делали различий между слотами, значения "
"которых\n"
"доложны были варьироваться от экземпляра к экземпляру, и слотами, которые "
"должны\n"
"быть постоянными по всему классу. В CLOS мы можем указать, что некоторые "
"слоты\n"
"должны быть общими, то есть их значение одинаково для каждого экземпляра. Мы "
"сделаем\n"
"это объявив слот имеющий :allocation :class. (Альтернативно это для слота "
"должно\n"
"быть :allocation :instance, но так как это значение по умолчанию, нет "
"необходимости\n"
"говорить об этом явнор.) Например, если все совы(owls) ведут ночной образ "
"жизни(nocturnal),\n"
"то мы можем сделать слот nocturnal класса owl разделяемым слотом, и задать "
"ему\n"
"начальное значение t:"

#: texi/node-25.texi:914
msgid ""
"(defclass owl ()\n"
"     ((nocturnal :accessor owl-nocturnal\n"
"                   :initform t\n"
"                   :allocation :class)))"
msgstr ""

#: texi/node-25.texi:916
msgid "Now every instance of the owl class will inherit this slot:"
msgstr "Теперь каждый экземпляр класса owl будет наследовать этот слот:"

#: texi/node-25.texi:919
msgid ""
"> (owl-nocturnal (make-instance 'owl))\n"
"T"
msgstr ""

#: texi/node-25.texi:922
msgid ""
"If we change the \"local\" value of this slot in an instance, we are "
"actually altering\n"
"the value stored in the class:"
msgstr ""
"Если мы изменим \"локальное\" значение этого слота в некотором экземпляре, "
"мы фактически\n"
"изменим значение, хранящееся в классе:"

#: texi/node-25.texi:927
msgid ""
"> (setf (owl-nocturnal (make-instance 'owl)) 'maybe)\n"
"MAYBE\n"
"> (owl-nocturnal (make-instance 'owl))\n"
"MAYBE"
msgstr ""

#: texi/node-25.texi:933
msgid ""
"     This could cause some confusion, so we might like to make such a slot "
"read-\n"
"only. When we define an accessor function for a slot, we create a way of "
"both\n"
"reading and writing the slot's value. If we want the value to be readable "
"but\n"
"not writable, we can do it by giving the slot just a reader function, "
"instead of a\n"
"full-fledged accessor function:"
msgstr ""
"     Это может вызвать некоторую путаницу, поэтому мы можем сделать такой "
"слот\n"
"доступным только для чтения. Когда мы определяем функцию доступа для слота, "
"мы\n"
"создаем способ чтения и записи значения слота. Если мы хотим, чтобы значение "
"было\n"
"читаемым, но не доступным для записи, мы можем сделать это, предоставив "
"слоту только\n"
"функцию чтения, а не полноценную функцию доступа:"

#: texi/node-25.texi:939
msgid ""
"(defclass owl ()\n"
"  ((nocturnal :reader owl-nocturnal\n"
"                      :initform t\n"
"                      :allocation :class)))"
msgstr ""

#: texi/node-25.texi:941
msgid ""
"Now attempts to alter the nocturnal slot of an instance will generate an "
"error:"
msgstr ""
"Тепарь попытки изменить слот nocturnal для экземпляра приведут к генерации "
"ошибки:"

#: texi/node-25.texi:944
msgid ""
"> (setf (owl-nocturnal (make-instance 'owl)) nil)\n"
">>Error: The function (SETF OWL-NOCTURNAL) is undefined."
msgstr ""

#: texi/node-25.texi:949
msgid ""
"@node 25-4 Methods, 25-5 Auxiliary Methods and Combination, 25-3 Classes and "
"Instances, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-4 Methods\n"
"@cindex 25-4 Methods"
msgstr ""
"@node 25-4 Methods, 25-5 Auxiliary Methods and Combination, 25-3 Classes and "
"Instances, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-4 Методы\n"
"@cindex 25-4 Methods"

#: texi/node-25.texi:954
msgid ""
"Our sketch emphasized the similarity between slots and methods in a "
"language\n"
"which provides lexical closures. In our program, a primary method was "
"stored\n"
"and inherited in the same way as a slot value. The only difference between a "
"slot\n"
"and a method was that defining a name as a slot by"
msgstr ""
"Наш набросок подчеркивал сходство между слотами и методами в языке, "
"которые \n"
"предоставляет лексические замыкания. В нашей программе основной/первичный "
"метод\n"
"хранился и наследовался так же, как и значения слота. Единственная разница\n"
"между слотом и методом заключалась в том, что определение имени как слота"

#: texi/node-25.texi:956
msgid "(defprop area)"
msgstr ""

#: texi/node-25.texi:959
msgid ""
"made area a function which would simply retrieve and return a value, while\n"
"defining it as a method by"
msgstr ""
"делало area функцией, которая будет просто извлекать и возвращаеть "
"значение,\n"
"определяя его как метод"

#: texi/node-25.texi:963
msgid ""
"@lisp\n"
"(defprop area t)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:966
msgid ""
"made area a function which would, after retrieving a value, funcall it on "
"its\n"
"arguments."
msgstr ""
"делало area функцией, которая после получения значения, вызывась бы "
"(funcall)\n"
"с этим аргументом."

#: texi/node-25.texi:970
msgid ""
"       In CLOS the functional units are still called methods, and it is "
"possible to define\n"
"them so that they each seem to be a property of some class. Here we define "
"an\n"
"area method for the circle class:"
msgstr ""
"       В CLOS функциональные блоки по прежнему называются методами, и их "
"можно определить\n"
"так, чтобы каждый из них казался свойством некоторого класса. Здесь мы "
"определяем метод\n"
"area для класса circle:"

#: texi/node-25.texi:975
msgid ""
"@lisp\n"
"(defmethod area ((c circle))\n"
"  (* pi (expt (circle-radius c) 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:978
msgid ""
"The parameter list for this method says that it is a function of one "
"argument which\n"
"applies to instances of the circle class."
msgstr ""
"Список параметров для этого метода говорит, что это функция одного "
"аргумента, которая\n"
"применяется к экземплярам класса circle."

#: texi/node-25.texi:980
msgid "       We invoke this method like a function, just as in our sketch:"
msgstr "       Мы вызываем этот метод как функцию, как в нашем наброске:"

#: texi/node-25.texi:985
msgid ""
"@example\n"
"> (area (make-instance 'circle :radius 1))\n"
"3.14...\n"
"@end example"
msgstr ""

#: texi/node-25.texi:987
msgid "We can also define methods that take additional arguments:"
msgstr ""
"Мы также можем определить методы, которые принимают дополнительные аргументы:"

#: texi/node-25.texi:994
msgid ""
"@lisp\n"
"(defmethod move ((c circle) dx dy)\n"
"  (incf (car (circle-center c)) dx)\n"
"  (incf (cdr (circle-center c)) dy)\n"
"  (circle-center c))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:998
msgid ""
"If we call this method on an instance of circle, its center will be shifted "
"by\n"
" dx,dy :"
msgstr ""
"Если мы вызовем этот метод для экземпляра circle, его центр(center) будет "
"сдвинут на\n"
" dx,dy :"

#: texi/node-25.texi:1001
msgid ""
"> (move (make-instance 'circle :center '(1 . 1)) 2 3)\n"
"(3.4)"
msgstr ""

#: texi/node-25.texi:1006
msgid ""
"The value returned by the method reflects the circle's new position.\n"
"   As in our sketch, if there is a method for the class of an instance, and "
"for\n"
"superclasses of that class, the most specific one runs. So if unit-circle is "
"a\n"
"subclass of circle, with the following area method"
msgstr ""
"Значение возвращаемое методом, отражает новую позицию circle.\n"
"   Как и в нашем наброске, если есть метод для экземпляра класса, и для "
"суперкласса\n"
"этого класса, запускается самый конкретный метод. Так что, если unit-circle "
"это\n"
"подкласс circle, со следующим методом area"

#: texi/node-25.texi:1010
msgid ""
"@lisp\n"
"(defmethod area ((c unit-circle)) pi)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1015
msgid ""
"then this method, rather than the more general one, will run when we call "
"area\n"
"on an instance of unit-circle.\n"
"   When a class has multiple superclasses, their precedence runs left to "
"right. By\n"
"defining the class patriotic-scoundrel as follows"
msgstr ""
"тогда этот метод, а не более общий, будет выполняться, когда мы вызовем "
"area\n"
"для экземпляра unit-circle.\n"
"   Когда у класса несколько суперклассов, их приоритет идет слева на "
"право. \n"
"Определив класс patriotic-scoundrel следующим образом"

#: texi/node-25.texi:1021
msgid ""
"@lisp\n"
"(defclass scoundrel nil nil)\n"
"(defclass patriot nil nil)\n"
"(defclass patriotic-scoundrel (scoundrel patriot) nil)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1024
msgid ""
"we specify that patriotic scoundrels are scoundrels first and patriots "
"second. When\n"
"there is an applicable method for both superclasses,"
msgstr ""
"мы уточняем, что патриотичные негодяи(patriotic scoundrels) являются сначала "
"негодяями\n"
"(scoundrels), а потом патриотами(patriots). Когда есть подходящий метод для "
"обоих\n"
"суперклассов,"

#: texi/node-25.texi:1028
msgid ""
"@lisp\n"
"(defmethod self-or-country? ((s scoundrel))\n"
"  'self)"
msgstr ""

#: texi/node-25.texi:1032
msgid ""
"(defmethod self-or-country? ((p patriot))\n"
"  'country)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1034
msgid "the method of the scoundrel class will run:"
msgstr "будет выполняться метод класса негодяев(scoundrel):"

#: texi/node-25.texi:1037
msgid ""
"> (self-or-country? (make-instance 'patriotic-scoundrel))\n"
"SELF"
msgstr ""

#: texi/node-25.texi:1044
msgid ""
"   The examples so far maintain the illusion that CLOS methods are methods "
"of\n"
"some object. In fact, they are something more general. In the parameter list "
"of\n"
"the move method, the element (c circle) is called a specialized parameter; "
"it\n"
"says that this method applies when the first argument to move is an instance "
"of the\n"
"circle class. In a CLOS method, more than one parameter can be specialized. "
"The\n"
"following method has two specialized and one optional unspecialized "
"parameter:"
msgstr ""
"   Пока приведенные примеры поддерживают иллюзию, что методы CLOS являются "
"методами\n"
"некоторого объекта. На самом деле они являются чем-то более общим. В списке "
"параметров\n"
"метода move, элемент (c circle) называется особенным(специализированным) "
"параметром; он\n"
"говорит, что этот метод применяется когда первый аргумент для move является "
"экземпляром\n"
"класса circle. В методе CLOS, может быть специализировано более одного "
"параметра.\n"
"Следующий метод имеет два специализированных и один не обязательный не "
"специализированный\n"
"параметр:"

#: texi/node-25.texi:1077
msgid ""
"@lisp\n"
"(defmethod combine ((ic ice-cream) (top topping)\n"
"                               &optional (where :here))\n"
"   (append (list (name ic) 'ice-cream)\n"
"                   (list 'with (name top) 'topping)\n"
"                   (list 'in 'a\n"
"                         (case where\n"
"                             (:here 'glass)\n"
"                             (:to-go 'styrofoam))\n"
"                         'dish)))\n"
"@end lisp\n"
"It is invoked when the first two arguments to combine are instances of ice-"
"cream\n"
"and topping, respectively. If we define some minimal classes to instantiate\n"
"@lisp\n"
"(defclass stuff () ((name :accessor name :initarg :name)))\n"
"(defclass ice-cream (stuff) nil)\n"
"(defclass topping (stuff) nil)\n"
"@end lisp\n"
"then we can define and run this method:\n"
"> (combine (make-instance 'ice-cream :name 'fig)\n"
"                   (make-instance 'topping :name 'olive)\n"
"                   :here)\n"
"(FIG ICE-CREAM WITH OLIVE TOPPING IN A GLASS DISH)\n"
"       When methods specialize more than one of their parameters, it is "
"difficult\n"
"to continue to regard them as properties of classes. Does our combine "
"method\n"
"belong to the ice-cream class or the topping class? In CLOS, the model of\n"
"objects responding to messages simply evaporates. This model seems natural "
"so\n"
"long as we invoke methods by saying something like:\n"
"(tell obj 'move 2 3)\n"
"Then we are clearly invoking the move method of obj. But once we drop this\n"
"syntax in favor of a functional equivalent:"
msgstr ""
"@lisp\n"
"(defmethod combine ((ic ice-cream) (top topping)\n"
"                               &optional (where :here))\n"
"   (append (list (name ic) 'ice-cream)\n"
"                   (list 'with (name top) 'topping)\n"
"                   (list 'in 'a\n"
"                         (case where\n"
"                             (:here 'glass)\n"
"                             (:to-go 'styrofoam))\n"
"                         'dish)))\n"
"@end lisp\n"
"Он вызывается, когда первые два аргумента, которые нужно объединить, "
"являются\n"
"экземплярами ice-cream(мороженное) и topping(начинка), соответственно. Если\n"
"мы определим некоторые минимальные классы для создания экземпляров\n"
"@lisp\n"
"(defclass stuff () ((name :accessor name :initarg :name)))\n"
"(defclass ice-cream (stuff) nil)\n"
"(defclass topping (stuff) nil)\n"
"@end lisp\n"
"тогда мы сможем определить и запустить этот метод:\n"
"> (combine (make-instance 'ice-cream :name 'fig)\n"
"                   (make-instance 'topping :name 'olive)\n"
"                   :here)\n"
"(FIG ICE-CREAM WITH OLIVE TOPPING IN A GLASS DISH)\n"
"       Когда методы специализируются более чем одним из их параметров, "
"трудно\n"
"продолжать рассматривать их как свойства классов. Наш метод combine "
"относиться\n"
"к классу ice-cream или классу topping? В CLOS модель объектнов, отвечающих "
"на\n"
"сообщения, просто испаряется. Эта модель кажеться естественной, пока мы "
"вызываем\n"
"методы, говоря что-то вроде:\n"
"\n"
"(tell obj 'move 2 3)\n"
"\n"
"Здесь мы явно вызваем метод move объекта obj. Но как только мы отбросим "
"этот\n"
"синтаксис в пользу функционального эквивалента:"

#: texi/node-25.texi:1081
msgid ""
"@lisp\n"
"(move obj 2 3)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1084
msgid ""
"then we have to define move so that it dispatches on its first argument-that "
"is,\n"
"looks at the type of the first argument and calls the appropriate method."
msgstr ""
"тогда мы имеем определениеe move, такое что его поведение диспетчеризируется "
"в \n"
"зависимости от первого аргумента, т.е. просматривает первый аргумент и "
"вызывает\n"
"соответствующий метод."

#: texi/node-25.texi:1090
msgid ""
"Once we have taken this step, the question arises: why only allow "
"dispatching\n"
"on the first argument? CLOS answers: why indeed? In CLOS, methods can\n"
"specialize any number of their parameters-and not just on user-defined "
"classes,\n"
"but on Common Lisp types,@footnote{Or more precisely, on the type-like "
"classes that CLOS defines in parallel with the Common Lisp type hierarchy.} "
"and even on individual objects. Here is a combine\n"
"method that applies to strings:"
msgstr ""
"После того, как мы сделали этот шаг, возникает вопрос: почему разрешается "
"проводить\n"
"диспетчеризацию только по первому аргументу? CLOS отвечает: действительно, "
"почему? В CLOS, \n"
"методы могут специализироваться любым количеством своих параметров - и не "
"только на\n"
"определяемых пользователем классах, но и на типах Common Lisp,@footnote{Или "
"точнее, на\n"
"типах подобных классам, которые определяет CLOS параллельно с иерархией "
"типов Common Lisp.} \n"
"и даже на отдельных объектах. Вот метод combine который применяется к "
"строкам(string):"

#: texi/node-25.texi:1096
msgid ""
"@lisp\n"
"(defmethod combine ((s1 string) (s2 string) &optional int?)\n"
"   (let ((str (concatenate 'string s1 s2)))\n"
"        (if int? (intern str) str)))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1099
msgid ""
"Which means not only that methods are no longer properties of classes, but "
"that\n"
"we can use methods without defining classes at all."
msgstr ""
"Это означает не только то, что методы больше не являются свойствами классов, "
"но\n"
"и то, что мы можем использовать методы вообще без определения классов."

#: texi/node-25.texi:1102
msgid ""
"> (combine \"I am not a \" \"cook.\")\n"
"\"I am not a cook.\""
msgstr ""

#: texi/node-25.texi:1104
msgid "Here the second parameter is specialized on the symbol palindrome:"
msgstr "Здесь второй параметр специализируется символом palindrome(палиндром):"

#: texi/node-25.texi:1113
msgid ""
"@lisp\n"
"(defmethod combine ((s1 sequence) (x (eql 'palindrome))\n"
"                                   &optional (length :odd))\n"
"   (concatenate (type-of s1)\n"
"                          s1\n"
"                          (subseq (reverse s1)\n"
"                                        (case length (:odd 1) (:even 0)))))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1115
msgid ""
"This particular method makes palindromes of any kind of sequence elements: "
"@footnote{In one (otherwise excellent) Common Lisp implementation, "
"concatenate will not accept cons as its first argument, so this call will "
"not work.}"
msgstr ""
"Этот конкретный метод делает палиндромы последовательностей любого вида: \n"
"@footnote{В одной(в остальном очень хорошей) реализации Common Lisp, "
"concatenate \n"
"не принимает cons в качестве первого аргумента, поэтому там этот вызов "
"работать не будет.}"

#: texi/node-25.texi:1118
msgid ""
"> (combine '(able was i ere) 'palindrome)\n"
"(ABLE WAS I ERE I WAS ABLE)"
msgstr ""

#: texi/node-25.texi:1127
msgid ""
"     At this point we no longer have object-oriented programming, but "
"something\n"
"more general. CLOS is designed with the understanding that beneath methods\n"
"there is this concept of dispatch, which can be done on more than one "
"argument,\n"
"and can be based on more than an argument's class. When methods are built "
"upon\n"
"this more general notion, they become independent of individual classes. "
"Instead\n"
"of adhering conceptually to classes, methods now adhere to other methods "
"with\n"
"the same name. In CLOS such a clump of methods is called a generic function. "
"All\n"
"our combine methods implicitly define the generic function combine."
msgstr ""
"     Здесь у нас больше нет объектно-ориентированного программирования. а "
"есть \n"
"нечто большее. CLOS разработан с пониманием того, что под методами "
"существует\n"
"такая концепция диспетчеризации(распределения вызовов), которая может быть "
"сделана\n"
"для более чем одного аргумента и может основываться больше чем на классе "
"аргументов.\n"
"Когда методы построены на этом более общем понятии, они становятся "
"независимыми от\n"
"отдельных классов. Вместо того, чтобы концептуально придерживаться классов, "
"методы\n"
"теперь придерживаются других методов с теми же именами. В CLOS такой набор "
"методов\n"
"называется обобщенной/родовой/общей функцией(generic function). Все наши "
"методы \n"
"combine неявно определяют обобщенную функцию combine."

#: texi/node-25.texi:1132
msgid ""
"     We can define generic functions explicitly with the defgeneric macro. "
"It\n"
"is not necessary to call defgeneric to define a generic function, but it can "
"be a\n"
"convenient place to put documentation, or some sort of safety-net for "
"errors. Here\n"
"we do both:"
msgstr ""
"     Мы можем определить обобщенные функции явно с помощью макроса "
"defgeneric. Нет\n"
"необходимости вызывать defgeneric для определения обобщенной функции, но оно "
"может\n"
"быть удобным местом для размещения документации или какой-то защитной сеткой "
"от\n"
"ошибок. Здесь мы делаем обе вещи:"

#: texi/node-25.texi:1139
msgid ""
"@lisp\n"
"(defgeneric combine (x y &optional z)\n"
"   (:method (x y &optional z)\n"
"         \"I can't combine these arguments.\")\n"
"   (:documentation \"Combines things.\"))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1142
msgid ""
"Since the method given here for combine doesn't specialize any of its "
"arguments,\n"
"it will be the one called in the event no other method is applicable."
msgstr ""
"Поскольку метод, указанный здесь для объединения, не специализирует ни один "
"из\n"
"его аргументов, он будет вызываться в том случае, если ни один другой "
"метод \n"
"не применим."

#: texi/node-25.texi:1147
msgid ""
"@example\n"
"> (combine #'expt \"chocolate\")\n"
"\"I can't combine these arguments.\"\n"
"@end example"
msgstr ""

#: texi/node-25.texi:1149
msgid "Before, this call would have generated an error."
msgstr "Ранее, этот вызов вызывал бы ошибку."

#: texi/node-25.texi:1156
msgid ""
"Generic functions impose one restriction that we don't have when methods\n"
"are properties of objects: when all methods of the same name get joined into "
"one\n"
"generic function, their parameter lists must agree. That's why all our "
"combine\n"
"methods had an additional optional parameter. After defining the first "
"combine\n"
"method to take up to three arguments,it would have caused an error if we "
"attempted\n"
"to define another which only took two."
msgstr ""
"Обобщенные функции накладывают одно ограничение, которого у нас небыло, "
"когда\n"
"методы являлись свойствами объектов: когда все методы с одинаковым именем "
"объединяются\n"
"в одну обобщенную функцию, их списоки параметров должны быть согласованы. "
"Вот почему\n"
"все наши методы combine имеют дополнительный необязательный параметр. После "
"определения\n"
"первого метода combine, который может принимать до трех аргументов, это "
"вызвало бы ошибку,\n"
"если бы мы попытались определить другой метод, который бы принимал только "
"два параметра."

#: texi/node-25.texi:1163
msgid ""
"CLOS requires that the parameter lists of all methods with the same name be\n"
"congruent. Two parameter lists are congruent if they have the same number "
"of\n"
"required parameters, the same number of optional parameters, and compatible "
"use\n"
"of &rest and &key. The actual keyword parameters accepted by different "
"methods\n"
"need not be the same, but defgeneric can insist that all its methods accept "
"a\n"
"certain minimal set. The following pairs of parameter lists are all "
"congruent:"
msgstr ""
"CLOS требует, чтобы списки параметров всех методов с одинаковыми именами "
"были\n"
"конгруэнтными(соответствующими). Два списка параметров являются "
"соответствующими,\n"
"если они имеют одинаковое количество обязательных параметров, одинаковое "
"количество\n"
"необязательных параметров и совместимое использование &rest и &key. "
"Фактические\n"
"параметры ключевые слова, принимаемые различными методами, не обязательно "
"должны\n"
"быть одинаковыми, но defgeneric может настаивать на том, что все его методы\n"
"принимают определенный минимальный набор. Следующие пары списков параметров\n"
"являются конгруэнтными(соответствующими):"

#: texi/node-25.texi:1170
msgid ""
"@example\n"
"(x)                     (a)\n"
"(x &optional y) (a &optional b)\n"
"(x y &rest z)           (a b &rest c)\n"
"(x y &rest z)           (a b &key c d)\n"
"@end example"
msgstr ""

#: texi/node-25.texi:1173
msgid ""
"@noindent\n"
"and the following pairs are not:"
msgstr ""
"@noindent\n"
"а следующие пары таковыми не являются:"

#: texi/node-25.texi:1180
msgid ""
"@example\n"
"(x)                     (a b)\n"
"(x &optional y) (a &optional b c)\n"
"(x &optional y) (a &rest b)\n"
"(x &key x y)            (a)\n"
"@end example"
msgstr ""

#: texi/node-25.texi:1185
msgid ""
"Redefining methods is just like redefining functions. Since only required\n"
"parameters can be specialized, each method is uniquely identified by its "
"generic\n"
"function and the types of its required parameters. If we define another "
"method\n"
"with the same specializations, it overwrites the original one. So by saying:"
msgstr ""
"Переопределение методов аналогично переопределению функций. Поскольку "
"специализироваными\n"
"могут быть только обязательные параметры, каждый метод уникально "
"идентифицируется\n"
"своей обобщенной функцией и типами его обязательных параметров. Если мы "
"определяем другой\n"
"метод с теми же специализациями, он перезаписывает исходный. Итак, сказав:"

#: texi/node-25.texi:1191
msgid ""
"@lisp\n"
"(defmethod combine ((x string) (y string)\n"
"                               &optional ignore)\n"
"  (concatenate 'string x \"+\"y))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1194
msgid ""
"@noindent\n"
"we redefine what combine does when its first two arguments are strings."
msgstr ""
"@noindent\n"
"мы переопределяем то, что combine делает, когда два первых аргумента "
"являются\n"
"строками(string)."

#: texi/node-25.texi:1197
msgid ""
"Unfortunately, if instead of redefining a method we want to remove it, "
"there\n"
"is no built-in converse of defmethod. Fortunately, this is Lisp, so we can "
"write"
msgstr ""
"К сожалению, если вместо переопределения метода мы хотим удалить его, "
"встроенной\n"
"функции обратной defmethod - нет. К счастью, это Lisp, поэтому мы можем его "
"написать"

#: texi/node-25.texi:1203
msgid ""
"@lisp\n"
" (defmacro undefmethod (name &rest args)\n"
"    (if (consp (car args))\n"
"         (udm name nil (car args))\n"
"         (udm name (list (car args)) (cadr args))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro undefmethod (name &rest args)\n"
"    (if (consp (car args))\n"
"         (udm name nil (car args))\n"
"         (udm name (list (car args)) (cadr args))))"

#: texi/node-25.texi:1213
msgid ""
" (defun udm (name qual specs)\n"
"    (let ((classes (mapcar #'(lambda (s)\n"
"                                       `(find-class ',s))\n"
"                                    specs)))\n"
"        `(remove-method (symbol-function ',name)\n"
"                            (find-method (symbol-function ',name)\n"
"                                               ',qual\n"
"                                               (list ,@@classes)))))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1215
msgid "                  Figure 25-12: Macro for removing methods."
msgstr ""
"                  Рисунок 25-12: Макрос для удаления методов.\n"
"@end cartouche"

#: texi/node-25.texi:1224
msgid ""
"@noindent\n"
"one. The details of how to remove a method by hand are summarized in the\n"
"implementation of undefmethod in Figure 25-12. We use this macro by giving\n"
"arguments similar to those we would give to defmethod, except that instead "
"of\n"
"giving a whole parameter list as the second or third argument, we give just "
"the\n"
"class-names of the required parameters. So to remove the combine method for\n"
"two strings, we say:"
msgstr ""
"@noindent\n"
"Детали того, как можно удалить метод в ручную, приведены в реализации\n"
"undefmethod на Рисунке 25-12. Мы используем этот макрос, передавая "
"аргументы\n"
"аналогичные тем, котоыре мы передаем в defmethod, за исключением того, что "
"вместо\n"
"того, чтобы передавать полный списко параметров в качестве второго и "
"третьего\n"
"аргументов, мы передаем просто названия классов требуемых параметров. Итак,\n"
"чтобы удалить метод combine для двух строк(string), мы скажем:"

#: texi/node-25.texi:1228
msgid ""
"@lisp\n"
"(undefmethod combine (string string))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1231
msgid ""
"Unspecialized arguments are implicitly of class t, so if we had defined a "
"method\n"
"with required but unspecialized parameters:"
msgstr ""
"Неспециализированные аргументы неявно относятся к классу  t, поэтому, если "
"бы мы\n"
"определили метод с обязательными, но неспециализированными параметрами:"

#: texi/node-25.texi:1236
msgid ""
"@lisp\n"
"(defmethod combine ((fn function) x &optional y)\n"
"  (funcall fn x y))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1238
msgid "we could get rid of it by saying"
msgstr "мы бы могли избавиться от него, сказав"

#: texi/node-25.texi:1242
msgid ""
"@lisp\n"
"(undefmethod combine (function t))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1245
msgid ""
"If we want to remove a whole generic function, we can do it the same way we\n"
"would remove the definition of any function, by calling fmakunbound:"
msgstr ""
"Если мы хотим удалить всю обобщенную функцию, мы можем сделать это так же, "
"как\n"
"мы бы удаляли определение любой функции, вызывав fmakunbound:"

#: texi/node-25.texi:1249
msgid ""
"@lisp\n"
"(fmakunbound 'combine)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1254
msgid ""
"@node 25-5 Auxiliary Methods and Combination, 25-7 When to Object, 25-4 "
"Methods, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-5 Auxiliary Methods and Combination\n"
"@cindex 25-5 Auxiliary Methods and Combination"
msgstr ""
"@node 25-5 Auxiliary Methods and Combination, 25-7 When to Object, 25-4 "
"Methods, 25 Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-5 Вспомогательные Методы и Комбинации\n"
"@cindex 25-5 Auxiliary Methods and Combination"

#: texi/node-25.texi:1260
msgid ""
"Auxiliary methods worked in our sketch basically as they do in CLOS. So far "
"we\n"
"have seen only primary methods, but we can also have before-, after- and "
"around-\n"
"methods. Such auxiliary methods are defined by putting a qualifying keyword\n"
"after the method name in the call to defmethod. If we define a primary "
"speak\n"
"method for the speaker class as follows:"
msgstr ""
"Вспомогательные методы работали в нашем наброске в основном так же как они \n"
"работаю и в CLOS. До сих пор мы видели только первичные методы, но у нас\n"
"также могут быть методы before-, after- и around-. Такие вспомогательные\n"
"методы определяются путем добавления ключевого слова после имени метода в\n"
"вызове defmethod. Если мы определим первичный метод speak для класса\n"
"speaker следующим образом:"

#: texi/node-25.texi:1263
msgid ""
"@lisp\n"
"(defclass speaker nil nil)"
msgstr ""

#: texi/node-25.texi:1267
msgid ""
"(defmethod speak ((s speaker) string)\n"
"  (format t \"~A\" string))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1269
msgid ""
"Then calling speak with an instance of speaker just prints the second "
"argument:"
msgstr ""
"Затем вызов speak с экземпляром speaker просто напечатает второй аргумент:"

#: texi/node-25.texi:1274
msgid ""
"> (speak (make-instance 'speaker)\n"
"            \"life is not what it used to be\")\n"
"life is not what it used to be\n"
"NIL"
msgstr ""

#: texi/node-25.texi:1277
msgid ""
"By defining a subclass intellectual which wraps before- and after-methods\n"
"around the primary speak method,"
msgstr ""
"Определим подкласс intellectual, который оборачивает методы before- и "
"after-\n"
"вокруг первичного метода speak,"

#: texi/node-25.texi:1280
msgid ""
"@lisp\n"
"(defclass intellectual (speaker) nil)"
msgstr ""

#: texi/node-25.texi:1283
msgid ""
"(defmethod speak :before ((i intellectual) string)\n"
"  (princ \"Perhaps \"))"
msgstr ""

#: texi/node-25.texi:1287
msgid ""
"(defmethod speak :after ((i intellectual) string)\n"
"  (princ \" in some sense\"))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1290
msgid ""
"we can create a subclass of speakers which always have the last (and the "
"first)\n"
"word:"
msgstr ""
"мы можем создать подкласс ораторов(speakers), у которых всегда есть "
"последнее (и первое)\n"
"слово:"

#: texi/node-25.texi:1295
msgid ""
"> (speak (make-instance 'intellectual)\n"
"            \"life is not what it used to be\")\n"
"Perhaps life is not what it used to be in some sense\n"
"NIL"
msgstr ""

#: texi/node-25.texi:1300
msgid ""
"In standard method combination, the methods are called as described in our\n"
"sketch: all the before-methods, most specific first, then the most specific "
"primary\n"
"method, then all the after-methods, most specific last. So if we define "
"before- or\n"
"after-methods for the speaker superclass,"
msgstr ""
"В стандартной комбинации методов, методы вызываются так, как описано в нашем "
"наброске%\n"
"все методы before-, сначала наиболее конкретные, затем наиболее конкретный "
"первичный\n"
"метод, затем все методы after, где самый конкретный вызывается последним. "
"Поэтому, если\n"
"мы определим методы before- или after- для суперкласса speaker,"

#: texi/node-25.texi:1306
msgid ""
"@lisp\n"
"(defmethod speak :before ((s speaker) string)\n"
"  (princ \"I think \"))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1308
msgid "they will get called in the middle of the sandwich:"
msgstr "они будут вызваны в середине \"сендвича\" из методов:"

#: texi/node-25.texi:1313
msgid ""
"> (speak (make-instance 'intellectual)\n"
"            \"life is not what it used to be\")\n"
"Perhaps I think life is not what it used to be in some sense\n"
"NIL"
msgstr ""

#: texi/node-25.texi:1326
msgid ""
"Regardless of what before- or after-methods get called, the value returned "
"by the\n"
"generic function is the value of the most specific primary method-in this "
"case,\n"
"the nil returned by format.\n"
"   This changes if there are around-methods. If one of the classes in an "
"object's\n"
"family tree has an around-method-or more precisely,if there is an around-"
"method\n"
"specialized for the arguments passed to the generic function-the around-"
"method\n"
"will get called first, and the rest of the methods will only run if the "
"around-method\n"
"decides to let them. As in our sketch, an around- or primary method can "
"invoke\n"
"the next method by calling a function: the function we defined as call-next "
"is\n"
"in CLOS called call-next-method. There is also a next-method-p, analogous\n"
"to our next-p. With around-methods we can define another subclass of "
"speaker\n"
"which is more circumspect:"
msgstr ""
"Независимо от того, что вызываются методы before- или after-, значение "
"возвращаемое\n"
"обобщенной функцией будет значением наиболее конкретного первичного метода - "
"в данном\n"
"случае nil возвращаемый функцией format.\n"
"   Оно измениться если есть методы around-. Если у одного из классов в "
"семейном дереве\n"
"объектов есть метод around- или точнее, если есть метод  around- "
"специализированный для\n"
"аргументов передаваемых в обобщенную функцию- сначала будет вызван метод "
"around-, а\n"
"остальные методы будут выполняться только в том случае, если метод around- "
"решит ими\n"
"воспользоваться. Как и в нашем наброске, метод around- или "
"primary(первичный) может\n"
"вызвать следующий метод вызывав функцию: функцию, которую мы определили как "
"call-next \n"
"в CLOS называется call-next-method. Существует также next-method-p, аналог "
"нашего\n"
"next-p. С помощью методов around- мы можем определить другой подкласс "
"speaker, который\n"
"является более осмотрительным:"

#: texi/node-25.texi:1329
msgid ""
"@lisp\n"
"(defclass courtier (speaker) nil)"
msgstr ""

#: texi/node-25.texi:1337
msgid ""
"(defmethod speak :around ((c courtier) string)\n"
"  (format t \"Does the King believe that ~A? \" string)\n"
"  (if (eq (read) 'yes)\n"
"        (if (next-method-p) (call-next-method))\n"
"        (format t \"Indeed, it is a preposterous idea.~%\"))\n"
"  'bow)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1340
msgid ""
"When the first argument to speak is an instance of the courtier class, the\n"
"courtier's tongue is now guarded by the around-method:"
msgstr ""
"Когда первым аргументом для speak является экземпляр класса courtier, язык\n"
"придворного(courtier) теперь защищен методом around-:"

#: texi/node-25.texi:1349
msgid ""
"> (speak (make-instance 'courtier) \"kings will last\")\n"
"Does the King believe that kings will last? yes\n"
"I think kings will last\n"
"BOW\n"
"> (speak (make-instance 'courtier) \"the world is round\")\n"
"Does the King believe that the world is round? no\n"
"Indeed, it is a preposterous idea.\n"
"BOW"
msgstr ""

#: texi/node-25.texi:1353
msgid ""
"Note that, unlike before- and after-methods, the value returned by the "
"around-\n"
"method is returned as the value of the generic function."
msgstr ""
"Обратите внимание, что в отличии от методов before- и after-, значение "
"возвращаемое\n"
"методом around-, возвращается как значение обобщенной функции."

#: texi/node-25.texi:1356
msgid ""
"Generally, methods are run as in this outline, which is reprinted from Sec-\n"
"tion 25-2:"
msgstr ""
"Как правило, методы выполняются, как показано в этой схеме, которая "
"перепечатана\n"
"из раздела 25-2:"

#: texi/node-25.texi:1358
msgctxt "texi/node-25.texi:1358"
msgid "   1. The most specific around-method, if there is one."
msgstr "   1. . Наиболее конкретный метод around- если он есть."

#: texi/node-25.texi:1360
msgctxt "texi/node-25.texi:1360"
msgid "   2. Otherwise, in order:"
msgstr "   2. Иначе, в порядке:"

#: texi/node-25.texi:1364
msgid ""
"          (a) All before-methods, from most specific to least specific.\n"
"          (b) The most specific primary method.\n"
"          (c) All after-methods, from least specific to most specific."
msgstr ""
"          (a) Все методы before-, от наиболее конкртетных до наименее "
"конкретных.\n"
"          (b) Наиболее конкретный первичный метод (то что мы привыкли "
"вызывать).\n"
"          (c) Все методы after-, от наименее конкретных до наиболее "
"конкретных."

#: texi/node-25.texi:1369
msgid ""
"This way of combining methods is called standard method combination. As in\n"
"our sketch, it is possible to define methods which are combined in other "
"ways:\n"
"for example, for a generic function to return the sum of all the applicable "
"primary\n"
"methods."
msgstr ""
"Этот способ объединения методов называется стандартным. Как и в нашем "
"наброске,\n"
"можно определять методы которые комбирируются другими способами:\n"
"например, для обобщенной функции возвращать сумму всех применимых первичных\n"
"методов."

#: texi/node-25.texi:1373
msgid ""
"In our program, we specified how to combine methods by calling defcomb.\n"
"By default, methods were combined as in the outline above, but by saying, "
"for\n"
"example,"
msgstr ""
"В нашей программе, мы указали, как объединять методы, вызывая defcomb.\n"
"По умолчанию, методы будут объединяться как в приведенной выше схеме,\n"
"но скажем, например,"

#: texi/node-25.texi:1377
msgid ""
"@lisp\n"
"(defcomb price #'+)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1381
msgid ""
"@noindent\n"
"we could cause the function price to return the sum of all the applicable "
"primary\n"
"methods."
msgstr ""
"@noindent\n"
"мы могли бы заставить функцию price возвращать сумму всех применимых "
"первичных\n"
"методов."

#: texi/node-25.texi:1388
msgid ""
"In CLOS this is called operator method combination. As in our program, such\n"
"method combination can be understood as if it resulted in the evaluation of "
"a Lisp\n"
"expression whose first element was some operator, and whose arguments were\n"
"calls to the applicable primary methods, in order of specificity. If we "
"defined the\n"
"price generic function to combine values with +, and there were no "
"applicable\n"
"around-methods, it would behave as though it were defined:"
msgstr ""
"В CLOS это называется комбинацией операторных методов. Как и в нашей "
"программе,\n"
"такая комбинация методов, может быть понята так, как если бы она приводила "
"к \n"
"вычислепнию выражения Lisp, первым элементом которого был бы некоторый "
"оператор,\n"
"аргументы которого были бы вызовами соответствующих первичных методов, в "
"порядке\n"
"конкретизации. Если мы определили обобщенную функцию price для объединения\n"
"значений с помощью +, и небыло бы применимых методов around-, она будет "
"вести себя\n"
"так, как если бы она была определена:"

#: texi/node-25.texi:1394
msgid ""
"@lisp\n"
"(defun price (&rest args)\n"
"  (+ (apply  most specific primary method  args)\n"
"         ...(apply  leastspecificprimarymethod  args)))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1400
msgid ""
"If there are applicable around-methods, they take precedence, just as in "
"standard\n"
"method combination. Under operator method combination, an around-methodcan\n"
"still call the next method via call-next-method. However, primary methods\n"
"can no longer use call-next-method. (This is a difference from our sketch,\n"
"where we left call-next available to such methods.)"
msgstr ""
"Если существуют применимые методы around-, они имеют приоритет, как в "
"стандартной\n"
"комбинации методов. В комбинации с операторным методом, метод around- может "
"вызывать\n"
"следующий метод через call-next-method. Однако первичные методы больше не "
"могут\n"
"испольовать call-next-method. (Это отличие от нашего наброска, где мы "
"оставляли\n"
"call-next доступным для таких методов.)"

#: texi/node-25.texi:1404
msgid ""
"In CLOS, we can specify the type of method combination to be used by a\n"
"generic function by giving the optional :method-combination argument to\n"
"defgeneric:"
msgstr ""
"В CLOS, мы можем указать тип комбинации методов, который будет "
"использоваться\n"
"обобщенной функцией, указав необязательный аргумент :аргумент method-"
"combination \n"
"для defgeneric:"

#: texi/node-25.texi:1409
msgid ""
"@lisp\n"
"(defgeneric price (x)\n"
"  (:method-combination +))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1412
msgid ""
"Now the price method will use + method combination. If we define some "
"classes\n"
"with prices,"
msgstr ""
"Теперь метод price будет использовать + для комбинации методов. Если мы "
"определим\n"
"некоторые классы с prices,"

#: texi/node-25.texi:1417
msgid ""
"@lisp\n"
"(defclass jacket nil nil)\n"
"(defclass trousers nil nil)\n"
"(defclass suit (jacket trousers) nil)"
msgstr ""

#: texi/node-25.texi:1421
msgid ""
"(defmethod price + ((jk jacket)) 350)\n"
"(defmethod price + ((tr trousers)) 200)\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1425
msgid ""
"@noindent\n"
"then when we ask for the price of an instance of suit, we get the sum of "
"the\n"
"applicable price methods:"
msgstr ""
"@noindent\n"
"затем, когда мы запрашиваем price для экземпляра suit, мы получаем сумму "
"применимых\n"
"методов price:"

#: texi/node-25.texi:1428
msgid ""
"> (price (make-instance 'suit))\n"
"550"
msgstr ""

#: texi/node-25.texi:1431
msgid ""
"The following symbols can be used as the second argument to defmethod or in\n"
"the :method-combination option to defgeneric:"
msgstr ""
"Следующие символы могут использоваться в качестве второго аргумента для "
"defmethod или\n"
"в опции :method-combination для defgeneric:"

#: texi/node-25.texi:1433
msgid ""
"    +      and     append      list       max     min    nconc    or    progn"
msgstr ""

#: texi/node-25.texi:1436
msgid ""
"By calling define-method-combination you can define other kinds of method\n"
"combination; see CLTL2, p. 830."
msgstr ""
"Вызывая define-method-combination вы можете определить другие виды\n"
"комбинации методов, см. CLTL2, p. 830."

#: texi/node-25.texi:1442
msgid ""
"Once you specify the method combination a generic function should use, all\n"
"methods for that function must use the same kind. Now it would cause an "
"error if\n"
"we tried to use another operator (or :before or :after) as the second "
"argument\n"
"in a defmethod for price. If we do want to change the method combination of\n"
"price we must remove the whole generic function by calling fmakunbound."
msgstr ""
"После указания метода комбинации, который должна использовать обобщенная "
"функция,\n"
"все методы для этой функции должны использовать один и тоже вид. Теперь это\n"
"вызовет ошибку, если мы попытаемся испольовать другой оператор (или :"
"before \n"
"или :after) в качестве второго аргумента в defmethod для price. Если мы "
"хотим\n"
"изменить комбинацию методов price мы должны удалить всю обобщенную функцию,\n"
"вызывав fmakunbound."

#: texi/node-25.texi:1445
msgid ""
"@section 25-6 CLOS and Lisp\n"
"@cindex 25-6 CLOS and Lisp"
msgstr ""
"@section 25-6 CLOS и Lisp\n"
"@cindex 25-6 CLOS and Lisp"

#: texi/node-25.texi:1448
msgid ""
"CLOS makes a good example of an embedded language. This kind of program\n"
"usually brings two rewards:"
msgstr ""
"CLOS является хорошим примером встроенного языка. Такая программа обычно "
"приносит\n"
"двойную выгоду:"

#: texi/node-25.texi:1452
msgid ""
"   1. Embedded languages can be conceptually well-integrated with their "
"envi-\n"
"         ronment, so that within the embedded language we can continue to "
"think of\n"
"         programs in much the same terms."
msgstr ""
"   1. Встраиваемые языки могут быть концептуально хорошо интегрированы с их "
"средой,\n"
"      так что в рамках встроенного языка мы можем продолжать думать о "
"программах во\n"
"      многом в тех же терминах."

#: texi/node-25.texi:1456
msgid ""
"   2. Embedded languages can be powerful, because they take advantage of "
"all\n"
"         the things that the base language already knows how to do."
msgstr ""
"   2. Встроенные языки могут быть мощными. потому что они используют все "
"то,\n"
"      что базовый язык уже знает как делать."

#: texi/node-25.texi:1461
msgid ""
"CLOS wins on both counts. It is very well-integrated with Lisp, and it "
"makes\n"
"good use of the abstractions that Lisp has already. Indeed, we can often see "
"Lisp\n"
"through CLOS, the way we can see the shapes of objects through a sheet "
"draped\n"
"over them."
msgstr ""
"CLOS побеждает по обоим пунктам. Он очень хорошо интегрирован с Lisp, и он "
"хорошо\n"
"использует абстракции, которые уже есть в лиспе.  Действительно, мы часто "
"можем\n"
"видеть Lisp через CLOS, также как, мы можем видеть форму объектов через "
"листы,\n"
"покрывающие их."

#: texi/node-25.texi:1466
msgid ""
"It is no accident that we usually speak to CLOS through a layer of macros.\n"
"Macros do transformation,and CLOS is essentially a program which takes "
"programs\n"
"built out of object-oriented abstractions, and translates them into programs "
"built\n"
"out of Lisp abstractions."
msgstr ""
"Не случайно мы говорим с CLOS через слой макросов. Макросы выполняют "
"преобразование.\n"
"а CLOS по сути, программа, которая берет программы построенные из объектно-"
"ориетированных\n"
"абстракций и переводит их в программы, построенные из абстракций Lisp."

#: texi/node-25.texi:1474
msgid ""
"As the first two sections suggested, the abstractions of object-oriented "
"pro-\n"
"gramming map so neatly onto those of Lisp that one could almost call the "
"former\n"
"a special case of the latter. The objects of object-oriented programming can "
"easily\n"
"be implemented as Lisp objects, and their methods as lexical closures. By "
"taking\n"
"advantage of such isomorphisms, we were able to provide a rudimentary form "
"of\n"
"object-oriented programming in just a few lines of code, and a sketch of "
"CLOS in\n"
"a few pages."
msgstr ""
"Как и предполагалось в первых двух разделах, абстракции объектно-"
"ориентированного\n"
"программироания настолько аккуратно отображаются на абстракции Lisp, что "
"практически\n"
"можно первые назвать частным случаем последнего. Объекты объектно-"
"ориентированного\n"
"программирования легко могут быть реализованы как объекты Lisp, а их методы "
"- как\n"
"лексические замыкания. Используя преимущество таких изоморфизмов, мы смогли\n"
"представить элементарную форму объектно ориентированного программирования "
"всего в\n"
"нескольких строках кода, и эскиз CLOS на нескольких страницах."

#: texi/node-25.texi:1479
msgid ""
"CLOS is a great deal larger and more powerful than our sketch, but not so "
"large\n"
"as to disguise its roots as an embedded language. Take defmethod as an "
"example.\n"
"Though CLTL2 does not mention it explicitly, CLOS methods have all the power "
"of\n"
"lexical closures. If we define several methods within the scope of some "
"variable,"
msgstr ""
"CLOS намного крупнее и мощнее нашего эскиза, но не настолько велик, чтобы "
"скрывать\n"
"свои корни как встроенного языка. Возьмите defmethod в качестве примера.\n"
"Хотя CLTL2 не упоминает это явно, методы CLOS обладают всей силой "
"лексических\n"
"замыканий. Если мы определим несколько методов в рамках некоторой переменной,"

#: texi/node-25.texi:1491
msgid ""
"@lisp\n"
"(let ((transactions 0))\n"
"  (defmethod withdraw ((a account) amt)\n"
"        (incf transactions)\n"
"        (decf (balance a) amt))\n"
"  (defmethod deposit ((a account) amt)\n"
"        (incf transactions)\n"
"        (incf (balance a) amt))\n"
"  (defun transactions ()\n"
"        transactions))\n"
"@end lisp"
msgstr ""

#: texi/node-25.texi:1496
msgid ""
"then at runtime they will share access to the variable, just like closures. "
"Methods\n"
"can do this because, underneath the syntax, they are closures. In the "
"expansion\n"
"of a defmethod, its body appears intact in the body of a sharp-quoted "
"lambda-\n"
"expression."
msgstr ""
"тогда во время выполнения они будут иметь доступ к переменной, как "
"замыкания. Методы\n"
"могут сделать это, потому что под синтаксисом они являются замыканиями. В "
"расширении\n"
"defmethod, его тело окажеться целиком в теле заквотированного с решёткой "
"('#) лямбда\n"
"выражения."

#: texi/node-25.texi:1500
msgid ""
"Section 7-6 suggested that it was easier to conceive of how macros work "
"than\n"
"what they mean. Likewise, the secret to understanding CLOS is to understand "
"how\n"
"it maps onto the fundamental abstractions of Lisp."
msgstr ""
"В разделеn 7-6 предполагается, что проще понять, как работают макросы, чем "
"то,\n"
"что они имеют в виду. Аналогично, секрет понимания CLOS заключается в том, "
"чтобы\n"
"понять как он отображается на фундаментальные абстракции Lisp."

#: texi/node-25.texi:1505
msgid ""
"@node 25-7 When to Object,  , 25-5 Auxiliary Methods and Combination, 25 "
"Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-7 When to Object\n"
"@cindex 25-7 When to Object"
msgstr ""
"@node 25-7 When to Object,  , 25-5 Auxiliary Methods and Combination, 25 "
"Object-Oriented Lisp\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 25-7 Когда использовать Объекты\n"
"@cindex 25-7 When to Object"

#: texi/node-25.texi:1511
msgid ""
"The object-oriented style provides several distinct benefits. Different "
"programs\n"
"need these benefits to varying degrees. At one end of the continuum there "
"are\n"
"programs-simulations, for example-which are most naturally expressed in the\n"
"abstractions of object-oriented programming. At the other end are programs\n"
"written in the object-oriented style mainly to make them extensible."
msgstr ""
"Объектно-ориентированный стиль обеспечивает несколько явных преимуществ. "
"Разные\n"
"программы нуждаются в этих преимуществах в разной степени. На одном конце\n"
"континуума находяться программы, например симуляторы, которые наиболее "
"естественным\n"
"образом выражаются в абстракциях объектно-ориентированного программирования. "
"На другом\n"
"конце программы написанные в объектно-ориентированном стиле, главным "
"образом, чтобы\n"
"сделать их расширяемыми."

#: texi/node-25.texi:1527
msgid ""
"Extensibility is indeed one of the great benefits of the object-oriented "
"style.\n"
"Instead of being a single monolithic blob of code, a program is written in "
"small\n"
"pieces, each labelled with its purpose. So later when someone else wants to\n"
"modify the program, it will be easy to find the part that needs to be "
"changed. If\n"
"we want to change the way that objects of type ob are displayed on the "
"screen, we\n"
"change the display method of the ob class. If we want to make a new class "
"of\n"
"objects like obs but different in a few respects, we can create a subclass "
"of ob;in\n"
"the subclass, we change the properties we want, and all the rest will be "
"inherited\n"
"by default from the ob class. And if we just want to make a single ob which\n"
"behaves differently from the rest, we can create a new child of ob and "
"modify the\n"
"child's properties directly. If the program was written carefully to begin "
"with, we\n"
"can make all these types of modifications without even looking at the rest "
"of the\n"
"code. From this point of view, an object-oriented program is a program "
"organized\n"
"like a table: we can change it quickly and safely by looking up the "
"appropriate\n"
"entry."
msgstr ""
"Расширяемость действительно является одним из больших преимуществ объектно-\n"
"ориентированного стиля. Вместо того, чтобы быть единым монолитным блоком "
"кода,\n"
"программа написана небольшими кусочками, каждый из которых помечен своей "
"целью.\n"
"Поэтому позже, когда кто-то захочет изменить программу, будет легко найти ту "
"часть,\n"
"которую необходимо изменить. Если мы хотим изменить способ отображения "
"объектов\n"
"типа ob на экране, мы изменим метод отображения(display) класса ob. Если мы "
"хотим\n"
"создать новый класс объектов подобных ob, но отличающихся от него в "
"нескольких\n"
"отношениях, мы можем создать подкласс ob; в подклассе мы поменяем нужные нам "
"свойства,\n"
"а все остальное по умолчанию наследуется от класса ob. И если мы просто "
"хотим создать\n"
"один объект ob, который ведет себя не так как остальные, мы можем создать "
"новый дочерний \n"
"объект ob и напрямую изменить его свойства. Если программа была тщательно "
"написана\n"
"с самого начала, мы можем внести все эти типы изменний, дже не глядя на "
"остальную\n"
"часть кода. С этой точки зрения объектно-ориентированная программа - это "
"программа\n"
"организованная как таблица: мы можем быстро и безопасно изменить ее, "
"посмотрев \n"
"соответствующую ячейку."

#: texi/node-25.texi:1535
msgid ""
"Extensibility demands the least from the object-oriented style. In fact, it\n"
"demands so little that an extensible program might not need to be object-"
"oriented\n"
"at all. If the preceding chapters have shown anything, they have shown that "
"Lisp\n"
"programs do not have to be monolithic blobs of code. Lisp offers a whole "
"range\n"
"of options for extensibility. For example, you could quite literally have a "
"program\n"
"organized like a table: a program which consisted of a set of closures "
"stored in an\n"
"array."
msgstr ""
"Расширяемость требуется меньше всего от объектно-ориентированного стиля. "
"Фактически,\n"
"она требует так мало, что расширяемая программа вообще не должна быть "
"объектно-\n"
"ориентированной. Если в предыдущих главах и было чтот-то показано, то оно "
"показало\n"
"что программы на Lisp не обязательно являются монолитными блоками. Lisp "
"предлагает\n"
"целый ряд возможностей для расширения. Например, вы могли бы буквально иметь "
"программу\n"
"организованную как таблица: программу, состоящую из набора замыканий, "
"хранящихся в\n"
"массиве."

#: texi/node-25.texi:1545
msgid ""
"If it's extensibility you need, you don't have to choose between an "
"\"object-\n"
"oriented\" and a \"traditional\" program. You can give a Lisp program "
"exactly\n"
"the degree of extensibility it needs, often without resorting to object-"
"oriented\n"
"techniques. A slot in a class is a global variable. And just as it is "
"inelegant to\n"
"use a global variable where you could use a parameter, it could be inelegant "
"to\n"
"build a world of classes and instances when you could do the same thing with "
"less\n"
"effort in plain Lisp. With the addition of CLOS, Common Lisp has become the\n"
"most powerful object-oriented language in widespread use. Ironically, it is "
"also\n"
"the language in which object-oriented programming is least necessary."
msgstr ""
"Если вам нужна расширяемость, вам не нужно выбирать между \"объектно-\n"
"ориентированной\" и \"традиционной\" программой. Вы можете дать программе на "
"Lisp\n"
"именно ту степень расширямости, в которой она нуждается, часто не прибегая "
"к\n"
"объектно ориентированным техникам. Слот в классе это глобальная переменная. "
"И также,\n"
"как некрасиво использовать глобальную переменную, там где вы могли "
"использовать\n"
"параметр, также неэлегантно создавать мир классов и экземпляров, когда вы "
"могли бы\n"
"сделать тоже самое с меньшими усилиями в простом Lisp. С добавлением CLOS, "
"Common \n"
"Lisp стал самым мощным используемым широкорасространненым объектно "
"ориентированным \n"
"языком. По иронии судьбы, это также язык, в котором объектно-"
"ориентированное \n"
"программирование наименее необходимо."

#: texi/node-25.texi:1550
msgid ""
"@node Appendix Packages, Notes, 25 Object-Oriented Lisp, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter Appendix Packages\n"
"@cindex Appendix Packages"
msgstr ""
"@node Appendix Packages, Notes, 25 Object-Oriented Lisp, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter Приложение: Пакеты\n"
"@cindex Appendix Packages"

#: texi/node-25.texi:1556
msgid ""
"Packages are Common Lisp's way of grouping code into modules. Early "
"dialects\n"
"of Lisp contained a symbol-table, called the oblist, which listed all the "
"symbols\n"
"read so far by the system. Through a symbol's entry on the oblist, the "
"system had\n"
"access to things like its value and its property list. A symbol listed in "
"the oblist\n"
"was said to be interned."
msgstr ""
"Пакеты - это способ Common Lisp группировать код в модули. Ранние диалекты "
"Lisp \n"
"содержали таблицу символов, называемую oblist, в которой перечислялись все "
"символы,\n"
"которые до сих пор прочитала система. Через ввод символа в oblist, система "
"получала\n"
"доступ к таким вещам как его значение и список свойств. Указанный в oblist "
"символ,\n"
"как говорят, был интернирован(interned)."

#: texi/node-25.texi:1562
msgid ""
"Recent dialects of Lisp have split the concept of the oblist into multiple\n"
"packages. Now a symbol is not merely interned, but interned in a particular\n"
"package. Packages support modularity because symbols interned in one "
"package\n"
"are only accessible in other packages (except by cheating) if they are "
"explicitly\n"
"declared to be so."
msgstr ""
"Недавние диалекты Lisp разделили концепцию oblist на несколько пакетов. "
"Теперь\n"
"символ не просто интернирован, но иинтернирован в определенном пакете. "
"Пакеты\n"
"поддерживают модульность, потому что символы, содержащиеся в одном пакете, "
"доступны\n"
"в других пакетах(за исключением читерства(cheating)) только если они явно "
"объявлены\n"
"таковыми."

#: texi/node-25.texi:1567
msgid ""
"A package is a kind of Lisp object. The current package is always stored\n"
"in the global variable *package*. When Common Lisp starts up, the current\n"
"package will be the user package: either user (in CLTL1 implementations), "
"or\n"
"common-lisp-user (in CLTL2 implementations)."
msgstr ""
"Пакет - это своего рода объект Lisp. Текущий пакет всегда храниться в "
"глобальной\n"
"переменной *package*. Когда запускается Common Lisp, текущим пакетом будет \n"
"пользовательский пакет: либо user (в реализации CLTL1), либо common-lisp-"
"user \n"
"(в реализации CLTL2)."

#: texi/node-25.texi:1570
msgid ""
"Packages are usually identified by their names, which are strings. To find "
"the\n"
"name of the current package, try:"
msgstr ""
"Пакеты обычно идентифицируются по их именам, которые являются строками. "
"Чтобы найти\n"
"имя текущего пакета, попробуйте:"

#: texi/node-25.texi:1578
msgid ""
"> (package-name *package*)\n"
"\"COMMON-LISP-USER\"\n"
"   Usually a symbol is interned in the package that was current at the time\n"
"it was read. To find the package in which a symbol is interned, we can use\n"
"symbol-package:\n"
"> (symbol-package 'foo)\n"
"#<Package \"COMMON-LISP-USER\" 4CD15E>"
msgstr ""
"> (package-name *package*)\n"
"\"COMMON-LISP-USER\"\n"
"   Обычно прочитанный символ помещается  в пакет, который был текущим на "
"момент \n"
"его прочтения. Чтобы определить пакет, в который помещается символ, мы "
"можем \n"
"использовать symbol-package:\n"
"> (symbol-package 'foo)\n"
"#<Package \"COMMON-LISP-USER\" 4CD15E>"

#: texi/node-25.texi:1581
msgid ""
"The return value here is the actual package object. For future use, let's "
"give foo\n"
"a value:"
msgstr ""
"Возвращаемое здесь значение - фактический объект пакета. Для использования в "
"будущем,\n"
"давайте дадим foo значение:"

#: texi/node-25.texi:1584
msgid ""
"> (setq foo 99)\n"
"99"
msgstr ""

#: texi/node-25.texi:1587
msgid ""
"By calling in-package we can switch to a new package, creating it if\n"
"necessary:@footnote{In older implementations of Common Lisp, omit the :use "
"argument.}"
msgstr ""
"Вызвав in-package мы можем переключиться на новый покет, создав его, если "
"это\n"
"необходимо(создать можно с помощью команды (defpackage :mine  (:use :common-"
"lisp)):\n"
"@footnote{В старых реализациях Common Lisp, опустите аргумент :use.}"

#: texi/node-25.texi:1590
msgid ""
"> (in-package 'mine :use 'common-lisp)\n"
"#<Package \"MINE\" 63390E>"
msgstr ""

#: texi/node-25.texi:1593
msgid ""
"At this point there should be eerie music, because we are in a different "
"world: foo\n"
"here is not what it used to be."
msgstr ""
"В этой точке должна быть жуткая музыка, потому что мы находимся в другом "
"мире: foo\n"
"здесь не то что раньше."

#: texi/node-25.texi:1596
msgid ""
"MINE> foo\n"
">>Error: FOO has no global value."
msgstr ""

#: texi/node-25.texi:1600
msgid ""
"Why did this happen? Because the foo we set to 99 above is a distinct "
"symbol\n"
"from foo here in mine.@footnote{Some implementations of Common Lisp print "
"the package name before the toplevel prompt whenever we are not in the user "
"package. This is not required, but it is a nice touch.} To refer to the "
"original foo from outside the user package,\n"
"we must prefix the package name and two colons:"
msgstr ""
"Почему это случилось? Поскольку foo, который мы выше установили в 99, "
"является\n"
"отличающимся символом от foo в  mine.@footnote{Некоторые реализации Common "
"Lisp \n"
"печатаю имя пакета перед запросом верхнего уровня всякий раз, когда мы не "
"находимся\n"
"в пользовательском пакете. Это не обязательно, но приятно.} Чтобы обратиться "
"к\n"
"оригинальному foo извне пользовательского пакета, мы должны поставить "
"префикс\n"
"имени пакета и двух двоеточий:"

#: texi/node-25.texi:1603
msgid ""
"MINE> common-lisp-user::foo\n"
"99"
msgstr ""

#: texi/node-25.texi:1611
msgid ""
"So different symbols with the same print-name can coexist in different "
"pack-\n"
"ages. There can be one foo in package common-lisp-user and another foo in\n"
"package mine, and they will be distinct symbols. In fact, that's partly the "
"point of\n"
"packages: if you're writing your program in a separate package, you can "
"choose\n"
"names for your functions and variables without worrying that someone will "
"use\n"
"the same name for something else. Even if they use the same name, it won't "
"be\n"
"the same symbol."
msgstr ""
"Таким образом, разные символы с одинаково печатающимися именами могут "
"сосуществовать\n"
"в разных пакетах. Может быть один foo в пакете common-lisp-user и другой foo "
"в\n"
"пакете mine, и они будут разными символами. На самом деле, в этом и "
"заключается суть\n"
"пакетов: если вы пишете свою программу в отдельном пакете, вы можете "
"выбирать имена\n"
"для своих функций и переменных, не беспокоясь о том, что кто-то будет "
"использовать\n"
"то же имя для чего-то другого. Даже если они используют одно и тоже имя, это "
"не будет\n"
"одним и тем же символом."

#: texi/node-25.texi:1616
msgid ""
"Packages also provide a means of information-hiding. Programs must refer to\n"
"functions and variables by their names. If you don't make a given name "
"available\n"
"outside your package, it becomes unlikely that code in another package will "
"be\n"
"able to use or modify what it refers to."
msgstr ""
"Пакеты также предоставляют средства сокрытия информации. Программы должны "
"ссылаться\n"
"на функции и переменные по их именам. Если вы не делаете данное имя "
"доступным за\n"
"пределами вашего пакета, маловероятно, что код в другом пакете сможет "
"использовать\n"
"или изменить то, на что оно ссылается."

#: texi/node-25.texi:1621
msgid ""
"In programs it's usually bad style to use package prefixes with double "
"colons.\n"
"By doing so you are violating the modularity that packages are supposed to\n"
"provide. If you have to use a double colon to refer to a symbol, it's "
"because\n"
"someone didn't want you to."
msgstr ""
"В программах обычно плохо использовать префиксы пакетов с двойными "
"двоеточиями.\n"
"Тем самым вы нарушаете модульность, которую должны предоставлять пакеты. "
"Если вам\n"
"нужно использовать двойное двоеточие для обозначения символа, это происходит "
"потому,\n"
"что кто-то не хочет чтобы вы это делали."

#: texi/node-25.texi:1625
msgid ""
"Usually one should only refer to symbols which have been exported. By\n"
"exporting a symbol from the package in which it is interned, we cause it to "
"be\n"
"visible to other packages. To export a symbol we call (you guessed it) "
"export:"
msgstr ""
"Обычно следует ссылаться только на символы, которые были экспортированы. "
"Экспортируя\n"
"символ из пакета, в котором он находиться, мы делаем его видимым для других "
"пакетов.\n"
"Чтобы экспортировать символ, мы  вызываем (как вы уже догадались) export:"

#: texi/node-25.texi:1633
msgid ""
"@example\n"
"MINE> (in-package 'common-lisp-user)\n"
"#<Package \"COMMON-LISP-USER\" 4CD15E>\n"
"> (export 'bar)\n"
"T> (setq bar 5)\n"
"5\n"
"@end example"
msgstr ""

#: texi/node-25.texi:1636
msgid ""
"Now when we return to mine, we can refer to bar with only a single colon,\n"
"because it is a publicly available name:"
msgstr ""
"Теперь, когда мы вернемся к пакету mine, мы можем сослаться на bar только с\n"
"одним двоеточием, потому что это общедоступное имя:"

#: texi/node-25.texi:1643
msgid ""
"@example\n"
"> (in-package 'mine)\n"
"#<Package \"MINE\" 63390E>\n"
"MINE> common-lisp-user:bar\n"
"5\n"
"@end example"
msgstr ""

#: texi/node-25.texi:1646
msgid ""
"By importing bar into mine we can go one step further, and make mine "
"actually\n"
"share the symbol bar with the user package:"
msgstr ""
"Импортируя(importing) bar в mine мы можем сделать еще один шаг, и сделать "
"так,\n"
"чтобы mine фактически поделилась символом bar с пакетом пользователя:"

#: texi/node-25.texi:1650
msgid ""
"MINE> (import 'common-lisp-user:bar)\n"
"TMINE> bar\n"
"5"
msgstr ""

#: texi/node-25.texi:1653
msgid ""
"After importing bar we can refer to it without any package qualifier at all. "
"The\n"
"two packages now share the same symbol; there can't be a distinct mine:bar."
msgstr ""
"После импорта bar мы можем ссылаться на него без какого либо спецификатора "
"пакета.\n"
"Два пакета теперь имеют один и тот же символ; здесь уже нет отдельного mine:"
"bar."

#: texi/node-25.texi:1656
msgid ""
"What if there already was one? In that case, the call to import would have\n"
"caused an error, as we see if we try to import foo:"
msgstr ""
"Что если такой символ уже был? В этом случае, вызов import вызвал бы "
"ошибку,\n"
"какую мы видим попытавшись имппортировать foo:"

#: texi/node-25.texi:1659
msgid ""
"MINE> (import 'common-lisp-user::foo)\n"
">>Error: FOO is already present in MINE."
msgstr ""

#: texi/node-25.texi:1665
msgid ""
"Before, when we tried unsuccessfully to evaluate foo in mine, we thereby "
"caused\n"
"a symbol foo to be interned there. It had no global value and therefore "
"generated\n"
"an error, but the interning happened simply as a consequence of typing its "
"name.\n"
"So now when we try to import foo into mine, there is already a symbol there "
"with\n"
"the same name."
msgstr ""
"Раньше, когда мы безуспешно пытались вычислить foo в mine, мы тем самым "
"вызывали\n"
"интернирование туда символа foo. Он не имел глобального значения, и "
"следовательно,\n"
"генерировал ошибку, но интернирование происходило просто как следствие ввода "
"его\n"
"имени. Так что теперь, когда мы пытаемся импортировать foo в mine, там уже "
"есть\n"
"символ с тем же именем."

#: texi/node-25.texi:1667
msgid ""
"We can also import symbols en masse by defining one package to use another:"
msgstr ""
"Мы также можем импортировать символы массово, определив один пакет для "
"использования другим:"

#: texi/node-25.texi:1670
msgid ""
"MINE> (use-package 'common-lisp-user)\n"
"T"
msgstr ""

#: texi/node-25.texi:1676
msgid ""
"Now all symbols exported by the user package will automatically be imported "
"by\n"
"mine. (If foo had been exported by the user package, this call would also "
"have\n"
"generated an error.)"
msgstr ""
"Теперь все символы экспортируемые пользовательским пакетом будут "
"автоматически\n"
"импортированы mine. (Если бы foo был экспортирован пользовательским пакетом, "
"этот\n"
"вызов также бы вызвал ошибку.)"

#: texi/node-25.texi:1681
msgid ""
"As of CLTL2, the package containing the names of built-in operators and\n"
"variables is called common-lisp instead of lisp, and new packages no longer\n"
"use it by default. Since we used this package in the call to in-package "
"which\n"
"created mine, all of Common Lisp's names will be visible here:"
msgstr ""
"Начиная с CLTL2, пакет, содержащий имена встроенных операторов и "
"переменных, \n"
"называется common-lisp вметос lisp, и новые пакеты больше не используют его\n"
"по умолчанию. Так как мы использовали этот пакет в вызове in-package, "
"который\n"
"создал mine, все имена Common Lisp будут видны здесь:"

#: texi/node-25.texi:1684
msgid ""
"MINE> #'cons\n"
"#<Compiled-Function CONS 462A3E>"
msgstr ""

#: texi/node-25.texi:1688
msgid ""
"You're practically compelled to make any new package use common-lisp (or\n"
"some other package containing Lisp operators). Otherwise you wouldn't even "
"be\n"
"able to get out of the new package."
msgstr ""
"Вы практически вынуждены заставлять любой новый пакет использовать common-"
"lisp \n"
"(или какой либо другой пакет содержащий операторы Lisp). Иначе вы бы даже "
"не\n"
"смогли выбраться из нового пакета."

#: texi/node-25.texi:1695
msgid ""
"As with compilation, operations on packages are not usually done at the\n"
"toplevel like this. More often the calls are contained in source files. "
"Generally\n"
"it will suffice to begin a file with an in-package and a defpackage. (The\n"
"defpackage macro is new in CLTL2, but some older implementations provide "
"it.)\n"
"Here is what you might put at the top of a file containing a distinct "
"package of\n"
"code:"
msgstr ""
"Как и в случае компиляции, операции над пакетами обычно не выполняются на "
"таком\n"
"верхнем уровне как этот. Чаще всего вызовы содержаться в исходныхs файлах. "
"Обычно\n"
"достаточно начать файл с in-package и defpackage. (Макрос defpackage "
"является\n"
"новым в CLTL2, но некоторые более старые реализации предоставляют его.)\n"
"Вот что вы пожете поместить в начало файла, содержащего отдельный пакет кода:"

#: texi/node-25.texi:1697
msgid "(in-package 'my-application :use 'common-lisp)"
msgstr ""

#: texi/node-25.texi:1702
msgid ""
"(defpackage my-application\n"
"                  (:use common-lisp my-utilities)\n"
"                  (:nicknames app)\n"
"                  (:export win lose draw))"
msgstr ""

#: texi/node-25.texi:1707
msgid ""
"This will cause the code in the file-or more precisely, the names in the "
"file-to\n"
"be in the package my-application. As well as common-lisp, this package uses\n"
"my-utilities, so any symbols exported thence can appear without any package\n"
"prefix in the file."
msgstr ""
"Это приведет к тому, что код в файле- или точнее, имена в файле- будут в "
"пакете\n"
"my-application. Этот пакет использует как common-lisp, так и  my-utilities, "
"поэтому\n"
"любые экспортируемые символы могут появиться без префикса пакета в этом "
"файле."

#: texi/node-25.texi:1711
msgid ""
"The my-application package itself exports just three symbols: win, lose,\n"
"and draw. Since the call to in-package gave my-application the nickname\n"
"app, code in other packages will be able to refer to them as e.g. app:win."
msgstr ""
"Сам пакет my-application экспортирует только три символа: win, lose,\n"
"и draw. Поскольку вызов in-package дал my-application прозвище\n"
"app, код в других пакетах будет ссылаться на них как, например app:win."

#: texi/node-25.texi:1719
msgid ""
"The kind of modularity provided by packages is actually a bit odd. We have\n"
"modules not of objects, but of names. Every package that uses common-lisp\n"
"imports the name cons, because common-lisp includes a function with that\n"
"name. But in consequence a variable called cons would also be visible every\n"
"package that used common-lisp. And the same thing goes for Common Lisp's\n"
"other name-spaces. If packages are confusing, this is the main reason why; "
"they're\n"
"not based on objects, but on names."
msgstr ""
"Тип модульности, предоставляемый пакетами, на самом деле немного странный. У "
"нас\n"
"есть модули не объектов, а имен. Каждый пакет, который использует common-"
"lisp\n"
"импортирует имя cons, потому что common-lisp включает функцию с этим именем. "
"Но\n"
"в результате переменная с именем cons также будет видна в каждом пакете "
"который\n"
"использует common-lisp. И то же самое относиться к другим пространствам "
"имен\n"
"Common Lisp. Если пакеты сбивают с толку, это основная причина; они основаны "
"не\n"
"на объектах, а на именах."

#: texi/node-25.texi:1723
msgid ""
"Things having to do with packages tend to happen at read-time, not runtime,\n"
"which can lead to some confusion. The second expression we typed:"
msgstr ""
"Вещи имеющие отношение к пакетам, обычно проихсодят во время чтения, а не\n"
"во время выполнения, что может привести к некоторой путанице. Вторым\n"
"выражением мы наберем:"

#: texi/node-25.texi:1725
msgid "(symbol-package 'foo)"
msgstr ""

#: texi/node-25.texi:1728
msgid ""
"returned the value it did because reading the query created the answer. To "
"evaluate\n"
"this expression, Lisp had to read it, which meant interning foo."
msgstr ""
"вернет значение, которое он прочитал, поскольку чтение запроса создало "
"ответ. Чтобы \n"
"выполнить это выражение, Lisp должен прочитать его, что означает "
"интернирование foo."

#: texi/node-25.texi:1730
msgid "As another example, consider this exchange, which appeared above:"
msgstr ""
"В качестве другого примера рассмотрим этот обмен, который появился выше:"

#: texi/node-25.texi:1734
msgid ""
"MINE> (in-package 'common-lisp-user)\n"
"#<Package \"COMMON-LISP-USER\" 4CD15E>\n"
"> (export 'bar)"
msgstr ""

#: texi/node-25.texi:1737
msgid ""
"Usually two expressions typed into the toplevel are equivalent to the same "
"two\n"
"expressions enclosed within a single progn. Not in this case. If we try "
"saying"
msgstr ""
"Обычно два выражения введенные в верхнем уровне эквивалентны тем же двум "
"выражениям,\n"
"заключенным в progn. Дело, не в этом. Если мы попробуем сказать"

#: texi/node-25.texi:1741
msgid ""
"MINE> (progn (in-package 'common-lisp-user)\n"
"                 (export 'bar))\n"
">>Error: MINE::BAR is not accessible in COMMON-LISP-USER."
msgstr ""

#: texi/node-25.texi:1746
msgid ""
"we get an error instead. This happens because the whole progn expression is\n"
"processed by read before being evaluated. When read is called, the current\n"
"package is mine,sobar is taken to be mine:bar. It is as if we had asked to\n"
"export this symbol, instead of common-lisp-user:bar, from the user package."
msgstr ""
"вместо этого мы получаем ошибку. Это происходит потому, что перед "
"вычислением\n"
"все выражения progn обрабатываются читателем выражений(read). Когда "
"вызывается read, \n"
"текущий пакет mine, поэтому принятый bar считается mine:bar. Это как если "
"бы\n"
"мы попросили экспортировать данный символ вместо common-lisp-user:bar, из\n"
"пакета пользователя."

#: texi/node-25.texi:1749
msgid ""
"The way packages are defined makes it a nuisance to write programs which\n"
"use symbols as data. For example, if we define noise as follows:"
msgstr ""
"То как определяются пакеты создает неудобства при написании программ, "
"которые\n"
"используют символы в качестве данных. Например, если мы определим noise "
"следующим\n"
"образомs:"

#: texi/node-25.texi:1754
msgid ""
"(in-package 'other :use 'common-lisp)\n"
"(defpackage other\n"
"                (:use common-lisp)\n"
"                (:export noise))"
msgstr ""

#: texi/node-25.texi:1760
msgid ""
"(defun noise (animal)\n"
"  (case animal\n"
"       (dog 'woof)\n"
"       (cat 'meow)\n"
"       (pig 'oink)))"
msgstr ""

#: texi/node-25.texi:1763
msgid ""
"then if we call noise from another package with an unqualified symbol as an\n"
"argument, it will usually fall off the end of the case clauses and return "
"nil:"
msgstr ""
"тогда если мы будем вызывать noise из другого пакета с неквалифицированным "
"символом\n"
"(без указания пакета символа) в качестве аргумента, он обычно будет попадать "
"в \n"
"конец предложений case и возвращать nil:"

#: texi/node-25.texi:1768
msgid ""
"OTHER> (in-package 'common-lisp-user)\n"
"#<Package \"COMMON-LISP-USER\" 4CD15E>\n"
"> (other:noise 'pig)\n"
"NIL"
msgstr ""

#: texi/node-25.texi:1776
msgid ""
"That's because what we passed as an argument was common-lisp-user:pig(no\n"
"offense intended), while the case key is other:pig. To make noise work as\n"
"one would expect, we would have to export all six symbols used within it, "
"and\n"
"import them into any package from which we intended to call noise."
msgstr ""
"Это происходит потому, что то что мы передали в качестве аргумента, было\n"
"common-lisp-user:pig(без обид), в то время как ключом для выражения case "
"является\n"
"other:pig. Чтобы noise работал так как следовало ожидать, мы должны "
"экспортировать\n"
"все шесть символов используемых в нем, и импортировать их в любой пакет, из "
"которого\n"
"мы собираемся вызывать noise."

#: texi/node-25.texi:1779
msgid ""
"In this case, we could evade the problem by using keywords instead of "
"ordinary\n"
"symbols. If noise had been defined"
msgstr ""
"В этом случае, мы можем избежать проблем, используя ключевые слова вместо "
"обычных\n"
"симолов. Если noise был определен"

#: texi/node-25.texi:1785
msgid ""
"(defun noise (animal)\n"
"  (case animal\n"
"        (:dog :woof)\n"
"        (:cat :meow)\n"
"        (:pig :oink)))"
msgstr ""

#: texi/node-25.texi:1787
msgid "then we could safely call it from any package:"
msgstr "тогда мы можем смело вызывать его из любого пакета:"

#: texi/node-25.texi:1794
msgid ""
"@example\n"
"OTHER> (in-package 'common-lisp-user)\n"
"#<Package \"COMMON-LISP-USER\" 4CD15E>\n"
"> (other:noise :pig)\n"
":OINK\n"
"@end example"
msgstr ""

#: texi/node-25.texi:1798
msgid ""
"Keywords are like gold: universal and self-evaluating. They are visible "
"every-\n"
"where, and they never have to be quoted. A symbol-driven function like "
"defanaph\n"
"(page 223) should nearly always be written to use keywords."
msgstr ""
"Ключевые слова как золото, универсальные и само вычисляемые. Они видны "
"повсюду, и \n"
"их никогда не нужно цитировать(квотировать). Функция управляемая символами "
"такая как\n"
"defanaph (стр. 223) почти всегда должна быть написана с использованием "
"ключевых слов."

#: texi/node-25.texi:1801
msgid ""
"Packages are a rich source of confusion. This introduction to the subject "
"has\n"
"barely scratched the surface. For all the details, see CLTL2, Chapter 11."
msgstr ""
"Пакеты являются богатым источником путаницы. Это введение в предмет едва "
"приподняло\n"
"завесу тайны. Все поднобности, см. CLTL2, Chapter 11."

#: texi/node-25.texi:1807
msgid ""
"@node Notes, Book's Index, Appendix Packages, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter Notes\n"
"@cindex Notes"
msgstr ""
"@node Notes, Book's Index, Appendix Packages, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter Замечания\n"
"@cindex Notes"

#: texi/node-25.texi:1810
msgid ""
"This section is also intended as a bibliography. All the books and papers "
"listed here should\n"
"be considered recommended reading."
msgstr ""

#: texi/node-25.texi:1826
msgid ""
"    v Foderaro, John K. Introduction to the Special Lisp Section. CACM 34, 9 "
"(September\n"
"       1991), p. 27.\n"
"  viii The final Prolog implementation is 94 lines of code. It uses 90 lines "
"of utilities from\n"
"       previous chapters. The ATN compiler adds 33 lines, for a total of "
"217. Since Lisp\n"
"       has no formal notion of a line, there is a large margin for error "
"when measuring the\n"
"       length of a Lisp program in lines.\n"
"   ix Steele, Guy L., Jr. Common Lisp: the Language, 2nd Edition. Digital "
"Press, Bedford\n"
"       (MA), 1990.\n"
"    5 Brooks, Frederick P. The Mythical Man-Month. Addison-Wesley, Reading "
"(MA),\n"
"       1975, p. 16.\n"
"   18 Abelson, Harold, and Gerald Jay Sussman, with Julie Sussman. Structure "
"and\n"
"       Interpretation of Computer Programs. MIT Press, Cambridge, 1985.\n"
"   21 More precisely, we cannot define a recursive function with a single "
"lambda-expression.\n"
"       We can, however, generate a recursive function by writing a function "
"to take itself\n"
"       as an additional argument,"
msgstr ""

#: texi/node-25.texi:1833
msgid ""
"       (setq fact\n"
"               #'(lambda (f n)\n"
"                        (if (= n 0)\n"
"                               1(* n (funcall f f (- n 1))))))\n"
"       and then passing it to a function that will return a closure in which "
"original function\n"
"       is called on itself:"
msgstr ""

#: texi/node-25.texi:1840
msgid ""
"       (defun recurser (fn)\n"
"         #'(lambda (&rest args)\n"
"                (apply fn fn args)))"
msgstr ""

#: texi/node-25.texi:1842
msgid ""
"       Passing fact to this function yields a regular factorial function,"
msgstr ""

#: texi/node-25.texi:1845
msgid ""
"       > (funcall (recurser fact) 8)\n"
"       40320"
msgstr ""

#: texi/node-25.texi:1847
msgid "       which could have been expressed directly as:"
msgstr ""

#: texi/node-25.texi:1874
msgid ""
"       ((lambda (f) #'(lambda (n) (funcall f f n)))\n"
"        #'(lambda (f n)\n"
"                (if (= n 0)\n"
"                       1(* n (funcall f f (- n 1))))))\n"
"       Many Common Lisp users will find labels or alambda more convenient.\n"
"  23 Gabriel, Richard P. Performance and Standardization. Proceedings of the "
"First\n"
"       International Workshop on Lisp Evolution and Standardization, 1988, "
"p. 60.\n"
"       Testing triangle in one implementation, Gabriel found that \"even "
"when the C\n"
"       compiler is provided with hand-generated register allocation "
"information, the Lisp\n"
"       code is 17% faster than an iterative C version of this function.\" "
"His paper mentions\n"
"       several other programs which ran faster in Lisp than in C, including "
"one that was\n"
"       42% faster.\n"
"  24 If you wanted to compile all the named functions currently loaded, you "
"could do it\n"
"       by calling compall:\n"
"       (defun compall ()\n"
"         (do-symbols (s)\n"
"            (when (fboundp s)\n"
"                (unless (compiled-function-p (symbol-function s))\n"
"                  (print s)\n"
"                  (compile s)))))\n"
"       This function also prints the name of each function as it is "
"compiled.\n"
"  26 You may be able to see whether inline declarations are being obeyed by "
"calling\n"
"       (disassemble 'foo), which displays some representation of the object "
"code of\n"
"       function foo. This is also one way to check whether tail-recursion "
"optimization is\n"
"       being done.\n"
"  31 One could imagine nreverse defined as:"
msgstr ""

#: texi/node-25.texi:1880
msgid ""
"       (defun our-nreverse (lst)\n"
"         (if (null (cdr lst))\n"
"                lst\n"
"                (prog1 (nr2 lst)\n"
"                           (setf (cdr lst) nil))))"
msgstr ""

#: texi/node-25.texi:1883
msgid ""
"                                         NOTES                                      "
"389"
msgstr ""

#: texi/node-25.texi:1916
msgid ""
"   (defun nr2 (lst)\n"
"      (let ((c (cdr lst)))\n"
"         (prog1 (if (null (cdr c))\n"
"                            c(nr2 c))\n"
"                    (setf (cdr c) lst))))\n"
"43 Good design always puts a premium on economy, but there is an additional "
"reason\n"
"   that programs should be dense. When a program is dense, you can see more "
"of it at\n"
"   once.\n"
"   People know intuitively that design is easier when one has a broad view "
"of one's\n"
"   work. This is why easel painters use long-handled brushes, and often step "
"back\n"
"   from their work. This is why generals position themselves on high ground, "
"even if\n"
"   they are thereby exposed to enemy fire. And it is why programmers spend a "
"lot of\n"
"   money to look at their programs on large displays instead of small ones.\n"
"   Dense programs make the most of one's field of vision. A general cannot "
"shrink a\n"
"   battle to fit on a table-top, but Lisp allows you to perform "
"corresponding feats of\n"
"   abstraction in programs. And the more you can see of your program at "
"once, the\n"
"   more likely it is to turn out as a unified whole.\n"
"   This is not to say that one should make one's programs shorter at any "
"cost. If you\n"
"   take all the newlines out of a function, you can fit it on one line, but "
"this does not\n"
"   make it easier to read. Dense code means code which has been made smaller "
"by\n"
"   abstraction, not text-editing.\n"
"   Imagine how hard it would be to program if you had to look at your code "
"on a\n"
"   display half the size of the one you're used to. Making your code twice "
"as dense\n"
"   will make programming that much easier.\n"
"44 Steele, Guy L., Jr. Debunking the \"Expensive Procedure Call\" Myth or, "
"Procedu-\n"
"   ral Call Implementations Considered Harmful or, LAMBDA: The Ultimate "
"GOTO.\n"
"   Proceedings of the National Conference of the ACM, 1977, p. 157.\n"
"48 For reference, here are simpler definitions of some of the functions in "
"Figures 4-2\n"
"   and 4-3. All are substantially (at least 10%) slower:\n"
"   (defun filter (fn lst)\n"
"      (delete nil (mapcar fn lst)))"
msgstr ""

#: texi/node-25.texi:1922
msgid ""
"   (defun filter (fn lst)\n"
"      (mapcan #'(lambda (x)\n"
"                       (let ((val (funcall fn x)))\n"
"                             (if val (list val))))\n"
"                   lst))"
msgstr ""

#: texi/node-25.texi:1929
msgid ""
"   (defun group (source n)\n"
"      (if (endp source)\n"
"            nil\n"
"            (let ((rest (nthcdr n source)))\n"
"              (cons (if (consp rest) (subseq source 0 n) source)\n"
"                       (group rest n)))))"
msgstr ""

#: texi/node-25.texi:1932
msgid "390                                        NOTES"
msgstr ""

#: texi/node-25.texi:1938
msgid ""
"       (defun flatten (x)\n"
"         (mapcan #'(lambda (x)\n"
"                              (if (atom x) (mklist x) (flatten x)))\n"
"                       x))"
msgstr ""

#: texi/node-25.texi:1948
msgid ""
"       (defun prune (test tree)\n"
"         (if (atom tree)\n"
"               tree\n"
"               (mapcar #'(lambda (x)\n"
"                                  (prune test x))\n"
"                              (remove-if #'(lambda (y)\n"
"                                              (and (atom y)\n"
"                                                     (funcall test y)))\n"
"                                         tree))))"
msgstr ""

#: texi/node-25.texi:1950
msgid ""
"  49 Written as it is, find2 will generate an error if it runs off the end "
"of a dotted list:"
msgstr ""

#: texi/node-25.texi:1953
msgid ""
"       > (find2 #'oddp '(2 . 3))\n"
"       >>Error: 3 is not a list."
msgstr ""

#: texi/node-25.texi:1959
msgid ""
"       CLTL2 (p. 31) says that it is an error to give a dotted list to a "
"function expecting a\n"
"       list. Implementations are not required to detect this error; some do, "
"some don't.\n"
"       The situation gets murky with functions that take sequences "
"generally. A dotted\n"
"       list is a cons, and conses are sequences, so a strict reading of CLTL "
"would seem to\n"
"       require that"
msgstr ""

#: texi/node-25.texi:1961
msgid "       (find-if #'oddp '(2 . 3))"
msgstr ""

#: texi/node-25.texi:1981
msgid ""
"       return nil instead of generating an error, because find-if is "
"supposed to take a\n"
"       sequence as an argument.\n"
"       Implementations vary here. Some generate an error anyway, and others "
"return nil.\n"
"       However, even implementations which follow the strict reading in the "
"case above\n"
"       tend to deviate in e.g. the case of (concatenate 'cons '(a . b) '(c . "
"d)),\n"
"       which is likely to return (ac.d)instead of (a c).\n"
"       In this book, the utilities which expect lists expect proper lists. "
"Those which operate\n"
"       on sequences will accept dotted lists. However, in general it would "
"be asking for\n"
"       trouble to pass dotted lists to any function that wasn't specifically "
"intended for use\n"
"       on them.\n"
"  66 If we could tell how many parameters each function had, we could write "
"a version of\n"
"       compose so that, in f  g, multiple values returned by g would become "
"the correspond-\n"
"       ing arguments to f. In CLTL2, the new function function-lambda-"
"expression\n"
"       returns a lambda-expression representing the original source code of "
"a function.\n"
"       However, it has the option of returning nil, and usually does so for "
"built-in func-\n"
"       tions. What we really need is a function that would take a function "
"as an argument\n"
"       and return its parameter list.\n"
"  73 A version of rfind-if which searches for whole subtrees could be "
"defined as\n"
"       follows:"
msgstr ""

#: texi/node-25.texi:1984
msgid ""
"                                         NOTES                                         "
"391"
msgstr ""

#: texi/node-25.texi:1993
msgid ""
"     (defun rfind-if (fn tree)\n"
"       (if (funcall fn tree)\n"
"             tree\n"
"             (if (atom tree)\n"
"                     nil\n"
"                     (or (rfind-if fn (car tree))\n"
"                            (and (cdr tree) (rfind-if fn (cdr tree)))))))"
msgstr ""

#: texi/node-25.texi:1996
msgid ""
"     The function passed as the first argument would then have to apply to "
"both atoms\n"
"     and lists:"
msgstr ""

#: texi/node-25.texi:2000
msgid ""
"     > (rfind-if (fint #'atom #'oddp) '(2 (3 4) 5))\n"
"     3> (rfind-if (fint #'listp #'cddr) '(a (b c d e)))\n"
"     (B C D E)"
msgstr ""

#: texi/node-25.texi:2009
msgid ""
" 95 McCarthy, John, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, "
"and\n"
"     Michael I. Levin. Lisp 1.5 Programmer's Manual, 2nd Edition. MIT Press, "
"Cam-\n"
"     bridge, 1965, pp. 70-71.\n"
"106 When Section 8-1 says that a certain kind of operator can only be "
"written as a macro,\n"
"     it means, can only be written by the user as a macro. Special forms can "
"do everything\n"
"     macros can, but there is no way to define new ones.\n"
"     A special form is so called because its evaluation is treated as a "
"special case. In an\n"
"     interpreter, you could imagine eval as a big cond expression:"
msgstr ""

#: texi/node-25.texi:2018
msgid ""
"     (defun eval (expr env)\n"
"       (cond ...\n"
"                   ((eq (car expr) 'quote) (cadr expr))\n"
"                   ...\n"
"                   (t (apply (symbol-function (car expr))\n"
"                                (mapcar #'(lambda (x)\n"
"                                              (eval x env))\n"
"                                        (cdr expr))))))"
msgstr ""

#: texi/node-25.texi:2031
msgid ""
"     Most expressions are handled by the default clause, which says to get "
"the function\n"
"     referred to in the car, evaluate all the arguments in the cdr, and "
"return the result of\n"
"     applying the former to the latter. However, an expression of the form "
"(quote x)\n"
"     should not be treated this way: the whole point of a quote is that its "
"argument is not\n"
"     evaluated. So eval has to have one clause which deals specifically with "
"quote.\n"
"     Language designers regard special forms as something like "
"constitutional amend-\n"
"     ments. It is necessary to have a certain number, but the fewer the "
"better. The special\n"
"     forms in Common Lisp are listed in CLTL2, p. 73.\n"
"     The preceding sketch of eval is inaccurate in that it retrieves the "
"function before\n"
"     evaluating the arguments, whereas in Common Lisp the order of these two "
"operations\n"
"     is deliberately unspecified. For a sketch of eval in Scheme, see "
"Abelson and\n"
"     Sussman, p. 299."
msgstr ""

#: texi/node-25.texi:2034
msgid "392                                         NOTES"
msgstr ""

#: texi/node-25.texi:2061
msgid ""
" 115 It's reasonable to say that a utility function is justified when it "
"pays for itself in\n"
"       brevity. Utilities written as macros may have to meet a stricter "
"standard. Reading\n"
"       macro calls can be more difficult than reading function calls, "
"because they can\n"
"       violate the Lisp evaluation rule. In Common Lisp, this rule says that "
"the value of\n"
"       an expression is the result of calling the function named in the car "
"on the arguments\n"
"       given in the cdr, evaluated left-to-right. Since functions all follow "
"this rule, it is no\n"
"       more difficult to understand a call to find2 than to find-books (page "
"42).\n"
"       However, macros generally do not preserve the Lisp evaluation rule. "
"(If one did,\n"
"       you could have used a function instead.) In principle, each macro "
"defines its own\n"
"       evaluation rule, and the reader can't know what it is without reading "
"the macro's\n"
"       definition. So a macro, depending on how clear it is, may have to "
"save much more\n"
"       than its own length in order to justify its existence.\n"
" 126 The definition of for given in Figure 9-2, like several others defined "
"in this book,\n"
"       is correct on the assumption that the initforms in a do expression "
"will be evaluated\n"
"       left-to-right. CLTL2 (p. 165) says that this holds for the stepforms, "
"but says nothing\n"
"       one way or the other about the initforms.\n"
"       There is good cause to believe that this is merely an oversight. "
"Usually if the order\n"
"       of some operations is unspecified, CLTL will say so. And there is no "
"reason that\n"
"       the order of evaluation of the initforms of a do should be "
"unspecified, since the\n"
"       evaluation of a let is left-to-right, and so is the evaluation of the "
"stepforms in do\n"
"       itself.\n"
" 128 Common Lisp's gentemp is like gensym except that it interns the symbol "
"it creates.\n"
"       Like gensym, gentemp maintains an internal counter which it uses to "
"make print\n"
"       names. If the symbol it wants to create already exists in the current "
"package, it\n"
"       increments the counter and tries again:"
msgstr ""

#: texi/node-25.texi:2067
msgid ""
"       > (gentemp)\n"
"       T1\n"
"       > (setq t2 1)\n"
"       1> (gentemp)\n"
"       T3"
msgstr ""

#: texi/node-25.texi:2080
msgid ""
"       and so tries to ensure that the symbol created will be unique. "
"However, it is still\n"
"       possible to imagine name conflicts involving symbols created by "
"gentemp. Though\n"
"       gentemp can guarantee to produce a symbol not seen before, it cannot "
"foresee what\n"
"       symbols might be encountered in the future. Since gensyms work "
"perfectly well\n"
"       and are always safe, why use gentemp? Indeed, for macros the only "
"advantage of\n"
"       gentemp is that the symbols it makes can be written out and read back "
"in, and in\n"
"       such cases they are certainly not guaranteed to be unique.\n"
" 131 The capture of function names would be a more serious problem in "
"Scheme, due to\n"
"       its single name-space. Not until 1991 did the Scheme standard suggest "
"any official\n"
"       way of defining macros. Scheme's current provision for hygienic "
"macros differs\n"
"       greatly from defmacro. For details, and a bibliography of recent "
"research on the\n"
"       subject, see the most recent Scheme report."
msgstr ""

#: texi/node-25.texi:2083
msgid ""
"                                          NOTES                                      "
"393"
msgstr ""

#: texi/node-25.texi:2089
msgid ""
"137 Miller, Molly M., and Eric Benson. Lisp Style and Design. Digital Press, "
"Bedford\n"
"     (MA), 1990, p. 86.\n"
"158 Instead of writing mvpsetq, it would be cleaner to define an inversion "
"for values.\n"
"     Then instead of"
msgstr ""

#: texi/node-25.texi:2091
msgid "     (mvpsetq (w x) (values y z) ...)"
msgstr ""

#: texi/node-25.texi:2093
msgid "     we could say"
msgstr ""

#: texi/node-25.texi:2095
msgid "     (psetf (values w x) (values y z) ...)"
msgstr ""

#: texi/node-25.texi:2129
msgid ""
"     Defining an inversion for values would also render multiple-value-setq "
"un-\n"
"     necessary. Unfortunately, as things stand in Common Lisp it is "
"impossible to define\n"
"     such an inversion; get-setf-method won't return more than one store "
"variable,\n"
"     and presumably the expansion function of psetf wouldn't know what to do "
"with\n"
"     them if it did.\n"
"180 One of the lessons of setf is that certain classes of macros can hide "
"truly enormous\n"
"     amounts of computation and yet leave the source code perfectly "
"comprehensible.\n"
"     Eventually setf may be just one of a class of macros for programming "
"with\n"
"     assertions.\n"
"     For example, it might be useful to have a macro insist which took "
"certain ex-\n"
"     pressions of the form (predicate . arguments), and would make them true "
"if they\n"
"     weren't already. As setf has to be told how to invert references, this "
"macro would\n"
"     have to be told how to make expressions true. In the general case, such "
"a macro call\n"
"     might amount to a call to Prolog.\n"
"198 Gelernter, David H., and Suresh Jagannathan. Programming Linguistics. "
"MIT\n"
"     Press, Cambridge, 1990, p. 305.\n"
"199 Norvig, Peter. Paradigms of Artificial Intelligence Programming: Case "
"Studies in\n"
"     Common Lisp. Morgan Kaufmann, San Mateo (CA), 1992, p. 856.\n"
"213 The constant least-negative-normalized-double-float and its three "
"cousins\n"
"     have the longest names in Common Lisp, with 38 characters each. The "
"operator\n"
"     with the longest name is get-setf-method-multiple-value, with 30.\n"
"     The following expression returns a list, from longest to shortest, of "
"all the symbols\n"
"     visible in the current package:\n"
"     (let ((syms nil))\n"
"       (do-symbols (s)\n"
"          (push s syms))\n"
"       (sort syms\n"
"                #'(lambda (x y)\n"
"                        (> (length (symbol-name x))\n"
"                           (length (symbol-name y))))))\n"
"217 As of CLTL2, the expansion function of a macro is supposed to be defined "
"in the\n"
"     environment where the defmacro expression appears. This should make it "
"possible\n"
"     to give propmacro the cleaner definition:"
msgstr ""

#: texi/node-25.texi:2132
msgid "394                                       NOTES"
msgstr ""

#: texi/node-25.texi:2176
msgid ""
"       (defmacro propmacro (propname)\n"
"             `(defmacro ,propname (obj)\n"
"                `(get ,obj ',propname)))\n"
"       But CLTL2 does not explicitly state whether the propname form "
"originally passed to\n"
"       propmacro is part of the lexical environment in which the inner "
"defmacro occurs.\n"
"       In principle, it seems that if color were defined with (propmacro "
"color),it\n"
"       should be equivalent to:\n"
"       (let ((propname 'color))\n"
"             (defmacro color (obj)\n"
"              `(get ,obj ',propname)))\n"
"       or\n"
"       (let ((propname 'color))\n"
"             (defmacro color (obj)\n"
"              (list 'get obj (list 'quote propname))))\n"
"       However, in at least some CLTL2 implementations, the new version of "
"propmacro\n"
"       does not work.\n"
"       In CLTL1, the expansion function of a macro was considered to be "
"defined in the null\n"
"       lexical environment. So for maximum portability, macro definitions "
"should avoid\n"
"       using the enclosing environment anyway.\n"
" 238 Functions like match are sometimes described as doing unification. They "
"don't,\n"
"       quite; match will successfully match (f ?x) and ?x, but those two "
"expressions\n"
"       should not unify.\n"
"       For a description of unification, see: Nilsson, Nils J. Problem-"
"Solving Methods in\n"
"       Artificial Intelligence. McGraw-Hill, New York, 1971, pp. 175-178.\n"
" 244 It's not really necessary to set unbound variables to gensyms, or to "
"call gensym? at\n"
"       runtime. The expansion-generating code in Figures 18-7 and 18-8 could "
"be written\n"
"       to keep track of the variables for which binding code had already "
"been generated. To\n"
"       do this the code would have to be turned inside-out, however: instead "
"of generating\n"
"       the expansion on the way back up the recursion, it would have to be "
"accumulated\n"
"       on the way down.\n"
" 244 A symbol like ?x occurring in the pattern of an if-match always denotes "
"a new\n"
"       variable, just as a symbol in the car of a let binding clause does. "
"So although Lisp\n"
"       variables can be used in patterns, pattern variables from outer "
"queries cannot-you\n"
"       can use the same symbol, but it will denote a new variable. To test "
"that two lists\n"
"       have the same first element, it wouldn't work to write:\n"
"       (if-match (?x . ?rest1) lst1\n"
"              (if-match (?x . ?rest2) lst2\n"
"                  ?x))\n"
"       In this case, the second ?x is a new variable. If both lst1 and lst2 "
"had at least one\n"
"       element, this expression would always return the car of lst2.\n"
"       However, since you can use (non-?ed) Lisp variables in the pattern of "
"an if-match,\n"
"       you can get the desired effect by writing:"
msgstr ""

#: texi/node-25.texi:2179
msgid ""
"                                        NOTES                                       "
"395"
msgstr ""

#: texi/node-25.texi:2185
msgid ""
"     (if-match (?x . ?rest1) lst1\n"
"          (let ((x ?x))\n"
"             (if-match (x . ?rest2) lst2\n"
"                  ?x)))"
msgstr ""

#: texi/node-25.texi:2191
msgid ""
"     The restriction, and the solution, apply to the with-answer and with-"
"inference\n"
"     macros defined in Chapters 19 and 24 as well.\n"
"254 If it were a problem that \"unbound\" pattern variables were nil, you "
"could have\n"
"     them bound to a distinct gensym by saying (defconstant unbound "
"(gensym))\n"
"     and then replacing the line"
msgstr ""

#: texi/node-25.texi:2193
msgid "     `(,v (binding ',v ,binds)))"
msgstr ""

#: texi/node-25.texi:2195
msgid "     in with-answer with:"
msgstr ""

#: texi/node-25.texi:2197
msgid "     `(,v (aif2 (binding ',v ,binds) it unbound))"
msgstr ""

#: texi/node-25.texi:2205
msgid ""
"258 Scheme was invented by Guy L. Steele Jr. and Gerald J. Sussman in 1975. "
"The\n"
"     language is currently defined by: Clinger, William, and Jonathan A. "
"Rees (Eds.).\n"
"     Revised4 Report on the Algorithmic Language Scheme. 1991.\n"
"     This report, and various implementations of Scheme, were at the time of "
"printing\n"
"     available by anonymous FTP from altdorf.ai.mit.edu:pub.\n"
"266 As another example of the technique presented in Chapter 16, here is the "
"derivation\n"
"     of the defmacro template within the definition of =defun:"
msgstr ""

#: texi/node-25.texi:2208
msgid ""
"     (defmacro fun (x)\n"
"       `(=fun *cont* ,x))"
msgstr ""

#: texi/node-25.texi:2212
msgid ""
"     (defmacro fun (x)\n"
"       (let ((fn '=fun))\n"
"          `(,fn *cont* ,x)))"
msgstr ""

#: texi/node-25.texi:2216
msgid ""
"     `(defmacro ,name ,parms\n"
"         (let ((fn ',f))\n"
"           `(,fn *cont* ,,@@parms)))"
msgstr ""

#: texi/node-25.texi:2219
msgid ""
"     `(defmacro ,name ,parms\n"
"         `(,',f *cont* ,,@@parms))"
msgstr ""

#: texi/node-25.texi:2221
msgid ""
"267 If you wanted to see multiple return values in the toplevel, you could "
"say instead:"
msgstr ""

#: texi/node-25.texi:2225
msgid ""
"     (setq *cont*\n"
"             #'(lambda (&rest args)\n"
"                  (if (cdr args) args (car args))))"
msgstr ""

#: texi/node-25.texi:2228
msgid ""
"273 This example is based on one given in: Wand, Mitchell. Continuation-"
"Based\n"
"     Program Transformation Strategies. JACM 27, 1 (January 1980), pp. 166."
msgstr ""

#: texi/node-25.texi:2231
msgid "396                                        NOTES"
msgstr ""

#: texi/node-25.texi:2238
msgid ""
" 273 A program to transform Scheme code into continuation-passing style "
"appears in:\n"
"       Steele, Guy L., Jr. LAMBDA: The Ultimate Declarative. MIT Artificial "
"Intelligence\n"
"       Memo 379, November 1976, pp. 30-38.\n"
" 292 These implementations of choose and fail would be clearer in T, a "
"dialect of\n"
"       Scheme which has push and pop, and allows define in non-toplevel "
"contexts:"
msgstr ""

#: texi/node-25.texi:2241
msgid ""
"       (define *paths* ())\n"
"       (define failsym '@@)"
msgstr ""

#: texi/node-25.texi:2250
msgid ""
"       (define (choose choices)\n"
"         (if (null? choices)\n"
"               (fail)\n"
"               (call-with-current-continuation\n"
"                 (lambda (cc)\n"
"                       (push *paths*\n"
"                             (lambda () (cc (choose (cdr choices)))))\n"
"                       (car choices)))))"
msgstr ""

#: texi/node-25.texi:2257
msgid ""
"       (call-with-current-continuation\n"
"         (lambda (cc)\n"
"            (define (fail)\n"
"               (if (null? *paths*)\n"
"                       (cc failsym)\n"
"                       ((pop *paths*))))))"
msgstr ""

#: texi/node-25.texi:2272
msgid ""
"       For more on T, see: Rees, Jonathan A., Norman I. Adams, and James R. "
"Meehan.\n"
"       The T Manual, 5th Edition. Yale University Computer Science "
"Department, New\n"
"       Haven, 1988.\n"
"       The T manual, and T itself, were at the time of printing available by "
"anonymous FTP\n"
"       from hing.lcs.mit.edu:pub/t3-1.\n"
" 293 Floyd, Robert W. Nondeterministic Algorithms. JACM 14, 4 (October "
"1967),\n"
"       pp. 636-644.\n"
" 298 The continuation-passing macros defined in Chapter 20 depend heavily on "
"the\n"
"       optimization of tail calls. Without it they may not work for large "
"problems. For\n"
"       example, at the time of printing, few computers have enough memory to "
"allow the\n"
"       Prolog defined in Chapter 24 to run the zebra benchmark without the "
"optimization\n"
"       of tail calls. (Warning: some Lisps crash when they run out of stack "
"space.)\n"
" 303 It's also possible to define a depth-first correct choose that works by "
"explicitly\n"
"       avoiding circular paths. Here is a definition in T:"
msgstr ""

#: texi/node-25.texi:2276
msgid ""
"       (define *paths* ())\n"
"       (define failsym '@@)\n"
"       (define *choice-pts* (make-symbol-table))"
msgstr ""

#: texi/node-25.texi:2279
msgid ""
"       (define-syntax (true-choose choices)\n"
"         `(choose-fn ,choices ',(generate-symbol t)))"
msgstr ""

#: texi/node-25.texi:2282
msgid ""
"                                        NOTES                                         "
"397"
msgstr ""

#: texi/node-25.texi:2311
msgid ""
"    (define (choose-fn choices tag)\n"
"       (if (null? choices)\n"
"            (fail)\n"
"            (call-with-current-continuation\n"
"                   (lambda (cc)\n"
"                     (push *paths*\n"
"                           (lambda () (cc (choose-fn (cdr choices)\n"
"                                                             tag))))\n"
"                     (if (mem equal? (car choices)\n"
"                                       (table-entry *choice-pts* tag))\n"
"                         (fail)\n"
"                         (car (push (table-entry *choice-pts* tag)\n"
"                                      (car choices))))))))\n"
"    In this version, true-choose becomes a macro. (The T define-syntax is "
"like\n"
"    defmacro except that the macro name is put in the car of the parameter "
"list.) This\n"
"    macro expands into a call to choose-fn, a function like the depth-first "
"choose\n"
"    defined in Figure 22-4, except that it takes an additional tag argument "
"to identify\n"
"    choice-points. Each value returned by a true-choose is recorded in the "
"global\n"
"    hash-table *choice-pts*. Ifagiventrue-choose is about to return a value "
"it has\n"
"    already returned, it fails instead. There is no need to change fail "
"itself; we can use\n"
"    the fail defined on page 396.\n"
"    This implementation assumes that paths are of finite length. For "
"example, it would\n"
"    allow path as defined in Figure 22-13 to find a path from a to e in the "
"graph displayed\n"
"    in Figure 22-11 (though not necessarily a direct one). But the true-"
"choose defined\n"
"    above wouldn't work for programs with an infinite search-space:\n"
"    (define (guess x)\n"
"       (guess-iter x 0))"
msgstr ""

#: texi/node-25.texi:2328
msgid ""
"    (define (guess-iter x g)\n"
"       (if (= x g)\n"
"            g(guess-iter x (+ g (true-choose '(-1 0 1))))))\n"
"    With true-choose defined as above, (guess n) would only terminate for "
"non-\n"
"    positive n.\n"
"    How we define a correct choose also depends on what we call a choice "
"point. This\n"
"    version treats each (textual) call to true-choose as a choice point. "
"That might\n"
"    be too restrictive for some applications. For example, if two-numbers "
"(page 291)\n"
"    used this version of choose, it would never return the same pair of "
"numbers twice,\n"
"    even if it was called by several different functions. That might or "
"might not be what\n"
"    we want, depending on the application.\n"
"    Note also that this version is intended for use only in compiled code. "
"In interpreted\n"
"    code, the macro call might be expanded repeatedly, each time generating "
"a new\n"
"    gensymed tag.\n"
"305 Woods, William A. Transition Network Grammars for Natural Language "
"Analysis.\n"
"    CACM 3, 10 (October 1970), pp. 591-606."
msgstr ""

#: texi/node-25.texi:2331
msgid "398                                       NOTES"
msgstr ""

#: texi/node-25.texi:2338
msgid ""
" 312 The original ATN system included operators for manipulating registers "
"on the stack\n"
"       while in a sub-network. These could easily be added, but there is "
"also a more general\n"
"       solution: to insert a lambda-expression to be applied to the register "
"stack directly\n"
"       into the code of an arc body. For example, if the node mods (page "
"316) had the\n"
"       following line inserted into the body of its outgoing arc,"
msgstr ""

#: texi/node-25.texi:2344
msgid ""
"       (defnode mods\n"
"         (cat n mods/n\n"
"            ((lambda (regs)\n"
"                 (append (butlast regs) (setr a 1 (last regs)))))\n"
"            (setr mods *)))"
msgstr ""

#: texi/node-25.texi:2349
msgid ""
"       then following the arc (however deep) would set the the topmost "
"instance of the\n"
"       register a (the one visible when traversing the topmost ATN)to1.\n"
" 323 If necessary, it would be easy to modify the Prolog to take advantage "
"of an existing\n"
"       database of facts. The solution would be to make prove (page 336) a "
"nested choose:"
msgstr ""

#: texi/node-25.texi:2356
msgid ""
"       (=defun prove (query binds)\n"
"         (choose\n"
"             (choose-bind b2 (lookup (car query) (cdr query) binds)\n"
"                 (=values b2))\n"
"             (choose-bind r *rules*\n"
"                 (=funcall r query binds))))"
msgstr ""

#: texi/node-25.texi:2359
msgid ""
" 325 To test quickly whether there is any match for a query, you could use "
"the following\n"
"       macro:"
msgstr ""

#: texi/node-25.texi:2364
msgid ""
"       (defmacro check (expr)\n"
"         `(block nil\n"
"             (with-inference ,expr\n"
"                 (return t))))"
msgstr ""

#: texi/node-25.texi:2381
msgid ""
" 344 The examples in this section are translated from ones given in: "
"Sterling, Leon, and\n"
"       Ehud Shapiro. The Art of Prolog: Advanced Programming Techniques. MIT "
"Press,\n"
"       Cambridge, 1986.\n"
" 349 The lack of a distinct name for the concepts underlying Lisp may be a "
"serious\n"
"       barrier to the language's acceptance. Somehow one can say \"We need "
"to use C++\n"
"       because we want to do object-oriented programming,\" but it doesn't "
"sound nearly as\n"
"       convincing to say \"We need to use Lisp because we want to do Lisp "
"programming.\"\n"
"       To administrative ears, this sounds like circular reasoning. Such "
"ears would rather\n"
"       hear that Lisp's value hinged on a single, easily understood concept. "
"For years we\n"
"       have tried to oblige them, with little success. Lisp has been "
"described as a \"list-\n"
"       processing language,\" a language for \"symbolic computation,\" and "
"most recently, a\n"
"       \"dynamic language.\" None of these phrases captures more than a "
"fraction of what\n"
"       Lisp is about. When retailed through college textbooks on programming "
"languages,\n"
"       they become positively misleading.\n"
"       Efforts to sum up Lisp in a single phrase are probably doomed to "
"failure, because the\n"
"       power of Lisp arises from the combination of at least five or six "
"features. Perhaps"
msgstr ""

#: texi/node-25.texi:2384
msgid ""
"                                       NOTES                                      "
"399"
msgstr ""

#: texi/node-25.texi:2391
msgid ""
"    we should resign ourselves to the fact that the only accurate name for "
"what Lisp\n"
"    offers is Lisp.\n"
"352 For efficiency, sort doesn't guarantee to preserve the order of sequence "
"elements\n"
"    judged equal by the function given as the second argument. For example, "
"a valid\n"
"    Common Lisp implementation could do this:"
msgstr ""

#: texi/node-25.texi:2395
msgid ""
"    > (let ((v #((2 . a) (3 . b) (1 . c) (1 . d))))\n"
"         (sort (copy-seq v) #'< :key #'car))\n"
"    #((1 . D) (1 . C) (2 . A) (3 . B))"
msgstr ""

#: texi/node-25.texi:2399
msgid ""
"    Note that the relative order of the first two elements has been "
"reversed.\n"
"    The built-in stable-sort provides a way of sorting which won't reorder "
"equal\n"
"    elements:"
msgstr ""

#: texi/node-25.texi:2403
msgid ""
"    > (let ((v #((2 . a) (3 . b) (1 . c) (1 . d))))\n"
"         (stable-sort (copy-seq v) #'< :key #'car))\n"
"    #((1 . C) (1 . D) (2 . A) (3 . B))"
msgstr ""

#: texi/node-25.texi:2409
msgid ""
"    It is a common error to assume that sort works like stable-sort. "
"Another\n"
"    common error is to assume that sort is nondestructive. In fact, both "
"sort and\n"
"    stable-sort can alter the sequence they are told to sort. If you don't "
"want this to\n"
"    happen, you should sort a copy. The call to stable-sort in get-ancestors "
"is\n"
"    safe because the list to be sorted has been freshly made."
msgstr ""

#: texi/node-25.texi:2412
msgid "400    NOTES"
msgstr ""

#: texi/node-25.texi:2417
msgid ""
"@node Book's Index, Concept Index, Notes, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter Book's Index\n"
"@cindex Book's Index"
msgstr ""

#: texi/node-25.texi:2449
msgid ""
"aand 191                                 =apply 267\n"
"abbrev 214                               arch\n"
"abbrevs 214                                 Lisp as 8\n"
"abbreviations 213                           bottom-up program as 4\n"
"Abelson, Harold 18                       architects 284\n"
"Abelson, Julie 18                        Armstrong, Louis vii\n"
"ablock 193                               artificial intelligence 1\n"
"Abrahams, Paul W. 391                    asetf 223\n"
":accessor 365                            assignment\n"
"accumulators 23, 47, 394                    macros for 170\n"
"acond 191                                   order of 177\n"
"acond2 198, 239                             parallel 96\n"
"Adams, Norman I. 396                        in Prolog 343\n"
"after 50                                    and referential transparency "
"198\n"
"aif 191                                     see also: generalized variables\n"
"aif2 198                                 assoc 196\n"
"alambda 193                              ATNs 305\n"
"Algol 8                                     arc types 311\n"
"allf 169                                    correctness of 312\n"
":allocation 367                             destructive operations in 313\n"
"always 227                                  like functional programs 316\n"
"alrec 205                                   for natural language 305\n"
"anaphora-see macros, anaphoric              nondeterminism in 308\n"
"ANSI Common Lisp ix                         operations on register stack "
"398\n"
"antecedent 322                              order of arcs 308\n"
"append                                      recursion in 306\n"
"  Prolog implementation 331                 registers of 306, 312\n"
"append1 45                                  represented as functions 309\n"
"apply 13                                    tracing 309\n"
"  with macros 110                        atrec 210\n"
"  on &rest parameters 137                augmented transition networks-see "
"ATNs"
msgstr ""

#: texi/node-25.texi:2452
msgid "                                  401"
msgstr ""

#: texi/node-25.texi:2455
msgid "402                                 INDEX"
msgstr ""

#: texi/node-25.texi:2504
msgid ""
"Autocad 1, 5                                 call-next-method 200, 375\n"
"automata theory 292                            sketch of 358\n"
"avg 182                                      call-with-current-continuation\n"
"awhen 191                                               (call/cc) 260\n"
"awhen2 198                                     at toplevel 292\n"
"awhile 191                                   capital expenditures 43\n"
"awhile2 198                                  capture 118\n"
"                                               avoiding with gensyms 128\n"
"backtraces 111                                 avoiding with packages 130\n"
"backtracking 292                               avoiding by prior evaluation "
"125\n"
"backquote (`)84                                of block names 131\n"
"   in ATNs 307                                 detecting potential 121\n"
"   nested 214, 217, 395                        free symbol capture 119\n"
"bad-reverse 29                                    avoiding 125\n"
"barbarians 283                                 of function names 131, 392\n"
"Basic 30, 33                                   intentional 190, 267, 313\n"
"battlefield 8                                  macro argument capture 118\n"
"before 50                                      of tags 131\n"
"Benson, Eric 137                             case 15\n"
"best 52                                      >case 152\n"
"Bezier curves 185                            case-sensitivity 331\n"
"=bind 267                                    chains of closures 76, 269\n"
"binding 239                                  Chocoblobs 298\n"
"binding lists 239                            choose 287\n"
"bindings, altering 107                         extent of 291\n"
"blackboards 281                              choose\n"
"block 154                                      Common Lisp version 295\n"
"   implicit 131, 155                           Scheme version 293\n"
"block-names 131                              choose-bind 295\n"
"body (of expressions) 87, 91, 87             chronological backtracking 292\n"
"body (of a rule) 322                         classes\n"
"&body 87                                       defining 364\n"
"bookshops 41                                   see also: superclasses\n"
"bottom-up design v, 3, 321                   Clinger, William 395\n"
"   and functional arguments 42               CLOS 364\n"
"   and incremental testing 38                  as an embedded language 349, "
"377\n"
"   and shape of programs 4                     see also: classes, generic "
"functions,\n"
"   multilayer 321                                       methods, slots\n"
"bound-see variables, bound                   closed world assumption 249\n"
"break-loop 56                                closures 17, 62, 76\n"
"brevity viii, 43                             CLTL-see Common Lisp: the "
"Language\n"
"bricks, furniture made of 117                code-walkers 237, 273\n"
"Brooks, Frederick P. 5                       Common Lisp: the Language ix\n"
"                                             Common Lisp\n"
"                                               case-sensitivity of 331\n"
"C 388                                          definition of ix\n"
"C++ 398"
msgstr ""

#: texi/node-25.texi:2507
msgid ""
"                                           INDEX                                          "
"403"
msgstr ""

#: texi/node-25.texi:2555
msgid ""
"  differences between versions                      complement 62\n"
"     compilation of closures 25                     compose 66\n"
"     complement 62                                  composition-see "
"functions,\n"
"     defpackage 384                                            composition "
"of\n"
"     destructuring-bind 93                          conc1 45\n"
"     dynamic-extent 150                             conc1f 170, 174\n"
"     environment of expanders 96, 393               concf 170\n"
"     no expansion in compiled code 136              concnew 170\n"
"     function-lambda-expression 390                 conditionals 108, 150\n"
"     *gensym-counter* 129                           condlet 146\n"
"     -if-not deprecated 62                          congruent parameter "
"lists 372\n"
"     ignore-errors 147                              consequent 322\n"
"     inversions from defun 179                      consing\n"
"     Lisp package 384                                 avoiding 31, 150, 197, "
"363\n"
"     name of user package 381                       constitutional "
"amendments 391\n"
"     redefining built-in operators 131,             constraints 332\n"
"       199                                          *cont* 266\n"
"     &rest parameters not fresh 137                 context\n"
"     symbol-macros 205                                and referential "
"transparency 199\n"
"     with-slots 236                                   see also: "
"environments; macros,\n"
"     see also: CLOS, series                                    context-"
"creating\n"
"  evaluation rule 392                               continuations 258\n"
"  long names in 393                                   destructive operations "
"in 261, 313\n"
"  vs. Scheme 259                                      cost of 284\n"
"Common Lisp Object System-see CLOS                    see also: call-with-"
"current-con-\n"
"common-lisp 384                                                tinuation\n"
"common-lisp-user 381                                continuation-passing "
"macros 266\n"
"compall 388                                           use in multiprocessing "
"283\n"
"compilation 24                                        use in "
"nondeterministic choice 296\n"
"  bounds-checking during 186                          restrictions on 270\n"
"  computation during 109, 181, 197,                   and tail-recursion "
"optimization 298\n"
"       254, 335                                     continuation-passing "
"style (CPS) 273\n"
"  of embedded languages 116, 254                    cookies 184\n"
"  errors emerging during 139                        copy-list 71, 206\n"
"  inline 26, 109, 110                               copy-tree 71, 210\n"
"     testing 388                                    courtiers 375\n"
"  of local functions 23, 25, 81, 346                cut 337\n"
"  of macro calls 83, 101, 136                         with fail 342\n"
"  of networks 79                                      green 339\n"
"  restrictions on 25                                  red 339\n"
"  senses of 346                                       in Lisp 298\n"
"  of queries 254                                    cut 301\n"
"  see also: tail-recursion optimization\n"
"compile 24, 116, 388                                databases\n"
"compile-file 25                                       caching updates to "
"179\n"
"compiled-function-p 24                                locks on 148"
msgstr ""

#: texi/node-25.texi:2558
msgid "404                                     INDEX"
msgstr ""

#: texi/node-25.texi:2606
msgid ""
"  natural language interfaces to 306               generalization of 156\n"
"  queries on 246                                 Dolphin Seafood 219\n"
"  representation of 247                          dotted lists 70, 390\n"
"  with Prolog 398                                duplicate 50\n"
"dbind 232                                        dynamic extent 127, 150\n"
"def! 64                                          dynamic languages 398\n"
"defanaph 223                                     dynamic scope 16\n"
"defclass 364\n"
"defdelim 228                                     Edwards, Daniel J. 391\n"
"defgeneric 371                                   elt 244\n"
"define-modify-macro 168                          Emacs-see Gnu Emacs\n"
"defmacro 82, 95                                  embedded languages 7, 188, "
"246\n"
"defpackage 384                                     ATNsas309\n"
"defprop 354                                        benefits of 110,116, 246, "
"377\n"
"defun 10, 113                                      borderline of 246\n"
"  defining inversions with 179                     compilation of 116\n"
"=defun 267                                         not quite compilers 346\n"
"defsetf 178                                        implementation of 116\n"
"delay 211                                          for multiprocessing 275\n"
"delete-if 64                                       Prolog as 321\n"
"density of source code 59, 389                     query languages as 246\n"
"destruc 232                                        see also: CLOS\n"
"destructive operations 31, 64                    end-of-file (eof) 197, 225\n"
"destructuring                                    English 306\n"
"  on arrays 234                                  environment\n"
"  on instances 236                                 argument 95\n"
"  on lists 230                                     interactive 8\n"
"  in macros 93                                     of macro expanders 96, "
"393\n"
"  and reference 236                                of macro expansions 108\n"
"  on sequences 231                                 null 96, 278, 394\n"
"  on structures 235                              error 148\n"
"destructuring-bind 93, 213, 230                  error-checking 45\n"
"differences 207                                  eval\n"
"disassemble 388                                    explicit 34, 163, 197, "
"278\n"
"dispatching 370, 371                               on macroexpansions 92\n"
"do 98                                              sketch of 391\n"
"  implicit block in 131                          evaluation\n"
"  multiple-valued version 162                      avoiding 151, 181\n"
"  order of evaluation in 392                       lazy 211\n"
"do-file 199                                        order of\n"
"do-symbols 388, 393                                      in Common Lisp 135\n"
"do-tuples/c 156                                          in Scheme 259\n"
"do-tuples/o 156                                    sketch of 391\n"
"do* 97                                           evaluation rule 392\n"
"  multiple-valued version 159                    evenp 14\n"
"dolist 94                                        evolution"
msgstr ""

#: texi/node-25.texi:2609
msgid ""
"                                         INDEX                                          "
"405"
msgstr ""

#: texi/node-25.texi:2657
msgid ""
"  design by 1                                     funcall 13, 259\n"
"  of Lisp 158                                     =funcall 267\n"
"  of programming languages 8                      function calls, avoiding\n"
"expander code 99                                    by inline compilation "
"26\n"
"expansion code 99                                   with macros 109\n"
"explode 58                                          by tail recursion 23\n"
"exploratory programming 1, 284                    functional interfaces 35\n"
"export 383                                        functional programs 28\n"
":export 384                                         almost 35\n"
"expt 32                                             and bottom-up "
"programming 37\n"
"extensibility 5                                     from imperative ones 33\n"
"  of object-oriented programs 16, 379               shape of 30\n"
"extent, dynamic 127, 150                          functions\n"
"                                                    as arguments 13, 42, "
"177\n"
"f 173, 222                                          constant 226\n"
"factions 167                                        closures of 17, 62, 76\n"
"factorials 343, 387                                    use in "
"nondeterministic choice 296\n"
"fail 287                                               stack allocation of "
"150\n"
"fail                                                combined with macros "
"141, 149, 266\n"
"  Common Lisp version 295                           compiled 24\n"
"  Scheme version 293                                composition of 66, 201, "
"228\n"
"failure 195                                         as a data type 9\n"
"fboundp 388                                         defining 10\n"
"fif 67                                              filleting 115\n"
"filter 47                                           generating recursive 68, "
"204\n"
"  simpler version 389                               generic-see generic "
"functions\n"
"find2 50                                            internal 172\n"
"  evolution of 41                                   interpreted 24\n"
"find-if 41, 195                                     as lists 27\n"
"  sketch of 206                                     literal 11\n"
"  version for trees 73                                 recursive 21, 193\n"
"finished programs 285                               local 21\n"
"fint 67                                             vs. macros 109\n"
"flatten 47, 72, 210                                 names of 11, 213\n"
"  simpler version 389                               as properties 15\n"
"Floyd, Robert W. 293                                redefining built-in 131, "
"174\n"
"fmakunbound 373                                     as return values 17, 61, "
"76, 201\n"
"fn 202, 229                                         set operations on 67, "
"201\n"
"Foderaro, John K. v                                 with state 18, 65\n"
"for 154                                             tail-recursive 23\n"
"force 211                                           transforming into macros "
"102\n"
"Fortran 8                                           undefining 373\n"
"free-see variables, free                            see also: compilation; "
"defgeneric;\n"
"fullbind 324                                              defun; labels\n"
"fun x                                             function-lambda-expression "
"390\n"
"fun 67"
msgstr ""

#: texi/node-25.texi:2660
msgid "406                                       INDEX"
msgstr ""

#: texi/node-25.texi:2708
msgid ""
"Gabriel, Richard P. 23                             incf 171\n"
"garbage                                               generalization of 173\n"
"  avoiding-see consing, avoiding                   incremental testing 37\n"
"  collection 8, 81                                 indexing 249\n"
"generalized variables 107, 165                     inheritance\n"
"  meaning of 179                                      single 196\n"
"  see also: inversions                                of slots 366\n"
"generic functions 371                                 multiple 366\n"
"  defining 371                                           sketch of 351\n"
"  removing 373                                     in-if 152\n"
"  see also: methods                                :initarg 365\n"
"gensym 128                                         :initform 365\n"
"  to indicate failure 197                          in-package 382\n"
"  as unbound 244, 330                              inq 152\n"
"gensym? 243                                        instances 365\n"
"*gensym-counter* 129                               intellectuals 374\n"
"gentemp 392                                        interactive development "
"37, 316\n"
"Gelernter, David H. 198                            interactive environment "
"8\n"
"get 63                                             intercourse, lexical 108\n"
"gethash 196                                        Interleaf 1, 5\n"
"  recursive version 350                            intern 128, 136, 266\n"
"get-setf-method 171                                interning 128, 136, 381\n"
"gift-shops, airport 278                            intersection 207\n"
"Gnu Emacs 1, 5                                     intersections 207\n"
"go 100, 155                                        inversions\n"
"gods 8                                                asymmetric 179\n"
"gold 386                                              defining 178\n"
"good-reverse 30                                       see also: generalized "
"variables\n"
"group 47                                           iteration\n"
"  simpler version 389                                 macros for 108, 154\n"
"                                                      vs. nondeterministic "
"choice 291, 325\n"
"Hart, Timothy P. 391                                  without loops 264, "
"325\n"
"hash tables 65, 247, 350\n"
"head 322                                           Jagannathan, Suresh 198\n"
"hiding implementation details 216, 382             jazz vii\n"
"hygienic macros 392                                joiner 62\n"
"                                                   joke, practical-see "
"Nitzberg, Mark\n"
"ice-cream 370\n"
"ice-skating 33                                     keywords 386\n"
"if3 150\n"
"if-match 242                                       labels 21\n"
"ignore-errors 147                                  lambda 11\n"
"Igor 289                                           =lambda 267\n"
"imperative programming 33                          lambda-expressions 11, "
"21\n"
"import 383                                         last 45\n"
"in 152                                             last1 45"
msgstr ""

#: texi/node-25.texi:2711
msgid ""
"                                            INDEX                                        "
"407"
msgstr ""

#: texi/node-25.texi:2759
msgid ""
"Latin 306                                            macro-characters-see "
"read-macros\n"
"lawyers 298                                          macros 82\n"
"let 144, 199                                           as abbreviations 213\n"
"let* 172                                               access 167, 216\n"
"lengths of programs 387                                anaphoric 189\n"
"Levin, Michael I. 391                                    defining "
"automatically 218\n"
"lexical scope 16                                         for distinguishing "
"failure from fal-\n"
"life, meaning of 197                                        sity 195\n"
"lions 37                                                 for generating "
"recursive functions\n"
"Lisp                                                        204\n"
"   1.5 95                                                multiple-valued "
"198\n"
"   defining features of 1, 8, 349, 398                   and referential "
"transparency 198\n"
"   integration with user programs 110                    see also: call-next-"
"method\n"
"   slowness of 285                                     and apply 110\n"
"   speed of 388                                        applications of 111\n"
"   see also Common Lisp, Scheme, T                     arguments to 107\n"
"lists                                                  for building "
"functions 201\n"
"   accumulating 47                                     calls invertible 166, "
"216\n"
"   as binary trees 70                                  clarity 99, 233\n"
"   as code 116                                         and CLOS 378\n"
"   decreased role of 44                                for computation at "
"compile-time 181\n"
"   disambiguating return values with 196               context-creating 143\n"
"   dotted 390                                          combined with "
"functions 141, 149,\n"
"   as facts 247                                             266\n"
"   flat-see flatten                                    compiled 83, 101, "
"136\n"
"   interleaving 160                                    complex 96\n"
"   operating on end of 170                             defining 82\n"
"   quoted 37                                           efficiency 99\n"
"   recursers on 68, 204                                environment argument "
"to 95\n"
"   as trees 262                                        environment of "
"expander 96, 393\n"
"   uses for 70                                         environment of "
"expansion 108\n"
"list processing 44, 398                                errors in\n"
"locality 36                                              modifying arguments "
"137\n"
"logic programs 334                                       modifying "
"expansions 139\n"
"longer 47                                                non-functional "
"expanders 136\n"
"   simpler version 389                                   nonterminating "
"expansion 139\n"
"loop 154                                                 number of "
"evaluations 133, 167\n"
"loops                                                    order of evaluation "
"135\n"
"   interrupting 154                                      see also: capture\n"
"   see also: iteration                                 expansion of 83\n"
"lrec 69                                                  in compiled code "
"136\n"
"                                                         multiple 136, 138\n"
"McCarthy, John 1, 391                                    non-terminating "
"139\n"
"mac 92                                                   testing 92\n"
"macroexpand 91                                           time of 83\n"
"macroexpand-1 91                                       from functions 102"
msgstr ""

#: texi/node-25.texi:2762
msgid "408                                    INDEX"
msgstr ""

#: texi/node-25.texi:2810
msgid ""
"  vs. functions 109                               misuse of 151\n"
"  hygienic 392                                    Prolog implementation 332\n"
"  justification of 392                            returns a cdr 50\n"
"  macro-defining 213, 266                       Miller, Molly M. 137\n"
"  parameter lists 93                            member-if 196\n"
"  position in source code 102, 266              memq 88\n"
"  as programs 96                                memoizing 65, 174\n"
"  proportion in a program 117                   message-passing 350\n"
"  recursion in 139                                vs. Lisp syntax 353\n"
"  redefining 101, 138                           methods\n"
"       built-in 199                               adhere to one another 369\n"
"  simple 88                                       after- 374\n"
"  skeletons of 121                                      sketch of 357\n"
"  style for 99                                    around- 375\n"
"  testing 91                                            sketch of 356\n"
"  unique powers of 106                            auxiliary 374\n"
"  when to use 106                                       sketch of 356\n"
"  see also: backquote, read-macros,               before- 374\n"
"         symbol-macros                                  sketch of 357\n"
"mainframes 348                                    of classes 368\n"
"make-dispatch-macro-character 226                 without classes 371\n"
"make-instance 365                                 as closures 378\n"
"make-hash-table 65                                redefining 372\n"
"make-string 58                                    removing 373\n"
"map-> 54                                                sketch of 359\n"
"map0-n 54                                         isomorphic to slots 368\n"
"map1-n 54                                         specialization of 369\n"
"mapa-b 54, 228                                          on objects 371\n"
"mapc 163                                                on types 370\n"
"mapcan 41, 46                                     see also: generic "
"functions\n"
"  nondestructive version 55                     method combination\n"
"  sketch of 55                                    and\n"
"mapcar 13                                               sketch of 363\n"
"  version for multiple lists 55                   operator 376\n"
"  version for trees 55                                  sketch of 362\n"
"mapcars 54                                        or\n"
"mapcon 176, 218                                         sketch of 363\n"
"mappend 54                                        progn\n"
"mappend-mklist idiom 160                                sketch of 362\n"
"mapping functions 53                              standard 376\n"
"mark 301                                                sketch of 358\n"
"match 239                                       :method-combination 377\n"
"matching-see pattern-matching                   Michelangelo 11\n"
"maxmin 207                                      mines 264\n"
"Meehan, James R. 396                            mklist 45, 160\n"
"member 88                                       mkstr 58"
msgstr ""

#: texi/node-25.texi:2813
msgid ""
"                                              INDEX                                        "
"409"
msgstr ""

#: texi/node-25.texi:2860
msgid ""
"modularity 167, 381, 382                                    restrictions on "
"297\n"
"de Montaigne, Michel 2                                      and tail-"
"recursion optimization 298,\n"
"most 52                                                        396\n"
"most-of 182                                              Scheme "
"implementation 293\n"
"mostn 52                                                 appearance of "
"foresight 289\n"
"moving parts 4                                           breadth-first 303\n"
"multiple inheritance-see inheritance,                    correct 302\n"
"           multiple                                      depth-first 292\n"
"multiple values 32                                          in ATNs 308\n"
"  to avoid side-effects 32                                  nonterminating "
"293\n"
"  to distinguish failure from falsity 196,                  in Prolog 334\n"
"           239                                           in functional "
"programs 286\n"
"  in generalized variables 172                           vs. iteration 291, "
"325\n"
"  iteration with 158                                     optimizing 298\n"
"  receiving-see multiple-value-bind                      and parsing-see "
"ATNs\n"
"  returning-see values                                   and search 290\n"
"multiple-value-bind 32                                   see also: choose, "
"fail\n"
"  leftover parameters nil 234                          Norvig, Peter 199\n"
"multiprocessing 275                                    nreverse 31\n"
"mvdo 162                                                 sketch of 388\n"
"mvdo* 159                                              nthmost 183\n"
"mvpsetq 161\n"
"Mythical Man-Month, The 5                              object-oriented "
"programming\n"
"                                                         dangers of 379\n"
"name-spaces 12, 205, 259, 273, 384, 392                  defining features "
"of 350\n"
"natural language-see ATNs                                like distributed "
"systems 348\n"
"nconc 31, 35, 137                                        and extensibility "
"16, 379\n"
"negation                                                 name of 349\n"
"  of facts 249                                           in plain Lisp 349\n"
"  in Prolog 325                                          see also: C++; "
"classes; CLOS; generic\n"
"  in queries 252                                               functions; "
"inheritance; methods;\n"
"networks                                                       message-"
"passing; slots; Smalltalk\n"
"  representing 76, 79                                  on-cdrs 205\n"
"next-method-p 375                                      on-trees 210\n"
"  sketch of 358                                        open systems 6\n"
":nicknames 384                                         open-coding-see "
"compilation, inline\n"
"nif 150                                                orthogonality 63\n"
"nildefault block name 131                              *package* 125, 381\n"
"  forbidden in case clauses 153                        packages 381\n"
"  multiple roles of 51, 195                              aberrations "
"involving 384\n"
"nilf 169                                                 avoiding capture "
"with 130, 131\n"
"Nitzberg, Mark-see joke, practical                       creating 382\n"
"nondeterministic choice 286                              current 381\n"
"  Common Lisp implementation 295                         using distinct 131, "
"382\n"
"     need for CPS macros 296                             inheriting symbols "
"from 384"
msgstr ""

#: texi/node-25.texi:2863
msgid "410                                        INDEX"
msgstr ""

#: texi/node-25.texi:2912
msgid ""
"  nicknames for 384                                      order of 329\n"
"  switching 382                                       subverting 346\n"
"  user 381                                            syntax of 331\n"
"  see also: intern; interning                       promises 211\n"
"parsers, nondeterministic-see ATNs                  prompt 56\n"
"paths, traversing 155                               property lists 15, 63, "
"216\n"
"pat-match 242                                       propmacro 216\n"
"pattern-matching 186, 238                             alternative definition "
"393\n"
"pattern variables 238                               propmacros 216\n"
"phrenology 30                                       prune 47\n"
"planning 2                                            simpler version 389\n"
"pointers 76                                         pruning search trees-see "
"cut\n"
"pools 313                                           psetq 96\n"
"popn 173                                              multiple-valued "
"version 161\n"
"pop-symbol 220                                      pull 173, 223\n"
"position 49                                         pull-if 173\n"
"*print-array* 245                                   push-nreverse idiom 47\n"
"*print-circle* 70                                   pushnew 174\n"
"print-names 57, 129, 382\n"
"processes 275                                       queries\n"
"  instantiation of 278                                complex 249, 335\n"
"  scheduling of 279                                   conditional 191\n"
"  state of 278                                      query languages 249\n"
"proclaim 23, 45                                     quicksort 345\n"
"productivity 5                                      quote 84, 391\n"
"programming languages                                 see also: '\n"
"  battlefield of 8                                  quoted lists, returning "
"37, 139\n"
"  embedded-see embedded languages\n"
"  expressive power of vii\n"
"  extensible 5                                      rapid prototyping 1, "
"284\n"
"  high-level 8                                        of individual "
"functions 24, 48\n"
"  see also: Algol; Basic; C; C++; Com-              read 56, 128, 197, 224\n"
"         mon Lisp; Fortran; Lisp; Pro-              read-delimited-list 227\n"
"         log; Scheme; Smalltalk; T                  :reader 367\n"
"Prolog 321                                          read-eval-print loop 57\n"
"  assignment in 343                                 read-from-string 58\n"
"  calling Lisp from 343                             read-line 56\n"
"  case-sensitivity of 331                           readlist 56\n"
"  conceptual ingredients 321                        read-macros 224\n"
"  nondeterminism in 333                             recurser 388\n"
"  programming techniques 332                        recursion\n"
"  restrictions on variables 344                       on cdrs 68, 204\n"
"  rules 329                                           in grammars 306\n"
"       bodyless 323, 330                              in macros 139, 192\n"
"       implicit conjunction in body 328               without naming 388\n"
"       left-recursive 334                             on subtrees 70, 208\n"
"                                                      tail- 23, 140"
msgstr ""

#: texi/node-25.texi:2915
msgid ""
"                                           INDEX                                         "
"411"
msgstr ""

#: texi/node-25.texi:2963
msgid ""
"reduce 207, 363                                     setf 165\n"
"Rees, Jonathan A. 395, 396                             see also: generalized "
"variables, inver-\n"
"referential transparency 198                                   sions\n"
"remove-duplicates                                   set-macro-character 224\n"
"  sketch of 206                                     setq\n"
"remove-if 14                                           destroys referential "
"transparency 198\n"
"remove-if-not 40                                       ok in expansions 100\n"
"rep 324                                                now redundant 170\n"
"reread 58                                           Shapiro, Ehud 398\n"
"&rest parameters 87                                 sharp (#) 226\n"
"  not guaranteed fresh 137                          shuffle 161\n"
"  in utilities 174                                  side-effects 28\n"
"return 131, 155                                        destroy locality 36\n"
"return-from 131, 154                                   in macro expanders "
"136\n"
"return values                                          mitigating 35\n"
"  functions as-see functions, as return                on &rest parameters "
"137\n"
"           values                                      on quoted objects 37\n"
"  multiple-see multiple values                      signum 86\n"
"re-use of software 4                                simple? 242\n"
"reverse 30                                          single 45\n"
"rfind-if 73, 210                                    Sistine Chapel 11\n"
"  alternate version 390                             skeletons-see macros, "
"skeletons of\n"
"rget 351                                            sketches 284\n"
"rich countries 285                                  sleep 65\n"
"rmapcar 54                                          slots\n"
"Rome 283                                               accessor functions "
"for 365\n"
"rotatef 29                                             declaring 364\n"
"rplaca 166                                             as global variables "
"379\n"
"rules                                                  initializing 365\n"
"  structure of 322                                     isomorphic to methods "
"368\n"
"  as virtual facts 323                                 read-only 367\n"
"  see also: Prolog, rules in                           shared 367\n"
"                                                    Smalltalk 350\n"
"Scheme                                              some\n"
"  vs. Common Lisp 259                                  sketch of 206\n"
"  cond 192                                          sort 14, 352\n"
"  macros in 392                                     sortf 176\n"
"  returning functions in 62                         sorting\n"
"scope 16, 62                                           of arguments 176\n"
"scoundrels, patriotic 352                              partial 184\n"
"scrod 219                                              see also: stable-"
"sort\n"
"search trees 265                                    special 17\n"
"sequence operators 244                              special forms 9, 391\n"
"series 55                                           specialization-see "
"methods, specializa-\n"
"set 178                                                        tion of\n"
"set-difference 207                                  speed 23"
msgstr ""

#: texi/node-25.texi:2966
msgid "412                                         INDEX"
msgstr ""

#: texi/node-25.texi:3014
msgid ""
"splicing 86                                          tagbody 155\n"
"splines-see Bezier curves                            tail-recursion "
"optimization 22\n"
"split-if 50                                            needed with CPS "
"macros 298\n"
"sqrt 32                                                testing for 388, 396\n"
"squash 160                                           taxable operators 32\n"
"stable-sort 352, 399                                 testing\n"
"stacks                                                 incremental 37\n"
"  allocation on 150                                    of macros-see macros, "
"testing\n"
"  of ATN registers 312                               TEX vi, 5\n"
"  in continuations 260, 261                          tf 169\n"
"  use for iteration 264                              Theodebert 236\n"
"  overflow of 396                                    three-valued logic 151\n"
"Steele, Guy Lewis Jr. ix, 43, 213, 395,              till 154\n"
"           396                                       time 65, 359\n"
"Sterling, Leon 398                                   times of evaluation "
"224, 229\n"
"strings                                              toggle 169\n"
"  building 57                                        top-down design 3\n"
"  matching 231, 244                                  trace 111, 266, 309\n"
"  as vectors 233                                     transition networks "
"306\n"
"Structure and Interpretation of Computer             transformation\n"
"           Programs 18                                 embedded languages "
"implemented by\n"
"structured programming 100                                      116, 241\n"
"subseq 244                                             of macro arguments "
"107, 112\n"
"superclasses                                         trec 75\n"
"  precedence of 369                                  trees 70, 262\n"
"       sketch of 352                                   cross-products of "
"265\n"
"Sussman, Gerald Jay 18, 395                            leavesof72\n"
"symb 58                                                recursers on 70\n"
"symbols                                              true-choose\n"
"  building 57                                          breadth-first version "
"304\n"
"  as data 385                                                 T "
"implementation 396\n"
"  exported 383                                         depth-first version "
"396\n"
"  imported 383                                       truncate 32\n"
"  interning-see intern                               ttrav 74\n"
"  names of 57, 129, 382                              Turing Machines vii\n"
"  see also: keywords                                 twenty questions 77\n"
"symbol-function 12, 388                              typecase 62\n"
"symbolic computation 398                             type-of 371\n"
"symbol-macrolet 105, 205, 210                        typep 243\n"
"symbol-name 58                                       types\n"
"symbol-package 381                                     declaration of 23\n"
"symbol-value 12, 178                                   specialization on "
"370\n"
"symbol-macros 105, 205, 236, 237                     typing 44, 112\n"
"swapping values 29\n"
"                                                     undefmethod 373\n"
"T 396                                                unification 394"
msgstr ""

#: texi/node-25.texi:3017
msgid ""
"                                            INDEX                                "
"413"
msgstr ""

#: texi/node-25.texi:3030
msgid ""
"union 206                                            with-output-to-string "
"58\n"
"   unspecified order of result 207, 364              with-places 237\n"
"unions 207                                           with-slots 236\n"
"unspecialized parameters 373                         with-struct 235\n"
"unwind-protect 148                                   writer's cramp 44\n"
":use 384                                             &whole 95\n"
"user 381                                             Woods, William A. 305\n"
"utilities 40                                         workstations 348\n"
"   as an investment 43, 392                          world, ideal 109\n"
"   become languages 113\n"
"   mistaken argument against 59                      X Windows vi, 5"
msgstr ""

#: texi/node-25.texi:3066
msgid ""
"var? 239                                             zebra benchmark 396\n"
"variable capture-see capture\n"
"variables\n"
"   bound 16                                          #' 10, 226\n"
"   free 16, 121                                      #( 233\n"
"   generalized-see generalized variables             #. 75\n"
"   global 36, 125, 268, 379                          #: 128\n"
"varsym? 239                                          #? 226\n"
"   redefined 335                                     #[ 227\n"
"vectors                                              #\\ 233\n"
"   for ATN registers 313                             #@{ 229\n"
"   creating with backquote 86                        ' 225\n"
"   matching 231, 244                                   see also: quote\n"
"visual aspects of source code 30, 213,               , 84\n"
"           231                                       ,@@ 86, 138\n"
"voussoirs 8                                          : 383\n"
"values 32                                            :: 382\n"
"   inversion for 393                                 @@ 294\n"
"=values 267                                           240, 252, 328\n"
"                                                     ` see backquote\n"
"                                                     | 58\n"
"wait 280\n"
"Wand, Mitchell 395\n"
"Weicker, Jacqueline J. x\n"
"when-bind 145\n"
"when-bind* 145\n"
"while 154\n"
"with-answer 251\n"
"   redefined 255\n"
"with-array 234\n"
"with-gensyms 145\n"
"with-inference 324\n"
"   redefined 335, 340\n"
"with-matrix 234\n"
"with-open-file 147"
msgstr ""

#: texi/node-25.texi:3070
msgid ""
"@node Concept Index, Function Index, Book's Index, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@unnumbered Concept Index"
msgstr ""

#: texi/node-25.texi:3072
msgid "@printindex cp"
msgstr ""

#: texi/node-25.texi:3076
msgid ""
"@node Function Index,  , Concept Index, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@unnumbered Function Index"
msgstr ""

#: texi/node-25.texi:3078
msgid "@printindex fn"
msgstr ""

#: texi/node-25.texi:3079
msgid "@bye"
msgstr ""
