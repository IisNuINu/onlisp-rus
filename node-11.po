#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-11.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-05-16 11:12+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-11.texi:5
msgid ""
"@node 11 Classic Macros, 12 Generalized Variables, 10 Other Macro Pitfalls, "
"Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 11 Classic Macros\n"
"@cindex 11 Classic Macros"
msgstr ""
"@node 11 Classic Macros, 12 Generalized Variables, 10 Other Macro Pitfalls, "
"Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 11 Классические Макросы\n"
"@cindex 11 Classic Macros"

#: texi/node-11.texi:12
msgid ""
"This chapter shows how to define the most commonly used types of macros.\n"
"They fall into three categories-with a fair amount of overlap. The first "
"group\n"
"are macros which create context. Any operator which causes its arguments to\n"
"be evaluated in a new context will probably have to be defined as a macro. "
"The\n"
"first two sections describe the two basic types of context, and show how to "
"define\n"
"macros for each."
msgstr ""
"В этой главе показано, как определить наиболее часто используемые типы "
"макросов.\n"
"Они деляться на три категории- с большим количеством пересечений. Первой "
"группой\n"
"являются макросы которые создают контекст. Любой оператор, который вычисляет "
"свои\n"
"аргументы в новом контексте, вероятно должен быть определен как макрос. "
"Первые \n"
"два раздела описывыают два основных типа контекста и показывают, как "
"определять\n"
"макросы для каждого из них."

#: texi/node-11.texi:20
msgid ""
"The next three sections describe macros for conditional and repeated "
"evalua-\n"
"tion. An operator whose arguments are to be evaluated less than once, or "
"more\n"
"than once, must also be defined as a macro. There is no sharp distinction "
"between\n"
"operators for conditional and repeated evaluation: some of the examples in "
"this\n"
"chapter do both (as well as binding). The final section explains another "
"similarity\n"
"between conditional and repeated evaluation: in some cases, both can be "
"done\n"
"with functions."
msgstr ""
"В следующих трех разделах описаны макросы для условных и повторных "
"вычислений.\n"
"Оператор, аргументы которого должны вычисляться менее одного раза, или "
"более\n"
"чем один раз, также должен быть определен как макрос. Там нет четкого "
"различия\n"
"межд операторами для условных и повторных вычислений: некоторые примеры в "
"этой\n"
"главе делают оба вычисления(а также связывание). Последний раздел объясняет\n"
"другое сходство между условными и повторяющимися вычислениями: в некоторых "
"случаях\n"
"можно выполнять оба типа вычислений используя функции."

#: texi/node-11.texi:29
msgid ""
"@menu\n"
"* 11-1 Creating Context::       \n"
"* 11-2 The with- Macro::        \n"
"* 11-3 Conditional Evaluation::  \n"
"* 11-4 Iteration::              \n"
"* 11-5 Iteration with Multiple Values::  \n"
"* 11-6 Need for Macros::        \n"
"@end menu"
msgstr ""

#: texi/node-11.texi:34
msgid ""
"@node 11-1 Creating Context, 11-2 The with- Macro, 11 Classic Macros, 11 "
"Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-1 Creating Context\n"
"@cindex 11-1 Creating Context"
msgstr ""
"@node 11-1 Creating Context, 11-2 The with- Macro, 11 Classic Macros, 11 "
"Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-1 Создание контекста\n"
"@cindex 11-1 Creating Context"

#: texi/node-11.texi:39
msgid ""
"Context here has two senses. One sort of context is a lexical environment. "
"The\n"
"let special form creates a new lexical environment; the expressions in the "
"body\n"
"of a let will be evaluated in an environment which may contain new "
"variables.\n"
"If x is set to a at the toplevel, then"
msgstr ""
"Контекст здесь имеет два смысла. Одним из видов контекста является "
"лексическое\n"
"окружение(среда). Специальная форма let создает новое лексическое "
"окружение; \n"
"выражения в теле let будут вычисляться в окружении, которое может содержать\n"
"новые переменные.\n"
"Если x установлен в a на верхнем уровне, то"

#: texi/node-11.texi:43
msgid ""
"@lisp\n"
"(let ((x 'b)) (list x))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:47
msgid ""
"@noindent\n"
"will nonetheless return (b), because the call to list will be made in an "
"environ-\n"
"ment containing a new x, whose value is b."
msgstr ""
"@noindent\n"
"выражение вернет все же (b), поскольку вызов list будет сделан в окружении, "
"содержещем\n"
"новый x, чьим значением является b."

#: texi/node-11.texi:58
msgid ""
"@lisp\n"
" (defmacro our-let (binds &body body)\n"
"       `((lambda ,(mapcar #'(lambda (x)\n"
"                                     (if (consp x) (car x) x))\n"
"                                binds)\n"
"            ,@@body)\n"
"         ,@@(mapcar #'(lambda (x)\n"
"                            (if (consp x) (cadr x) nil))\n"
"                       binds)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro our-let (binds &body body)\n"
"       `((lambda ,(mapcar #'(lambda (x)\n"
"                                     (if (consp x) (car x) x))\n"
"                                binds)\n"
"            ,@@body)\n"
"         ,@@(mapcar #'(lambda (x)\n"
"                            (if (consp x) (cadr x) nil))\n"
"                       binds)))\n"
"@end lisp"

#: texi/node-11.texi:60
msgid "                     Figure 11-1: Macro implementation of let."
msgstr ""
"                     Рисунок 11-1: Реализация макроса let.\n"
"@end cartouche"

#: texi/node-11.texi:67
msgid ""
"An operator which is to have a body of expressions must usually be defined "
"as\n"
"a macro. Except for cases like prog1 and progn, the purpose of such an "
"operator\n"
"will usually be to cause the body to be evaluated in some new context. A "
"macro\n"
"will be needed to wrap context-creating code around the body, even if the "
"context\n"
"does not include new lexical variables."
msgstr ""
"Оператор, который должен иметь тело выражений, обычно должен быть определен "
"как\n"
"макрос. За исключением случаев, таких как prog1 и progn, цель такого "
"оператор,\n"
"обычно будет вызвать вычисление тела в каком то новом контексте. Марос "
"должен\n"
"будет обернуть вокруг тела код, создающий контекст, даже если контекст не \n"
"включает новые лексические переменные."

#: texi/node-11.texi:70
msgid ""
"Figure 11-1 shows how let could be defined as a macro on lambda.An\n"
"our-let expands into a function application-"
msgstr ""
"Рисунок 11-1 показывает, как let может быть определен через макрос "
"использующий\n"
"lambda. our-let расширяется в применение функции -"

#: texi/node-11.texi:75
msgid ""
"@lisp\n"
"(our-let ((x 1) (y 2))\n"
"  (+ x y))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:78
msgid ""
"@noindent\n"
"expands into"
msgstr ""

#: texi/node-11.texi:82
msgid ""
"@lisp\n"
"((lambda (x y) (+ x y)) 1 2)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:90
msgid ""
"Figure 11-2 contains three new macros which establish lexical environments.\n"
"Section 7-5 used when-bind as an example of parameter list destructuring, so "
"this\n"
"macro has already been described on page 94. The more general when-bind*\n"
"takes a list of pairs of the form (symbol expression)-the same form as the\n"
"first argument to let.If any expression returns nil, the whole when-bind*\n"
"expression returns nil. Otherwise its body will be evaluated with each "
"symbol\n"
"bound as if by let*:"
msgstr ""
"Рисунок 11-2 содержит три новых макроса, которые устанавливают лексическое\n"
"окружение. Раздел 7-5 использовал when-bind в качестве примера "
"деструктуризации\n"
"списка параметров, поэтому этот макрос уже был описан на странице 94. Более\n"
"общий when-bind* принимает список пар вида (symbol expression) - той же "
"формы,\n"
"что и первый аргумент let. Если какое либо выражение возвращает nil, всё "
"выражение\n"
"when-bind* вернет nil. В противном случае его тело будет вычисляться, как "
"будто \n"
"каждый символ связан с помощью let*:"

#: texi/node-11.texi:92
msgid "@example"
msgstr ""

#: texi/node-11.texi:98
msgid ""
"> (when-bind* ((x (find-if #'consp '(a (1 2) b)))\n"
"                       (y (find-if #'oddp x)))\n"
"        (+ y 10))\n"
"11\n"
"@end example"
msgstr ""

#: texi/node-11.texi:102
msgid ""
"Finally, the macro with-gensyms is itself for use in writing macros. Many\n"
"macro definitions begin with the creation of gensyms, sometimes quite a "
"number\n"
"of them. The macro with-redraw (page 115) had to create five:"
msgstr ""
"Наконец, макрос with-gensyms сам по себе используется для написания "
"макросов.\n"
"Много определений макросов начинаются с создания символов с помощью "
"gensyms,\n"
"иногда их чило очень больше. Макрос with-redraw (стр. 115) должен был "
"создать\n"
"пять:"

#: texi/node-11.texi:108
msgid ""
"@lisp\n"
" (defmacro when-bind ((var expr) &body body)\n"
"    `(let ((,var ,expr))\n"
"          (when ,var\n"
"            ,@@body)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro when-bind ((var expr) &body body)\n"
"    `(let ((,var ,expr))\n"
"          (when ,var\n"
"            ,@@body)))"

#: texi/node-11.texi:115
msgid ""
" (defmacro when-bind* (binds &body body)\n"
"    (if (null binds)\n"
"           `(progn ,@@body)\n"
"           `(let (,(car binds))\n"
"                 (if ,(caar binds)\n"
"                    (when-bind* ,(cdr binds) ,@@body)))))"
msgstr ""

#: texi/node-11.texi:122
msgid ""
" (defmacro with-gensyms (syms &body body)\n"
"    `(let ,(mapcar #'(lambda (s)\n"
"                               `(,s (gensym)))\n"
"                          syms)\n"
"          ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:124
msgid "                      Figure 11-2: Macros which bind variables."
msgstr ""
"                      Рисунок 11-2: Макросы которые связывают переменные.\n"
"@end cartouche"

#: texi/node-11.texi:132
msgid ""
"@lisp\n"
"(defmacro with-redraw ((var objs) &body body)\n"
"  (let ((gob (gensym))\n"
"           (x0 (gensym)) (y0 (gensym))\n"
"           (x1 (gensym)) (y1 (gensym)))\n"
"        ...))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:135
msgid ""
"Such definitions are simplified by with-gensyms, which binds a whole list "
"of\n"
"variables to gensyms. With the new macro we would write just:"
msgstr ""
"Такие определения гораздо проще с with-gensyms, который связывет целый "
"список\n"
"переменных со символами генерируемыми gensym. С новым макросом мы могли бы\n"
"просто записать:"

#: texi/node-11.texi:141
msgid ""
"@lisp\n"
"(defmacro with-redraw ((var objs) &body body)\n"
"  (with-gensyms (gob x0 y0 x1 y1)\n"
"        ...))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:143
msgid "This new macro will be used throughout the remaining chapters."
msgstr "Этот новый макрос будет использоваться в оставшихся главах."

#: texi/node-11.texi:146
msgid ""
"If we want to bind some variables and then, depending on some condition,\n"
"evaluate one of a set of expressions, we just use a conditional within a let:"
msgstr ""
"Если мы хотим связать некоторые переменные, а затем от некоторых условий,\n"
"вычислить одно из набора выражений, мы просто используем условное выражение\n"
"в let:"

#: texi/node-11.texi:152
msgid ""
"@lisp\n"
"(let ((sun-place 'park) (rain-place 'library))\n"
"  (if (sunny)\n"
"          (visit sun-place)\n"
"          (visit rain-place)))"
msgstr ""
"@lisp\n"
"(let ((sun-place 'park) (rain-place 'library))\n"
"  (if (sunny)\n"
"          (visit sun-place)\n"
"          (visit rain-place)))\n"
"@end lisp"

#: texi/node-11.texi:165
msgid ""
" (defmacro condlet (clauses &body body)\n"
"       (let ((bodfn (gensym))\n"
"              (vars (mapcar #'(lambda (v) (cons v (gensym)))\n"
"                                (remove-duplicates\n"
"                                  (mapcar #'car\n"
"                                             (mappend #'cdr clauses))))))\n"
"         `(labels ((,bodfn ,(mapcar #'car vars)\n"
"                         ,@@body))\n"
"             (cond ,@@(mapcar #'(lambda (cl)\n"
"                                       (condlet-clause vars cl bodfn))\n"
"                                 clauses)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro condlet (clauses &body body)\n"
"       (let ((bodfn (gensym))\n"
"              (vars (mapcar #'(lambda (v) (cons v (gensym)))\n"
"                                (remove-duplicates\n"
"                                  (mapcar #'car\n"
"                                             (mappend #'cdr clauses))))))\n"
"         `(labels ((,bodfn ,(mapcar #'car vars)\n"
"                         ,@@body))\n"
"             (cond ,@@(mapcar #'(lambda (cl)\n"
"                                       (condlet-clause vars cl bodfn))\n"
"                                 clauses)))))"

#: texi/node-11.texi:170
msgid ""
" (defun condlet-clause (vars cl bodfn)\n"
"       `(,(car cl) (let ,(mapcar #'cdr vars)\n"
"                        (let ,(condlet-binds vars cl)\n"
"                          (,bodfn ,@@(mapcar #'cdr vars))))))"
msgstr ""

#: texi/node-11.texi:179
msgid ""
" (defun condlet-binds (vars cl)\n"
"       (mapcar #'(lambda (bindform)\n"
"                     (if (consp bindform)\n"
"                          (cons (cdr (assoc (car bindform) vars))\n"
"                                  (cdr bindform))))\n"
"                (cdr cl)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:181
msgid "                    Figure 11-3: Combination of cond and let."
msgstr ""
"                    Рисунок 11-3: Комбинация cond и let.\n"
"@end cartouche"

#: texi/node-11.texi:186
msgid ""
"Unfortunately, there is no convenient idiom for the opposite situation, "
"where\n"
"we always want to evaluate the same code, but where the bindings must vary\n"
"depending on some condition."
msgstr ""
"К сожалению, нет удобной идиомы длля противоположной ситуации, когда мы "
"хотим\n"
"всегда вычислить один и тот же код, но где привязки длжны отличаться в "
"зависимости\n"
"от некоторых условий."

#: texi/node-11.texi:194
msgid ""
"Figure 11-3 contains a macro intended for such situations. As its name\n"
"suggests, condlet behaves like the offspring of cond and let. It takes as\n"
"arguments a list of binding clauses, followed by a body of code. Each of "
"the\n"
"binding clauses is guarded by a test expression; the body of code will be "
"evaluated\n"
"with the bindings specified by the first binding clause whose test "
"expression returns\n"
"true. Variables which occur in some clauses and not others will be bound to "
"nil\n"
"if the successful clause does not specify bindings for them:"
msgstr ""
"Рисунок 11-3 содержит макрос предназначеный для таких ситуаций. Назаченное "
"ему\n"
"имя, предполагает, что condlet ведет себя как потомок cond и let. Он "
"требует\n"
"в качестве аргументов список связывающих предложений, за которым следует\n"
"тело кода. Каждое из связвающих предложений защищено тестовым выражением; "
"тело\n"
"кода будет вычислено с привязками указанными предложением, чье тестовое "
"выражене\n"
"первым вернет истинное значение. Переменные, которые встречаются в одних "
"предложениях\n"
"и их нет в других будут связанаы с nil, если в успешном предложении не "
"указаны\n"
"привязки для них:"

#: texi/node-11.texi:203
msgid ""
"@example\n"
"> (condlet (((= 1 2) (x (princ 'a)) (y (princ 'b)))\n"
"                  ((= 1 1) (y (princ 'c)) (x (princ 'd)))\n"
"                  (t          (x (princ 'e)) (z (princ 'f))))\n"
"        (list x y z))\n"
"CD\n"
"(D C NIL)\n"
"@end example"
msgstr ""
"@example\n"
"> (condlet (((= 1 2) (x (princ 'a)) (y (princ 'b)))\n"
"            ((= 1 1) (y (princ 'c)) (x (princ 'd)))\n"
"            (t       (x (princ 'e)) (z (princ 'f))))\n"
"        (list x y z))\n"
"CD\n"
"(D C NIL)\n"
"@end example"

#: texi/node-11.texi:209
msgid ""
"The definition of condlet can be understood as a generalization of the def-\n"
"inition of our-let. The latter makes its body into a function, which is "
"applied\n"
"to the results of evaluating the initial-value forms. A condlet expands into "
"code\n"
"which defines a local function with labels; within it a cond clause "
"determines\n"
"which set of initial-value forms will be evaluated and passed to the "
"function."
msgstr ""
"Определение condlet можно понять как обобщение определения our-let. "
"Последнее\n"
"превращает свое телол в функцию, которая применяется к результатам "
"вычислений\n"
"инициирующих значений форм. condlet расширяется в код, которые определяет\n"
"локальную функцию используя labels; в нем предложение cond определяет, "
"какой\n"
"набором форм инициализирующих значения будет выполнен и передан в функцию."

#: texi/node-11.texi:213
msgid ""
"Notice that the expander uses mappend instead of mapcan to extract the\n"
"variable names from the binding clauses. This is because mapcan is "
"destructive,\n"
"and as Section 10-3 warned, it is dangerous to modify parameter list "
"structure."
msgstr ""
"Обратите внимание, что расширитель использжует mappend вместо mapcan для "
"извлечения\n"
"имен переменных из связывающих предложений. Это сделано потому, что mapcan "
"является\n"
"деструктивной функций, а как указано в Разделе 10-3, опасно изменять "
"структуру\n"
"списка параметров."

#: texi/node-11.texi:218
msgid ""
"@node 11-2 The with- Macro, 11-3 Conditional Evaluation, 11-1 Creating "
"Context, 11 Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-2 The with- Macro\n"
"@cindex 11-2 The with- Macro"
msgstr ""
"@node 11-2 The with- Macro, 11-3 Conditional Evaluation, 11-1 Creating "
"Context, 11 Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-2 Макрос with-\n"
"@cindex 11-2 The with- Macro"

#: texi/node-11.texi:224
msgid ""
"There is another kind of context besides a lexical environment. In the "
"broader\n"
"sense, the context is the state of the world, including the values of "
"special variables,\n"
"the contents of data structures, and the state of things outside Lisp. "
"Operators\n"
"which build this kind of context must be defined as macros too, unless their "
"code\n"
"bodies are to be packaged up in closures."
msgstr ""
"Существует еще один вид контекста по мимо лексического окружения. В более "
"широком\n"
"смысле, контекст - это состояние мира, в том числе значений специальных "
"переменных,\n"
"содержимое структур данных и состояние снаружи Lisp. Операторы, которые "
"создают\n"
"этот вид контекста, также должны быть определены как макросы, если только их "
"тело\n"
"кода не должно быть упаковано в замыкание."

#: texi/node-11.texi:228
msgid ""
"The names of context-building macros often begin with with-. The most\n"
"commonly used macro of this type is probably with-open-file. Its body is\n"
"evaluated with a newly opened file bound to a user-supplied variable:"
msgstr ""
"Имена макросов создающих контекст часто начинаются с префикса with-. \n"
"Большинство обычно используемых макросов этого типа, вероятно  \n"
"with-open-file. Его тело вычисляется в контексте вновь открытого файла,\n"
"привязванного к определяемой пользователем переменной:"

#: texi/node-11.texi:233
msgid ""
"@lisp\n"
"(with-open-file (s \"dump\" :direction :output)\n"
"  (princ 99 s))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:236
msgid ""
"After evaluation of this expression the file \"dump\" will automatically be "
"closed,\n"
"and its contents will be the two characters \"99\"."
msgstr ""
"После вычисления этого выражения файл \"dump\" автоматически закроется, и "
"его\n"
"содержимое будет состоять из двух знаков \"99\"."

#: texi/node-11.texi:245
msgid ""
"This operator clearly has to be defined as a macro,because it binds s. "
"However,\n"
"operators which cause forms to be evaluated in a new context must be defined "
"as\n"
"macros anyway. The ignore-errors macro, new in CLTL2, causes its arguments\n"
"to be evaluated as if in a progn. If an error occurs at any point, the "
"whole\n"
"ignore-errors form simply returns nil. (This would be useful, for example,\n"
"when reading input typed by the user.) Though ignore-errors creates no\n"
"variables, it still must be defined as a macro, because its arguments are "
"evaluated\n"
"in a new context."
msgstr ""
"Этот оператор должен быть явно определен как макрос, поскольку он связывает\n"
"переменную s. Тем не менее, операторы, которые вызывают вычисление форм в "
"новом\n"
"контексте, в любом случае должны быть определены как макросы. Макрос ignore-"
"errors\n"
"новый в CLTL2, вызывает вычисление своих аргументов как будто они "
"выполняются в \n"
"progn. Если в некоторый момент возникает ошибка, вся форма  ignore-errors "
"просто\n"
"возвращет nil. (это было бы полезно, например при чтении набираемых "
"пользователем\n"
"символьных знаков). Хотя ignore-errors не создает переменных, он все равно "
"должен \n"
"быть определен как макрос, потому что его аргументы вычисляются в новом "
"контексте."

#: texi/node-11.texi:252
msgid ""
"Generally, macros which create context will expand into a block of code;\n"
"additional expressions may be placed before the body, after it, or both. If "
"code\n"
"occurs after the body, its purpose may be to leave the system in a "
"consistent\n"
"state-to clean up something. For example, with-open-file has to close the\n"
"file it opened. In such situations, it is typical to make the context-"
"creating macro\n"
"expand into an unwind-protect."
msgstr ""
"Обычно макросы, которые создают контекст, расширяются в блок кода; "
"дополнительные\n"
"выражения могут быть помещены перед телом, после него или по обоим его "
"сторонам.\n"
"Если код появляется после тела, его цель может состоять в том, чтобы "
"оставить систему\n"
"в устойчивом состоянии - убрать, чтото уже не нужное. Например, with-open-"
"file должен \n"
"закрыть открытый им файл. В таких ситуациях обычно макрос создающий "
"контекст, \n"
"расширяется в unwind-protect."

#: texi/node-11.texi:258
msgid ""
"The purpose of unwind-protect is to ensure that certain expressions are\n"
"evaluated even if execution is interrupted. It takes one or more arguments, "
"which\n"
"are evaluated in order. If all goes smoothly it will return the value of the "
"first\n"
"argument, like a prog1. The difference is, the remaining arguments will be\n"
"evaluated even if an error or throw interrupts evaluation of the first."
msgstr ""
"Цель unwind-protect состоит в том, чтобы гарантировать, что определенные "
"выражения\n"
"вычислятся, даже если выполнение будет прервано. Он принимает один или более "
"аргументов,\n"
"которые вычисляются по порядку. Если все пойдет гладко, он вернет значение "
"первого \n"
"аргумента, как prog1. Разница в том, что остальные аргументы будут вычислены "
"даже\n"
"если ошибка или исключение прервет вычисление первого аргумента."

#: texi/node-11.texi:269
msgid ""
"@example\n"
"> (setq x 'a)\n"
"A> (unwind-protect\n"
"        (progn (princ \"What error?\")\n"
"                 (error \"This error.\"))\n"
"        (setq x 'b))\n"
"What error?\n"
">>Error: This error.\n"
"@end example"
msgstr ""

#: texi/node-11.texi:272
msgid ""
"The unwind-protect form as a whole yields an error. However, after "
"returning\n"
"to the toplevel, we notice that the second argument still got evaluated:"
msgstr ""
"Форма unwind-protect в целом выдает ошибку. Однако, после возвращения на "
"верхний\n"
"уровень, мы замечаем, что второй аргумент все же был вычислен:"

#: texi/node-11.texi:277
msgid ""
"@example\n"
">x\n"
"B\n"
"@end example"
msgstr ""

#: texi/node-11.texi:280
msgid ""
"Because with-open-file expands into an unwind-protect, the file it opens\n"
"will usually be closed even if an error occurs during the evaluation of its "
"body."
msgstr ""
"Поскольку with-open-file расширяется в форму unwind-protect, открываемый "
"файл\n"
"обычно будет закрыт, даже если во время вычисления его тела произойдет "
"ошибка."

#: texi/node-11.texi:287
msgid ""
"Context-creating macros are mostly written for specific applications. As an\n"
"example, suppose we are writing a program which deals with multiple, remote\n"
"databases. The program talks to one database at a time, indicated by the "
"global\n"
"variable *db*. Before using a database, we have to lock it, so that no one "
"else can\n"
"use it at the same time. When we are finished we have to release the lock. "
"If we\n"
"want the value of the query q on the database db, we might say something "
"like:"
msgstr ""
"Макросы создающие контекст в основном пишуться для конкретных приложений. "
"Так\n"
"например, предположим , что мы пишем программу, которая работает с "
"несколькими\n"
"базам данных. Одновренменно программа общается только с одной базой данных,\n"
"указанной в переменной *db*. Перед использованием базы данных мы должны \n"
"заблокировать её, чтобы никто другой не смог использовать ее одновременно с "
"нами.\n"
"Когда мы закончим, мы должны снять блокировку. Если мы хотим получить "
"значение\n"
"запроса q в базе данных db, мы можем сказать что то вроде:"

#: texi/node-11.texi:296
msgid ""
"@lisp\n"
"(let ((temp *db*))\n"
"     (setq *db* db)\n"
"     (lock *db*)\n"
"     (prog1 (eval-query q)\n"
"              (release *db*)\n"
"              (setq *db* temp)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:300
msgid ""
"With a macro we can hide all this bookkeeping. Figure 11-4 defines a macro\n"
"which will allow us to deal with databases at a higher level of abstraction. "
"Using\n"
"with-db, we would say just:"
msgstr ""
"С помощью макрса мы можем скрыть всю эту бухгалтерию. Рисунок 11-4 "
"определяет макрос,\n"
"который позволит нам иметь дело с базами данных н а более высоком уровне "
"абстракции.\n"
"С помощью with-db, мы бы просто сказали:"

#: texi/node-11.texi:302
msgid "Pure macro:"
msgstr ""
"@cartouche\n"
"Чистый макрос:"

#: texi/node-11.texi:316
msgid ""
"@lisp\n"
" (defmacro with-db (db &body body)\n"
"    (let ((temp (gensym)))\n"
"        `(let ((,temp *db*))\n"
"          (unwind-protect\n"
"             (progn\n"
"                  (setq *db* ,db)\n"
"                  (lock *db*)\n"
"                  ,@@body)\n"
"             (progn\n"
"                  (release *db*)\n"
"                  (setq *db* ,temp))))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:319
msgid ""
"@noindent\n"
"Combination of macro and function:"
msgstr ""
"@noindent\n"
"Комбинация макроса и функции:"

#: texi/node-11.texi:326
msgid ""
"@lisp\n"
" (defmacro with-db (db &body body)\n"
"    (let ((gbod (gensym)))\n"
"        `(let ((,gbod #'(lambda () ,@@body)))\n"
"          (declare (dynamic-extent ,gbod))\n"
"          (with-db-fn *db* ,db ,gbod))))"
msgstr ""

#: texi/node-11.texi:337
msgid ""
" (defun with-db-fn (old-db new-db body)\n"
"    (unwind-protect\n"
"        (progn\n"
"         (setq *db* new-db)\n"
"         (lock *db*)\n"
"         (funcall body))\n"
"        (progn\n"
"         (release *db*)\n"
"         (setq *db* old-db))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:339
msgid "                       Figure 11-4: A typical with- macro."
msgstr ""
"                       Рисунок 11-4: Типичный макрос with-.\n"
"@end cartouche"

#: texi/node-11.texi:345
msgid ""
"@lisp\n"
"(with-db db\n"
"  (eval-query q))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:348
msgid ""
"Calling with-db is also safer, because it expands into an unwind-protect\n"
"instead of a simple prog1."
msgstr ""
"Вызов with-db также безопаснее, поскольку он разворачивается в unwind-"
"protect\n"
"вместо простого prog1."

#: texi/node-11.texi:352
msgid ""
"The two definitions of with-db in Figure 11-4 illustrate two possible ways\n"
"to write this kind of macro. The first is a pure macro, the second a "
"combination\n"
"of a function and a macro. The second approach becomes more practical as the"
msgstr ""
"Два определения with-db на рисунке 11-4 илюстрируют два возможных пути "
"написания\n"
"этого макроса. Первый чистый макрос, второй комбинация макроса и функции. "
"Второй\n"
"подход становиться более практичным, так как"

#: texi/node-11.texi:359
msgid ""
"@lisp\n"
" (defmacro if3 (test t-case nil-case ?-case)\n"
"       `(case ,test\n"
"           ((nil) ,nil-case)\n"
"           (?       ,?-case)\n"
"           (t       ,t-case)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro if3 (test t-case nil-case ?-case)\n"
"       `(case ,test\n"
"           ((nil) ,nil-case)\n"
"           (?       ,?-case)\n"
"           (t       ,t-case)))"

#: texi/node-11.texi:367
msgid ""
" (defmacro nif (expr pos zero neg)\n"
"       (let ((g (gensym)))\n"
"         `(let ((,g ,expr))\n"
"             (cond ((plusp ,g) ,pos)\n"
"                      ((zerop ,g) ,zero)\n"
"                      (t ,neg)))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:369
msgid "                    Figure 11-5: Macros for conditional evaluation."
msgstr ""
"                    Рисунок 11-5: Макрос для условных вычислений.\n"
"@end cartouche"

#: texi/node-11.texi:373
msgid ""
"@noindent\n"
"desired with- macro grows in complexity."
msgstr ""
"@noindent\n"
"у искомого макроса with- возрастает сложность."

#: texi/node-11.texi:380
msgid ""
"In CLTL2 Common Lisp, the dynamic-extent declaration allows the closure\n"
"containing the body to be allocated more efficiently (in CLTL1 "
"implementations,\n"
"it will be ignored). We only need this closure for the duration of the call "
"to\n"
"with-db-fn, and the declaration says as much, allowing the compiler to "
"allocate\n"
"space for it on the stack. This space will be reclaimed automatically on "
"exit from\n"
"the let expression, instead of being reclaimed later by the garbage-"
"collector."
msgstr ""
"В CLTL2 Common Lisp, объявление dynamic-extent позволяет замыканию "
"содержащему\n"
"тело более эффективно его размещать (в реализации CLTL1 оно будет "
"игнорироваться).\n"
"Нам нужно это замкание только на время вызова with-db-fn, и объявление "
"говорит о\n"
"том же, позволяя компилятору выделить для него место в стеке. Это "
"пространство\n"
"будет автоматически восстановлено(возвращено) при выходе из выражения let,\n"
"вместо того, чтобы быть восстановленым позже с помощью сборщика мусора."

#: texi/node-11.texi:385
msgid ""
"@node 11-3 Conditional Evaluation, 11-4 Iteration, 11-2 The with- Macro, 11 "
"Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-3 Conditional Evaluation\n"
"@cindex 11-3 Conditional Evaluation"
msgstr ""
"@node 11-3 Conditional Evaluation, 11-4 Iteration, 11-2 The with- Macro, 11 "
"Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-3 Условное Вычисление\n"
"@cindex 11-3 Conditional Evaluation"

#: texi/node-11.texi:391
msgid ""
"Sometimes we want an argument in a macro call to be evaluated only under\n"
"certain conditions. This is beyond the ability of functions, which always "
"evaluate\n"
"all their arguments. Built-in operators like if, and, and cond protect some "
"of\n"
"their arguments from evaluation unless other arguments return certain "
"values. For\n"
"example, in this expression"
msgstr ""
"Иногда мы хотим, чтобы аргумент в вызове макроса вычслялся только при "
"выполеннии\n"
"определенного условия. Это находиться за пределами возможностей функции, "
"которые \n"
"всегда вычисляют свои аргументы. Встроенные операторы, такие как if, and, и "
"cond \n"
"защищают некоторые из своих аргументов от вычислений, если другие аргументы\n"
"не возвращают определенных значений. Для примера, в этом выражении"

#: texi/node-11.texi:396
msgid ""
"@lisp\n"
"(if t'phew\n"
"        (/ x 0))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:400
msgid ""
"the third argument would cause a division-by-zero error if it were "
"evaluated. But\n"
"since only the first two arguments ever will be evaluated, the if as a whole "
"will\n"
"always safely return phew."
msgstr ""
"третий аргумент вызвал бы ошибку деления на ноль, если бы был вычислен. Но "
"поскольку\n"
"только первые два аргумента будут когда либо вычислены, этот if в целом "
"будет всегда\n"
"безопасно возвращать phew."

#: texi/node-11.texi:407
msgid ""
"We can create new operators of this sort by writing macros which expand "
"into\n"
"calls to the existing ones. The two macros in Figure 11-5 are two of many "
"possible\n"
"variations on if. The definition of if3 shows how we could define a "
"conditional\n"
"for a three-valued logic. Instead of treating nil as false and everything "
"else\n"
"as true, this macro considers three categories of truth: true, false, and "
"uncertain,\n"
"represented as ?. It might be used as in the following description of a five "
"year-old:"
msgstr ""
"Мы можем создавать новые операторы такого рода, написав макросы, которые "
"расширяются\n"
"в вызовы существующих макросов.  Два макроса на рисунке 11-5 являются двумя "
"из многих\n"
"возможных варинтов if. Определение if3 показывает, как мы можем опредилить "
"условие\n"
"для трех значной логики. Вместо того. чтобы рассматривать nil как ложь и все "
"остальное\n"
"как истину, этот макрос рассматривате три категории истин: истина(true), "
"ложь(false) и\n"
"неопределенность(uncertain), представленную как ?. Это может быть "
"использовано в\n"
"следующем описании пятилетнего ребенка:"

#: texi/node-11.texi:415
msgid ""
"@lisp\n"
"(while (not sick)\n"
"  (if3 (cake-permitted)\n"
"         (eat-cake)\n"
"         (throw 'tantrum nil)\n"
"         (plead-insistently)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(while (not sick)\n"
"  (if3 (cake-permitted)\n"
"         (eat-cake)\n"
"         (throw 'tantrum nil)\n"
"         (plead-insistently)))\n"
"(пока (не болен)\n"
"  (if3 (торт-разрешен)\n"
"         (ем-торт)\n"
"         (выброшу 'истерику nil)\n"
"         (настойчиво-умоляю)))\n"
"@end lisp"

#: texi/node-11.texi:419
msgid ""
"The new conditional expands into a case. (The nil key has to be enclosed "
"within\n"
"a list because a nil key alone would be ambiguous.) Only one of the last "
"three\n"
"arguments will be evaluated, depending on the value of the first."
msgstr ""
"Новое условие расширяется в case. (ключ nil должен быть заключен в список, \n"
"поскольку в одиночку ключ nil будет неоднознаным.) Только один из последних\n"
"трех аргументов будет вычислен, в зависимости от значения первого аргумента."

#: texi/node-11.texi:423
msgid ""
"The name nif stands for \"numeric if.\" Another implementation of this "
"macro\n"
"appeared on page 86. It takes a numeric expression as its first argument, "
"and\n"
"depending on its sign evaluates one of the remaining three arguments."
msgstr ""
"Имя nif означает \"числовой(numeric) if.\" Другая реализация этого макроса \n"
"представлена на странице 86. Он принимает числовое выражение в качестве \n"
"первого аргумента и в зависимости от его знака вычисляется один из трех\n"
"оставшихся аргументов."

#: texi/node-11.texi:430
msgid ""
"@example\n"
"> (mapcar #'(lambda (x)\n"
"                   (nif x 'p 'z 'n))\n"
"              '(0 1 -1))\n"
"(ZPN)\n"
"@end example"
msgstr ""

#: texi/node-11.texi:435
msgid ""
"Figure 11-6 contains several more macros which take advantage of "
"conditional\n"
"evaluation. The macro in is to test efficiently for set membership. When "
"you\n"
"want to test whether an object is one of a set of alternatives, you could "
"express the\n"
"query as a disjunction:"
msgstr ""
"Рисунок 11-6 содержит еще несколько макросов, которые используют условные\n"
"вычисления. Макрос in должен эффективно проверять членство в наборе. Когда "
"вы\n"
"хотите проверить, является ли объект одним из множества альтернатив, вы "
"можете\n"
"выразить запрос как дизъюнкцию:"

#: texi/node-11.texi:440
msgid ""
"@lisp\n"
"(let ((x (foo)))\n"
"  (or (eql x (bar)) (eql x (baz))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:443
msgid ""
"@noindent\n"
"or you could express it in terms of set membership:"
msgstr ""
"@noindent\n"
"или вы можете выразить это в терминах членства в множестве:"

#: texi/node-11.texi:447
msgid ""
"@lisp\n"
"(member (foo) (list (bar) (baz)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:457
msgid ""
"The latter is more abstract, but less efficient. The member expression "
"incurs\n"
"unnecessary costs from two sources. It conses, because it must assemble the\n"
"alternatives into a list for member to search. And to form the alternatives "
"into a\n"
"list they all have to be evaluated, even though some of the values may never "
"be\n"
"needed. If the value of (foo) is equal to the value of (bar), then there is "
"no need\n"
"to evaluate (baz). Whatever its conceptual advantages, this is not a good "
"way to\n"
"use member. We can get the same abstraction more efficiently with a macro: "
"in\n"
"combines the abstraction of member with the efficiency of or. The equivalent "
"in\n"
"expression"
msgstr ""
"Последнее более абстрактнро, но менее эффективно. Выражение member "
"привлекает\n"
"неэффективность из двух источников. Это создание списка(conse), поскольку "
"он\n"
"должен собрать альтернативы в список для функции поиска члена(member). И "
"все\n"
"альтернативные формы в списке должны быть вычислены, хотя некоторые "
"значения,\n"
"возможно, никогда нам не понадобяться.  Если значение (foo) равно значению\n"
"(bar), тогда нет необходимости вычслять значение (baz). Безотносительно его\n"
"концептуальных преимуществ, использовать member далеко не лучший способ. \n"
"Мы можем получить ту же абстракцию более эффективно с помощью макроса:\n"
"сочетающего абстракуию member с эффективностью or. Эквиваленое выражение in"

#: texi/node-11.texi:464
msgid ""
"@lisp\n"
" (defmacro in (obj &rest choices)\n"
"       (let ((insym (gensym)))\n"
"        `(let ((,insym ,obj))\n"
"           (or ,@@(mapcar #'(lambda (c) `(eql ,insym ,c))\n"
"                            choices)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro in (obj &rest choices)\n"
"       (let ((insym (gensym)))\n"
"        `(let ((,insym ,obj))\n"
"           (or ,@@(mapcar #'(lambda (c) `(eql ,insym ,c))\n"
"                            choices)))))"

#: texi/node-11.texi:469
msgid ""
" (defmacro inq (obj &rest args)\n"
"       `(in ,obj ,@@(mapcar #'(lambda (a)\n"
"                                  `',a)\n"
"                              args)))"
msgstr ""

#: texi/node-11.texi:476
msgid ""
" (defmacro in-if (fn &rest choices)\n"
"       (let ((fnsym (gensym)))\n"
"        `(let ((,fnsym ,fn))\n"
"           (or ,@@(mapcar #'(lambda (c)\n"
"                                 `(funcall ,fnsym ,c))\n"
"                            choices)))))"
msgstr ""

#: texi/node-11.texi:482
msgid ""
" (defmacro >case (expr &rest clauses)\n"
"       (let ((g (gensym)))\n"
"        `(let ((,g ,expr))\n"
"           (cond ,@@(mapcar #'(lambda (cl) (>casex g cl))\n"
"                               clauses)))))"
msgstr ""

#: texi/node-11.texi:489
msgid ""
" (defun >casex (g cl)\n"
"       (let ((key (car cl)) (rest (cdr cl)))\n"
"        (cond ((consp key) `((in ,g ,@@key) ,@@rest))\n"
"              ((inq key t otherwise) `(t ,@@rest))\n"
"              (t (error \"bad >case clause\")))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:491
msgid "                Figure 11-6: Macros for conditional evaluation."
msgstr ""
"                Рисунок 11-6: Макросы для условных вычислений.\n"
"@end cartouche"

#: texi/node-11.texi:496
msgid ""
"@lisp\n"
"(in (foo) (bar) (baz))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:499
msgid ""
"@noindent\n"
"has the same shape as the member expression, but expands into"
msgstr ""
"@noindent\n"
"имеет ту же форму, что и выражение member, но расширяется в"

#: texi/node-11.texi:505
msgid ""
"@lisp\n"
"(let ((#:g25 (foo)))\n"
"  (or (eql #:g25 (bar))\n"
"         (eql #:g25 (baz))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:509
msgid ""
"As is often the case, when faced with a choice between a clean idiom and an\n"
"efficient one, we go between the horns of the dilemma by writing a macro "
"which\n"
"transforms the former into the latter."
msgstr ""
"Как это часто бывает, когда сталкиваешся с выбором между ясностью выражения "
"и\n"
"эффективностью, мы получаем неразрешимую дилему, написав макрос мы получаем\n"
"первое и второе, одновременно."

#: texi/node-11.texi:512
msgid ""
"Pronounced \"in queue,\" inq is a quoting variant of in,assetq used to be "
"of\n"
"set. The expression"
msgstr ""
"Произноситься как \"в очереди(in queue),\" inq это квотированный вариант in, "
"так\n"
"же как setq использует set. Выражение"

#: texi/node-11.texi:516
msgid ""
"@lisp\n"
"(inq operator + - *)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:518
msgid "expands into"
msgstr "расширяется в"

#: texi/node-11.texi:522
msgid ""
"@lisp\n"
"(in operator '+ '- '*)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:527
msgid ""
"As member does by default, in and inq use eql to test for equality. When\n"
"you want to use some other test-or any other function of one argument-you\n"
"can use the more general in-if. What in is to member, in-if is to some. The\n"
"expression"
msgstr ""
"Как и member по умолчанию, in и inq используют eql для проверки на "
"равенство.\n"
"Когда вы захотите использовать какую то другую проверку test-or или любую \n"
"другую функцию от одного аргумента - вы можете использовать более общий\n"
"in-if. Как in соответствует member, так in-if соответствует some. \n"
"Выражение"

#: texi/node-11.texi:531
msgid ""
"@lisp\n"
"(member x (list a b) :test #'equal)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:534
msgid ""
"@noindent\n"
"can be duplicated by"
msgstr ""
"@noindent\n"
"может быть продублировано, как"

#: texi/node-11.texi:538
msgid ""
"@lisp\n"
"(in-if #'(lambda (y) (equal x y)) a b)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:541
msgid ""
"@noindent\n"
"and"
msgstr ""
"@noindent\n"
"и"

#: texi/node-11.texi:545
msgid ""
"@lisp\n"
"(some #'oddp (list a b))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:548
msgid ""
"@noindent\n"
"becomes"
msgstr ""
"@noindent\n"
"становиться"

#: texi/node-11.texi:552
msgid ""
"@lisp\n"
"(in-if #'oddp a b)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:560
msgid ""
"Using a combination of cond and in, we can define a useful variant of case.\n"
"The Common Lisp case macro assumes that its keys are constants. Sometimes "
"we\n"
"may want the behavior of a case expression, but with keys which are "
"evaluated.\n"
"For such situations we define >case, like case except that the keys "
"guarding\n"
"each clause are evaluated before comparison. (The > in the name is intended "
"to\n"
"suggest the arrow notation used to represent evaluation.) Because >case uses "
"in,\n"
"it evaluates no more of the keys than it needs to."
msgstr ""
"Используя комбинацию cond и in, мы можем определить полезный варинат case.\n"
"Макрос Common Lisp case предполагает, что его ключи становятся "
"константами. \n"
"Иногда нам может потребоваться поведение выражения case, но с ключами, "
"которые\n"
"вычисляются. Для таких ситуаций мы определяем >case, такой же как case за \n"
"исключением того, что ключи которые охраняют каждое предложение, вычисляются "
"перед\n"
"сравнением. (Знак > в названии предназначен для предложения обозначения "
"стрелки,\n"
"используемое для представления вычислений.) Поскольку >case использует in,\n"
"он вычисляет не больше ключей, чем нужно."

#: texi/node-11.texi:567
msgid ""
"Since keys can be Lisp expressions, there is no way to tell if (x y) is a "
"call or\n"
"a list of two keys. To avoid ambiguity, keys (other than t and otherwise) "
"must\n"
"always be given in a list, even if there is only one of them. In case "
"expressions,\n"
"nil may not appear as the car of a clause on grounds of ambiguity. In a "
">case\n"
"expression, nil is no longer ambiguous as the car of a clause, but it does "
"mean\n"
"that the rest of the clause will never be evaluated."
msgstr ""
"Поскольку ключи могут быть выражениями Lisp, невозможно определить является "
"ли\n"
"(x y) вызовом или списком из двух ключей. Чтобы избежать двусмысленности, "
"ключи\n"
"(кроме t и других) должны всегда указваться в списке, даже если есть только "
"один\n"
"из них. В выражениях case, nil не может выступать в качестве начала(car) "
"предложения\n"
"из за двусмысленности. В выражении >case, nil больше не является "
"двусмысленным, как\n"
"и начало(car) предложения, но он означает, что остальная часть предложения "
"никогда\n"
"не будет вычислена."

#: texi/node-11.texi:570
msgid ""
"For clarity, the code that generates the expansion of each >case clause is\n"
"defined as a separate function, >casex. Notice that >casex itself uses inq."
msgstr ""
"Для ясности, код который генерирует расширение для каждого предложения "
">case\n"
"определяется как отдельная функция, >casex. Обратите внимание, чтоt >casex \n"
"сама использует inq."

#: texi/node-11.texi:576
msgid ""
"@lisp\n"
" (defmacro while (test &body body)\n"
"       `(do ()\n"
"             ((not ,test))\n"
"          ,@@body))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro while (test &body body)\n"
"       `(do ()\n"
"             ((not ,test))\n"
"          ,@@body))"

#: texi/node-11.texi:581
msgid ""
" (defmacro till (test &body body)\n"
"       `(do ()\n"
"             (,test)\n"
"          ,@@body))"
msgstr ""

#: texi/node-11.texi:589
msgid ""
" (defmacro for ((var start stop) &body body)\n"
"       (let ((gstop (gensym)))\n"
"         `(do ((,var ,start (1+ ,var))\n"
"                  (,gstop ,stop))\n"
"               ((> ,var ,gstop))\n"
"             ,@@body)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:591
msgid "                        Figure 11-7: Simple iteration macros."
msgstr ""
"                        Рисунок 11-7: Простые макросы итерации(повторения).\n"
"@end cartouche"

#: texi/node-11.texi:596
msgid ""
"@node 11-4 Iteration, 11-5 Iteration with Multiple Values, 11-3 Conditional "
"Evaluation, 11 Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-4 Iteration\n"
"@cindex 11-4 Iteration"
msgstr ""
"@node 11-4 Iteration, 11-5 Iteration with Multiple Values, 11-3 Conditional "
"Evaluation, 11 Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-4 Итерации(Повторения)\n"
"@cindex 11-4 Iteration"

#: texi/node-11.texi:602
msgid ""
"Sometimes the trouble with functions is not that their arguments are always\n"
"evaluated, but that they are evaluated only once. Because each argument to "
"a\n"
"function will be evaluated exactly once, if we want to define an operator "
"which\n"
"takes some body of expressions and iterates through them, we will have to "
"define\n"
"it as a macro."
msgstr ""
"Иногда проблема с функциями возникает не в том, что их аргументы всегда "
"вычисляются,\n"
"а в том что они вычисляются только один раз. Поскольку каждый аргумент "
"функции будет\n"
"вычислен ровно один раз, если мы хотим определить оператор который получает "
"тело\n"
"выражений и повторяет их вычисление, нам нужно определить его как макрос."

#: texi/node-11.texi:605
msgid ""
"The simplest example would be a macro which evaluated its arguments in\n"
"sequence forever:"
msgstr ""
"Простейшим примером будет макрос, который последовательно вычисляет свои \n"
"аргументы forever:"

#: texi/node-11.texi:612
msgid ""
"@lisp\n"
"(defmacro forever (&body body)\n"
"  `(do ()\n"
"           (nil)\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:618
msgid ""
"This is just what the built-in loop macro does if you give it no loop "
"keywords. It\n"
"might seem that there is not much future (or too much future) in looping "
"forever.\n"
"But combined with block and return-from, this kind of macro becomes the\n"
"most natural way to express loops where termination is always in the nature "
"of an\n"
"emergency."
msgstr ""
"Это именно то, что делает встроенный макрос цикла loops, если вы не даете "
"ему\n"
"ключевых слов цикла. Может показаться, что у такого цикла нет будущего (или\n"
"слишком много будущего) т.к он представляет бесконечный цикл. Но в "
"сочетании\n"
"с block и return-from, этот вид макроса становиться наиболее естественным\n"
"способом выразить циклы, где завершение цикла, по своей природе, это "
"чрезвычайная\n"
"ситуация."

#: texi/node-11.texi:624
msgid ""
"Some of the simplest macros for iteration are shown in Figure 11-7. We\n"
"have already seen while (page 91), whose body will be evaluated while a "
"test\n"
"expression returns true. Its converse is till, which does the same while a "
"test\n"
"expression returns false. Finally for, also seen before (page 129), iterates "
"for a\n"
"range of numbers."
msgstr ""
"Некоторые из простейших макросов для итерации показаны на рисунке 11-7. Мы "
"уже\n"
"видели while (на стр. 91), чье тело будет вычисляться пока тестовое "
"выражение\n"
"возвращает истину. Обратное ему till, которое делает тоже самое пока "
"тестовое \n"
"выражение возвращает ложь. Наконец for, также показанное раньше (стр. "
"129), \n"
"выполняет итерации для диапазона чисел."

#: texi/node-11.texi:631
msgid ""
"By defining these macros to expand into dos, we enable the use of go and\n"
"return within their bodies. As do inherits these rights from block and "
"tagbody,\n"
"while, till, and for inherit them from do. As explained on page 131, the "
"nil\n"
"tag of the implicit block around do will be captured by the macros defined "
"in\n"
"Figure 11-7. This is more of a feature than a bug, but it should at least be "
"mentioned\n"
"explicitly."
msgstr ""
"По определению эти макросы расширяются в do, мы делаем доступным "
"использование go и\n"
"return в их телах. Как do наследует эти права от block и tagbody, так и "
"while, till\n"
"и for наследует их от do. Как объяснено на странице 131, метка nil неявного "
"block \n"
"обернутого вокруг do будет захвачена определенными на Рисунке 11-7. Это "
"скорее\n"
"особенность, чем ошибка, но об этом следует явно упомянуть."

#: texi/node-11.texi:636
msgid ""
"Macros are indispensable when we need to define more powerful iteration\n"
"constructs. Figure 11-8 contains two generalizations of dolist; both "
"evaluate\n"
"their body with a tuple of variables bound to successive subsequences of a "
"list.\n"
"For example, given two parameters, do-tuples/o will iterate by pairs:"
msgstr ""
"Макросы необходимы когда нам нужно определить более мощную конструкцию для \n"
"итерации. Рисунок 11-8 содержит два обобщения dolist; оба вычисляют свои "
"тела\n"
"с набором(tuple) переменных, связанных с последовательными "
"подпоследовательностями\n"
"списка(list). Например, если заданы два параметра do-tuples/o будет "
"итерировать\n"
"по парам:"

#: texi/node-11.texi:643
msgid ""
"@example\n"
"> (do-tuples/o (x y) '(abcd)\n"
"         (princ (list x y)))\n"
"(A B)(B C)(C D)\n"
"NIL\n"
"@end example"
msgstr ""
"@example\n"
"> (do-tuples/o (x y) '(a b c d)\n"
"         (princ (list x y)))\n"
"(A B)(B C)(C D)\n"
"NIL\n"
"@end example"

#: texi/node-11.texi:647
msgid ""
"@noindent\n"
"Given the same arguments, do-tuples/c will do the same thing, then wrap\n"
"around to the front of the list:"
msgstr ""
"@noindent\n"
"С теми же аргументами, do-tuples/c сделает тоже самое, а затем завернёт\n"
"на начало списка, для получения недостающих аргументов:"

#: texi/node-11.texi:654
msgid ""
"@example\n"
"> (do-tuples/c (x y) '(abcd)\n"
"         (princ (list x y)))\n"
"(A B)(B C)(C D)(D A)\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-11.texi:656
msgid ""
"Both macros return nil, unless an explicit return occurs within the body."
msgstr "Оба макроса возвращают nil, если в теле нет явного возрвата return."

#: texi/node-11.texi:662
msgid ""
"This kind of iteration is often needed in programs which deal with some "
"notion\n"
"of a path. The suffixes /o and /c are intended to suggest that the two "
"versions\n"
"traverse open and closed paths, respectively. For example, if points is a "
"list of\n"
"points and (drawline xy) draws the line between x and y, then to draw the "
"path\n"
"from the first point to the last we write."
msgstr ""
"Этот вид итерации часто необходим в программах, которые имеют дело с "
"некоторыми\n"
"представлениями пути. Суфиксы /o и /c предполагают две версии перемещения "
"по\n"
"открытым и замкнутым путям, соответственно. Например, если точки это список\n"
"точек и (drawline x y) рисует линию между x и y, а затем рисует путь от\n"
"первой точки к последней мы напишем."

#: texi/node-11.texi:666
msgid ""
"@lisp\n"
"(do-tuples/o (x y) points (drawline x y))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:670
msgid ""
"@noindent\n"
"whereas, if points is a list of the vertices of a polygon, to draw its "
"perimeter we\n"
"write"
msgstr ""
"@noindent\n"
"тогда как, если точки это список вершин многоугольника, мы рисуем его "
"периметр\n"
"написав"

#: texi/node-11.texi:674
msgid ""
"@lisp\n"
"(do-tuples/c (x y) points (drawline x y))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:677
msgid ""
"The list of parameters given as the first argument can be any length, and\n"
"iteration will proceed by tuples of that length. If just one parameter is "
"given, both"
msgstr ""
"Список аргументов, указанных в качестве первого аргумента, может быть "
"любой \n"
"длины, и итерация буде продолжаться кортежами этой же длины. Если задан "
"только\n"
"один параметр, оба"

#: texi/node-11.texi:687
msgid ""
"@lisp\n"
" (defmacro do-tuples/o (parms source &body body)\n"
"       (if parms\n"
"          (let ((src (gensym)))\n"
"            `(prog ((,src ,source))\n"
"                (mapc #'(lambda ,parms ,@@body)\n"
"                        ,@@(map0-n #'(lambda (n)\n"
"                                         `(nthcdr ,n ,src))\n"
"                                      (1- (length parms))))))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro do-tuples/o (parms source &body body)\n"
"       (if parms\n"
"          (let ((src (gensym)))\n"
"            `(prog ((,src ,source))\n"
"                (mapc #'(lambda ,parms ,@@body)\n"
"                        ,@@(map0-n #'(lambda (n)\n"
"                                         `(nthcdr ,n ,src))\n"
"                                      (1- (length parms))))))))"

#: texi/node-11.texi:705
msgid ""
" (defmacro do-tuples/c (parms source &body body)\n"
"       (if parms\n"
"          (with-gensyms (src rest bodfn)\n"
"            (let ((len (length parms)))\n"
"              `(let ((,src ,source))\n"
"                    (when (nthcdr ,(1- len) ,src)\n"
"                      (labels ((,bodfn ,parms ,@@body))\n"
"                        (do ((,rest ,src (cdr ,rest)))\n"
"                             ((not (nthcdr ,(1- len) ,rest))\n"
"                              ,@@(mapcar #'(lambda (args)\n"
"                                                  `(,bodfn ,@@args))\n"
"                                           (dt-args len rest src))\n"
"                              nil)\n"
"                          (,bodfn ,@@(map1-n #'(lambda (n)\n"
"                                                      `(nth ,(1- n)\n"
"                                                              ,rest))\n"
"                                                   len))))))))))"
msgstr ""

#: texi/node-11.texi:716
msgid ""
" (defun dt-args (len rest src)\n"
"       (map0-n #'(lambda (m)\n"
"                     (map1-n #'(lambda (n)\n"
"                                   (let ((x (+ m n)))\n"
"                                       (if (>= x len)\n"
"                                           `(nth ,(- x len) ,src)\n"
"                                           `(nth ,(1- x) ,rest))))\n"
"                              len))\n"
"              (- len 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:718
msgid "               Figure 11-8: Macros for iteration by subsequences."
msgstr ""
"               Рисунок 11-8: Макросы для итерации на "
"подпоследовательностях.\n"
"@end cartouche"

#: texi/node-11.texi:726
msgid ""
"@lisp\n"
" (do-tuples/c (x y z) '(a b c d)\n"
"       (princ (list x y z)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (do-tuples/c (x y z) '(a b c d)\n"
"       (princ (list x y z)))\n"
"@end lisp"

#: texi/node-11.texi:729
msgctxt "texi/node-11.texi:729"
msgid ""
"@noindent\n"
"expands into:"
msgstr ""
"@noindent\n"
"расширяется в:"

#: texi/node-11.texi:748
msgid ""
"@lisp\n"
" (let ((#:g2 '(a b c d)))\n"
"       (when (nthcdr 2 #:g2)\n"
"         (labels ((#:g4 (x y z)\n"
"                       (princ (list x y z))))\n"
"           (do ((#:g3 #:g2 (cdr #:g3)))\n"
"               ((not (nthcdr 2 #:g3))\n"
"                  (#:g4 (nth 0 #:g3)\n"
"                          (nth 1 #:g3)\n"
"                          (nth 0 #:g2))\n"
"                  (#:g4 (nth 1 #:g3)\n"
"                          (nth 0 #:g2)\n"
"                          (nth 1 #:g2))\n"
"                  nil)\n"
"             (#:g4 (nth 0 #:g3)\n"
"                      (nth 1 #:g3)\n"
"                      (nth 2 #:g3))))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:750
msgid "                  Figure 11-9: Expansion of a call to do-tuples/c."
msgstr ""
"                  Рисунок 11-9: Expansion of a call to do-tuples/c.\n"
"@end cartouche"

#: texi/node-11.texi:754
msgid ""
"@noindent\n"
"degenerate to dolist:"
msgstr ""
"@noindent\n"
"вырождаются в dolist:"

#: texi/node-11.texi:763
msgid ""
"@example\n"
"> (do-tuples/o (x) '(a b c) (princ x))\n"
"ABC\n"
"NIL\n"
"> (do-tuples/c (x) '(a b c) (princ x))\n"
"ABC\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-11.texi:767
msgid ""
"The definition of do-tuples/c is more complex than that of do-tuples/o,\n"
"because it has to wrap around on reaching the end of the list. If there are "
"n\n"
"parameters, do-tuples/c must do n-1 more iterations before returning:"
msgstr ""
"Определение do-tuples/c является более сложным, чем определение do-tuples/"
"o,\n"
"поскольку он должен заворачивать по достижении конца списка. Если есть n\n"
"параметров do-tuples/c должен выполнить еще n-1 итераций перед возвратом:"

#: texi/node-11.texi:773
msgid ""
"@example\n"
"> (do-tuples/c (x y z) '(abcd)\n"
"        (princ (list x y z)))\n"
"(A B C)(B C D)(C D A)(D A B)\n"
"NIL"
msgstr ""

#: texi/node-11.texi:779
msgid ""
"> (do-tuples/c (wxyz)'(abcd)\n"
"           (princ (list w x y z)))\n"
"   (A B C D)(B C D A)(C D A B)(D A B C)\n"
"   NIL\n"
"@end example"
msgstr ""

#: texi/node-11.texi:783
msgid ""
"The expansion of the former call to do-tuples/c is shown in Figure 11-9. "
"The\n"
"hard part to generate is the sequence of calls representing the wrap around "
"to the\n"
"front of the list. These calls (in this case, two of them) are generated by "
"dt-args."
msgstr ""
"Расширение предшествующего вызова do-tuples/c показано на рисунке 11-9. "
"Сложная\n"
"часть для генерации  - это последовательность вызовов представляющих "
"переход\n"
"на начало списка. Эти вызовы (в данном случае два из них) генерируются  dt-"
"args."

#: texi/node-11.texi:788
msgid ""
"@node 11-5 Iteration with Multiple Values, 11-6 Need for Macros, 11-4 "
"Iteration, 11 Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-5 Iteration with Multiple Values\n"
"@cindex 11-5 Iteration with Multiple Values"
msgstr ""
"@node 11-5 Iteration with Multiple Values, 11-6 Need for Macros, 11-4 "
"Iteration, 11 Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-5 Итерация с Множественными Значениями\n"
"@cindex 11-5 Iteration with Multiple Values"

#: texi/node-11.texi:794
msgid ""
"The built-in do macros have been around longer than multiple return values.\n"
"Fortunately do can evolve to suit the new situation, because the evolution "
"of Lisp\n"
"is in the hands of the programmer. Figure 11-10 contains a version of do* "
"adapted\n"
"for multiple values. With mvdo*, each of the initial clauses can bind more "
"than\n"
"one variable:"
msgstr ""
"Встроенные макросы do существуют дольше, чем возврат множественных "
"значений.\n"
"К счастью do может развиваться в соответствии с новой ситуацией, поскольку "
"эволюция\n"
"Lisp находиться в руках программиста. Рисунок 11-10 содержит версию do* "
"приспособленную\n"
"для работы с множественными значениями. С mvdo*, каждое начальное "
"предложение может \n"
"связать больше чем одну переменную:"

#: texi/node-11.texi:803
msgid ""
"@example\n"
"   > (mvdo* ((x 1 (1+ x))\n"
"                    ((y z) (values 0 0) (values z x)))\n"
"                  ((> x 5) (list x y z))\n"
"           (princ (list x y z)))\n"
"   (1 0 0)(2 0 2)(3 2 3)(4 3 4)(5 4 5)\n"
"   (656)\n"
"@end example"
msgstr ""

#: texi/node-11.texi:806
msgid ""
"This kind of iteration is useful, for example, in interactive graphics "
"programs,\n"
"which often have to deal with multiple quantities like coordinates and "
"regions."
msgstr ""
"Этот вид итерации полезен, например, в интерактивных графических "
"программах,\n"
"которые часто имеют дело с несколькими величинами, таким как координаты и\n"
"регионы(области)."

#: texi/node-11.texi:811
msgid ""
"Suppose that we want to write a simple interactive game, in which the "
"object\n"
"is to avoid being squashed between two pursuing objects. If the two pursuers "
"both\n"
"hit you at the same time, you lose; if they crash into one another first, "
"you win.\n"
"Figure 11-11 shows how the main loop of this game could be written using "
"mvdo*."
msgstr ""
"Предположим, что мы хотим написать простую интерактивную игру, в которой "
"объект,\n"
"должен избежать зажатия между двумя преследующими его объектами. Если два "
"преследователя\n"
"оба ударят вас одновременно, вы проиграете; если они столкнутья друг с "
"другом первыми,\n"
"вы виграете. На рисунке 11-11 показано, как можно написать основной цикл "
"этой игры,\n"
"используя mvdo*."

#: texi/node-11.texi:813
msgid ""
"It is also possible to write an mvdo, which binds its local variables in "
"parallel:"
msgstr ""
"Также возможно написать mvdo, которая связывает свои локальные переменные "
"параллельно:"

#: texi/node-11.texi:822
msgid ""
"@example\n"
"   > (mvdo ((x 1 (1+ x))\n"
"                  ((y z) (values 0 0) (values z x)))\n"
"                 ((> x 5) (list x y z))\n"
"           (princ (list x y z)))\n"
"   (1 0 0)(2 0 1)(3 1 2)(4 2 3)(5 3 4)\n"
"   (645)\n"
"@end example"
msgstr ""

#: texi/node-11.texi:827
msgid ""
"The need for psetq in defining do was described on page 96. To define mvdo,\n"
"we need a multiple-value version of psetq. Since Common Lisp doesn't have\n"
"one, we have to write it ourselves, as in Figure 11-12. The new macro works "
"as\n"
"follows:"
msgstr ""
"Необходимый для psetq в определении do был описан на странице 96. Чтобы "
"определить\n"
"mvdo нам необходима версия psetq поддерживающая множественные значения. "
"Поскольку\n"
"Common Lisp такой не имеет, мы дожны сами ее написать, как на рисунке 11-12. "
"Новый\n"
"макрос работает следующим образом:"

#: texi/node-11.texi:831
msgid ""
"@lisp\n"
" (defmacro mvdo* (parm-cl test-cl &body body)\n"
"    (mvdo-gen parm-cl parm-cl test-cl body))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro mvdo* (parm-cl test-cl &body body)\n"
"    (mvdo-gen parm-cl parm-cl test-cl body))"

#: texi/node-11.texi:847
msgid ""
" (defun mvdo-gen (binds rebinds test body)\n"
"    (if (null binds)\n"
"           (let ((label (gensym)))\n"
"             `(prog nil\n"
"                ,label\n"
"                (if ,(car test)\n"
"                     (return (progn ,@@(cdr test))))\n"
"                ,@@body\n"
"                ,@@(mvdo-rebind-gen rebinds)\n"
"                (go ,label)))\n"
"           (let ((rec (mvdo-gen (cdr binds) rebinds test body)))\n"
"             (let ((var/s (caar binds)) (expr (cadar binds)))\n"
"               (if (atom var/s)\n"
"                    `(let ((,var/s ,expr)) ,rec)\n"
"                    `(multiple-value-bind ,var/s ,expr ,rec))))))"
msgstr ""

#: texi/node-11.texi:859
msgid ""
" (defun mvdo-rebind-gen (rebinds)\n"
"    (cond ((null rebinds) nil)\n"
"             ((< (length (car rebinds)) 3)\n"
"              (mvdo-rebind-gen (cdr rebinds)))\n"
"             (t(cons (list (if (atom (caar rebinds))\n"
"                                   'setq\n"
"                                   'multiple-value-setq)\n"
"                              (caar rebinds)\n"
"                              (third (car rebinds)))\n"
"                     (mvdo-rebind-gen (cdr rebinds))))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:861
msgid "              Figure 11-10: Multiple value binding version of do*."
msgstr ""
"              Рисунок 11-10: Связывающая множественные значения версия do*.\n"
"@end cartouche"

#: texi/node-11.texi:870
msgid ""
"@example\n"
"> (let ((w 0) (x 1) (y 2) (z 3))\n"
"        (mvpsetq (w x) (values 'a 'b) (y z) (values w x))\n"
"        (list wxyz))\n"
"(AB01)\n"
"@end example"
msgstr ""

#: texi/node-11.texi:873
msgid ""
"The definition of mvpsetq relies on three utility functions: mklist (page "
"45),\n"
"group (page 47), and shuffle, defined here, which interleaves two lists:"
msgstr ""
"Определение mvpsetq опирается на три служебные функции: mklist (стр 45),\n"
"group (стр 47), и shuffle, определеннуюю здесь, которая смешивает два\n"
"списка:"

#: texi/node-11.texi:891
msgid ""
"@lisp\n"
" (mvdo* (((px py) (pos player)               (move player mx my))\n"
"              ((x1 y1) (pos obj1)            (move obj1 (- px x1)\n"
"                                                            (- py y1)))\n"
"              ((x2 y2) (pos obj2)            (move obj2 (- px x2)\n"
"                                                            (- py y2)))\n"
"              ((mx my) (mouse-vector) (mouse-vector))\n"
"              (win       nil                 (touch obj1 obj2))\n"
"              (lose      nil                 (and (touch obj1 player)\n"
"                                                   (touch obj2 player))))\n"
"             ((or win lose) (if win 'win 'lose))\n"
"       (clear)\n"
"       (draw obj1)\n"
"       (draw obj2)\n"
"       (draw player))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (mvdo* (((px py) (pos player)               (move player mx my))\n"
"              ((x1 y1) (pos obj1)            (move obj1 (- px x1)\n"
"                                                            (- py y1)))\n"
"              ((x2 y2) (pos obj2)            (move obj2 (- px x2)\n"
"                                                            (- py y2)))\n"
"              ((mx my) (mouse-vector) (mouse-vector))\n"
"              (win       nil                 (touch obj1 obj2))\n"
"              (lose      nil                 (and (touch obj1 player)\n"
"                                                   (touch obj2 player))))\n"
"             ((or win lose) (if win 'win 'lose))\n"
"       (clear)\n"
"       (draw obj1)\n"
"       (draw obj2)\n"
"       (draw player))\n"
"@end lisp"

#: texi/node-11.texi:894
msgid ""
" (pos obj) returns two values x,y representing the position of obj. "
"Initially,\n"
" the three objects have random positions."
msgstr ""
" (pos obj) возвращает два значения x,y представляющих позицию объекта obj. "
"Первоначально\n"
"три объекта имеют случайное положение."

#: texi/node-11.texi:897
msgid ""
" (move obj dx dy) moves the object obj depending on its type and the vector\n"
"  dx,dy . Returns two values x,y indicating the new position."
msgstr ""
" (move obj dx dy) перемещает объект obj в зависимости от его типа и вектора\n"
"  dx,dy . Возвращает два значения x,y указывающих на новыую позицию."

#: texi/node-11.texi:900
msgid ""
" (mouse-vector) returns two values dx,dy indicating the current movement\n"
" of the mouse."
msgstr ""
" (mouse-vector) возвращает два значения dx,dy указывающих на текущее\n"
"перемещение мыши."

#: texi/node-11.texi:902
msgid " (touch obj1 obj2) returns true if obj1 and obj2 are touching."
msgstr " (touch obj1 obj2) возвращает истину если obj1 и obj2 соприкасаются."

#: texi/node-11.texi:904
msgid " (clear) clears the game region."
msgstr " (clear) очищает игровой регион."

#: texi/node-11.texi:906
msgid " (draw obj) draws obj at its current position."
msgstr " (draw obj) рисует obj в его текущей позиции."

#: texi/node-11.texi:908
msgid "                         Figure 11-11: A game of squash."
msgstr ""
"                        Рисунок 11-11: Игра в мяч.\n"
"@end cartouche"

#: texi/node-11.texi:915
msgid ""
"@example\n"
"> (shuffle '(a b c) '(1 2 3 4))\n"
"(A1B2C34)\n"
"@end example"
msgstr ""

#: texi/node-11.texi:919
msgid ""
"With mvpsetq, we can define mvdo as in Figure 11-13. Like condlet, this\n"
"macro uses mappend instead of mapcar to avoid modifying the original macro\n"
"call. The mappend-mklist idiom flattens a tree by one level:"
msgstr ""
"С помощью mvpsetq, мы можем определить mvdo как показано на Рисунке 11-13. "
"Подобно condlet, \n"
"этот макрос использует mappend вместо mapcar чтобы избежать изменения "
"исходного вызова\n"
"макроса. Идиома mappend-mklist сглаживает у дерева один уровень:"

#: texi/node-11.texi:924
msgid ""
"@example\n"
"> (mappend #'mklist '((a b c) d (e (f g) h) ((i)) j))\n"
"(ABCDE(FG)H(I)J)\n"
"@end example"
msgstr ""

#: texi/node-11.texi:949
msgid ""
"@lisp\n"
" (defmacro mvpsetq (&rest args)\n"
"    (let* ((pairs (group args 2))\n"
"              (syms (mapcar #'(lambda (p)\n"
"                                      (mapcar #'(lambda (x) (gensym))\n"
"                                                 (mklist (car p))))\n"
"                                 pairs)))\n"
"        (labels ((rec (ps ss)\n"
"                     (if (null ps)\n"
"                          `(setq\n"
"                              ,@@(mapcan #'(lambda (p s)\n"
"                                               (shuffle (mklist (car p))\n"
"                                                           s))\n"
"                                          pairs syms))\n"
"                          (let ((body (rec (cdr ps) (cdr ss))))\n"
"                              (let ((var/s (caar ps))\n"
"                                     (expr (cadar ps)))\n"
"                               (if (consp var/s)\n"
"                                     `(multiple-value-bind ,(car ss)\n"
"                                                                   ,expr\n"
"                                         ,body)\n"
"                                     `(let ((,@@(car ss) ,expr))\n"
"                                         ,body)))))))\n"
"         (rec pairs syms))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro mvpsetq (&rest args)\n"
"    (let* ((pairs (group args 2))\n"
"              (syms (mapcar #'(lambda (p)\n"
"                                      (mapcar #'(lambda (x) (gensym))\n"
"                                                 (mklist (car p))))\n"
"                                 pairs)))\n"
"        (labels ((rec (ps ss)\n"
"                     (if (null ps)\n"
"                          `(setq\n"
"                              ,@@(mapcan #'(lambda (p s)\n"
"                                               (shuffle (mklist (car p))\n"
"                                                           s))\n"
"                                          pairs syms))\n"
"                          (let ((body (rec (cdr ps) (cdr ss))))\n"
"                              (let ((var/s (caar ps))\n"
"                                     (expr (cadar ps)))\n"
"                               (if (consp var/s)\n"
"                                     `(multiple-value-bind ,(car ss)\n"
"                                                                   ,expr\n"
"                                         ,body)\n"
"                                     `(let ((,@@(car ss) ,expr))\n"
"                                         ,body)))))))\n"
"         (rec pairs syms))))"

#: texi/node-11.texi:956
msgid ""
" (defun shuffle (x y)\n"
"    (cond ((null x) y)\n"
"              ((null y) x)\n"
"              (t (list* (car x) (car y)\n"
"                         (shuffle (cdr x) (cdr y))))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:958
msgid "                 Figure 11-12: Multiple value version of psetq."
msgstr ""
"                Рисунок 11-12: Версия работющего с Множественным значением "
"psetq.\n"
"@end cartouche"

#: texi/node-11.texi:962
msgid ""
"To help in understanding this rather large macro, Figure 11-14 contains a "
"sample\n"
"expansion."
msgstr ""
"Чтобы понять этот довольно большой макрос. на рисунке 11-14 приведен пример\n"
"его расширения."

#: texi/node-11.texi:967
msgid ""
"@node 11-6 Need for Macros,  , 11-5 Iteration with Multiple Values, 11 "
"Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-6 Need for Macros\n"
"@cindex 11-6 Need for Macros"
msgstr ""
"@node 11-6 Need for Macros,  , 11-5 Iteration with Multiple Values, 11 "
"Classic Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 11-6 Потребность в Макросах\n"
"@cindex 11-6 Need for Macros"

#: texi/node-11.texi:971
msgid ""
"Macros aren't the only way to protect arguments against evaluation. Another "
"is to\n"
"wrap them in closures. Conditional and repeated evaluation are similar "
"because\n"
"neither problem inherently requires macros. For example, we could write a "
"version"
msgstr ""
"Макрос это не единственный способ защитить аргументы от вычисления. Другой, "
"заключается\n"
"в том чтобы обернуть их в замыкание. Условные и повторяющиеся вычисления "
"похожи, потому\n"
"что ни одна проблема по своей сути не требует макросов. Например, мы могли "
"бы написать\n"
"версию"

#: texi/node-11.texi:1001
msgid ""
"@lisp\n"
" (defmacro mvdo (binds (test &rest result) &body body)\n"
"       (let ((label (gensym))\n"
"            (temps (mapcar #'(lambda (b)\n"
"                                       (if (listp (car b))\n"
"                                            (mapcar #'(lambda (x)\n"
"                                                            (gensym))\n"
"                                                        (car b))\n"
"                                            (gensym)))\n"
"                                  binds)))\n"
"        `(let ,(mappend #'mklist temps)\n"
"           (mvpsetq ,@@(mapcan #'(lambda (b var)\n"
"                                           (list var (cadr b)))\n"
"                                      binds\n"
"                                      temps))\n"
"           (prog ,(mapcar #'(lambda (b var) (list b var))\n"
"                               (mappend #'mklist (mapcar #'car binds))\n"
"                               (mappend #'mklist temps))\n"
"                 ,label\n"
"                 (if ,test\n"
"                     (return (progn ,@@result)))\n"
"                 ,@@body\n"
"                 (mvpsetq ,@@(mapcan #'(lambda (b)\n"
"                                               (if (third b)\n"
"                                                     (list (car b)\n"
"                                                          (third b))))\n"
"                                        binds))\n"
"                 (go ,label)))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro mvdo (binds (test &rest result) &body body)\n"
"       (let ((label (gensym))\n"
"            (temps (mapcar #'(lambda (b)\n"
"                                       (if (listp (car b))\n"
"                                            (mapcar #'(lambda (x)\n"
"                                                            (gensym))\n"
"                                                        (car b))\n"
"                                            (gensym)))\n"
"                                  binds)))\n"
"        `(let ,(mappend #'mklist temps)\n"
"           (mvpsetq ,@@(mapcan #'(lambda (b var)\n"
"                                           (list var (cadr b)))\n"
"                                      binds\n"
"                                      temps))\n"
"           (prog ,(mapcar #'(lambda (b var) (list b var))\n"
"                               (mappend #'mklist (mapcar #'car binds))\n"
"                               (mappend #'mklist temps))\n"
"                 ,label\n"
"                 (if ,test\n"
"                     (return (progn ,@@result)))\n"
"                 ,@@body\n"
"                 (mvpsetq ,@@(mapcan #'(lambda (b)\n"
"                                               (if (third b)\n"
"                                                     (list (car b)\n"
"                                                          (third b))))\n"
"                                        binds))\n"
"                 (go ,label)))))\n"
"@end lisp"

#: texi/node-11.texi:1003
msgid "                 Figure 11-13: Multiple value binding version of do."
msgstr ""
"                 Рисунок 11-13: Версия do связывающая множественные "
"значения.\n"
"@end cartouche"

#: texi/node-11.texi:1006
msgid ""
"@noindent\n"
"of if as a function:"
msgstr ""
"@noindent\n"
" if как функцию:"

#: texi/node-11.texi:1013
msgid ""
"@lisp\n"
"(defun fnif (test then &optional else)\n"
"  (if test\n"
"         (funcall then)\n"
"         (if else (funcall else))))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:1016
msgid ""
"We would protect the then and else arguments by expressing them as "
"closures,\n"
"so instead of"
msgstr ""
"Мы бы защитили аргументы then и else, выражая их как замыкания,\n"
"так вместо"

#: texi/node-11.texi:1024
msgid ""
"@lisp\n"
"(if (rich) (go-sailing) (rob-bank))\n"
" (mvdo ((x 1 (1+ x))\n"
"             ((y z) (values 0 0) (values z x)))\n"
"           ((> x 5) (list x y z))\n"
"     (princ (list x y z)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(if (rich) (go-sailing) (rob-bank))\n"
"@end lisp\n"
"@cartouche\n"
"@lisp\n"
" (mvdo ((x 1 (1+ x))\n"
"             ((y z) (values 0 0) (values z x)))\n"
"           ((> x 5) (list x y z))\n"
"     (princ (list x y z)))\n"
"@end lisp"

#: texi/node-11.texi:1027
msgctxt "texi/node-11.texi:1027"
msgid ""
"@noindent\n"
"expands into:"
msgstr ""
"@noindent\n"
"Расширяется в:"

#: texi/node-11.texi:1041
msgid ""
"@lisp\n"
" (let (#:g2 #:g3 #:g4)\n"
"     (mvpsetq #:g2 1\n"
"                   (#:g3 #:g4) (values 0 0))\n"
"     (prog ((x #:g2) (y #:g3) (z #:g4))\n"
"          #:g1\n"
"          (if (> x 5)\n"
"                (return (progn (list x y z))))\n"
"          (princ (list x y z))\n"
"          (mvpsetq x (1+ x)\n"
"                        (y z) (values z x))\n"
"          (go #:g1)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:1043
msgid "                       Figure 11-14: Expansion of a call to mvdo."
msgstr ""
"                       Рисунок 11-14: Расширение вызова mvdo.\n"
"@end cartouche"

#: texi/node-11.texi:1047
msgid ""
"@noindent\n"
"we would say"
msgstr ""
"@noindent\n"
"мы бы сказали"

#: texi/node-11.texi:1053
msgid ""
"@lisp\n"
"(fnif (rich)\n"
"         #'(lambda () (go-sailing))\n"
"         #'(lambda () (rob-bank)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:1057
msgid ""
"If all we want is conditional evaluation, macros aren't absolutely "
"necessary. They\n"
"just make programs cleaner. However, macros are necessary when we want to\n"
"take apart argument forms, or bind variables passed as arguments."
msgstr ""
"Если все, что нам нужно, это условные вычисления, макросы не являются "
"абсолютно \n"
"необходмыми. Они просто делают программы яснее. Тем не менее, макросы "
"необходмы, когда\n"
"мы хотим разобрать аргументы формы, или связывать переменные передаваемые в "
"качестве\n"
"аргументов."

#: texi/node-11.texi:1068
msgid ""
"The same applies to macros for iteration. Although macros offer the\n"
"only way to define an iteration construct which can be followed by a\n"
"body of expressions, it is possible to do iteration with functions, so\n"
"long as the body of the loop is packaged up in a function\n"
"itself.@footnote{It's not impossible to write an iteration function\n"
"which doesn't need its argument wrapped up in a function. We could\n"
"write a function that called eval on expressions passed to it as\n"
"arguments. For an explanation of why it's usually bad to call eval,\n"
"see page 278.} The built-in function mapc, for example, is the\n"
"functional counterpart of dolist. The expression"
msgstr ""
"Тоже самое отностся к макросам для итерации. Хотя макросы предлагают\n"
"естественный способ определить итерационную конструкцию, за которой\n"
"может следовать тело выражений, можно выполнить итерацию с использованием\n"
"функций, если тело цикла само упаковано в функцию.@footnote{Возможно\n"
"написать итерационную функцию, которая не нуждается в аргументах,\n"
"обернутых в функцию. Мы могли бы написать функцию, которая вызывала бы\n"
"eval для выражений переданных ей в качестве аргументов. Для объяснения\n"
"того, почему обычно плохо вызывать eval, смотри стр. 278.} Например, \n"
"встроенная функция mapc, это функциональный аналог dolist. \n"
"Выражение"

#: texi/node-11.texi:1074
msgid ""
"@lisp\n"
"(dolist (b bananas)\n"
"   (peel b)\n"
"   (eat b))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:1077
msgid ""
"@noindent\n"
"has the same side-effects as"
msgstr ""
"@noindent\n"
"имеет те же побочные эффекты, что и"

#: texi/node-11.texi:1084
msgid ""
"@lisp\n"
"(mapc #'(lambda (b)\n"
"                (peel b)\n"
"                (eat b))\n"
"           bananas)\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:1088
msgid ""
"@noindent\n"
"(though the former returns nil and the latter returns the list bananas). We "
"could\n"
"likewise implement forever as a function,"
msgstr ""
"@noindent\n"
"(хотя первый возвращает nil, а последующий возвращает список бананов). Мы "
"могли бы\n"
"аналогично реализовать forever как функцию,"

#: texi/node-11.texi:1095
msgid ""
"@lisp\n"
"(defun forever (fn)\n"
"  (do ()\n"
"           (nil)\n"
"        (funcall fn)))\n"
"@end lisp"
msgstr ""

#: texi/node-11.texi:1098
msgid ""
"@noindent\n"
"if we were willing to pass it a closure instead of a body of expressions."
msgstr ""
"@noindent\n"
"если бы мы были готовы передать это как замыкание вместо тела выражений."

#: texi/node-11.texi:1105
msgid ""
"However, iteration constructs usually want to do more than just iterate, as\n"
"forever does: they usually want to do a combination of binding and "
"iteration.\n"
"With a function, the prospects for binding are limited. If you want to bind "
"variables\n"
"to successive elements of lists, you can use one of the mapping functions. "
"But\n"
"if the requirements get much more complicated than that, you'll have to "
"write a\n"
"macro."
msgstr ""
"Тем не менее, итерационные конструкции обычно хотят делать больше, чем "
"просто\n"
"итерацию, как это forever делает: они обычно хотят сделать комбинацию "
"связвания и\n"
"итерации. С использованием функций, перспективы связывания ограничены. Если "
"вы хотите\n"
"связать переменные для последовательности элементов списков, вы можете "
"использовать\n"
"одну из функций отображения(mapping). Но если требования усложняются, вам "
"придется\n"
"писать макрос."
