@node 9 Variable Capture, 10 Other Macro Pitfalls, 8 When to Use Macros, Top
@comment  node-name,  next,  previous,  up
@chapter 9 Захват Переменных
@cindex 9 Variable Capture

Макрос уязвимы для проблемы, называемой захватом переменных. Захват переменной
происходит когда расширение макроса вызывает конфликт имен: когда какой то символ
заканчивается ссылкой на переменную из другого контекста. Случайный захват переменной
может вызвать трудно уловимые ошибки. Эта глава о том, как предвидеть и избежать их.
Тем не менее, преднамеренный захват переменных является полезным методом программирования,
и глава 14 полна макросов, которые полагаются на него.

@menu
* 9-1 Macro Argument Capture::  
* 9-2 Free Symbol Capture::     
* 9-3 When Capture Occurs::     
* 9-4 Avoiding Capture with Better Names::  
* 9-5 Avoiding Capture by Prior Evaluation::  
* 9-6 Avoiding Capture with Gensyms::  
* 9-7 Avoiding Capture with Packages::  
* 9-8 Capture in Other Name-Spaces::  
* 9-9 Why Bother?::             
@end menu

@node 9-1 Macro Argument Capture, 9-2 Free Symbol Capture, 9 Variable Capture, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-1 Захват Аргумента Макроса
@cindex 9-1 Macro Argument Capture

Макрос уязвимый к непреднамеренному захвату переменных, является макросом с ошибкой. 
Чтобы избежать написания такого макроса, мы должны точно знать, когда может произойти
захват. Отдельные случаи захвата переменной можно отнести к одной из двух ситуаций:
захват аргумента макроса и захват свободного символа. При захвате аргумента, символ
передаваемый как аргумент в вызов макроса непреднамеренно ссылается на переменную,
установленную расширением самого макроса. Рассмотрим следующее определение макроса for,
который выполняет итерации для выражений body подобно циклу в for в языке Pascal:

@lisp
(defmacro for ((var start stop) &body body)                              ; wrong
  `(do ((,var ,start (1+ ,var))
          (limit ,stop))
         ((> ,var limit))
      ,@@body))
@end lisp

На первый взгляд этот макрос выглядит правильно. Кажеться он работает нормально:

@example
> (for (x 1 5)
        (princ x))
12345
NIL
@end example

Действительно, ошибка настолько неуловима, что мы можем использовать эту версию
макроса сотни раз, и он всегда будет работать отлично. Однако если мы вызовем
этот макрос так:

@lisp
(for (limit 1 5)
  (princ limit))
@end lisp

Мы ожидаем, что это выражение будет иметь тот же эффект, что и раньше. Но оно ничего
не печатает; оно генерирует ошибку. Чтобы понять почему оно не работает, надо посмотреть
на его расширение:

@lisp
(do ((limit 1 (1+ limit))
         (limit 5))
        ((> limit limit))
  (princ limit))
@end lisp

Теперь очевидно, что идет не так. Здесь есть конфликт имен между локальным 
символом расширения макроса и символом переданным как аргумент в макрос.
Расширение макроса захватывает limit. Этот символ возникает дважды в одном
и том же do, что является ошибкой.

Ошибки, вызываемые захватом переменных редки, но то чего они не добирают в частоте,
они берут злобностью. Этот захват был сравнительно мягким - здесь мы, по крайней
мере, получили ошибку. Чаще всего, захватывающий переменную макрос будет просто
выдвать не верные результаты без указания того, что пошло не так. В этом случае,

@example
> (let ((limit 5))
        (for (i 1 10)
           (when (> i limit)
              (princ i))))
NIL
@end example

@noindent
полученный код тихо ничего не делает.

@node 9-2 Free Symbol Capture, 9-3 When Capture Occurs, 9-1 Macro Argument Capture, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-2 Захват Свободного Символа
@cindex 9-2 Free Symbol Capture

Менее часто, само определение макроса содержит символ, который непреднамеренно
ссылается на привязку в окружении, где разворачивается макрос. Предположим, что
какая то программа, вместо того чтобы печатать предупреждения пользователю по мере
их возникновения, хочет сохранить предупреждения в списке, чтобы рассмотреть их
позже. Один человек пишет макрос gripe, который принимает предупреждающее сообщение
и добавляет его в глобальный список w:

@lisp
(defvar w nil)

(defmacro gripe (warning)                                                ; wrong
  `(progn (setq w (nconc w (list ,warning)))
               nil))
@end lisp

Кто-то еще хочет написать функцию sample-ratio, возвращающую соотношени длин
двух списков. Если любой из списков содержит менее двух элементов, функция должна
возвращать nil вместо него, таже выдавая предупреждение, что она была вызвана для
статистически незначимого случая. (Фактические предупреждения могут быть более
информативными, но их содержание не имеет отношения к этому примеру.)

@lisp
(defun sample-ratio (v w)
  (let ((vn (length v)) (wn (length w)))
       (if (or (< vn 2) (< wn 2))
           (gripe "sample < 2")
           (/ vn wn))))
@end lisp

Если  sample-ratio вызывается с w = (b), то он захочет выдать предупреждение, что один
из его аргументов, имеет только один элемент, статистически не значим. Но когда вызов
gripe будет расширен, он создаст код такой, как если бы sample-ratio было определено:

@lisp
(defun sample-ratio (v w)
  (let ((vn (length v)) (wn (length w)))
       (if (or (< vn 2) (< wn 2))
           (progn (setq w (nconc w (list "sample < 2")))
                    nil)
           (/ vn wn))))
@end lisp

Проблема здесь в том, что gripe используется в контексте, где w имеет свою собственную
локальную привязку. Предупреждение, вместо сохранения в глобальном списке предупреждений,
будет добавлено (nconced) в конец одного из параметров sample-ratio. Предупреждение
не только будет потеряно, но и список (b), который вероятно используется в качестве данных
в другом месте программы, будет добавлена посторонняя строка:

@example
> (let ((lst '(b)))
       (sample-ratio nil lst)
       lst)
(B "sample < 2")
>w
NIL
@end example

@node 9-3 When Capture Occurs, 9-4 Avoiding Capture with Better Names, 9-2 Free Symbol Capture, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-3 Когда Происходит Захват
@cindex 9-3 When Capture Occurs

Множество авторов макросов просят посмотреть определение макроса и предугадать
все возможные проблемы, возникающие из этих двух типов захвата. Захват переменной
является хитрым вопросом, и требуется некоторый опыт, чтобы предвидеть все пути,
которыми захватываемый символ может нанести вред программе. К счастью, вы можете
обнаружить и устранять захватываемые символы в ваших определениях макросов без
размышлений о том, как этот захват может испортить вашу программу. Этот раздел
предоставляет простое правило для обнаружения захватываемых символов. Остальные
разделы этой главы объясняют методы их устранения.

Правило для определения захватываемой переменной зависит от некоторого
подчиненного понятия, которое должно быть определено в перувую очередь:

@quotation
Свобода: Символ s появляется в выражении свободным, когда он используется в 
         качестве  перемменной в этом выражении, но выражение не создает 
         привязку для него.
@end quotation

В следующем выражении,

@lisp
(let ((x y) (z 10))
  (list w x z))
@end lisp

w, x и z - все встречаются свободными в выражении list, которое не устанавливает привязок.
Тем не менее, включающее выражение let устанавливает привязку для x и z, поэтому в целом
в let только y и w являются свободными. Обратите внимание, что

@lisp
(let ((x x))
  x)
@end lisp

второй экземпляр x является свободным - он не входит в сферу действия новой привязки
устанавливаемой для x.

@quotation
Каркас: Каркас расширения макроса - это всё разложение за исключением всего
        что было частью аргументов в вызове макроса.
@end quotation

Если foo определено как:

@lisp
(defmacro foo (x y)
  `(/ (+ ,x 1) ,y))
@end lisp

и вызывается как:

@lisp
(foo (- 5 2) 6)
@end lisp

тогда этот вызов дает расширение макроса:

@lisp
(/ (+ (- 5 2) 1) 6)
@end lisp

Каркас этого расширения представляет собой приведенное выше выражение с "отверстиями",
куда были вставлены параметры x и y:

@lisp
(/ (+    ____  1)  ____)
@end lisp

С определением этих двух концепций(свободы и каркаса), становиться возможно
сформулировать правило для обнаружения захватываемых символов:

@quotation
Захватываемый: символ может быть захвачен в некотором разложении макроса, если (a) он
         появляется свободным в каркасе разложения макроса, или (b) он является 
         связанным частью каркаса, в которой аргументы, передаваемые макросу, либо 
         связваются, либо вычисляются.
@end quotation

Несколько примеров прояснят смысл этого правила. В простейшем случае:

@lisp
(defmacro cap1 ()
  '(+ x 1))
@end lisp

x является захватываемым, поскольку он встречается свободным в каркасе макроса. Это
то что вызвало ошибку в макросе gripe. В этом макросе:

@lisp
(defmacro cap2 (var)
  `(let ((x ...)
              (,var ...))
         ...))
@end lisp

x является захватываемым, поскольку он связывается в выражении, где также связывается
аргумент  вызова макроса. (Это то, что пошло не так в макросе for.) Аналогично и
для следующих двух макросов

@lisp
(defmacro cap3 (var)
  `(let ((x ...))
         (let ((,var ...))
            ...)))

(defmacro cap4 (var)
  `(let ((,var ...))
         (let ((x ...))
            ...)))
@end lisp

в обоих x является захватываемым. Однако, если нет контекста, в котором привязка x
и переменная переданная как аргумент будут обе видны, как в

@lisp
(defmacro safe1 (var)
  `(progn (let ((x 1))
                    (print x))
                 (let ((,var 1))
                    (print ,var))))
@end lisp

здесь x не будет захватываемой. Не все переменные, связанные в каркасе, находятся в
опсности быть захваченными. Однако, если аргументы в вызове макроса вычисляются в
установленной привязке в соответствии с каркасом,

@lisp
(defmacro cap5 (&body body)
  `(let ((x ...))
         ,@@body))
@end lisp

тогда связанные в ней переменные находятся под угрозой захвата: в cap5, x является 
захватываемой. Хотя в это случае,

@lisp
(defmacro safe2 (expr)
  `(let ((x ,expr))
         (cons x 1)))
@end lisp

x не может быть захвачена, потому что, когда переданный аргумент expr вычисляется, 
новая привязка x не будет видна. Обратите внимание, что это только связывание каркасных
переменных, о которых мы должны беспокоиться. В этом макросе

@lisp
(defmacro safe3 (var &body body)
  `(let ((,var ...))
         ,@@body))
@end lisp

ни один символ не подвергается риску случайного захвата (при условии, что пользователь ожидает,
что первый аргумент будет связан).

Теперь давайте посмотрим на исходное определение for в свете нового правила для
идентификации захватываемых символов:

@lisp
(defmacro for ((var start stop) &body body)                               ; wrong
  `(do ((,var ,start (1+ ,var))
             (limit ,stop))
            ((> ,var limit))
         ,@@body))
@end lisp

Теперь выясняется, что это определение уязвимо для захвата двумя способами:
limit может быть передан в качестве первого аргумента для for, как в исходном
примере:

@lisp
(for (limit 1 5)
  (princ limit))
@end lisp

но столь же опасно, если limit встречается в теле цикла:

@lisp
(let ((limit 0))
  (for (x 1 10)
        (incf limit x))
  limit)
@end lisp

Кто-либо используя for данным способом, будет ожидать что его собственная привязка
для limit будет увеличиваться в цикле, и выражение в целом вернет 55; на самом деле,
полько привязка limit, созданная каркасом расширения будет увеличиваться:

@lisp
(do ((x 1 (1+ x))
         (limit 10))
        ((> x limit))
  (incf limit x))
@end lisp

и поскольку именно она контролирует итерации, цикл никогда не прекратиться.

Правила представленные в этом разделе, должны использоваться с оговоркой, что они 
предназначены только как ориентир. Они даже официально не установлены, не говоря уже
о формальной корректности. Проблема захвата является неопределенной, так как зависит
от ожиданий. Например, в выражении типа

@lisp
(let ((x 1)) (list x))
@end lisp

мы не считаем ошибкой то, что когда вычисляется (list x), x будет ссылаться на
новую переменную. Это то, что let должен делать. Правила обнаружения захвата
также неточны. Вы можете написать макросы, которые пройдут эти тесты, и которые
все равно еще будут уязвимы для непреднамеренного захвата. Например,

@lisp
(defmacro pathological (&body body)                                          ; wrong
  (let* ((syms (remove-if (complement #'symbolp)
                                       (flatten body)))
               (var (nth (random (length syms))
                             syms)))
        `(let ((,var 99))
            ,@@body)))
@end lisp

Когда вызывается этот макрос, выражения в теле будут вычисляться как если бы
они были в progn - но одна случайная переменная в теле может иметь другое 
значение. Это явно захват, но он проходит все наши тесты, потому что переменная
не встречается в каркасе. Однако, на практике, эти правила будут работать почти
всегда: очень редко(если вообще) кто захочет написать макрос, как в примере
выше.

@cartouche
Уявзвимый к захвату вариант:

@lisp
 (defmacro before (x y seq)
       `(let ((seq ,seq))
           (< (position ,x seq)
               (position ,y seq))))
@end lisp

Правильная версия:

@lisp
 (defmacro before (x y seq)
       `(let ((xval ,x) (yval ,y) (seq ,seq))
           (< (position xval seq)
               (position yval seq))))
@end lisp

                       Рисунок 9-1: Как избежать захвата с помощью let.
@end cartouche

@node 9-4 Avoiding Capture with Better Names, 9-5 Avoiding Capture by Prior Evaluation, 9-3 When Capture Occurs, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-4 Как избежать захвата с помощью Лучших Имен
@cindex 9-4 Avoiding Capture with Better Names

Первые два раздела делят отдельные случаи захвата переменной на два типа:
захват аргумента, когда символ используемый в аргументе, перехватывается
привязкой устанавливаемой каркасом макроса и захват свободного символа, когда
свободный символ в разложении макроса захватывается в силу внешней привязки,
в месте расширения макроса. Проблема в последнем случае обычно решается путем
предоставления глобальным переменным отличительных имен. В Common Lisp, имена
глобальным переменным обычно дают начинающимися и заканчивающимися звездочкой.
Например, переменная определяющия текущий пакет называется *package*. (Такое 
имя может быть произнесено "star-package-star", чтобы подчеркнуть, что это
не обычная переменная.)

Так что на самом деле ответственноть за хранение предупреждений лежит на авторе
макроса gripe, сохраняя предупреждения в переменной, которому надо было назвать
переменную для хранения предупреждений, чем-то вроде *warnings*, а не просто w. 
Если автор sample-ratio использовал бы *warnings* как параметр, тогда бы он заслужил
каждую ошибку, которую он получил, но он не может быть обвинен в том, что не подумал
о безопасности использоваия вызова с параметром w.

@node 9-5 Avoiding Capture by Prior Evaluation, 9-6 Avoiding Capture with Gensyms, 9-4 Avoiding Capture with Better Names, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-5 Как избежать Захвата с помощью Предварительного Вычисления
@cindex 9-5 Avoiding Capture by Prior Evaluation

Иногда захват аргументов можно вылечить, просто вычислив подвергаемые
опасности аргументы за пределами любых создаваемых асширением макроса
привязок. Простейшие случаи можно обработать, начав макрос с выражения
let.  Рисунок 9-1 содержит две версии макроса before, который принимает
два объекта и последовательность и возвращает истину если первый объект
встречается в последовательности раньше, чем второй.@footnote{Этот макрос
используется только как пример. На самом деле это не долно быть реализовано
как макрос, ни испольовать неэффективный алгоритм, который он показывает. 
Для праильного определения см. стр. 50.}

Первое определение не верно. Его начальный let гарантирует, что
форма переданная как seq будет вычислена только один раз, но этого
не достаточно, чтобы избежать следующих проблем:

@example
> (before (progn (setq seq '(b a)) 'a)
                      'b
                      '(a b))
NIL
@end example

Это равносильно тому, чтобы спросить "Стоит ли a перед b в (a b)?" Если before 
верно, он вернул бы истину. Расширение макроса показывает, что на самом деле 
происходит: вычисление первого аргумента операции < переустанавливает список
для поиска.

@lisp
(let ((seq '(a b)))
        (< (position (progn (setq seq '(b a)) 'a)
                              seq)
              (position 'b seq)))
@end lisp

Чтобы избежать этой проблемы, достаточно вначале вычислить все аргументы в одном большом
let. Таким образом, второе определение на рисунке 9-1 защищено от захвата.

К сожалению, метод использования let работает в узком диапазоне случаев:
макросы где

@enumerate
@item
все аргументы, подвергаются риску захвата, вычисляются только один раз, и

@item
ни один из аргументов не должен вычисляться в области охвата привязок установленых
каркасом макроса.
@end enumerate

Это правило исключает множество макросов. Предлагаемый макрос нарушает оба
условия. Тем не менее, мы можем использовать вариант этой схемы, чтобы сделать
макросы подобными защищенным от захвата: обернув его формы тела в лямбда выражение
снаружи любых локально созданных привязок.

Некоторые макросы, в том числе используемые для итерации, дают расширения,
где выражение появляющиеся в вызвое макроса будет вычисляться в рамках вновь
созданных привязок. Например в определении for тело цикла должно вычисляться
в do созданным макросом. Таким образом, переменные встречающиеся в теле цикла
также уязвимы к захвату привязками устанавливаемыми в do. Мы можем защитить
переменные в теле от такого захвата, обернув тело в замыкание, и внутри цикла,
вместо вставки самих выражений, просто выполнить вызов замыкания.

Рисунок 9-2 показывает версию for которая использует этот метод. После замыкания

@cartouche
Уязвимая к захвату:

@lisp
 (defmacro for ((var start stop) &body body)
       `(do ((,var ,start (1+ ,var))
               (limit ,stop))
             ((> ,var limit))
           ,@@body))
@end lisp

Правильная версия:

@lisp
 (defmacro for ((var start stop) &body body)
       `(do ((b #'(lambda (,var) ,@@body))
               (count ,start (1+ count))
               (limit ,stop))
             ((> count limit))
           (funcall b count)))
@end lisp

                     Рисунок 9-2: Избежание захвата с помощью замыкания.
@end cartouche

являющимся первым, что создает расширение for, свободные символы встречающиеся
в теле body будут ссылаться на переменные из окружения вызова макроса. Теперь do
взаимодействует с телом body через параметры замыкания. Все что нужно знать
замыканию от do это номер текущей итерации, поэтому оно имеет только один
параметр, символ указанный как переменная индекса в вызове макроса.

Техника обертывания выражений в лямбда функции не является универсальным средством.
Вы можете использовать её для защиты кода тела, но замыкания не годяться когда,
например, существует риск того, что одна и та же переменная будет дважды связана
одним и тем же let или do (как в нашем исходном не работающем for). К счастью, в
этом случае,  переписав for и упаковав его тело в замыкание, мы также избавились
от необходимости устанавливать  привязки для аргумента var. Аргумент var старого
for стал параметром замыкания и может быть заменен в do на символ count. 
Таким образом, новое определение for полностью невоспримиимчиво к захвату, как
покажет тест в Разделе 9-3.

Недостаток использования замыканий состоит в том, что они могут быть менее эффективными.
Мы можем ввести другой вызов функции. Потенциально хуже, если компилятор не дает замыканию
динамического пространства, пространство для него должно быть выделено в куче во время
выполнения.

@node  9-6 Avoiding Capture with Gensyms, 9-7 Avoiding Capture with Packages, 9-5 Avoiding Capture by Prior Evaluation, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-6 Как избежать захвата с помощью Gensyms
@cindex 9-6 Avoiding Capture with Gensyms

Есть один определенный способ избежать захвата аргументов макроса: заменить 
захватываемые символы с помощью gensyms. В исходной версии for, проблемы возникают
когда два символа имеют одно и тоже имя. Если мы хотим избежать этого, т.е что бы 
каркас макроса содержал символ так же используемый в вызывающем коде, мы могли бы
уповать на использование в определении макроса символов со странными именами:

@lisp
   (defmacro for ((var start stop) &body body)                              ; wrong
      `(do ((,var ,start (1+ ,var))
                (xsf2jsh ,stop))
               ((> ,var xsf2jsh))
            ,@@body))
@end lisp

но это не решение проблемы. Это не устраняет ошибку, просто снижает вероятность ее 
проявления. И не так уж и менее вероятно, а все еще весьма возможно представить
конфликты, возникающие во вложенных экземплярах одного и того же макроса.

Нам нужен какой-то способ убедиться, что символ уникален. Функция Common Lisp gensym
сущетсвует только для этой цели. Она возвращает символ, вызывая gensym, который
гарантированно не будет равен любому другому символу, набранному или составленному
в программе.

Как Lisp может обещать это? В Common Lisp, каждый пакет содержит списко всех
символов известных в этом пакете. (Для ознакомления с пакетами, см. стр. 381.) 
Символ, который находиться в списке называется интернированным(внедренным) в пакет.
Каждый вызов gensym взвращает уникальный, интернированный символ. И так как
каждый символ при чтении получает интернирование, никто не может напечатать
что либо идентичное gensym.
Таким образом, если вы начинаете выражение

   (eq (gensym) ...

нет способа завершить его, чтобы оно вернуло истину.

Запросить gensym создать нам символ, все равно что, выбрать подход использующий
символы со странными именами, но на один шаг более продвинутый - gensym даст нам
символ, чьего имени нет даже в телефонной книге. Когда Lisp должен отобразить gensym,

@example
   > (gensym)
   #:G47
@end example

то что он печатает, на самом деле просто Lisp эквивалент "John Doe", вымышленного
произвольного имени, чьё имя не имеет значения. И чтобы быть уверенным, что это 
не какие то наши иллюзии, отображаемым символам gensym  предшествует решетка с
двоеточием, специальный макрос чтения, который существует только для того, чтобы
вызывать ошибку, если мы когда-нибудь попытаемся прочитать gensym повторно.

@cartouche
Уязвимый для захвата:

@lisp
 (defmacro for ((var start stop) &body body)
       `(do ((,var ,start (1+ ,var))
               (limit ,stop))
              ((> ,var limit))
           ,@@body))
@end lisp

Правильная версия:

@lisp

 (defmacro for ((var start stop) &body body)
       (let ((gstop (gensym)))
          `(do ((,var ,start (1+ ,var))
                  (,gstop ,stop))
                ((> ,var ,gstop))
              ,@@body)))
@end lisp

                      Рисунок 9-3: Как избежать захвата с помощью gensym.
@end cartouche

В CLTL2 Common Lisp, число в печатном представлении gensym происходит от
*gensym-counter*, глобальной переменной всегда связанной с целым числом.
Сбрасывая этот счетчик, мы можем заставить два gensyms печататься одинаково

@example
> (setq x (gensym))
#:G48
> (setq *gensym-counter* 48 y (gensym))
#:G48
>(eq x y)
NIL
@end example

@noindent
но они не будут идентичными.

Рисунок 9-3 содержит правильное определение for использующее gensyms. Там нет
символа limit, который может совпасть с символами из форм переданных в макрос.
Он был заменен символом сгенерированным gensym на месте. В каждом расширении
макроса, вместо limit будет взят уникальный символ, созданый во время расширения.

Правильное определение for является сложным для получения с первой попытки.
Законченный код, как и законченая теорема, часто проходят через много проб и 
ошибок. Так что не беспокойтесь , если вам придется написать несколько версий
макроса. Начиная писать макрос подобный for, вы можете написать первую версию,
не думая о захвате переменной, а затем вернуться и сделать gensyms для символов,
которые можгут быть вовлечены в захваты.

@node 9-7 Avoiding Capture with Packages, 9-8 Capture in Other Name-Spaces, 9-6 Avoiding Capture with Gensyms, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-7 Как избежать захвата с помощью пакетов(packages)
@cindex 9-7 Avoiding Capture with Packages

В некоторой степени можно избежать захвата, определяя макросы в своих собственных
пакетах. Если вы создаете макрос в пакете и определяете for в нем, вы можете использовать
определение данное первым

@lisp
(defmacro for ((var start stop) &body body)
     `(do ((,var ,start (1+ ,var))
             (limit ,stop))
            ((> ,var limit))
         ,@@body))
@end lisp

и безопасно вызывать его из любого другого пакета. Если вы вызываете for из другого
пакет, скажем mycode, тогда даже если вы будете использовать limit в качестве первого
аргуемента, это будет mycode::limit - символ отличный от символа macros::limit, 
который встречается в каркасе макроса.

Тем не менее, пакеты не дают общего решения проблемы захватов. Во-первых, макросы
являются неотъемлемой частью некоторых программ, и было бы неудобно разделять их
на отдельные пакеты. Во-вторых, этот подход не обеспечивает защиты от захвата
другим кодом в макросах пакета.

@node 9-8 Capture in Other Name-Spaces, 9-9 Why Bother?, 9-7 Avoiding Capture with Packages, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-8 Захват в Других Пространствах Имен
@cindex 9-8 Capture in Other Name-Spaces

В предыдущих разделах говорилось о захвате, как если бы это была проблем свойственная
исключительно переменным. Хотя большая часть проблем захвата это захват переменных,
проблема может возникнуть и в других пространствах имен Common Lisp.

Функции так же могут быть локально связаны и привязки функций одинаково ответственны
за непреднамеренный захват. Например:

@example
> (defun fn (x) (+ x 1))
FN
> (defmacro mac (x) `(fn ,x))
MAC
> (mac 10)
11
> (labels ((fn (y) (- y 1)))
        (mac 10))
9
@end example

Как и предсказывает правило захвата, fn который встречается свободным в каркасе mac
подвергается риску захвата. Когда fn локально пересвязывается, mac возвращает другое
значение, чем ожидалось.

Что делать в этом случае? Когда символом подвергающимся риску захвата является
встроенная функци или макрос, то разумнее ничего не делать! В CLTL2 (стр. 260)  
если имя чего-либо встроенного имеет локальную привязку функции или макроса,
последствия не определены." Так что не имеет значения, что делал ваш марос,
некто, кто перепривязывает встроенные функции, будет иметь проблемы не только
с вашим макросом..

В противном случае, вы можете защитить имена функций от захвата аргументами
макроса так же, как защищали бы имена переменных: используя gensyms как имя
для любых функций, заданных локальными определениями в каркасе макроса. Избежать
захвата свободных симолов, как в случае выше, немного сложнее. Способ защитить
переменные от захвата свободных символов, дать им отчетливые глобальные имена:
такие как *warnings* вместо w. Это решение не практично для функций, потому что
не существует соглашения о различении имен глобальных функций - а большинство
функций являются глобальными. Если вы обеспокоены тем. что макрос вызывается в
окружении, где функция может быть переопределена, вероятно лучшим решением, будет
поместить ваш код в отдельный пакет.

Имена блоков также могут быть захвачены, как и теги используемые go и throw.
Когда вашим макросам нужны такие символы, вы должны использовать gensyms, как
в определении our-do на стр. 98.

Помните также , что операторы типа do неявно заключены в блок с именем
nil. Таким образом, возврат(return) или (return-from nil) в пределах
do возвращает из do, а не из содержащего его выражения:

@example
> (block nil
        (list 'a
                (do ((x 1 (1+ x)))
                     (nil)
                   (if (> x 5)
                        (return-from nil x)
                        (princ x)))))
12345
(A 6)
@end example

Если  бы do не создавалось в блоке с именем nil, этот пример вернул бы просто 6,
а не (A 6).

Неявный блок(block) в do не является проблемой, потому что do и должен вести 
себя таким образом.  Однако, вы должны понимать, что если вы пишите макросы,
которые расширяются в do, они захватят имя блока nil. В макросе вроде for, 
return или return-from nil будет возвращать из выражения for, а не из
вмещающего блока(block).

@node 9-9 Why Bother?,  , 9-8 Capture in Other Name-Spaces, 9 Variable Capture
@comment  node-name,  next,  previous,  up
@section 9-9 Зачем Беспокоиться?
@cindex 9-9 Why Bother?

Некоторые из предыдущих примеров довольно патологические. Глядя на них, некто 
может сказать "захват переменных маловероятен - зачем беспокоиться о нём?". 
Есть два способа ответить на этот вопрос. Один ответ с другим вопросом:
зачем писать программы с небольшими ошибками, когда вы можете писать программы
без ошибок?

Более линный ответ состоит в том, чтобы указать, что в реальных приложениях это
опасно, предполагать что-нибудь о том, как будет использоваться ваш код. 
Любая программа на Lisp имеет то, что сейчас называется "открытой архитектурой." 
Если вы пишете код другим людям, они могут использовать его так, как вы никогда
бы не ожидали. Вы должны беспокоитсья о том, что это просто люди. Программы тоже
пишут программы. Может быть, что ни один человек не написал бы код так

@lisp
(before (progn (setq seq '(b a)) 'a)
             'b
             '(a b))
@end lisp

но код, сгенерированный программами, часто выглядит подобным образом. Даже если
отдельные макросы генерируют простые и разумные расширения, как только вы
начнете вкладывать вызовы макросов, расширения могут стать большими программами,
которые не похожи ни на что, что написал бы человек.  При таких обстоятельствах
стоит защищаться от случаев, какими бы надуманными они не были, когда они могут 
привести к неправильному расширению ваших макросов.

В конце концов, избежать захвата переменных не так уж и сложно. Это скоро станет
вашей второй натурой. Классический Common Lisp defmacro похож на нож повара:
элегантная идея, которая кажется опасной, но которой эксперты уверенно пользуются.