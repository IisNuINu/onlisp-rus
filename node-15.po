#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-15.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 11:52+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-15.texi:5
msgid ""
"@node 15 Macros Returning Functions, 16 Macro-Defining Macros, 14 Anaphoric "
"Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 15 Macros Returning Functions\n"
"@cindex 15 Macros Returning Functions"
msgstr ""
"@node 15 Macros Returning Functions, 16 Macro-Defining Macros, 14 Anaphoric "
"Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 15 Макосы возвращающие Функции\n"
"@cindex 15 Macros Returning Functions"

#: texi/node-15.texi:10
msgid ""
"Chapter 5 showed how to write functions which return other functions. "
"Macros\n"
"make the task of combining operators much easier. This chapter will show how "
"to\n"
"use macros to build abstractions which are equivalent to those defined in "
"Chapter 5,\n"
"but cleaner and more efficient."
msgstr ""
"В главе 5 показано, как писать функции, котоыре возвращают другие функции. "
"Макрос\n"
"упрощает задачу объединения операторов. Эта глава покажет, как использовать "
"макросы\n"
"для построения абстракций, эквивалентных тем, которые определены в главе 5, "
"но\n"
"яснее и  более эффективнее."

#: texi/node-15.texi:17
msgid ""
"@menu\n"
"* 15-1 Building Functions::     \n"
"* 15-2 Recursion on Cdrs::      \n"
"* 15-3 Recursion on Subtrees::  \n"
"* 15-4 Lazy Evaluation::        \n"
"@end menu"
msgstr ""

#: texi/node-15.texi:22
msgid ""
"@node 15-1 Building Functions, 15-2 Recursion on Cdrs, 15 Macros Returning "
"Functions, 15 Macros Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-1 Building Functions\n"
"@cindex 15-1 Building Functions"
msgstr ""
"@node 15-1 Building Functions, 15-2 Recursion on Cdrs, 15 Macros Returning "
"Functions, 15 Macros Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-1 Построение Функций\n"
"@cindex 15-1 Building Functions"

#: texi/node-15.texi:25
msgid ""
"If f and g are functions, then f  g(x)=f (g(x)). Section 5-4 showed how to\n"
"implement the   operator as a Lisp function called compose:"
msgstr ""
"Если f и g являются функциями, тогда f ◦ g(x)=f (g(x)). Раздел 5-4 показал, "
"как \n"
"реализовать оператор ◦ как функцию  Lisp называемую  compose:"

#: texi/node-15.texi:30
msgid ""
"@example\n"
"> (funcall (compose #'list #'1+) 2)\n"
"(3)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:38
msgid ""
"In this section, we consider ways to define better function builders with "
"macros.\n"
"Figure 15-1 contains a general function-builder called fn, which builds "
"compound\n"
"functions from their descriptions. Its argument should be an expression of "
"the\n"
"form (operator . arguments). The operator can be the name of a function or\n"
"macro-or compose, which is treated specially. The arguments can be names of\n"
"functions or macros of one argument, or expressions that could be arguments "
"to\n"
"fn. For example,"
msgstr ""
"В этом разделе, мы рассмотрим способы определения лучших "
"компоновщиков(объединителей)\n"
"функцийс помощью макросов. На рисунке 15-1 содержиться общий построитель "
"функций \n"
"называемый fn, который создает составные функции из их описаний. Его "
"аргументом\n"
"должно быть выражение вида (operator . arguments). Оператор(operator) может "
"быть\n"
"именем функции или макроса или  compose, который рассматривается отдельно. "
"Аргументами\n"
"могут быть имена фунций или макросов от одного аргумента, или выражения "
"которые могут\n"
"быть аргументами для fn. Например,"

#: texi/node-15.texi:42
msgid ""
"@lisp\n"
"(fn (and integerp oddp))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:45
msgid ""
"@noindent\n"
"yields a function equivalent to"
msgstr ""
"@noindent\n"
"дает функцию, эквивалентную"

#: texi/node-15.texi:48
msgid ""
"@lisp\n"
"#'(lambda (x) (and (integerp x) (oddp x)))"
msgstr ""
"@lisp\n"
"#'(lambda (x) (and (integerp x) (oddp x)))\n"
"@end lisp"

#: texi/node-15.texi:50
msgid " (defmacro fn (expr) `#',(rbuild expr))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro fn (expr) `#',(rbuild expr))"

#: texi/node-15.texi:57
msgid ""
" (defun rbuild (expr)\n"
"       (if (or (atom expr) (eq (car expr) 'lambda))\n"
"            expr\n"
"            (if (eq (car expr) 'compose)\n"
"                 (build-compose (cdr expr))\n"
"                 (build-call (car expr) (cdr expr)))))"
msgstr ""

#: texi/node-15.texi:64
msgid ""
" (defun build-call (op fns)\n"
"       (let ((g (gensym)))\n"
"         `(lambda (,g)\n"
"             (,op ,@@(mapcar #'(lambda (f)\n"
"                                      `(,(rbuild f) ,g))\n"
"                                 fns)))))"
msgstr ""

#: texi/node-15.texi:75
msgid ""
" (defun build-compose (fns)\n"
"       (let ((g (gensym)))\n"
"         `(lambda (,g)\n"
"             ,(labels ((rec (fns)\n"
"                             (if fns\n"
"                                  `(,(rbuild (car fns))\n"
"                                     ,(rec (cdr fns)))\n"
"                                  g)))\n"
"                 (rec fns)))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:77
msgid "                    Figure 15-1: General function-building macro."
msgstr ""
"                    Рисунок 15-1: Макрос общий построитель функций.\n"
"@end cartouche"

#: texi/node-15.texi:82
msgid ""
"If we use compose as the operator, we get a function representing the "
"compo-\n"
"sition of the arguments, but without the explicit funcalls that were needed "
"when\n"
"compose was defined as a function. For example,"
msgstr ""
"Если мы используем compose в качестве оператора, мы получаем функцию "
"представляющую\n"
"композицию аргументов, но без явных funcall, которые были бы необходимы, "
"когда\n"
"композиция(compose) была определена как функция. Например,"

#: texi/node-15.texi:86
msgid ""
"@lisp\n"
"(fn (compose list 1+ truncate))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:89
msgctxt "texi/node-15.texi:89"
msgid ""
"@noindent\n"
"expands into:"
msgstr ""
"@noindent\n"
"расширяется в:"

#: texi/node-15.texi:93
msgid ""
"@lisp\n"
"#'(lambda (#:g1) (list (1+ (truncate #:g1))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:97
msgid ""
"which enables inline compilation of simple functions like list and 1+. The\n"
"fn macro takes names of operators in the general sense; lambda-expressions "
"are\n"
"allowed too, as in"
msgstr ""
"которая позволяет встроенную компиляцию простых функций, таких как list и "
"1+. \n"
"Макрос fn берет имена операторов в общем смысле; лямбда-выражения также "
"разрешено\n"
"использовать, как в"

#: texi/node-15.texi:101
msgid ""
"@lisp\n"
"(fn (compose (lambda (x) (+ x 3)) truncate))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:104
msgid ""
"@noindent\n"
"which expands into"
msgstr ""
"@noindent\n"
"которое расширяется в"

#: texi/node-15.texi:108
msgid ""
"@lisp\n"
"#'(lambda (#:g2) ((lambda (x) (+ x 3)) (truncate #:g2)))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:112
msgid ""
"Here the function expressed as a lambda-expression will certainly be "
"compiled\n"
"inline, whereas a sharp-quoted lambda-expression given as an argument to "
"the\n"
"function compose would have to be funcalled."
msgstr ""
"Здесь функция выраженная как лямбда-выражение, обязательно будет "
"скомпилирована\n"
"встроенной в вызывающий контекст, в то время как квотированное с "
"решеткой('#) \n"
"лямбда-выражение, переданное в качестве аргумента функции compose должна "
"будет\n"
"вызвана, посредством funcall."

#: texi/node-15.texi:116
msgid ""
"Section 5-4 showed how to define three more function builders: fif, fint,\n"
"and fun. These are now subsumed in the general fn macro. Using and as the\n"
"operator yields the intersection of the operators given as arguments:"
msgstr ""
"В разделе 5-4 показано, как определить еще три построителя функций: fif, "
"fint,\n"
"и fun. Теперь они включены в общий макрос fn. Использование and как "
"оператора\n"
"дает пересечение операторов, заданных в качестве аргументов:"

#: texi/node-15.texi:123
msgid ""
"@example\n"
"> (mapcar (fn (and integerp oddp))\n"
"             '(c 3 p 0))\n"
"(NIL T NIL NIL)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:126
msgid ""
"@noindent\n"
"while or yields the union:"
msgstr ""
"@noindent\n"
"в то время как or дает их объединение:"

#: texi/node-15.texi:133
msgid ""
"@example\n"
"> (mapcar (fn (or integerp symbolp))\n"
"             '(c 3 p 0-2))\n"
"(T T T NIL)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:136
msgid ""
"@noindent\n"
"and if yields a function whose body is a conditional:"
msgstr ""
"@noindent\n"
"и if возвращает функцию, тело которой является условным:"

#: texi/node-15.texi:142
msgid ""
"@example\n"
"> (map1-n (fn (if oddp 1+ identity)) 6)\n"
"(224466)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:144
msgid "However, we can use other Lisp functions besides these three:"
msgstr "Однако, мы можем использовать другие функции Lisp, кроме этих трех:"

#: texi/node-15.texi:151
msgid ""
"@example\n"
"> (mapcar (fn (list 1- identity 1+))\n"
"             '(1 2 3))\n"
"((012)(123)(234))\n"
"@end example"
msgstr ""

#: texi/node-15.texi:154
msgid ""
"@noindent\n"
"and the arguments in the fn expression may themselves be expressions:"
msgstr ""
"@noindent\n"
"и аргументы в выражении fn сами могут быть выражениями:"

#: texi/node-15.texi:162
msgid ""
"@example\n"
"> (remove-if (fn (or (and integerp oddp)\n"
"                                (and consp cdr)))\n"
"                 '(1 (a b) c (d) 2 3-4 (e f g)))\n"
"(C (D) 2 3-4)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:165
msgid ""
"Making fn treat compose as a special case does not make it any more "
"powerful.\n"
"If you nest the arguments to fn, you get functional composition. For example,"
msgstr ""
"Заставляя fn рассматривать compose как особый случай его более мощным.\n"
"Если вы вложите аргументы в fn, вы получите функциональную композицию.\n"
"Например,"

#: texi/node-15.texi:169
msgid ""
"@lisp\n"
"(fn (list (1+ truncate)))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:175
msgctxt "texi/node-15.texi:175"
msgid ""
"@noindent\n"
"expands into:"
msgstr ""
"@noindent\n"
"расширяется в:"

#: texi/node-15.texi:180
msgid ""
"@lisp\n"
"#'(lambda (#:g1)\n"
"         (list ((lambda (#:g2) (1+ (truncate #:g2))) #:g1)))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:183
msgid ""
"@noindent\n"
"which behaves like"
msgstr ""
"@noindent\n"
"которая ведет себя как"

#: texi/node-15.texi:187
msgid ""
"@lisp\n"
"(compose #'list #'1+ #'truncate)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:190
msgid ""
"The fn macro treats compose as a special case only to make such calls easier "
"to\n"
"read."
msgstr ""
"Макрос fn рассматривает compose как особый случай только для упрощения "
"чтения таких\n"
"вызовов."

#: texi/node-15.texi:195
msgid ""
"@node 15-2 Recursion on Cdrs, 15-3 Recursion on Subtrees, 15-1 Building "
"Functions, 15 Macros Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-2 Recursion on Cdrs\n"
"@cindex 15-2 Recursion on Cdrs"
msgstr ""
"@node 15-2 Recursion on Cdrs, 15-3 Recursion on Subtrees, 15-1 Building "
"Functions, 15 Macros Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-2 Рекурсия по Cdrs(по окончанию списка)\n"
"@cindex 15-2 Recursion on Cdrs"

#: texi/node-15.texi:199
msgid ""
"Sections 5-5 and 5-6 showed how to write functions that build recursive "
"functions.\n"
"The following two sections show how anaphoric macros can provide a cleaner\n"
"interface to the functions we defined there."
msgstr ""
"В разделах 5-5 и 5-6 показано, как писать функции, которые создают "
"рекурсивные функции.\n"
"Следующие два раздела показывают как анафорические макросы могут обеспечить "
"ясный\n"
"интерфейс к функциям, которые мы там определили."

#: texi/node-15.texi:202
msgid ""
"Section 5-5 showed how to define a flat list recurser builder called lrec. "
"With\n"
"lrec we can express a call to:"
msgstr ""
"В разделе 5-5 показано, как определить построитель рекурсеров для плоских "
"списков\n"
"с именем lrec. С lrec мы можем выразить вызов:"

#: texi/node-15.texi:209
msgid ""
"@lisp\n"
"(defun our-every (fn lst)\n"
"     (if (null lst)\n"
"           t(and (funcall fn (car lst))\n"
"                 (our-every fn (cdr lst)))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:212
msgctxt "texi/node-15.texi:212"
msgid ""
"@noindent\n"
"for e.g. oddp as:"
msgstr ""
"@noindent\n"
"например для oddp как:"

#: texi/node-15.texi:217
msgid ""
"@lisp\n"
"(lrec #'(lambda (x f) (and (oddp x) (funcall f)))\n"
"           t)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:222
msgid ""
"Here macros could make life easier. How much do we really have to say to\n"
"express recursive functions? If we can refer anaphorically to the current "
"car of\n"
"the list (as it) and the recursive call (as rec), we should be able to make "
"do with\n"
"something like:"
msgstr ""
"Здесь макросы могут облегчить жизнь. Сколько мы должны сказать, чтобы "
"выразить\n"
"рекурсивную функцию? Если мы можем обратиться анафорически к текущему "
"началу(car)\n"
"списка (как it) и рекурсивно вызвать (как rec), мы должны быть в состоянии\n"
"обойтись, чем-то вроде:"

#: texi/node-15.texi:226
msgid ""
"@lisp\n"
"(alrec (and (oddp it) rec) t)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:228
msgid ""
"Figure 15-2 contains the definition of the macro which will allow us to say "
"this."
msgstr ""
"Рисунок 15-2 содержит определение макроса, который позволяет нам сказать это."

#: texi/node-15.texi:235
msgid ""
"@example\n"
"> (funcall (alrec (and (oddp it) rec) t)\n"
"                 '(1 3 5))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-15.texi:247
msgid ""
"@lisp\n"
" (defmacro alrec (rec &optional base)\n"
"    \"cltl2 version\"\n"
"    (let ((gfn (gensym)))\n"
"        `(lrec #'(lambda (it ,gfn)\n"
"                     (symbol-macrolet ((rec (funcall ,gfn)))\n"
"                        ,rec))\n"
"                ,base)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro alrec (rec &optional base)\n"
"    \"cltl2 version\"\n"
"    (let ((gfn (gensym)))\n"
"        `(lrec #'(lambda (it ,gfn)\n"
"                     (symbol-macrolet ((rec (funcall ,gfn)))\n"
"                        ,rec))\n"
"                ,base)))"

#: texi/node-15.texi:255
msgid ""
" (defmacro alrec (rec &optional base)\n"
"    \"cltl1 version\"\n"
"    (let ((gfn (gensym)))\n"
"        `(lrec #'(lambda (it ,gfn)\n"
"                     (labels ((rec () (funcall ,gfn)))\n"
"                        ,rec))\n"
"                ,base)))"
msgstr ""

#: texi/node-15.texi:259
msgid ""
" (defmacro on-cdrs (rec base &rest lsts)\n"
"    `(funcall (alrec ,rec #'(lambda () ,base)) ,@@lsts))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:261
msgid "                     Figure 15-2: Macros for list recursion."
msgstr ""
"                     Рисунок 15-2: Макросы для рекурсии по Списку.\n"
"@end cartouche"

#: texi/node-15.texi:267
msgid ""
"The new macro works by transforming the expression given as the second\n"
"argument into a function to be passed to lrec. Since the second argument "
"may\n"
"refer anaphorically to it or rec, in the macro expansion the body of the "
"function\n"
"must appear within the scope of bindings established for these symbols."
msgstr ""
"Новый макрос работает путем преобразования выражения переданного как второй\n"
"аргумент в функцию для передачи в lrec. Поскольку второй аргумент может "
"ссылаться\n"
"анафорически на it или rec, в расширении макроса тело функции должно "
"находиться \n"
"в области привязок, установленных для этих символов."

#: texi/node-15.texi:274
msgid ""
"Figure 15-2 actually has two different versions of alrec. The version used\n"
"in the preceding examples requires symbol macros (Section 7-11). Only "
"recent\n"
"versions of Common Lisp have symbol macros, so Figure 15-2 also contains\n"
"a slightly less convenient version of alrec in which rec is defined as a "
"local\n"
"function. The price is that, as a function, rec would have to be enclosed "
"within\n"
"parentheses:"
msgstr ""
"На рисунке 15-2 фактически есть две разные версии alrec. Версии используемой "
"в\n"
"предыдущих примерах требуется символьные макросы (Раздел 7-11). Только "
"последние\n"
"версии Common Lisp имеют символьные макросы, поэтому Рисунок 15-2 также "
"содержит\n"
"чуть менее удобную версию alrec, в которой rec определена как локальная "
"функция.\n"
"Цена этого неудобства том, что как функция, rec должна быть заключена в "
"скобки:"

#: texi/node-15.texi:278
msgid ""
"@lisp\n"
"(alrec (and (oddp it) (rec)) t)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:281
msgid ""
"The original version is preferable in Common Lisp implementations which "
"provide\n"
"symbol-macrolet."
msgstr ""
"Оригинальная версия предпочтительнее в реализациях Common Lisp, которые "
"предоставляют\n"
"symbol-macrolet."

#: texi/node-15.texi:284
msgid ""
"Common Lisp, with its separate name-space for functions, makes it awkward\n"
"to use these recursion builders to define named functions:"
msgstr ""
"Common Lisp, с его отдельным пространство имепн для функций делает "
"неудобным\n"
"использование этих построителей рекурсий для определения именованных функций:"

#: texi/node-15.texi:288
msgid ""
"@lisp\n"
"(setf (symbol-function 'our-length)\n"
"        (alrec (1+ rec) 0))"
msgstr ""
"@lisp\n"
"(setf (symbol-function 'our-length)\n"
"        (alrec (1+ rec) 0))\n"
"@end lisp"

#: texi/node-15.texi:295
msgid ""
" (defun our-copy-list (lst)\n"
"       (on-cdrs (cons it rec) nil lst))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun our-copy-list (lst)\n"
"       (on-cdrs (cons it rec) nil lst))"

#: texi/node-15.texi:298
msgid ""
" (defun our-remove-duplicates (lst)\n"
"       (on-cdrs (adjoin it rec) nil lst))"
msgstr ""

#: texi/node-15.texi:301
msgid ""
" (defun our-find-if (fn lst)\n"
"       (on-cdrs (if (funcall fn it) it rec) nil lst))"
msgstr ""

#: texi/node-15.texi:305
msgid ""
" (defun our-some (fn lst)\n"
"       (on-cdrs (or (funcall fn it) rec) nil lst))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:307
msgid "            Figure 15-3: Common Lisp functions defined with on-cdrs."
msgstr ""
"            Рисунок 15-3: Функции Common Lisp определенные с помощью on-"
"cdrs.\n"
"@end cartouche"

#: texi/node-15.texi:311
msgid ""
"The final macro in Figure 15-2 is intended to make this more abstract. "
"Using\n"
"on-cdrs we could say instead:"
msgstr ""
"Последний макрос на Рисунке 15-2 предназначен для того, чтобы сделать это "
"еще\n"
"более абстрактным. С помощью on-cdrs мы могли бы вместо этого, сказать:"

#: texi/node-15.texi:315
msgid ""
"@lisp\n"
"(defun our-length (lst)\n"
"  (on-cdrs (1+ rec) 0 lst))"
msgstr ""

#: texi/node-15.texi:319
msgid ""
"(defun our-every (fn lst)\n"
"  (on-cdrs (and (funcall fn it) rec) t lst))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:324
msgid ""
"Figure 15-3 shows some existing Common Lisp functions defined with the\n"
"new macro. Expressed with on-cdrs, these functions are reduced to their "
"most\n"
"basic form, and we notice similarities between them which might not "
"otherwise\n"
"have been apparent."
msgstr ""
"На Рисунке 15-3 показаны некоторые существующие функции Common Lisp "
"определенные\n"
"с помощью нового макроса. Выраженные с помощью on-cdrs, эти функции упрощены "
"к\n"
"самой общей форме, и мы замечаем сходство между ними, которые иначе не были "
"бы\n"
"очевидны."

#: texi/node-15.texi:330
msgid ""
"Figure 15-4 contains some new utilities which can easily be defined with\n"
"on-cdrs. The first three, unions, intersections, and differences imple-\n"
"ment set union, intersection, and complement, respectively. Common Lisp has\n"
"built-in functions for these operations, but they can only take two lists at "
"a time.\n"
"Thus if we want to find the union of three lists we have to say:"
msgstr ""
"Рисунок 15-4 содержит некотоыре утилиты, которые можно легко определить с\n"
"помощью on-cdrs. Первые три unions, intersections, и differences реализуют\n"
"объединение, пересечение и дополнение множеств, соответственно. Common Lisp\n"
"имеет встроенные функции для этих операций, но они могут принимать только\n"
"два списка одновременно. Таким образом, если мы хотим найти объединение\n"
"трех списков, мы должны сказать:"

#: texi/node-15.texi:336
msgid ""
"@example\n"
"> (union '(a b) (union '(b c) '(c d)))\n"
"(ABCD)\n"
"@end example"
msgstr ""
"@example\n"
"> (union '(a b) (union '(b c) '(c d)))\n"
"(A B C D)\n"
"@end example"

#: texi/node-15.texi:339
msgid ""
"The new unions behaves like union, but takes an arbitrary number of "
"arguments,\n"
"so that we could say:"
msgstr ""
"Новое unions ведет себя также как union, но принимают произвольное "
"количество\n"
"аргументов, так что мы можем сказать:"

#: texi/node-15.texi:345
msgid ""
"@example\n"
"> (unions '(a b) '(b c) '(c d))\n"
"(DCAB)\n"
"@end example"
msgstr ""
"@example\n"
"> (unions '(a b) '(b c) '(c d))\n"
"(D C A B)\n"
"@end example"

#: texi/node-15.texi:352
msgid ""
"@lisp\n"
" (defun unions (&rest sets)\n"
"    (on-cdrs (union it rec) (car sets) (cdr sets)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun unions (&rest sets)\n"
"    (on-cdrs (union it rec) (car sets) (cdr sets)))"

#: texi/node-15.texi:356
msgid ""
" (defun intersections (&rest sets)\n"
"    (unless (some #'null sets)\n"
"         (on-cdrs (intersection it rec) (car sets) (cdr sets))))"
msgstr ""

#: texi/node-15.texi:359
msgid ""
" (defun differences (set &rest outs)\n"
"    (on-cdrs (set-difference rec it) set outs))"
msgstr ""

#: texi/node-15.texi:367
msgid ""
" (defun maxmin (args)\n"
"    (when args\n"
"         (on-cdrs (multiple-value-bind (mx mn) rec\n"
"                      (values (max mx it) (min mn it)))\n"
"                   (values (car args) (car args))\n"
"                   (cdr args))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:369
msgid "                Figure 15-4: New utilities defined with on-cdrs."
msgstr ""
"                Рисунок 15-4: Новые утилиты определенные с помощью on-cdrs.\n"
"@end cartouche"

#: texi/node-15.texi:373
msgid ""
"@noindent\n"
"Like union, unions does not preserve the order of the elements in the "
"initial lists."
msgstr ""
"@noindent\n"
"Подобно union, unions не сохраняет поряедок элементов в начальных списках."

#: texi/node-15.texi:378
msgid ""
"The same relation holds between the Common Lisp intersection and the\n"
"more general intersections. In the definition of this function, the initial "
"test\n"
"for null arguments was added for efficiency; it short-circuits the "
"computation if\n"
"one of the sets is empty."
msgstr ""
"Тоже самое можно сказать в отношении между Common Lisp intersection и более\n"
"общим intersections. В определении этой функции, для эффективности "
"добавлена\n"
"проверка на пустой аргумент; это приводит к более короткой схеме вычислений\n"
"если одно из множеств является пустым."

#: texi/node-15.texi:381
msgid ""
"Common Lisp also has a function called set-difference, which takes two\n"
"lists and returns the elements of the first which are not in the second:"
msgstr ""
"Common Lisp также имеет функцию называемую set-difference, которая "
"принимает\n"
"два списка и возвращает элементы первого, которых нет во втором:"

#: texi/node-15.texi:387
msgid ""
"@example\n"
"> (set-difference '(a b c d) '(a c))\n"
"(D B)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:391
msgid ""
"Our new version handles multiple arguments much as - does. For example,\n"
"(differences x y z) is equivalent to (set-difference x (unions y z)),\n"
"though without the consing that the latter would entail."
msgstr ""
"Наша новая версия обрабатывает несколько аргументов также как и остальные.\n"
"Нарпимер, (differences x y z) эквивалента (set-difference x (unions y z)),\n"
"хотя без создания списка которое влечет за собой последнее выражение."

#: texi/node-15.texi:397
msgid ""
"@example\n"
"> (differences '(a b c d e) '(a f) '(d))\n"
"(BCE)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:401
msgid ""
"These set operators are intended only as examples. There is no real need "
"for\n"
"them, because they represent a degenerate case of list recursion already "
"handled\n"
"by the built-in reduce. For example, instead of"
msgstr ""
"Эти операторы множеств предназначены только для примера. Там нет реальной "
"необходимости\n"
"в них, поскольку они представляют собой вырожденный случай рекурсии, уже "
"обработанный \n"
"встроенной функцией reduce. Например, вместо"

#: texi/node-15.texi:405
msgid ""
"@lisp\n"
"(unions ...)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:411
msgid ""
"@noindent\n"
"you might as well say just"
msgstr ""
"@noindent\n"
"с таким же успехом можно сказать"

#: texi/node-15.texi:415
msgid ""
"@lisp\n"
"((lambda (&rest args) (reduce #'union args)) ...)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:417
msgid "In the general case, on-cdrs is more powerful than reduce, however."
msgstr "Однако в общем случае, on-cdrs является более мощным, чем reduce."

#: texi/node-15.texi:422
msgid ""
"Because rec refers to a call instead of a value, we can use on-cdrs to "
"create\n"
"functions which return multiple values. The final function in Figure 15-4, "
"maxmin,\n"
"takes advantage of this possibility to find both the maximum and minimum "
"ele-\n"
"ments in a single traversal of a list:"
msgstr ""
"Поскольку rec ссылается на вызвов вместо значения, мы можем использовать on-"
"cdrs для\n"
"создания функций, которые возвращают множественные значения. Последняя "
"функция на \n"
"рисунке 15-4, maxmin, использует эту возможность, чтобы найти максимальный и "
"минимальный\n"
"элементы при единственном обходе списка:"

#: texi/node-15.texi:428
msgid ""
"@example\n"
"> (maxmin '(3 4 2 85167))\n"
"81\n"
"@end example"
msgstr ""
"@example\n"
"> (maxmin '(3 4 2 8 5 1 6 7))\n"
"8\n"
"1\n"
"@end example"

#: texi/node-15.texi:431
msgid ""
"It would also have been possible to use on-cdrs in some of the code which\n"
"appears in later chapters. For example, compile-cmds (page 310)"
msgstr ""
"Также было бы возможно испольовать on-cdrs в некотором коде, который "
"появляется\n"
"в последующих главах. Например, compile-cmds (стр. 310)"

#: texi/node-15.texi:438
msgid ""
"@lisp\n"
"(defun compile-cmds (cmds)\n"
"      (if (null cmds)\n"
"           'regs\n"
"           `(,@@(car cmds) ,(compile-cmds (cdr cmds)))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:441
msgid ""
"@noindent\n"
"could have been defined as simply:"
msgstr ""
"@noindent\n"
"можно было бы определить просто:"

#: texi/node-15.texi:446
msgid ""
"@lisp\n"
"(defun compile-cmds (cmds)\n"
"      (on-cdrs `(,@@it ,rec) 'regs cmds))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:451
msgid ""
"@node 15-3 Recursion on Subtrees, 15-4 Lazy Evaluation, 15-2 Recursion on "
"Cdrs, 15 Macros Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-3 Recursion on Subtrees\n"
"@cindex 15-3 Recursion on Subtrees"
msgstr ""
"@node 15-3 Recursion on Subtrees, 15-4 Lazy Evaluation, 15-2 Recursion on "
"Cdrs, 15 Macros Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-3 Рекурсия на Поддеревьях\n"
"@cindex 15-3 Recursion on Subtrees"

#: texi/node-15.texi:455
msgid ""
"What macros did for recursion on lists, they can also do for recursion on "
"trees.\n"
"In this section, we use macros to define cleaner interfaces to the tree "
"recursers\n"
"defined in Section 5-6."
msgstr ""
"То что макросы делали для рекурсии на списках, они также могут делать для "
"рекурсии\n"
"на деревьях. В этом разделе, мы используем макросы для определения более "
"ясных\n"
"интерфейсов для рекурсеров по деревьям определенным в Разделе 5-6."

#: texi/node-15.texi:459
msgid ""
"In Section 5-6 we defined two tree recursion builders,ttrav, which always "
"tra-\n"
"verses the whole tree, and trec which is more complex, but allows you to "
"control\n"
"when recursion stops. Using these functions we could express our-copy-tree"
msgstr ""
"В Разделе 5-6 мы определили два создателя рекурсии по деревьям, ttrav, "
"который всегда\n"
"проходит все дерево, и trec, который является более сложным, но позволяет "
"контролировать,\n"
"когда нужно остановить рекурсию. Используя эти функции мы можем выразить our-"
"copy-tree"

#: texi/node-15.texi:467
msgid ""
"@lisp\n"
"(defun our-copy-tree (tree)\n"
"      (if (atom tree)\n"
"           tree\n"
"           (cons (our-copy-tree (car tree))\n"
"                    (if (cdr tree) (our-copy-tree (cdr tree))))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:470
msgid ""
"@noindent\n"
"as"
msgstr ""
"@noindent\n"
"как"

#: texi/node-15.texi:474
msgid ""
"@lisp\n"
"(ttrav #'cons)\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:477
msgid ""
"@noindent\n"
"and a call to rfind-if"
msgstr ""
"@noindent\n"
"и вызвов  rfind-if"

#: texi/node-15.texi:485
msgid ""
"@lisp\n"
"(defun rfind-if (fn tree)\n"
"  (if (atom tree)\n"
"        (and (funcall fn tree) tree)\n"
"        (or (rfind-if fn (car tree))\n"
"             (and (cdr tree) (rfind-if fn (cdr tree))))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:488
msgctxt "texi/node-15.texi:488"
msgid ""
"@noindent\n"
"for e.g. oddp as:"
msgstr ""
"@noindent\n"
"например для oddp как:"

#: texi/node-15.texi:493
msgid ""
"@lisp\n"
"(trec #'(lambda (o l r) (or (funcall l) (funcall r)))\n"
"        #'(lambda (tree) (and (oddp tree) tree)))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:500
msgid ""
"Anaphoric macros can make a better interface to trec, as they did for lrec "
"in\n"
"the previous section. A macro sufficient for the general case will have to "
"be able\n"
"to refer anaphorically to three things: the current tree, which we'll call "
"it, the\n"
"recursion down the left subtree, which we'll call left, and the recursion "
"down\n"
"the right subtree, which we'll call right. With these conventions "
"established, we\n"
"should be able to express the preceding functions in terms of a new macro "
"thus:"
msgstr ""
"Анафорические макросы могут улучшить интерфейс к trec, как это было сделано "
"для lrec\n"
"в предыдущем разделе. Макрос, достаточный для общего случая, должен быть в "
"состоянии\n"
"анафорически ссылаться на три вещи: текущее дерево, которое мы назовем it, "
"рекурсию\n"
"вниз по левому поддереву, которую мы назовем left, и на рекурсию вниз по "
"правому\n"
"поддереву, которую мы назовем right. Установив эти соглашения, мы будем в "
"состоянии\n"
"выразить предыдущие функции в терминах нового макроса следующим образом:"

#: texi/node-15.texi:503
msgid ""
"@lisp\n"
"(atrec (cons left right))"
msgstr ""

#: texi/node-15.texi:506
msgid ""
"(atrec (or left right) (and (oddp it) it))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:508
msgid "Figure 15-5 contains the definition of this macro."
msgstr "Рисунок 15-5 содержит определение этого макроса."

#: texi/node-15.texi:512
msgid ""
"In versions of Lisp which don't have symbol-macrolet,we can define atrec\n"
"using the second definition in Figure 15-5. This version defines left and "
"right\n"
"as local functions, so our-copy-tree would have to be expressed as:"
msgstr ""
"В весрисях Lisp которые не имеют symbol-macrolet, мы можем определить atrec\n"
"используя второе определение на Рисунке 15-5. Эта версия определяет left и "
"right\n"
"как локальные функции, таким образом our-copy-tree может быть выражено как:"

#: texi/node-15.texi:516
msgid ""
"@lisp\n"
"(atrec (cons (left) (right)))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:520
msgid ""
"For convenience, we also define a macro on-trees, which is analogous to\n"
"on-cdrs from the previous section. Figure 15-6 shows the four functions "
"from\n"
"Section 5-6 defined with on-trees."
msgstr ""
"Для удобства, мы также определим макрос on-trees, который аналогичен on-"
"cdrs \n"
"из предыдущего раздела. На Рисунке 15-6 показаны четыре функции из раздела  "
"5-6 \n"
"определенные с помощью on-trees."

#: texi/node-15.texi:529
msgid ""
"As noted in Chapter 5, functions built by the recurser generators defined "
"in\n"
"that chapter will not be tail-recursive. Using on-cdrs or on-trees to define "
"a\n"
"function will not necessarily yield the most efficient implementation. Like "
"the\n"
"underlying trec and lrec, these macros are mainly for use in prototypes and "
"in\n"
"parts of a program where efficiency is not paramount. However, the "
"underlying\n"
"idea of this chapter and Chapter 5 is that one can write function generators "
"and\n"
"put a clean macro interface on them. This same technique could equally well "
"be\n"
"used to build function generators which yielded particularly efficient code."
msgstr ""
"Как отмечено в Главе 5, функции созданные генератором рекурсеров, "
"определенные\n"
"в этой главе не будут иметь хвостовой рекурсии. Использование on-cdrs или on-"
"trees\n"
"для определения функций не обязательно даст наибольшую эффективную "
"реализацию.\n"
"Лежащие в основе trec и lrec, эти макросы в основном предназначены для "
"использования\n"
"в прототипах и в части программы, где эффективность не имеет первостепенного "
"значения.\n"
"Тем не менеее, основная идея этой главы и главы 5 заключается в том, что "
"можно написать\n"
"генераторы функций и предоставить ясный интерфейс в виде макросов для них. "
"Эта же\n"
"техника может быть одинаково хорошо использована для создания генераторов "
"функций,\n"
"которые создают действительно эффективный код."

#: texi/node-15.texi:539
msgid ""
"@lisp\n"
" (defmacro atrec (rec &optional (base 'it))\n"
"       \"cltl2 version\"\n"
"       (let ((lfn (gensym)) (rfn (gensym)))\n"
"        `(trec #'(lambda (it ,lfn ,rfn)\n"
"                    (symbol-macrolet ((left (funcall ,lfn))\n"
"                                            (right (funcall ,rfn)))\n"
"                       ,rec))\n"
"               #'(lambda (it) ,base))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro atrec (rec &optional (base 'it))\n"
"       \"cltl2 version\"\n"
"       (let ((lfn (gensym)) (rfn (gensym)))\n"
"        `(trec #'(lambda (it ,lfn ,rfn)\n"
"                    (symbol-macrolet ((left (funcall ,lfn))\n"
"                                            (right (funcall ,rfn)))\n"
"                       ,rec))\n"
"               #'(lambda (it) ,base))))"

#: texi/node-15.texi:548
msgid ""
" (defmacro atrec (rec &optional (base 'it))\n"
"       \"cltl1 version\"\n"
"       (let ((lfn (gensym)) (rfn (gensym)))\n"
"        `(trec #'(lambda (it ,lfn ,rfn)\n"
"                    (labels ((left () (funcall ,lfn))\n"
"                                 (right () (funcall ,rfn)))\n"
"                       ,rec))\n"
"               #'(lambda (it) ,base))))"
msgstr ""

#: texi/node-15.texi:552
msgid ""
" (defmacro on-trees (rec base &rest trees)\n"
"       `(funcall (atrec ,rec ,base) ,@@trees))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:554
msgid "                  Figure 15-5: Macros for recursion on trees."
msgstr ""
"                  Рисунок 15-5: Макросы для рекурсии на деревьях.\n"
"@end cartouche"

#: texi/node-15.texi:560
msgid ""
"@lisp\n"
" (defun our-copy-tree (tree)\n"
"       (on-trees (cons left right) it tree))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun our-copy-tree (tree)\n"
"       (on-trees (cons left right) it tree))"

#: texi/node-15.texi:563
msgid ""
" (defun count-leaves (tree)\n"
"       (on-trees (+ left (or right 1)) 1 tree))"
msgstr ""

#: texi/node-15.texi:566
msgid ""
" (defun flatten (tree)\n"
"       (on-trees (nconc left right) (mklist it) tree))"
msgstr ""

#: texi/node-15.texi:572
msgid ""
" (defun rfind-if (fn tree)\n"
"       (on-trees (or left right)\n"
"                (and (funcall fn it) it)\n"
"                tree))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:574
msgid "               Figure 15-6: Functions defined using on-trees."
msgstr ""
"               Рисунок 15-6: Функции определенные с использованием on-"
"trees.\n"
"@end cartouche"

#: texi/node-15.texi:577
msgid ""
"@lisp\n"
" (defconstant unforced (gensym))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defconstant unforced (gensym))"

#: texi/node-15.texi:579
msgid " (defstruct delay forced closure)"
msgstr ""

#: texi/node-15.texi:587
msgid ""
" (defmacro delay (expr)\n"
"    (let ((self (gensym)))\n"
"         `(let ((,self (make-delay :forced unforced)))\n"
"            (setf (delay-closure ,self)\n"
"                     #'(lambda ()\n"
"                          (setf (delay-forced ,self) ,expr)))\n"
"            ,self)))"
msgstr ""

#: texi/node-15.texi:595
msgid ""
" (defun force (x)\n"
"    (if (delay-p x)\n"
"           (if (eq (delay-forced x) unforced)\n"
"                  (funcall (delay-closure x))\n"
"                  (delay-forced x))\n"
"           x))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:597
msgid "                  Figure 15-7: Implementation of force and delay."
msgstr ""
"                  Рисунок 15-7: Реализация force и delay.\n"
"@end cartouche"

#: texi/node-15.texi:602
msgid ""
"@node 15-4 Lazy Evaluation,  , 15-3 Recursion on Subtrees, 15 Macros "
"Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-4 Lazy Evaluation\n"
"@cindex 15-4 Lazy Evaluation"
msgstr ""
"@node 15-4 Lazy Evaluation,  , 15-3 Recursion on Subtrees, 15 Macros "
"Returning Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 15-4 Ленивые вычисления\n"
"@cindex 15-4 Lazy Evaluation"

#: texi/node-15.texi:615
msgid ""
"Lazy evaluation means only evaluating an expression when you need its "
"value.\n"
"One way to use lazy evaluation is to build an object known as a delay. A "
"delay is\n"
"a placeholder for the value of some expression. It represents a promise to "
"deliver\n"
"the value of the expression if it is needed at some later time. Meanwhile, "
"since\n"
"the promise is a Lisp object, it can serve many of the purposes of the value "
"it\n"
"represents. And when the value of the expression is needed, the delay can "
"return\n"
"it. Scheme has built-in support for delays. The Scheme operators force and\n"
"delay can be implemented in Common Lisp as in Figure 15-7. A delay is\n"
"represented as a two-part structure. The first field indicates whether the "
"delay has\n"
"been evaluated yet, and if it has, contains the value. The second field "
"contains a\n"
"closure which can be called to find the value that the delay represents. The "
"macro\n"
"delay takes an expression, and returns a delay representing its value:"
msgstr ""
"Ленивые вычисления означают выполнение вычислений выражения только тогда, "
"когда вам \n"
"нужно его значение. Один из способов использования ленивого(отложенного) "
"вычисления\n"
"является создание объекта известного как задержка(delay). delay это обещание "
"выдать\n"
"значение выражения, если оно необходимо в более позднее время. Между тем, "
"так как\n"
"promise(обещание) является объектом Lisp, оно может служить многим целям "
"представляя\n"
"его значение. И когда значение выражения понадобиться, delay может вернуть "
"его\n"
"Scheme имеет встроенную поддержку для задержек(delays). Оператор Scheme "
"force и\n"
"delay можно реализовать в  Common Lisp как показано на Рисунке 15-7. delay "
"представлена\n"
"как структура из двух частей. Первое поле указывает, была ли delay уже "
"вычислена, и\n"
"если это так, содержит его значение. Второе поле содержит замыкание, которое "
"надо\n"
"вызвать, чтобы найти значение, которое представляет delay. Макрос delay "
"принимает\n"
"выражение, и возвращает delay представляющую его значение:"

#: texi/node-15.texi:621
msgid ""
"@example\n"
"> (let ((x 2))\n"
"        (setq d (delay (1+ x))))\n"
"#S(DELAY ...)\n"
"@end example"
msgstr ""

#: texi/node-15.texi:625
msgid ""
"To call the closure within a delay is to force the delay. The function "
"force\n"
"takes any object: for ordinary objects it is the identity function, but for "
"delays it\n"
"is a demand for the value that the delay represents."
msgstr ""
"Вызвать замыкание внутри delay значит форсировать задержку(force the delay). "
"Функция \n"
"force берет любой объект: для обычных объектов это функция identity(ничего "
"не делает, \n"
"а возвращает сам объект),но для задержек(delays) она требует значение, "
"которое \n"
"эта delay представляет."

#: texi/node-15.texi:631
msgid ""
"@example\n"
"> (force 'a)\n"
"A> (force d)\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-15.texi:634
msgid ""
"We use force whenever we are dealing with objects that might be delays. For\n"
"example, if we are sorting a list which might contain delays, we would say:"
msgstr ""
"Мы используем force всякий раз, когда имеем дело с объектами, которые могут\n"
"быть задержаны(быть delay). Например, если мы сортируем список, который \n"
"может содержать задержки(delay), мы должны сказть:"

#: texi/node-15.texi:638
msgid ""
"@lisp\n"
"(sort lst #'(lambda (x y) (> (force x) (force y))))\n"
"@end lisp"
msgstr ""

#: texi/node-15.texi:641
msgid ""
"It's slightly inconvenient to use delays in this naked form. In a real "
"application,\n"
"they might be hidden beneath another layer of abstraction."
msgstr ""
"Немного не удобно использовать задержки(delay) в этой незащищенной форме. В "
"реальном\n"
"приложении они могут быть скрыты под другим слоем абстракции."
