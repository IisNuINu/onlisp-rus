@node 20 Continuations, 21 Multiple Processes, 19 A Query Compiler, Top
@comment  node-name,  next,  previous,  up
@chapter 20 Продолжения
@cindex 20 Continuations

Продолжение - это программа, замороженная в действии: единый/отдельный функциональный объект
содержащий состояние вычисления. Когда объект вычисляется, сохраненное
вычисление перезапускается с того места, где оно было остановлено. При решении
определенных типов проблем может быть полезно сохранить состояние программы и 
перезапустить её позже. Например в многопроцессной обработке продолжение
представляет собой приостановленный процесс. В недетерминированных программах
поиска продолжение может представлять собой узел в дереве поиска.

Продолжения могут быть трудными для понимания. Эта глава подходит к теме в два этапа.
В первой части главы рассматривается использование продолжений в  Scheme, в которую
встроена их поддержка. После объяснения поведения продолжений, во второй части показано,
как использовать макросы для создания продолжений в программах Common Lisp. Главы 21-­24
используют макросы определенные здесь.

@menu
* 20-1 Scheme Continuations::   
* 20-2 Continuation-Passing Macros::  
* 20-3 Code-Walkers and CPS Conversion::  
@end menu

@node 20-1 Scheme Continuations, 20-2 Continuation-Passing Macros, 20 Continuations, 20 Continuations
@comment  node-name,  next,  previous,  up
@section 20-1 Продолжения Scheme
@cindex 20-1 Scheme Continuations

Одним из основных отличий Scheme от Common Lisp является явная поддержка продлжений.
В этом разделе показано, как работают продолжения в Scheme. (На Рисунке 20-1 перечислены
некоторые другие различия между Scheme и Common Lisp.)

Продолжение это функция, представляющая будущее вычислений. Всякий раз, когда выражение
вычисляется, что-то(другое выражение) ждет значения, которое оно вернет.


@cartouche
@enumerate
@item
Scheme не делает различий между тем, что Common Lisp называет символ-значение и
символ-функция символа. В Scheme, переменная имеет единственное значение, которое
может быть либо функцией или каким-либо другим видом объекта. Таким образом, в
Scheme нет необходимости использовать решётку с кавычкой(#') или funcall. 
Common Lisp:

@lisp
 (let ((f #'(lambda (x) (1+ x))))
   (funcall f 2))
@end lisp

@noindent
будет на Scheme:

@lisp
 (let ((f (lambda (x) (1+ x))))
   (f 2))
@end lisp

@item
Поскольку у Scheme есть только одно пространство имен, ей не нужны отдельные
операторы (например defun и setq) для присваивания значений в случае функции
или переменной. Вместо этого она имеет определение, которое примерно эквивалентно
defvar, и set! - которое заменяет setq.
Глобальные переменные должны быть созданы с помощью define, прежде чем они могут
быть установлены с помощью set!.
@item
В Scheme, именованные функции обычно определяются с помощью define, который заменяет
defun и defvar. Common Lisp:

@lisp
 (defun foo (x) (1+ x))
@end lisp

@noindent
Scheme имеет два возможных варианта:

@lisp
 (define foo (lambda (x) (1+ x)))
 (define (foo x) (1+ x))
@end lisp

@item
В Common Lisp, аргументы функции вычисляются слева на право. В Scheme, порядок
вычисления намеренно не указан. (И разработчики радуются удивлению тех, кто про
это забывает.)
@item
Вместо t и nil, в Scheme есть #t и #f. Пустой списокt, (), в некоторых реализациях
имеет значение истина, а в других ложь.
@item
Предложение по умолчанию в выражениях cond и case имеет ключ else в Scheme, а
не t как в Common Lisp.
@item
Несколько встроенных операторов имеют разные имена: consp это pair?, null это
null?, mapcar это (почти) map, и так далее. Обычно это должно быть очевидно
из контекста.
@end enumerate

        Рисунок 20-1: Несколько отличий между Scheme и Common Lisp.
@end cartouche

  Например, в

@lisp
(/ (- x 1) 2)
@end lisp

когда (- x 1) вычисляется, внешнее выражение / ожидает его значения, а что-то еще
ожидает значения выражения / и так далее, и так далее, вплоть до верхнего уровня-
где ожидает print(в цикле REPL).

Мы можем думать о продолжении в любой момент времени как о фунции одного аргумента.
Если предыдущее выражение было введено на верхнем уровне, то при вычислении
подвыражения (- x 1), продолжение будет:

@lisp
(lambda (val) (/ val 2))
@end lisp

То есть, оставшаяся часть вычисления может быть продублирована путем вызова этой
функции для возвращаемого значения. Если вместо выражения встречающегося в
следующем контексте

@lisp
(define (f1 w)
  (let ((y (f2 w)))
        (if (integer? y) (list 'a y) 'b)))

(define (f2 x)
  (/ (- x 1) 2))
@end lisp

и f1 был вызван из верхнего уровня, тогда когда (- x 1) был вычислен, 
продолжение будет эквивалентно

@lisp
(lambda (val)
  (let ((y (/ val 2)))
        (if (integer? y) (list 'a y) 'b)))
@end lisp

В Scheme, продолжения яляются объектами первого класса, как и функции. Вы можете
запросить у Scheme текущее продолжение, и она создаст вам функцию от одного аргумента,
представляющую будущие вычисления. Вы можете хранить этот объект так долго, как захотите,
и при вызове он перезапустит вычисление, которое имело место при его создании.

Продолжение можно понимать как обобщение замыканий. Замыкание это функция плюс указатели
на лексические переменные, видимые во время его создания. Продолжение является функцией
плсю указатель на весь стек, ожидающий ее в момент создания. Когда продолжение вычисляется,
оно возвращает значение, используя собственную копию стека, игнорируя текущий стек. Если
продолжение создано в момент T1 и вычисляется в момент T2, оно будет вычисляться с помощью 
стека, ожидающего в момент T1.

Программы Scheme имеют доступ к текущему продолжению через встроенный оператор
call-with-current-continuation (call/cc для краткости). Когда программа вызывает
call/cc для функции с одним аргументом:

@lisp
(call-with-current-continuation
  (lambda (cc)
        ...))
@end lisp

функции будет передана другая функция, представляющая текущее продолжение.
Сохраняя где-то значение cc, мы сохраняем состояние вычисления в точке
call/cc.

В этом примере, мы добавляем список, последним элементом которого является
значение, возвращаемое выражением call/cc:

@example
> (define frozen)
FROZEN
> (append '(the call/cc returned)
                 (list (call-with-current-continuation
                         (lambda (cc)
                           (set! frozen cc)
                           'a))))
(THE CALL/CC RETURNED A)
@end example

call/cc возвращает символ a, но сначала сохраняет продолжение в глобальной 
переменной frozen.

Вызов frozen перезапустит старое вычисление в точке call/cc. Какое бы значение
мы не передали frozen оно будет возвращено как значение call/cc:

@example
> (frozen 'again)
(THE CALL/CC RETURNED AGAIN)
@end example

Продолжения не исчерпываются(заканчиваютс) вычислением. Их можно вызывать повторно, 
как и любой другой функциональный объект:

@example
> (frozen 'thrice)
(THE CALL/CC RETURNED THRICE)
@end example
   Когда мы вызываем продолжение в каком-то другом вычислении, мы более
ясно видим, что значит вернуть обратно старый стек:

@example
> (+ 1 (frozen 'safely))
(THE CALL/CC RETURNED SAFELY)
@end example

Здесь, ожидающий "+" игнорируется, когда вызывается frozen. Последний возвращает
стек, который находился в состоянии ожидания в момент его создания: через list, 
затем append, и на верхний уровень, к печати результата. Если бы значение frozen
венулось, как при обычном вызове функции, вышепреведенная операция привела бы
к возникновению ошибки, когда + попробовал бы сложить 1 со списком.

Продолжения не получают уникальной копии стека. Они могут разделять переменные с 
другими продолжениями или с текущими вычислениями. В этом примере два продолжения
используют один и тот же стек:

@example
> (define froz1)
FROZ1
> (define froz2)
FROZ2
> (let ((x 0))
        (call-with-current-continuation
              (lambda (cc)
               (set! froz1 cc)
               (set! froz2 cc)))
        (set! x (1+ x))
        x)
1
@end example

поэтому вызов любого из них будет возвращать последовательные
целые числа:

@example
> (froz2 ())
2> (froz1 ())
3
@end example

Так как значение выражения call/cc будет отброшено, не имеет значения какой аргумент
мы дадим froz1 и froz2.

Теперь, когда мы можем сохранять состояние вычислений, что нам с ними делать?
Главы 21-­24 посвящены приложениям, в которых используются продолжения. Здесь мы 
рассмотрим простой пример, который хорошо передает вкус программирования с сохраненными
состояниями: у нас есть набор деревьев и мы хотим генерировать списки, содержащие один
элемент из каждого дерева, пока мы не получим комбинацию, удовлетворяющую некоторому
условию.

Деревья могут быть представлены в виде вложенных списков. На странице 70 описан
способ представленя одного вида деревьев в виде списка. Здесь мы используем другой,
который позволяет внутренним узлам иметь (атомарные) значения и любое количество
дочерних элементов. В этом представлении внутренний узел становится списком, его
начало(car) содержит значение, хранящееся в узле(node) и его хвост(cdr) содержит
представления дочерних узлов. Например, два дерева, показанные на рисунке 20-2 
могут быть представлены как:

@lisp
(define t1 '(a (b (d h)) (c e (f i) g)))
(define t2 '(1 (2 (3 6 7) 4 5)))
@end lisp

На Рисунке 20-3 показаны функции, которые выполняют обход в глубину на таких 
деревьях. В реальной программе мы хотели бы что-то сделать с узлами, когда мы
встречаемся с ними. Здесь мы просто печатаем их. Функция dft, приведенная для
сравнения, выполняет обычный обход в глубину:

@example
> (dft t1)
ABDHCEFIG()
@end example

@cartouche



                                Рисунок 20-2: Два Дерева.
@end cartouche

Функция dft-node следует тому же пути через дерево, но обрабатывает узлы по
одному за раз. Когда dft-node достигает узла, она следует за началом(car) узла,
и заталкивает в *saved* продолжение для исследования хвоста узла(cdr).

@example
> (dft-node t1)
A
@end example

Вызов перезапуска(restart) продолжает обход, выдавая последнее сохраненное
продолжение и вызывая его.

@example
> (restart)
B
@end example

В конечном итоге не останется ни одного сохраненного состояния, условие которое
давало сигнал перезапуска продолжений вернет done:

@example
...> (restart)
G> (restart)
DONE
@end example

Наконец, функция dft2 аккуратно упаковывает то, что мы только что сделали
в ручную:

@example
> (dft2 t1)
ABDHCEFIG()
@end example

@cartouche
@lisp
 (define (dft tree)
       (cond ((null? tree) ())
               ((not (pair? tree)) (write tree))
               (else (dft (car tree))
                        (dft (cdr tree)))))

 (define *saved* ())

 (define (dft-node tree)
       (cond ((null? tree) (restart))
               ((not (pair? tree)) tree)
               (else (call-with-current-continuation
                           (lambda (cc)
                             (set! *saved*
                                     (cons (lambda ()
                                                (cc (dft-node (cdr tree))))
                                             *saved*))
                             (dft-node (car tree)))))))

 (define (restart)
       (if (null? *saved*)
            'done
            (let ((cont (car *saved*)))
               (set! *saved* (cdr *saved*))
               (cont))))

 (define (dft2 tree)
       (set! *saved* ())
       (let ((node (dft-node tree)))
         (cond ((eq? node 'done) ())
                 (else (write node)
                           (restart)))))
@end lisp

                     Рисунок 20-3: Проход по Дереву используя продолжения.
@end cartouche

Обратите внимание, что в определении dft2 нет явной рекурсии или итерации: печатаются
последовательные узлы, потому что продолжения вызываемые restart всегда возвращаются
через одно и тоже условие cond в dft-node.

Такая программа работает как рудник. Она копает начальную шахту вызывая
dft-node. Пока возвращаемое значение не будет done, код следующий за вызовом
dft-node будет вызывать restart, который снова возвращает управление обратно
в стек.
Этот процесс продолжается, пока возвращаемое значение не сигнализирует, что
рудник пуст. Вместо печати этого значения, dft2 возвращает #f. Поиск с продолжениями
представляет собой новый способ мышления о программах: поместите правильный код
в стек и получите результат, многократно возвращаясь к нему.

Если мы хотим проходить только одно дерево за раз, как в dft2, то нет смысла 
использовать эту технику. Преимущество dft-node в том, что у нас может быть
несколько экземпляров одновременно. Предположим, у нас есть два дерева, и мы
хотим сгенерировать, в порядке поиска в глубину, перекрестное произведение
их элементов.

@example
> (set! *saved* ())
()
> (let ((node1 (dft-node t1)))
        (if (eq? node1 'done)
             'done
             (list node1 (dft-node t2))))
(A 1)
> (restart)
(A 2)
...> (restart)
(B 1)
@end example
...

Используя обыные методы, нам пришлось бы предпринять явные шаги, чтобы сохранять
наше положение на двух деревьях. С продолжениями состояние двух текущих обходов
поддерживается автоматически. В таком простом случае, как этот, сохранить наше 
место на дереве не так уж и сложно. Деревья являются постоянными структурами данных,
поэтому, по крайней мере, у нас есть какой-то способ получить "наше место" на дереве.
Самое замечательное в продолжениях заключается в том, что они могут так же легко,
сохранить наше местоположение в середине любого вычисления, даже если с ним не
связаны постоянные структуры данных. Вычислениея не должны даже иметь конечного
числа состояний, если мы только хотим перезапустить конечное число из них.

Как будет показано в главе 24, оба эти соображения оказываются важными для реализации
Пролога. В программах на Прологе, "деревья поиска" не являются реальными струкурами
данных, но подразумемвают это, когда программа генерирует результаты. И часто, деревья
бесконечны, и в этом случае мы не можем надеяться обыскать одно, прежде чем
искать в следующем; у нас нет выбора, кроме как сохранить наше место, так или 
иначе.

@node 20-2 Continuation-Passing Macros, 20-3 Code-Walkers and CPS Conversion, 20-1 Scheme Continuations, 20 Continuations
@comment  node-name,  next,  previous,  up
@section 20-2 Макросы Передачи Продолжений
@cindex 20-2 Continuation-Passing Macros

Common Lisp не предоставляет call/cc, но с небольшими дополнительными усилиями
мы можем сделать тоже самое, что и в  Scheme. В этом разделе показано, как использовать
макросы для построения продолжений в программан на Common Lisp. Продолжения
Scheme дают нам две вещи:

@enumerate
@item
Привязки всех переменных, во то время когда было создано продолжение.
@item
Состояние вычислений - что должно было произойти с тех пор.
@end enumerate

В лексически ограниченном Lisp, замыкания дают перове из них. Оказывается, что мы можем
использовать замыкания и для поддержки второго, сохраняя состояние вычислений, так же
в привязках переменных.

Макросы, показанные на рисунке 20-4, позволяют выполнять вызовы функций, сохраняя 
продолжения. Эти макросы заменяют встроенные формы Common Lisp для определения 
функций, их вызова и возврата значений.

Функции, которые хотят использовать продолжения (или вызывают функции, которые
это делают), должны быть определены с =defun вместо defun. Синтаксис =defun 
такой же, как и у defun, но его эффект несколько отличается. Вместо определения 
просто функции, = defun определяет функцию и макрос, который расширяется до ее вызова.
(Макрос должен быть определен первым в случае, если функция вызывает себя сама.) 
Функция будет иметь тело, которое было передано в =defun, но будет иметь 
дополнительный параметр *cont*, состоящий из списка своих параметров. В расширении 
макроса эта функция получит *cont* вместе с другими аргументами. Так

@lisp
   (=defun add1 (x) (=values (1+ x)))

   расширяет макрос в
   (progn (defmacro add1 (x)
                  `(=add1 *cont* ,x))
               (defun =add1 (*cont* x)
                  (=values (1+ x))))
@end lisp

Когда мы вызываем add1, мы фактически вызываем не функцию, а макрос. 
Макрос расширяется до вызова функции, @footnote{Функциям, созданным =defun, 
преднамеренно присваиваются интернированные имена, чтобы их можно было 
отследить. Если бы в трассировке не было необходимости, было бы безопаснее 
использовать gensym имена.}, Но с одним дополнительным параметром: *cont*. 
Таким образом, текущее значение *cont* всегда неявно передается при вызове 
оператора, определенного с помощью =defun.

Для чего нужен *cont*? Он будет связан с текущим продолжением. 
Определение =values показывает, как будет использоваться это продолжение. 
Любая функция, определенная с помощью =defun, должна возвращать с
помощью =values или вызывать какую-то другую функцию, которая делает это.

@cartouche
@lisp
 (setq *cont* #'identity)

 (defmacro =lambda (parms &body body)
    `#'(lambda (*cont* ,@@parms) ,@@body))

 (defmacro =defun (name parms &body body)
    (let ((f (intern (concatenate 'string
                                           "=" (symbol-name name)))))
        `(progn
             (defmacro ,name ,parms
                `(,',f *cont* ,,@@parms))
             (defun ,f (*cont* ,@@parms) ,@@body))))

 (defmacro =bind (parms expr &body body)
    `(let ((*cont* #'(lambda ,parms ,@@body))) ,expr))

 (defmacro =values (&rest retvals)
    `(funcall *cont* ,@@retvals))

 (defmacro =funcall (fn &rest args)
    `(funcall ,fn *cont* ,@@args))

 (defmacro =apply (fn &rest args)
    `(apply ,fn *cont* ,@@args))
@end lisp

                    Рисунок 20-4: Макросы передающие продолжения.
@end cartouche

Синтаксис =values такой же, как и у той же формы Common Lisp. Он может возвращать 
несколько значений, если существует =bind с тем же числом аргументов, ожидающий их,
но не может возвращать несколько значений на верхний уровень.

Параметр *cont* сообщает функции, определенной  =defun, что делать с возвращаемым
значением. Когда =values макро расширяется, он будет захватывать *cont* и 
использовать его для имитации возврата из функции. Выражение

@example
> (=values (1+ n))
@end example

расширяется в

@lisp
(funcall *cont* (1+ n))
@end lisp

На верхнем уровне значение *cont* является тождеством, которое просто возвращает то,
что ему передано. Когда мы вызываем (add1 2) с верхнего уровня, вызов получает
макрорасширение эквивалентное

@lisp
(funcall #'(lambda (*cont* n) (=values (1+ n))) *cont* 2)
@end lisp

Ссылка *cont* в этом случае получит глобальную привязку. Таким образом, выражение 
=values будет макрорасширяться в эквивалент:

@lisp
(funcall #'identity (1+ n))
@end lisp

который просто добавляет 1 к n и возвращает результат.

В таких функциях, как add1, мы проходим через все эти проблемы только для того, 
чтобы имитировать, что делают, в любом случае, вызов функции Lisp и возврат:

@example
> (=defun bar (x)
        (=values (list 'a (add1 x))))
BAR
> (bar 5)
(A 6)
@end example

Дело в том, что теперь мы взяли вызов функции и ее возврат под свой собственный 
контроль и можем сделать другие вещи, если захотим.

Именно манипулируя *cont*, мы получим эффект продолжений.
Хотя *cont* является глобальным значением, оно редко будет использоваться: *cont* 
почти всегда будет параметром, захватываемым =values и макросами, определенными 
=defun. Например, в теле add1 *cont* является параметром, а не глобальной переменной.
Это различие важно, потому что эти макросы не работали бы, если бы *cont* не была 
локальной переменной. Вот почему *cont* получает свое начальное значение в setq 
вместо defvar: последний также объявит его специальным.

Третий макрос на рис. 20-4, =bind, предназначен для использования так же, как и
multiple-value-bind(множественное связывание). Он принимает список параметров, 
выражение и тело кода: параметры привязываются к значениям, возвращаемым выражением, 
и тело кода вычисляется с помощью этих привязок. Этот макрос должен использоваться 
всякий раз, когда дополнительные выражения должны вычисляться после вызова функции, 
определенной с помощью =defun.

@example
> (=defun message ()
        (=values 'hello 'there))
MESSAGE

> (=defun baz ()
        (=bind (m n) (message)
          (=values (list m n))))
BAZ
> (baz)
(HELLO THERE)
@end example

Обратите внимание, что расширение =bind создает новую переменную с именем *cont*. 
Тело baz макроса расширяется в:

@lisp
(let ((*cont* #'(lambda (m n)
                          (=values (list m n)))))
  (message))
@end lisp

@noindent
который в свою очередь становится:

@lisp
(let ((*cont* #'(lambda (m n)
                          (funcall *cont* (list m n)))))
  (=message *cont*))
@end lisp

Новое значение *cont* является телом выражения =bind, поэтому, когда message
«возвращается» с помощью функции *cont*, результатом будет вычисление тела кода. 
Однако (и это ключевой момент) в теле =bind:

@example
#'(lambda (m n)
        (funcall *cont* (list m n)))
@end example

*cont*, который был передан в качестве аргумента =baz, все еще виден, поэтому, 
когда тело кода в свою очередь вычисляет =values, оно будет иметь возможность 
вернуться к исходной вызывающей функции. Замыкания связаны между собой: каждая
привязка *cont* является замыканием, содержащим предыдущую привязку *cont*, 
образуя цепочку, которая ведет обратно к глобальному значению.

  Мы можем увидеть тот же эффект, но в меньшем масштабе, здесь:

@example
> (let ((f #'identity))
        (let ((g #'(lambda (x) (funcall f (list 'a x)))))
          #'(lambda (x) (funcall g (list 'b x)))))
#<Interpreted-Function BF6326>
> (funcall * 2)
(A (B 2))
@end example

В этом примере создается функция, которая является замыканием, содержащим ссылку на g, 
которая сама является замыканием, содержащим ссылку на f. Подобные цепочки замыканий 
были построены компилятором сетей на стр. 80.

@cartouche
@enumerate
@item
Список параметров функции, определенной с помощью =defun, должен состоять
исключительно из имен параметров.
@item
Функции, использующие продолжения или вызывающие другие функции, которые это
делают, должны быть определены с помощью =lambda или =defun.
@item
Такие функции должны завершаться, либо путем возврата значений с использованием
=values, или вызовом другой функции, которая подчиняется этому ограничению.
@item
Если в сегменте кода встречается выражение =bind, =values, =apply, или =funcall,
это должен быть хвостовой вызов. Любой код, который будет вычисляться после =bind,
должен быть помещен в его тело.  Поэтому, если мы хотим иметь несколько привязок
=binds следующих друг за другом, они должны быть вложенными:
@end enumerate

@lisp
 (=defun foo (x)
       (=bind (y) (bar x)
         (format t "Ho ")
         (=bind (z) (baz x)
            (format t "Hum.")
            (=values x y z))))
@end lisp

              Рисунок 20-5: Ограничения накладываемые на макросы передающие продолжения.
@end cartouche

Остальные макросы, =apply и =funcall, предназначены для использования с функциями,
определенными =lambda. Обратите внимние, что "функции" определенные с помощью =defun,
поскольку на самом деле они являются макросами, не могут быть заданы в качестве
аргументов для apply или funcall. Обход этой проблемы аналогичен уловке упомянутой
на стр. 110. Она заключается в том, чтобы упаковать вызов в другую =lambda:

@example
> (=defun add1 (x)
        (=values (1+ x)))
ADD1
> (let ((fn (=lambda (n) (add1 n))))
        (=bind (y) (=funcall fn 9)
           (format nil "9 + 1 = ~A" y)))
"9+1=10"
@end example

На рисунке 20-5 обобщены все ограничения, накладываемые на макросы передающие 
продолжения. Функции, которые ни сохраняют продолжения, ни вызывают другие функции,
которые это делают, не должны использовать эти специальные макросы. Например,
исключаются встроенные функции, такие как list.

Рисунок 20-6 содержит код из Рисунка 20-3, переведенный со Scheme на Common 
Lisp, и использующий макросы передающие продолжения вместо продолжений Scheme.

@cartouche
@lisp
 (defun dft (tree)
       (cond ((null tree) nil)
             ((atom tree) (princ tree))
             (t (dft (car tree))
                (dft (cdr tree)))))

 (setq *saved* nil)

 (=defun dft-node (tree)
       (cond ((null tree) (restart))
             ((atom tree) (=values tree))
             (t (push #'(lambda () (dft-node (cdr tree)))
                         *saved*)
                (dft-node (car tree)))))

 (=defun restart ()
       (if *saved*
          (funcall (pop *saved*))
          (=values 'done)))

 (=defun dft2 (tree)
       (setq *saved* nil)
       (=bind (node) (dft-node tree)
        (cond ((eq node 'done) (=values nil))
               (t (princ node)
                   (restart)))))
@end lisp

          Рисунок 20-6: Обход дерева с использованием макросов передающих продолжения.
@end cartouche

С тем же примером дерева, dft2 работает также как и раньше:

@example
> (setq t1 '(a (b (d h)) (c e (f i) g))
           t2 '(1 (2 (3 6 7) 4 5)))
(1 (2 (3 6 7) 4 5))
> (dft2 t1)
ABDHCEFIG
NIL
@end example

Сохранение состояний нескольких обходов также работает как в Scheme, хотя пример
становитсья немного длиннее:

@example
> (=bind (node1) (dft-node t1)
        (if (eq node1 'done)
             'done
             (=bind (node2) (dft-node t2)
               (list node1 node2))))
(A 1)
> (restart)
(A 2)
...> (restart)
(B 1)
...
@end example

Связывая вместе в цепочку лексические замыкания, программы Common Lisp могут 
создавать свои собственные продолжения. К счастью, замыкания связываются вместе
внутри макросов представленных на Рисунке 20-4, и пользователь может получить
эффект использования продолжений, не задумываясь о его происхождении.

Все главы 21-­24 так или иначе опираются на продолжения. Эти главы покажут, что
продолжения это абстракция необычной силы.  Они могут быть не слишком быстрыми,
особенно когда они реализованы поверх языка в виде макросов, но абстракции,
которые мы можем строить на их основе, делают создание некоторых программ
намного быстрее, и ускорение этой работы также очень важно.

@node 20-3 Code-Walkers and CPS Conversion,  , 20-2 Continuation-Passing Macros, 20 Continuations
@comment  node-name,  next,  previous,  up
@section 20-3 Code-Walkers(Путешественник по Коду) и преобразование к CPS(стилю передачи продолжений)
@cindex 20-3 Code-Walkers and CPS Conversion

Макросы описанные в предыдущем разделе, представляют собой компромисс. Они дают нам
силу продолжений, но только если мы напишем наши программы опредленным образом.
Правило 4 на Рисунке 20-5 означает, что мы должны написать

@lisp
(=bind (x) (fn y)
       (list 'a x))
@end lisp

@noindent
скорее чем

@lisp
(list 'a                                                                ; wrong
           (=bind (x) (fn y) x))
@end lisp

Настоящий call/cc не накладывает таких ограничений на программиста. call/cc может
получить продолжение в любой точке программы любой формы. Мы могли бы реализовать
оператор имеющий всю мощь call/cc, но это потребовало бы намного больше работы.
В этом разделе описывается как это можно сделать.

Программа на Lisp может быть преобразована в форму называемую "стиль передачи
продолжений"(continuation-passing style). Программы прошедшие полное преобразование
CPS, невозоможно читать, но можно понять дух этого процесса, взглянув на код, который
был частично преобразован. Следующая функция для реверсирования списков:                     

@lisp
(defun rev (x)
  (if (null x)
          nil
          (append (rev (cdr x)) (list (car x)))))
@end lisp

@noindent
имеет эквивалентную версию написанную в стиле передачи продолжений:

@lisp
(defun rev2 (x)
  (revc x #'identity))

(defun revc (x k)
  (if (null x)
          (funcall k nil)
          (revc (cdr x)
                  #'(lambda (w)
                         (funcall k (append w (list (car x))))))))
@end lisp

При использовании стиля передачи продолжений, функции получают дополнительный параметр
(здесь k), значением которого будет продолжение. Продожение является замыканием,
представляющим то, что должно быть сделано с текущим значением функции. В первой
рекурсси продожением является identity; т.е то что должно быть сделано, это то, что
функция дожна просто вернуть значение своего аргумента. На второй рекурсии продолжение
будет эквивалентно:

@lisp
#'(lambda (w)
        (identity (append w (list (car x)))))
@end lisp

что говорит о том, что нужно сделать, это добавить начало(car) списка к текущему значению
и вернуть результат.

Как только вы сможете выполнить преобразование CPS, становиться легко написать 
call/cc. В программе, которая подверглась преобразованию CPS, всегда присутствуют
все текущие продожения, и  call/cc может быть реализован как простой макрос, который
вызывается с некоторой функцией в качестве его аргумента.

Для преобразования кода в CPS нам понадобиться программа-обходчик(code-walker), 
которая обходит дерево, представляющее исходный код программы. Написание code-walker
для Common Lisp это серьёзная задача. Чтобы быть полезным, code-walker должен делать
больше, чем просто обходить выражения. Он также должен знать много о том, что
означают эти выражения. Например, code-walker не может просто мыслить в терминах
символов. Символ может представлять собой, помимо прочего, функцию, переменную, имя
блока или тег для перехода. code-walker должен использовать контекст, чтобы отличать
одно от другого, и действовать соответственно.

Поскольку написание code-walker выходит за рамки этой книги, макросы описанные в
этой главе, являются наиболее практичной альтернативой. Макросы в этой главе
разделяют работу по созданию продолжений вместе с пользователем. Если пользователь
пишет программы в чем-то достаточно близком к CPS, макросы будут делать все остальное.
Вот чем на самом деле является правило  4: если все, что следует за выражением =bind,
находиться внутри его тела, затем между значением *cont* и кодом в теле =bind, 
программа имеет достаточно инофрмации для создания текущего продолжения.

Макрос =bind специально написан, чтобы сделать этот стиль программирования
наиболее естественным. На практике ограничения, накладываемые макросами
передающими продолжения, терпимы.