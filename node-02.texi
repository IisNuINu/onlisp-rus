@node 2 Functions, 3 Functional Programming, 1 Extensible Language , Top
@comment  node-name,  next,  previous,  up
@chapter 2 Функции
@cindex 2 Functions

Функции - стандартные блоки программ Лисп. Они также и стандартные
блоки Лисп. В большинстве языков оператор ”+” – это нечто, совершенно
отличное от определяемых пользователем функций. Но у Лисп есть единая
модель для описания всех вычислений, сделанных программой – применение
функций. В Лисп оператор ”+” – это точно такая же функция, какую вы
можете определить сами.

В действительности, за исключением небольшого количества операторов,
называемых специальными формами, ядро Лисп – это коллекция функций
Лисп. Что же остановит вас от пополнения коллекции? Совершенно
ничего. Если вы думаете о чем-нибудь, что бы вам хотелось, чтобы делал Лисп,
то можете написать это сами, и ваша новая функция будет работать точно
так же, как встроенная.
Этот факт имеет важные следствия для программиста. Это означает, что
любую новую функцию можно рассматривать или как дополнение к Лисп, или
как часть определенного приложения. Как правило, опытный программист
Лисп напишет всего понемногу, корректируя границу между языком и
приложением, пока они не подойдут друг другу идеально. Эта книга о
том, как достигнуть хорошей подгонки между языком и приложением. 
Поскольку всё, что мы делаем в этом направлении, в конечном счете, 
зависит от функций, функция – это естественная точка отсчета.

@menu
* 2-1 Functions as Data::       
* 2-2 Defining Functions::      
* 2-3 Functional Arguments::    
* 2-4 Functions as Properties::  
* 2-5 Scope::                   
* 2-6 Closures::                
* 2-7 Local Functions::         
* 2-8 Tail-Recursion::          
* 2-9 Compilation::             
* 2-10 Functions from Lists::   
@end menu

@node 2-1 Functions as Data, 2-2 Defining Functions, 2 Functions, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-1 Функции в качестве данных
@cindex 2-1 Functions as Data

Функции Лисп отличаются двумя вещами. Первая, упомянутая выше, это то,
что сам Лисп – коллекция функций. Это означает, что мы можем добавить
к Лисп свои новые операторы. Другая важная вещь, которую нужно знать о
функциях, это то, что они являются объектами Лисп.


В Лисп можно найти большинство типов данных, которые имеются в других
языках. Такие, как целые числа и числа с плавающей запятой, строки,
массивы, структуры и так далее. А еще Лисп поддерживает один тип
данных, который может поначалу вызвать удивление: функция. Почти все
языки программирования в том или ином виде поддерживают функции или
процедуры. Что значит, когда говорят, что Лисп представляет функции
как тип данных? Это значит, что в Лисп мы можем делать с ними то же
самое, что могли бы делать с известными типами данных, например,
целыми числами: создавать новые во время выполнения, сохранять их в
переменных и в структурах, передавать их как параметры другим функциям
и возвращать их как результаты.

Способность создавать и возвращать функции во время выполнения
особенно полезна. Сначала кажется, что это сомнительное преимущество,
подобно такому, как самомодифицирующиеся программы на машинном языке,
которые могут работать на некоторых компьютерах. Но создание новых
функций во время выполнения, оказывается, обычная методика
программирования на Лисп.


@node 2-2 Defining Functions, 2-3 Functional Arguments, 2-1 Functions as Data, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-2 Определение функций.
@cindex 2-2 Defining Functions

Многие люди сначала учатся, как создавать функции при помощи defun. Следующее выражение 
определяет функцию с именем double, которая возвращает удвоение аргумента.

@example
> (defun double (x) (* x 2))
DOUBLE
@end example

Скормив это Lisp, мы можем вызывать double из других функций или из
верхнего уровня:

@example
> (double 1)
2
@end example

Файл с исходным кодом Лисп, как правило, состоит из подобных defun и
этим походит на файл с определением процедур на языке Си или Паскаль. 
Но происходит кое-что совершенно другое. Эти defun – это не
только определения процедур, но и вызовы Лисп. Это различие станет
более ясным, когда мы увидим, что же происходит внутри defun.

Функции – это полноправные объекты. На самом деле, defun выстраивает
такой объект и сохраняет его под именем, заданным первым
аргументом. Помимо этого, по имени double, мы можем выяснить, что за функция
его реализует. Обычно это делают при помощи оператора #'. Этот
оператор следует понимать как отображение имен на существующие
функциональные объекты. Применяя его к имени double,

@example
> #'double
#<Interpreted-Function C66ACE>
@end example

мы получим реально существующий объект, созданный определением выше. Хотя это 
напечатанное представление меняется от реализации к реализации, функция Коммон Лисп – 
это объект первого класса с полностью такими же правами, как и более привычные объекты,
вроде чисел и строк. Так что мы можем передавать эту функцию как аргумент,
возвращать ее, сохранять в структуре данных и так далее:

@example
> (eq #'double (car (list #'double)))
T
@end example

Нам даже не нужен defun, чтобы создавать функции. Как и на большинство
объектов Лисп, мы можем прямо на них ссылаться. Когда мы хотим
сослаться на целое число, мы прямо используем само целое число. Для
представления строки мы используем последовательность символов,
окруженных двойными кавычками. Для представления функции мы используем
так называемое лямбда-выражение. Лямбда-выражение – это список,
состоящий из трех частей: символа лямбда, списка параметров и тела из
нуля или более выражений. Лямбда-выражение ссылается на функцию,
эквивалентную double:

@lisp
(lambda (x) (* x 2))
@end lisp

Оно описывает функцию, принимающую один аргумент x и возвращающую 2x.

Лямбда-выражение также может рассматриваться как имя функции. Если
double – имя собственное, как “Микеланджело”, то (lambda (x) (* x 2))
– точное определение, как “человек, расписавший свод Сикстинской
капеллы”. Помещая диез-кавычку перед лямбда-выражением, мы получим
соответствующую функцию:

@example
> #'(lambda (x) (* x 2))
#<Interpreted-Function C674CE>
@end example
— : After #\# is #\RIGHT_SINGLE_QUOTATION_MARK an undefined dispatch
macro Измените, пожалуйста, апострофы на прямые '. При копировании
примеров в интерпретатор Lisp ошибки выполнения форм. — lispuser

Эта функция ведет себя точно так же, как и double, но это два различных объекта.

При вызове функции имя функции идет в начале, а за ним следуют
аргументы:


@example
> (double 3)
6
@end example

Так как лямбда-выражения – это также имена функций, то при вызове
функций они также могут появиться в начале:

@example
> ((lambda (x) (* x 2)) 3)
6
@end example

В Коммон Лисп у нас одновременно может быть функция с именем double и
переменная с именем double.

@example
> (setq double 2)
2> (double double)
4
@end example

Когда имя встречается первым при вызове функции или ему предшествует
диез-кавычка, то оно воспринимается как ссылка на функцию. В противном
случае рассматривается как имя переменной.

Именно поэтому говорят, что Коммон Лисп имеет различные пространства имен
для переменных и функций. У нас может быть переменная с именем foo и
функция с именем foo, и им необязательно быть одинаковыми. Ситуация
может сбивать с толку и приводить к определенному уродству в коде, но
это что-то, с чем программисты Common Lisp вынуждены сосуществовать.


Если необходимо, Коммон Лисп предоставляет две функции, отображающие
символы в значения или функции, которые они представляют. Функция
symbol-value принимает символ и возвращает значение соответствующей
специальной переменной:

@example
> (symbol-value 'double)
2
@end example

в то время как symbol-function делает то же самое для глобально
определенной функции:

@example
> (symbol-function 'double)
#<Interpreted-Function C66ACE>
@end example

Обратите внимание: так как функции являются обычными объектами данных,
переменные могут иметь функцию в качестве значения:

@example
> (setq x #'append)
#<Compiled-Function 46B4BE>
> (eq (symbol-value 'x) (symbol-function 'append))
T
@end example

За кулисами defun устанавливает symbol-function от первого аргумента
на функцию, состоящую из последующих аргументов. Следующие два
выражения делают примерно то же самое:

@lisp
(defun double (x) (* x 2))

(setf (symbol-function 'double)
          #'(lambda (x) (* x 2)))
@end lisp

Итак, defun делает то же, что и описание процедуры в других языках –
связывает имя с участком кода. Но лежащий в основе механизм иной. Нам
не нужен defun для создания функций, и функции не обязаны сохраняться
как значение некоторого символа. В основе defun, который аналогичен
описанию процедуры в любом другом языке, лежит более общий механизм:
создание функции и связывание ее с определенным именем – это две
различные операции. Когда нам не требуется полная общность
представления функций в Лисп, defun делает определение функции таким
же простым, как и в более ограниченных языках.

@node 2-3 Functional Arguments, 2-4 Functions as Properties, 2-2 Defining Functions, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-3 Функциональные аргументы
@cindex 2-3 Functional Arguments

Представление функций как объектов данных означает, помимо прочего,
что мы можем передавать их в качестве аргументов другим функциям. Эта
возможность отчасти отвечает за важность восходящего программирования
в Лисп.

Язык, допускающий функции в качестве объектов данных, должен также
предоставить определенные способы их вызова. В Лисп это функция
apply. Вообще, мы вызываем apply с двумя аргументами: функцией и
списком ее аргументов. Все последующие четыре выражения выполняют одно
и то же действие:

@lisp
(+ 1 2)

(apply #'+ '(1 2))

(apply (symbol-function '+) '(1 2))

(apply #'(lambda (x y) (+ x y)) '(1 2))
@end lisp

В Коммон Лисп apply может принимать любое число аргументов, и функция,
заданная первой, будет применена к списку, полученному путем синтеза в
него оставшихся аргументов, заданному в конце. Так, выражение


@lisp
(apply #'+ 1 '(2))
@end lisp

эквивалентно четырем предыдущим. Если задавать аргументы в виде списка
неудобно, то мы можем использовать funcall, который отличается от
apply только в этом отношении. Это выражение

@lisp
(funcall #'+ 1 2)
@end lisp

выполняет то же действие, что и все предыдущие.

Множество встроенных в Коммон Лисп функций принимает функциональные
аргументы. Среди наиболее широко используемых находятся отображающие
функции. Например, mapcar принимает два или более аргументов, функцию
и один или более списков (один на каждый параметр функции) и применяет
функцию последовательно к элементам каждого списка:

@example
> (mapcar #'(lambda (x) (+ x 10))
               '(1 2 3))
(11 12 13)
> (mapcar #'+
               '(1 2 3)
               '(10 100 1000))
(11 102 1003)
@end example

Программы на Лисп часто испытывают необходимость делать что-то с
каждым аргументом списка и вернуть назад список результатов. Первый
пример, приведенный выше, показывает обычный способ это реализовать:
создать функцию, которая выполняет то, что вам нужно, и при помощи
mapcar применить ее к списку.

Мы уже видим, насколько удобно иметь возможность обращаться с
функциями, как с данными. Во многих языках, даже если мы могли бы
передать функцию в качестве аргумента чему-то, вроде mapcar, она бы,
тем не менее, была функцией, определенной заранее в каком-нибудь
исходном файле. Если бы требовался именно цельный код, добавляющий 10
к каждому элементу списка, мы бы определили функцию с именем plus
ten или каким-то подобным только для этого единственного применения. С
помощью лямбда выражений мы можем ссылаться на функции
непосредственно.


Одно из существенных отличий между Коммон Лисп и предшествовавшими ему
диалектами состоит в огромном количестве встроенных функций,
принимающих функциональные аргументы. Две из наиболее используемых
после вездесущего mapcar – это sort и remove-if. Первая из них
является функцией сортировки общего назначения. Она принимает список
аргументов и предикат, а возвращает список, отсортированный
пропусканием через предикат каждой пары элементов.

@example
> (sort '(1 4 2 5 6 7 3) #'<)
(1234567)
@end example

Чтобы запомнить, как работает sort, полезно помнить, что если вы
сортируете список без повторяющихся элементов с помощью <, а затем
примените < к результирующему списку, он вернет true.

Если бы remove-if не был бы включен в Коммон Лисп, то это, возможно,
была бы первая утилита, которую бы вы написали. Она принимает функцию
и список, а возвращает все элементы списка, для которых функция
вернула false.

@example
> (remove-if #'evenp '(1 2 3 4 5 6 7))
(1 3 5 7)
@end example

В качестве примера функции, принимающей функциональные аргументы,
здесь приводится определение ограниченной версии remove-if:


@lisp
(defun our-remove-if (fn lst)
  (if (null lst)
            nil
            (if (funcall fn (car lst))
                   (our-remove-if fn (cdr lst))
                   (cons (car lst) (our-remove-if fn (cdr lst))))))
@end lisp

Заметим, что в этом определении fn используется без диеза-кавычки. Так
как функции являются объектами данных, то переменные могут содержать
функцию в качестве обычного значения. Вот что здесь
происходит. Диез-кавычка служит только для ссылки на функцию, имеющую
символьное имя, как правило, глобально определенное с помощью defun.


Как покажет глава 4, написание новых утилит, принимающих
функциональные аргументы, является важным элементом программирования
снизу-вверх. В Коммон Лисп есть так много встроенных утилит, что та,
которая вам требуется, возможно, уже существует. Но используете ли вы
встроенные функции, как sort, или пишете собственные утилиты, принцип
тот же. Вместо того, чтобы вписывать функциональность, передавайте
функциональный аргумент.


@node 2-4 Functions as Properties, 2-5 Scope, 2-3 Functional Arguments, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-4 Функции в качестве свойств
@cindex 2-4 Functions as Properties

То обстоятельство, что функции Лисп являются объектами, также
позволяет нам писать программы, которые могут быть расширены на лету
для работы в изменившихся условиях. Допустим, мы хотим написать
функцию, принимающую аргумент – вид животного и ведущую себя
соответственно. В большинстве языков естественным средством для этого
будет оператор case, и мы точно так же можем это сделать и в Lisp:

@lisp
(defun behave (animal)
  (case animal
        (dog (wag-tail)
               (bark))
        (rat (scurry)
               (squeak))
        (cat (rub-legs)
               (scratch-carpet))))
@end lisp

       Что, если нам потребуется добавить новый тип животного? Если бы мы
хотели добавить новых животных, то было бы лучше определить behave
следующим образом:

@lisp
(defun behave (animal)
  (funcall (get animal 'behavior)))
@end lisp

и определить поведение отдельного животного как функцию, сохраненную,
к примеру, в списке свойств его имени:

@lisp
(setf (get 'dog 'behavior)
            #'(lambda ()
               (wag-tail)
               (bark)))
@end lisp

В таком случае, все, что потребуется сделать для добавления нового
животного это определить новое свойство. Никаких функций переписывать
не нужно.

Другой подход, несмотря на большую гибкость кажется медленным. Так и
есть. Если скорость была бы критична, то мы использовали бы структуры
вместо списков свойств и, главным образом, компилированные, вместо
интерпретируемых функций. (Раздел 2.9 объясняет, как это
сделать). Более гибкий вид кода, со структурами и компилированными
функциями , может приблизиться или обогнать по скорости версии,
использующие оператор case.

Такое использование функций передаёт концепцию методов в
объектно-ориентированном программировании. Собственно, метод – это
функция, являющаяся свойством объекта, и это всё. Если мы добавим
наследование в эту модель, то получим все элементы
объектно-ориентированного программирования. Глава 25 покажет, как
сделать это с удивительно маленьким кодом.

Одним из больших преимуществ объектно-ориентированного
программирования является расширяемость. Такая перспектива не особо
удивительна в мире Лиспа, где расширяемость всегда была в порядке
вещей. Если она не очень сильно зависит от наследования, то простоты
Лиспа уже может хватать.

@node 2-5 Scope, 2-6 Closures, 2-4 Functions as Properties, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-5 Область видимости(Scope)
@cindex 2-5 Scope

Common Lisp — Лисп с лексическим связыванием. Scheme является
старейшим диалектом с лексическим связыванием; до Scheme динамическое
связывание считалось одной из особенностей Лиспа.

Разница между лексической и динамической областью действия связываемых переменных
 заключается в том, как реализация поступает со свободными переменными. Символ 
связывается в выражении, если он используется в роли переменной, например как
аргумент или при помощи операторов связывания таких, как let и
do. Символы, которые остаются несвязанными, называются свободными. В
данном примере связывание проявляет себя:

@lisp
(let ((y 7))
      (defun scope-test (x)
       (list x y)))
@end lisp

Внутри defun x является связанной переменной а y - свободной. Интерес
к свободным переменным появляется потому, что неясно, каким должно
быть их значение. Нет никакой неопределенности в значении связанной
переменной -- когда scope-test будет вычисляться значение x будет тем,
что передадут в качестве аргумента, но каким должно быть значение y?
На этот вопрос могут ответить правила связывания переменных
конкретного диалекта.

В лиспе с динамической областью видимости для того, чтобы найти
значение свободной переменной во время выполнения scope-test мы
смотрим назад по цепочке вызовов функций, когда мы находим окружение,
в котором y - связана, мы используем эту привязку в scope-test, если
же такого окружения нет, будет взято значение глобальной переменной
y. Таким образом в лиспе с динамическим связыванием y будет содержать
то значение, которое оно содержало в вызывающем выражении:

@example
> (let ((y 5))
        (scope-test 3))
(3 5)
@end example

При динамическом связывании ничего не значит тот факт, что y было
связано со значением 7 при объявлении scope-test. Имеет значение
только то, что y содержало значение 5 когда scope-test была вызвана.


В лиспе с лексическим связыванием вместо просматривания всей цепочки
вызовов функций мы смотрим назад, на окружение в тот момент, когда
функция была объявлена. В лиспе с лексическим связыванием наш пример
захватит значение y в тот момент, когда scope-test была объявлена. Так
что в Common Lisp произойдет следующее:


@example
> (let ((y 5))
        (scope-test 3))
(3 7)
@end example

Здесь связывание y со значением 5 во время вызова никак не повлияло на
возвращаемое значение.

Несмотря на то, что вы можете получить динамическое связывание,
объявляя переменную специальной, лексические связывание являются
стандартными для Common Lisp. В основном комьюнити относится к
динамическому связыванию с недоверием. Так, например, оно может быть
причиной опасных неуловимых ошибок, но лексические замыкания - это
больше чем просто способ избежать ошибки. В следующем параграфе показано,
как с его помощью можно использовать некоторые новые техники.

@node 2-6 Closures, 2-7 Local Functions, 2-5 Scope, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-6 Замыкания

Поскольку Common Lisp является языком с лексическим связыванием, когда
мы определяем функцию, содержащую свободные переменные, система должна
сохранить копии привязок к этим переменным, в то время когда функция
определяется. Такое сочетание функции и набора привязок переменных
называется - Замыканием. Замыкания оказываются полезными в широком
спектре приложений.

Замыкания настолько распространены в обычных программах на Lisp, что
можно использовать их даже не подозревая об этом. Каждый раз, когда вы
отдаёте mapcar лямбда-выражение с диез-кавычкой, вы используете
замыкания. Например, предположим, что мы хотим написать функцию,
которая принимает список номеров и добавляет определённую сумму к
каждому. Функция list+

@lisp
   (defun list+ (lst n)
         (mapcar #'(lambda (x) (+ x n))
                    lst))
@end lisp

будет делать то, что мы хотим:

@example
   > (list+ '(1 2 3) 10)
   (11 12 13)
@end example

Если мы посмотрим внимательно на функцию, передаваемую в mapcar внутри
list+, то поймём, что это замыкание. Экземпляр n является свободным и
будет связан со значением из внешнего окружения. С лексическим
связыванием, каждое использование присваивающей функции приводит к
появлению замыкания. @footnote{С динамическим связыванием та же идиома 
будет работать по другой причине и до тех пор, пока ни один из 
параметров mapcar не назван x.}

Замыкания играют важную роль в стиле программирования, предлагаемом в
книге Абельсона и Сассмана структура и интерпретация компьютерных
программ (SICP). Замыкания - это функции с локальным
состоянием. Простейший способ применения показан ниже:

@lisp
   (let ((counter 0))
         (defun new-id ()   (incf counter))
         (defun reset-id () (setq counter 0)))
@end lisp

Эти две функции используют одну переменную(разделяют ее меж собой), 
являющуюся счетчиком. Первая возвращает следующее значение, вторая 
обнуляет счетчик. Аналогичный результат можно получить сделав 
счетчик глобальной переменной, но применение замыканий защищает от 
случайных ссылок.

Замыкания также удобно использовать для создания функций с локальным
состоянием. Например функция make-adder


@lisp
   (defun make-adder (n)
         #'(lambda (x) (+ x n)))
@end lisp

в качестве аргумента принимает число и возвращает замыкание, которое,
если его вызвать, складывает это число со своим аргументом. Мы может
создать столько таких замыканий, сколько нам нужно:

@example
> (setq add2 (make-adder 2)
             add10 (make-adder 10))
#<Interpreted-Function BF162E>
> (funcall add2 5)
7> (funcall add10 3)
13
@end example

В замыкании возвращаемом функцией make-adder внутреннее состояние фиксированно, 
но можно сделать замыкание, которое можно попросить менять свое состояние

@lisp
(defun make-adderb (n)
     #'(lambda (x &optional change)
          (if change
                (setq n x)
                (+ x n))))
@end lisp

Эта новая версия make-adder возвращает замыкание, которое, при вызове
его с одним аргументом, действует так же как и его предыдущая версия.


@example
> (setq addx (make-adderb 1))
#<Interpreted-Function BF1C66>
> (funcall addx 3)
4
@end example

Тем не менее если новую версию вызвать со вторым аргументом, не равным
nil, то его внутренняя копия переменной n будет установлена в
значение, переданное первым аргументом:


@example
> (funcall addx 100 t)
100
> (funcall addx 3)
103
@end example

Более того, можно вернуть набор замыканий, которые разделяют одно
состояние. Рисунок 2.1 содержит функцию, которая создает примитивную
базу данных. В качестве аргумента она принимает ассоциативный список
(база данных) и возвращает список из трех замыканий для выборки,
добавления и удаления данных соответственно.


Каждый вызов make-dbms создает новую базу данных - новый набор
функций, лексически замкнутых относительно разделяемого ими
ассоциативного списка.

@example
> (setq cities (make-dbms '((boston . us) (paris . france))))
(#<Interpreted-Function 8022E7>
     #<Interpreted-Function 802317>
     #<Interpreted-Function 802347>)
@end example

@cartouche
@lisp
 (defun make-dbms (db)
       (list
         #'(lambda (key)
                (cdr (assoc key db)))
         #'(lambda (key val)
                (push (cons key val) db)
                key)
         #'(lambda (key)
                (setf db (delete key db :key #'car))
                key)))
@end lisp

                          Рисунок 2-1: Три замыкания совместно используют список
@end cartouche

Настоящий ассоциативный список внутри базы данных невидим для внешнего
мира, мы даже не можем сказать что это ассоциативный список, но мы
может взаимодействовать с ним при помощи функций:


@example
> (funcall (car cities) 'boston)
US
> (funcall (second cities) 'london 'england)
LONDON
> (funcall (car cities) 'london)
ENGLAND
@end example

Вызов (car list) - не самое красивое решение. В настоящих
программах функции для доступа могут быть, например, элементами
структуры. Их использование может быть проще - база данных может быть
доступна не напрямую, через функции, например:

@lisp
(defun lookup (key db)
      (funcall (car db) key))
@end lisp

Тем не менее поведение замыканий не зависит от подобных тонкостей.

В настоящих программах замыкания и структуры данных могут быть гораздо
сложней тех, что мы видели в make-adder или make-dbms. Вместо одной
разделяемой переменной может быть любой набор переменных, каждая из
которых связана с какой-нибудь структурой данных.

Замыкания - одно из явных, осязаемых достоинств лиспа. Некоторые
программы на лиспе могут быть, с некоторыми усилиями, перенесены на
менее мощный язык, но попробуйте перевести программу, использующую
замыкания, например, как приведенная выше, и станет очевидно насколько
меньше работы нам пришлось проделать имея такую абстракцию как
замыкание. В следующих главах мы рассмотрим замыкания более
детально. Глава 5 покажет нам, как использовать их для построения еще
более сложных функций

@node 2-7 Local Functions, 2-8 Tail-Recursion, 2-6 Closures, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-7 Локальные функции
@cindex 2-7 Local Functions

Когда мы определяли функции при помощи лямбда-выражений, то
столкнулись с ограничением, которого нет при использовании defun: у
функции определенной как лямбда нет имени, так что нет возможности
ссылаться на себя. Это означает что в Common Lisp мы неможем
использовать лямбды для определения рекурсивных функций.

Если мы хотим применить некоторую функцию ко всем элементам списка, мы
используем наиболее привычный для лиспа стиль:

@example
> (mapcar #'(lambda (x) (+ 2 x))
                '(2 5 7 3))
(4795)
@end example

Но что поделать, если мы хотим передать первым аргументом mapcar
рекурсивную функцию? Если бы функция была определена через defun, мы
могли бы просто сослаться на нее по имени:

@example
> (mapcar #'copy-tree '((a b) (c d e)))
((A B) (C D E))
@end example

Но предположим теперь, что функция должны быть замыканием, содержащим
некоторые свящанные переменные из окружения в котором будет работать
mapcar. В нашем примере list+:

@lisp
(defun list+ (lst n)
  (mapcar #'(lambda (x) (+ x n))
                lst))
@end lisp

первый аргумент mapcar, #'(lambda (x) (+ x n)), должен быть определен
внутри list+, потому что ему нужно связанное значение n. Пока что все
хорошо, но что поделать, если нам нужно передать в mapcar и локально
связанную переменную и рекурсивную функцию? Мы не можем использовать
функцию, определенную где-то при помощи defun, потому что нам нужны
локально связанные переменные и мы не можем использовать лямбду для
определения рекурсивной функции, потому что она неможет ссылаться на
себя.


Common Lisp дает нам labels для разрешения этой дилеммы. С одной
важной оговоркой, labels должны быть описаны в форме похожей на
let. Каждое описание связывания в выражении должно быть следующего
вида

@lisp
( name  parameters  .  body )
@end lisp

Внутри labels выражение <name> ссылается на функцию, эквивалентную
следующей:

@lisp
#'(lambda  parameters  .  body )
@end lisp

В качестве примера:

@example
> (labels ((inc (x) (1+ x)))
       (inc 3))
4
@end example

Тем не менее есть важное различие между let и labels. Внутри let
выражения значение одной переменной не может зависеть от какой-либо
другой объявленной внутри одной let формы, это значит что вы НЕ можете
написать


@lisp
(let ((x 10) (y x))
      y)
@end lisp

и ожидать что значение новой переменной y будет содержать значение
новой x. С другой стороны тело функции f определенной внутри выражения
labels может ссылаться на любую другую функцию, определенную там же,
влючая саму себя, что делает возможным описание рекурсивных функций.


Используя labels мы можем написать функцию, аналогичную list+, но в
которой первый аргумент mapcar будет рекурсивной функцией:


@lisp
(defun count-instances (obj lsts)
      (labels ((instances-in (lst)
                   (if (consp lst)
                        (+ (if (eq (car lst) obj) 1 0)
                            (instances-in (cdr lst)))
                        0)))
       (mapcar #'instances-in lsts)))
@end lisp

Эта функция берет объект и список и возвращает список чисел,
соответствующих числу вхождений объекта в каждый элемент:


@example
> (count-instances 'a '((a b c) (d a r p a)(d a r)(a a)))
(1 2 1 2)
@end example

@node 2-8 Tail-Recursion, 2-9 Compilation, 2-7 Local Functions, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-8 Хвостовая Рекурсия
@cindex 2-8 Tail-Recursion

Рекурсивными называют функции вызывающие сами себя. Хвостовой
рекурсией называется рекурсия, если в вызывающей не остается никакой
работы после вызова себя рекурсивно. Следующая функция НЕ является
функцией с хвостовой рекурсией


@lisp
(defun our-length (lst)
      (if (null lst)
         0
         (1+ (our-length (cdr lst)))))
@end lisp

поскольку, вернувшись из рекурсивыного вызова, мы должны передать
результат в 1 +. Следующая функция является функцией с хвостовой
рекурсией

@lisp
(defun our-find-if (fn lst)
   (if (funcall fn (car lst))
               (car lst)
               (our-find-if fn (cdr lst))))
@end lisp

потому что значение рекурсивного вызова сразу же возвращается.

Хвостовая рекурсия более эффективна, потому что многие реализации
Common Lisp могут трасформировать хвостовую рекурсию в цикл. С такими
компиляторами вы можете получить элегантность рекурсии в исходном коде
без накладных расходов на вызов функций. Прирост скорости обычно настолько
высок, что программисты делают многое, чтобы сделать функцию с
хвостовой рекурсией.

Функция, не обладающая свойством хвостовой рекурсии, часто может быть
трансформированна в таковую, при помощи включения в нее локальной
функции, использующей аккумулятор. В нашем контексте аккумулятор - это
параметр, представляющий значение, которое нужно вычислить в процессе
рекурсии. Например наша функция our-length может быть трансформирована
в

@lisp
(defun our-length (lst)
   (labels ((rec (lst acc)
              (if (null lst)
                  acc
                  (rec (cdr lst) (1+ acc)))))
      (rec lst 0)))
@end lisp

где колличество элементов списка, которые будут пройдены содержится во
втором параметре acc. Когда рекурсивная функция достигнет конца
списка, значение acc будет его длиной, которое сразу может быть
возвращено. Аккумулируя значения при спуске по дереву вызовов вместо
того чтобы конструировать его поднимаясь мы можем сделать rec функцией
с хвостовой рекурсией.


Многие компиляторы Common Lisp делают оптимизацию хвостовой рекурсии,
но не все делают это по умолчанию. Так что после написания функции с
хвостовой рекурсией непомешает так же добавить


@lisp
(proclaim '(optimize speed))
@end lisp

в начале файла, чтобы компилятор смог извлечь пользу из ваших
стараний. @footnote {Декларация (optimize speed) является аббревиатурой для (optimize
(speed 3)). Тем не менее некоторые компиляторы Common Lisp делают
оптимизацию хвостовой рекурсии при первом варианте но не втором.}

Используя хвостовую рекурсию и декларацию типов существующие
реализации компиляторов Common Lisp могут генерировать код такой же
бытрый, или даже быстрее кода на C. Ричард Гэбриэл приводит пример
следующей функции, которая возвращает сумму целых чисел от 1 до n:


 

@lisp
  (defun triangle (n)
     (labels ((tri (c n)
                (declare (type fixnum n c))
                (if (zerop n)
                    c
                    (tri (the fixnum (+ n c))
                         (the fixnum (- n 1))))))
        (tri 0 n)))
@end lisp

Это пример того, как выглядит быстрый код на Common Lisp. С первого
взгляда не кажется естественным писать код в таком виде. Хорошей идеей
будет написать функцию в том виде, в котором она выражается на лиспе
наиболее естественно, и затем, если возникнет необходимость,
трансформировать ее в вариант с хвостовой рекурсией.

@node 2-9 Compilation, 2-10 Functions from Lists, 2-8 Tail-Recursion, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-9 Компиляция
@cindex 2-9 Compilation

Функции в лиспе могут быть скомпилированы либо индивидуально, либо в
составе файла. Если вы просто напечатаете выражение defun в toplevel


@example
  > (defun foo (x) (1+ x))
  FOO
@end example

то многие реализации создадут интерпретируемую функцию. Вы можете
проверить, является ли данная функция скомпилированной скормив ее
compiled-function-p:

@example
  > (compiled-function-p #'foo)
  NIL
@end example

Мы можем получить скомпилированную версию, передав ее имя функции
compile


@example
  > (compile 'foo)
  FOO
@end example

которая скомпилирует определение функции foo и заменит
интерпретируемую версию на скомпилированную.


@example
> (compiled-function-p #'foo)
T
@end example

Скомпилированная и интерпретируемая версии являются объектами в лиспе
и ведут себя одинаково за исключением функции
compiled-function-p. Лямбда функции так же могут быть скомпилированы:
compile ожидает в качестве первого аргумента имя функции, но если
передать nil, то она скомпилирует лямбда выражение, переданое вторым
аргументом.

@example
> (compile nil '(lambda (x) (+ x 2)))
#<Compiled-Function BF55BE>
@end example

Если передать и имя и лямбда выражение, то compile будет работать как
компилирующий defun:

@example
> (progn (compile 'bar '(lambda (x) (* x 3)))
                 (compiled-function-p #'bar))
T
@end example

Наличие compile в языке означает, что программа может строить и
компилировать новые функции на лету. Тем не менее вызов compile в
явном виде является очень сильным средством, сравнимым с eval и должно
применяться с такой же осторожностью.  @footnote{Объяснение, почему плохо 
вызывать eval в явном виде есть на 278 странице.} Когда в секции 2.1 
@xref{2-1 Functions as Data} говорилось, что создание новых функций во время
выполнения является привычной техникой - имелось ввиду создание новых замыканий,
вроде тех, которые создавались при помощи make-adder, но не функции созданные 
при помощи вызова compile на сыром списке. Вызов compile - не обычная техника,
это крайне редкий случай. Так что избегайте применения ее без
необходимости. И все же если вы реализуете другой язык над лиспом (и
даже в таком случае) то что вам нужно может быть возможно при помощи
макросов.

Существует два вида функций, которые вы не можете передать compile в
качестве аргумента. Согласно CLTL2 (стр. 677), вы не можете
скомпилировать функцию "объявленную интерпретируемо в ненулевом
лексическом окружении". Тоесть если в toplevel определить foo внутри
let

@example
> (let ((y 2))
        (defun foo (x) (+ x y)))
@end example

то (compile 'foo) необязательно сработает. @footnote{Не страшно держать 
такой код в файле и затем компилировать его. Ограничение распространяется
на интерпретируемый код по причине реализации, но не из-за того, что что-то
не так с определением функций в различных окружениях.} Вы так же несможете
скомпилировать функцию, которая уже была скомпилирована. В этой
ситуации CLTL2 отвечает туманно "результат... не определен."

Привычный способ копмилирования лисп кода - не компиляция отдельных
функций, а компиляция всего файла при помощи compile-file. Это функция
берет имя файла и создает скомпилированную версию исходного файла -
как правило с таким же именем и другим расширением. Когда
скомпилированный файл загружен, compile-function-p должен вернуть true
для всех функций в нем.

В следующих главах будем опираться на еще один эффект компиляции:
когда одна функция встречается внутри другой, и внешняя функция
компилируется, то внутренняя функция так же будет
скомпилирована. CLTL2 явно не оговаривает этот момент, но вы можете
расчитывать на него в основных реализациях.

Компиляция внутренней функции становится явной в функциях, которые
возвращают функции. Когда make-adder (стр. 18) будет скомпилирована,
она вернет скомпилированную фунуцию:

@example
> (compile 'make-adder)
MAKE-ADDER
> (compiled-function-p (make-adder 2))
T
@end example

В следующих главах будет показано, что этот факт играет важнейшую роль
в разработке встроенного языка. Если новый язык реализован как
трансформация и трансформирующий код скомпилирован, то будет получен
скомпилированный результат - и таким образом получаем эффективный
компилятор для нового языка. (Простой пример описан на странице 81.)


Если у нас есть очень маленькая функция, мы можем попросить компилятор
сделать ее встроенной. Иначе издержки на вызов функции могут быть
больше, чем ее полезная работа. Если мы определим функцию:


@lisp
   (defun 50th (lst) (nth 49 lst))
@end lisp

и добавим декларацию:

@lisp
   (proclaim '(inline 50th))
@end lisp

то ссылка на функцию 50th внутри скомпилированной функции больше не
должно требовать реального вызова функции. Если мы определим и
скомпилируем функцию, которая вызывает 50th,

@lisp
   (defun foo (lst)
         (+ (50th lst) 1))
@end lisp

то когда foo будет скомпилирована, код 50th будет вкомпилирован
непосредственно в нее, как быдто мы написали


@lisp
   (defun foo (lst)
         (+ (nth 49 lst) 1))
@end lisp

в первом случае. Недостаток в том, что если мы переопределим 50th то
придется перекомпилировать foo, или она все еще будет работать со
старым определением. Ограничение на встраиваемые функции то же, что и на
макросы (см Глава 7.9).

@node 2-10 Functions from Lists,  , 2-9 Compilation, 2 Functions
@comment  node-name,  next,  previous,  up
@section 2-10 Функции из списков
@cindex 2-10 Functions from Lists

В некоторых ранних диалектах лиспов функции были представлены как
списки. Это давало лиспу выдающуюся способность писать и выполнять
свои собственные программы на лисп. В Common Lisp функции более не
списки, хорошие реализации сразу компилируют их в машинный код. Но вы
все еще можете писать программы, которые пишут программы, потому что
списки можно отдать компилятору.

Нельзя переоценить насколько важен факт того, что программы на лиспе
могут писать программы на лиспе, особенно учитывая то как часто эту
возможность недооценивают. Даже опытные программисты редко осознают
какой выигрыш они получают от этой возможности языка. Это причина
того, почему макросы лиспа настолько могущественны. Большинство техник
в этой книге зависят от возможности писать программы, манипулирующие
лисп выражениями.