@node 23 Parsing with ATNs, 24 Prolog, 22 Nondeterminism, Top
@comment  node-name,  next,  previous,  up
@chapter 23 Разбор с ATN
@cindex 23 Parsing with ATNs

В этой главе показано, как писать недетерминированный синтаксический анализатор
как встроенный язык. Первая часть объясняет, что такое парсеры ATN и как они
представляют граматические правила. Во второй части представлен компилятор ATN
который использует недетерминированные операторы определенные в предыдущей главе.
В заключительных разделах представлена небольшая граматика  ATN и она показана
в действии при разборе входных данных.

@menu
* 23-1 Background::             
* 23-2 The Formalism::          
* 23-3 Nondeterminism::         
* 23-4 An ATN Compiler::        
* 23-5 A Sample ATN::           
@end menu

@node 23-1 Background, 23-2 The Formalism, 23 Parsing with ATNs, 23 Parsing with ATNs
@comment  node-name,  next,  previous,  up
@section 23-1 История Вопроса
@cindex 23-1 Background

Расширенная Сеть Переходов(Augmented Transition Networks), илиr ATNs, является видом
синтаксического анализатора, описанного  Bill Woods в 1970. С тех пор они стали широко
используемым формализмом для анализа естественного языка. Через час вы сможете
написать граматику ATN, которая анализирует интересные предложения на английском
языке. По этой причине людей часто держат в некоем заклинании, когда они впервые
сталкиваются с ними.

В 1970-х некоторые люди думали, что  ATN смогут однажды стать компонентами 
действительно интеллектуальных программ. Хотя немногие занимают эту позицию 
сегодня, ATN нашли свою нишу. Они не так хороши, как вы при разборе английского,
но они все же могут анализировать впечатляющее разнообразие предложений.

ATN полезны если вы соблюдаете следующие четыре ограничения:

@enumerate
@item
Используйте их в семантически ограниченном домене - например, во внешнем
интерфейсе конкретной базы данных.
@item
Не скармливайте им слишком сложный ввод. Помимо прочего, не ожидайте, что 
они поймут дико не грамотные предложения так, как это могут люди.
@item
Используйте их только для английского или других языков, в которых порядок
слов определяет грамматическую структуру. ATN не будут полезны при разборе
таких языков как латынь.
@item
Не ожидайте, что они будут работать все время. Используйте их в предложениях,
где это полезно, если они работают 90 процентах случаев, а не в тех, где
важно, чтобы они работали в 100 процентах случаев.
@end enumerate

В этих пределах есть много полезных приложений. Канонический пример - это внешний
интерфейс базы данных. Если к такой системе подключить интерфейс, управляемый
ATN, то вместо формального запроса пользователи могут задавать вопросы в ограниченной
форме английского языка.

@node 23-2 The Formalism, 23-3 Nondeterminism, 23-1 Background, 23 Parsing with ATNs
@comment  node-name,  next,  previous,  up
@section 23-2 Формализм
@cindex 23-2 The Formalism

Чтобы понять что делалетt ATNs, мы должны вспомнить их полное название: расширенные
сети переходов. Сеть переходов - это набор узлов, содединенных между собой
направленными дугами, по сути, диаграмма-потоков. Один узел обозначен как начальный
узел, а некоторые другие узлы обозначены как конечные узлы(terminal node). К каждой
дуге прикрепляются условия, которые должны быть выполнены до того, как можно будет
проследовать по дуге.  Теперь возмем входное предложение, с указателем на текущее
слово. Следование некоторым дугам приведет к продвижению указателя. Разобрать
предложение в сети переходов - это найти путь, от начального узла к некоторому
конечному/терминальному(terminal) узлу, для которого выполнены все условия.

ATN добавляет две функции к этой модели:

@enumerate
@item
ATN имеет регистры - именованные слоты для хранения информации в процессе
анализа. Помимо выполнения тестов, дуги могут изменять содержимое регистров.
@item
ATN является рекурсивным. Дуги могут потребовать, чтобы для прохождения по 
ним, анализ(парсер) прошел через некоторую подсеть.
@end enumerate

Терминальные узлы используют информацию, накопленную в регистрах, для построения
списковых структур, которые они возвращают почти так же, как функции возвращают
значения. Фактически, за исключением того, что ATN являются недетерминированными,
они ведут себя во многом как функциональный язык программирования.

 ATN определенный на рисунке 23-1 является почти самым простым из возмжных. Он 
анализирует высказывания существительное-глагол в форме "Spot(место) runs(беги)." 
Сетевое представление этого ATN показано на рисунке 23-2.

Что делает этот ATN когда получает на вход предложение (spot runs)? Первый узел
имеет одну отходящую дугу - кошку или дугу категории, ведущую к узлу s2. Он говорит,
по сути, 

@cartouche
@lisp
 (defnode s
    (cat noun s2
        (setr subj *)))

 (defnode s2
    (cat verb s3
        (setr v *)))

 (defnode s3
    (up `(sentence
              (subject ,(getr subj))
              (verb ,(getr v)))))
@end lisp

                          Рисунок 23-1: Очень маленький ATN.
@end cartouche

@cartouche
                        Рисунок 23-2: Граф маленькой ATN.
@end cartouche

@noindent
что вы можете следовать за мной, если текущее слово является существительным,
и если вы  это делаете, вы должны сохранить текущее слово(обозначенное *) в регистре
subj. Таким образом, мы оставляем этот узел со spot(местом) сохраненным в регистре
subj.

Здесь всегда есть указатель на текущее слово. В начале он указывает на первое слово
в предложении. Когда мы следуем по дуге-категории(кошке), этот указатель перемещается
вперед на одно слово. Поэтому когда мы добираемся до узлв s2, текущим словом становиться
второе слов - runs. Вторая дуга, такая же как и первая, за исключением того, что она 
ищет глагол. Она находит runs, сохраняет его в регистре v, и переходит к s3.

Последний узел s3, имеет только входящую или конечную/терминальную дугу. (Узлы
с терминальным дугами обозначаются пунктирной линией.) Поскольку мы достигаем
терминальной дуги, когда у нас закончился ввод, мы имеем успешно выполненный анализ.
Терминальная дуга возвращает выражение в кавычках с ним:

@lisp
(sentence (subject spot)
              (verb runs))
@end lisp

ATN соответствует граматике языка, который она(сеть) должна анализировать
Приличный размер ATN для разбора английского языка будет иметь основную сеть
для разбора предложений, и подсети для разбора именных фраз, предлоговых фраз,
групп модификаторов, и так далее. Необходимость рекурсии очевидна, если учесть,
что  именные фразы(noun-phrases) могут содержать предлоговые фразы, которые 
могут содержать именные фразы, и так до бесконечности, как в

@quotation
"the key on the table in the hall of the house on the hill"
"ключ на столе в холле дома на холме"
@end quotation

@node 23-3 Nondeterminism, 23-4 An ATN Compiler, 23-2 The Formalism, 23 Parsing with ATNs
@comment  node-name,  next,  previous,  up
@section 23-3 Недетерминизм
@cindex 23-3 Nondeterminism

Хотя мы не видели в этом небольшом примере, ATNs недетерминированы. Узел может
иметь несколько исходящих дуг, более чем по одной из которых может следовать
заданный ввод. Например, достаточно хороший ATN должен уметь анализировать как 
императивные, так и декларативные высказывания. Таким образом, первый узел может
иметь исходящие дуги-категории как для существительных(в операторах), так и для
глаголов (в командах).

Что если первое слово в предложении время("time"), которое в английском является
и существительным и глаголом?  Как анализатор(парсепр) узнает, какой дуге следовать?
Когда ATN описывается как недетерминированный, это означает, что пользователи могут
предполагать, что анализатор будет правильно угадывать, какой дуге следовать. Если
некоторые дуги приводят только к неудачным анализам, по ним нельзя будет проходить.

В действительности парсер не может заглядывать в будущее. Он имитирует правильное
угадывание путем обратного отслеживания, когда у него заканчиваются дуги или ввод.
Но все механизмы обратного отслеживания автоматически вставляются в код, сгенерированный
компилятором ATN. Мы можем написать ATN так, как будто парсер действительно может угадать,
по какой дуге надо следовать.

Как и многие(возможно большинство) программы, которые используют недетерминизм,
ATNs использует реализацию в глубину(принцип - сначала в глубь(depth-first)). 
Опыт разбора английского языка быстро учит, что в любом предложении есть множество
законных разборов(legal parsings), большинство из которых не желательны. На обычной
однопроцессорной машине, лучеше попытаться быстро получить хороший анализ. Вместо 
того, чтобы получать все разборы одновременно, мы получаем несколько наиболее
вероятных. Если они имеют разумное толкование, то мы сэкономили усилия на поиске
других разборов; если нет мы можем вызвать fail, чтобы получить больше анализов.

Чтобы управлять порядком в котором генерируются синтаксические разборы, программист
должен иметь какой-то способ управления порядком, в котором choose(выбор) выбирает
альтернативы. Реализация в глубину не единственный способ управления порядком поиска.
Любая реализация, за исключением случайной, накладывает какой-то порядок. Тем не менее
ATN, такие как Prolog, имеют концептуально встроенную реализацию с поиском в глубину.
В ATN дуги, покидающие узел, проверяются в порядке, в котором они были определены.
Это соглашение позволяет программисту упорядочивать дуги по приоритету.

@node 23-4 An ATN Compiler, 23-5 A Sample ATN, 23-3 Nondeterminism, 23 Parsing with ATNs
@comment  node-name,  next,  previous,  up
@section 23-4 Компилятор ATN
@cindex 23-4 An ATN Compiler

Обычно синтаксическому анализатору на основе ATN необходимы три компонента: сама ATN,
интерпретатор для ее обхода, и словарь, который может сказать, например. что "runs"
это глагол(verb). Словари - отдельная тема, здесь мы будем использовать элементарную
ручную работу. Нам также не нужно иметь дело с интерпретатором сети, потому что мы
переведем ATN непосредственно в код на Lisp. Описанная здесь программа называется
компилятором ATN, поскольку она преобразует всю ATN в код. Узлы превращаются в
функции, а дуги становяться блоками кода внутри них.

Глава 6 ввела использование функций в качестве формы представления. Эта практика
обычно делает программы быстрее. Здесь это означает, что не будет никаких затрат
на интерпретацию сети во время выполнения. Недостатком является то, что происходит
меньше проверок, когда что то идет не так, особенно если вы используете реализацию
Common Lisp, которая не предоставляет функцию лямбда-выржения.

На Рисунке 23-3 показан весь код преобразования узлов ATN в код Lisp.
Макрос defnode используется для определения узлов. Он сам генерирует небольшой код,
просто выбирая выражения, сгенерированные для каждой из дуг. Два параметра функции
node получают следующие значения: pos это текущий указатель ввода (целое число), и 
regs это текущий набор регистров (список ассоциативных списков(assoc-lists)).

Макрос defnode определяет макрос с тем же именем, что и соответствующий узел.
Узел s будет определен как максрос s. Это соглашение позволяет дугам знать,
как ссылаться на их узлы назначения - они просто вызывают макрос с этим именем.
Это также означает, что вы не должны давать узлам имена существующих функций или
макросов, иначе они будут переопределены.

Отладка ATN требует своего рода средства трассировки. Поскольку узылы становятся
функциями, нам не нужно писать свою собственную трассировку. Мы можем использовать
встроенную функцию трассировки Lisp trace. Как упомянуто на стр. 266, использование
=defun для определения узлов означает, что мы можем отслеживать анализ, проходящий
через узлы mods просто сказав (trace =mods).

Дуги в теле узла - это просто вызовы макросов, возвращающие код, который 
внедряется в функцию узла, создаваемую defnode. Парсер использует
недетерминизм в каждом узле, выполняя выбор кода, представляющего каждую из
дуг, покидающих этот узел. Узел с несоклькими исходящими дугами, скажем

@lisp
(defnode foo
  <arc 1>
  <arc 2>)
@end lisp

@noindent
транслируется в определение функции следующего вида:

@lisp
(=defun foo (pos regs)
  (choose
        <translation of arc 1>
        <translation of arc 2>))
@end lisp

@cartouche
@lisp
 (defmacro defnode (name &rest arcs)
       `(=defun ,name (pos regs) (choose ,@@arcs)))

 (defmacro down (sub next &rest cmds)
       `(=bind (* pos regs) (,sub pos (cons nil regs))
          (,next pos ,(compile-cmds cmds))))

 (defmacro cat (cat next &rest cmds)
       `(if (= (length *sent*) pos)
           (fail)
           (let ((* (nth pos *sent*)))
             (if (member ',cat (types *))
                   (,next (1+ pos) ,(compile-cmds cmds))
                   (fail)))))

 (defmacro jump (next &rest cmds)
       `(,next pos ,(compile-cmds cmds)))

 (defun compile-cmds (cmds)
       (if (null cmds)
          'regs
          `(,@@(car cmds) ,(compile-cmds (cdr cmds)))))

 (defmacro up (expr)
       `(let ((* (nth pos *sent*)))
          (=values ,expr pos (cdr regs))))

 (defmacro getr (key &optional (regs 'regs))
       `(let ((result (cdr (assoc ',key (car ,regs)))))
          (if (cdr result) result (car result))))

 (defmacro set-register (key val regs)
       `(cons (cons (cons ,key ,val) (car ,regs))
             (cdr ,regs)))

 (defmacro setr (key val regs)
       `(set-register ',key (list ,val) ,regs))

 (defmacro pushr (key val regs)
       `(set-register ',key
                        (cons ,val (cdr (assoc ',key (car ,regs))))
                        ,regs))
@end lisp

                   Рисунок 23-3: Компиляция узлов и дуг.
@end cartouche

@cartouche
@lisp
 (defnode s
    (down np s/subj
        (setr mood 'decl)
        (setr subj *))
    (cat v v
        (setr mood 'imp)
        (setr subj '(np (pron you)))
        (setr aux nil)
        (setr v *)))
@end lisp

@noindent
макро расширяетс в:

@lisp
 (=defun s (pos regs)
    (choose
        (=bind (* pos regs) (np pos (cons nil regs))
         (s/subj pos
                    (setr mood 'decl
                            (setr subj * regs))))
        (if (= (length *sent*) pos)
            (fail)
            (let ((* (nth pos *sent*)))
               (if (member 'v (types *))
                    (v (1+ pos)
                        (setr mood 'imp
                                (setr subj '(np (pron you))
                                        (setr aux nil
                                                   (setr v * regs)))))
                    (fail))))))
@end lisp

                Рисунок 23-4: Макрорасширение функции узла.
@end cartouche

На рисунке 23-4 показано макроразложение первого узла в примере для ATN с 
Рисунка 23-11. При вызове во время выполнения, функция узла, такая как s 
недетерминированно выбирает дуга для следования. Параметр pos будет текущей
позицией во входящем предложении и  regs текущими регистрами.

Категориальные дуги, как мы видели в нашем первоначальном примере, настаивают на
том, что текущее слово входного предложения относиться к определенной граматической
категории. В теле категориальной дуги, символ * будет связан с текущим входным словом.

Push дуги, определенные с помощью down, требуют успешных вызовов в подсетях. Они
принимают два узла назначения, подсеть назначения - sub, и следующий узел в 
текущей сети - next. Обратите внимание, что хотя код сгенерированный для категориальной
дуги просто вызывает следующий(next) узел в сети, код генерируемый для push
дуги использует  =bind. push дуга должна успешно вернуться из подсети, прежде
чем перейдет к узлу следующему за ней. Чистый набор регистров (nil) 
попадает на фронт regs прежде чем они будут переданы в подсеть.
В телах други типов дуг, символ * будет связан с текущим входным словом, но в 
push дугах он будет связан с выражением возвращаемым подсетью.

Jump дуги похожи на короткое замыкание в схеме. Синтаксический анализатор пропходит
прямо к узлу назначения, никаких тестов не требуется, и указатель входного слова не 
передвигается.

Последний тип дуги это pop дуга, определяемая с помощью up. Pop дуги необычны тем,
что у них нет места назначения. Точно также как команда return Lisp  не приводит
к вызову подпорограммы, а к переходу в вызывающую функцию, pop дуга не ведет к
новому узлу, а ведет обратно к "вызывающейg" push дуге. =values в pop дуге 
"возвращают" значение  для =bind в самой последней push дуге. Но, как пояснено
в Разделе 20-2 происходящее не является обычным возвратом Lisp: тело =bind было
заключено в подолжение и передано в качестве параметра через любое количество
дуг, пока значения  =values pop дуги, накоенц, не вызовут его для "возврата" значений.

В главе 22 описаны две версии недетерминированного выбора: быстрый выбор (стр.293),
который не гарантированно завершиться при наличии циклов в циклов в пространстве
поиска, и более медленный истинный выбор(true-choose) (стр. 304), который был более
безопасен для таких циклов. Конечно, в  ATN могут быть циклы, но пока по крайней мере
одна дуга в каждом цикле опережает входной указатель, синтаксический анализатор в 
конечном итоге переходит  за конец предложения. Проблема возникает с циклами,
которые не перемещают указатель ввода.
Здесь у нас есть две альтернативы:

@enumerate
@item
Использовать медленный, правильный недетерминированный оператор выбора(поиск в глубину
версия данная на стр. 396).
@item
Использовать быстрый выбор, и указать, что ошибочно определять сети содержащие циклы,
которые можно пройти следуюя простым jump дугам (перехода).
@end enumerate

Код определенныый на рисунке 23-3 использует второй подход.

Последние четыре определения на рисунке 23-3 определяют макросы, используемые для
чтения и установки регистров внутри тела дуги. В этой программе наборы регистров
представлени в виде ассоциативных списков(assoc-lists). ATN имеет дело не с набором
регистров, а с наборами наборов регистров. Когда анализатор(парсер) перемещается
вниз в подсеть, он получает чистый набор регистров, помещенный поверх существующих.
Таким образом, вся коллекция регистров в любой момент времени представляет собой
список ассоциативных спиков(assoc-lists).

Предопределенные операторы регистров работают с текущим или самым верхним набором
регистров: getr читает регистр; setr устанавливает один; и pushr помещает одно значение.
Оба getr и pushr используют макрос set-register упавляющий примитивом регистра.

Обратите внимание что регистры не должны объявляться. Если set-register посылает
определенное имя, оно создает регистр с этим именем.

Операторы работающие с регистрами все совершенно не разрушающие. Cons, cons, cons,
говорит set-register. Это замедляет их работу и создает много мусора, но как
объясняется на стр. 261, объекты используемые в части программы, в которой создаются
продолжения, не должны подвергаться деструктивному изменению. Объект в одном потоке
управления может использоваться другим потоком, который в данный момент приостановлен.
В этом случае регистры, найденные в одном разборе, будут иметь общую структуру с 
регистрами во многих других разборах. Если бы скорость была приемлемой, мы могли бы
хранить регистры в векторах, вместо ассоциативных списков(assoc-lists), и повторно
использовать векторы в общем пуле.

Push, cat, и jump дуги, все могут содержать тела выражений. Обычно это просто
сеттеры. Вызывая compile-cmds для своих тел, функция расширения этих типов дуг
объединяет серию сеттеров(setrs) в одно выражение:

@example
> (compile-cmds '((setr a b) (setr c d)))
(SETR A B (SETR C D REGS))
@end example

Каждое выражение имеет следующее выражение, вставленное в качестве последнего аргумента,
кроме последнего, который получает regs. Таким образом, серия выражений в теле дуги
будет преобразована в одно выражение возвращающее новые регистры.

Этот подход позволяет пользователям вставлять произвольный код Lisp в тела дуг,
помещая его в progn. Например:

@example
> (compile-cmds '((setr a b)
                        (progn (princ "ek!"))
                        (setr c d)))
(SETR A B (PROGN (PRINC "ek!") (SETR C D REGS)))
@end example

Некоторые переменные остаются видимыми для кода, встречающегося в телах дуг.
Предложение(sentence) будет в глобальном *sent*. Также будут видны, две 
лексические переменные: pos, содержащая текущий указатель на входное слово
и regs, содержащий текущие регистры. Это еще один пример преднамеренного захвата
переменных. Если было бы желательно, чтобы пользователь не ссылался на эти 
переменные, их можно было бы заменить на gensyms.

Макрос with-parses, определенный на Рисунке 23-5, дает нам возможность не вызвать
ATN. Он должен вызываться с именем начального узла, выражением, которое нужно
проанализировать, и телом кода, описывающим, что делать с возвращенными значениями
парсера. Тело кода в  выражении with-parses будет вычисляться один раз для каждого
успешного анализа. Внутри тела, символ parse будет привязан к текущему анализу/парсеру.
Внешне with-parses напоминает оператор, такой как dolist, но под ним используется
поиск с возвратом, вместо простой итерации. Выражение with-parses вернет @, потому 
что это то, что возвращает fail когда у него заканчивается выбор.

@cartouche
@lisp
     (defmacro with-parses (node sent &body body)
       (with-gensyms (pos regs)
         `(progn
              (setq *sent* ,sent)
              (setq *paths* nil)
              (=bind (parse ,pos ,regs) (,node 0 '(nil))
                (if (= ,pos (length *sent*))
                     (progn ,@@body (fail))
                     (fail))))))
@end lisp

                             Рисунок 23-5: Марос верхнего уровня.
@end cartouche

Прежде чем перейти к рассмотрению более представительного ATN, давайте рассмотрим
синтаксический анализ, созданный из крошечного ATN, определенного ранее. Компилятор
ATN (Рисунок 23-3) генерирует код, который вызывает types для определения граматических
ролей слов, поэтому сначала мы должны дать ему некоторое определение:

@lisp
(defun types (w)
     (cdr (assoc w '((spot noun) (runs verb)))))
@end lisp

Теперь мыы просто вызываем with-parsesс именем начального узла в качестве 
первого аргумента:

@example
> (with-parses s '(spot runs)
        (format t "Parsing: ~A~%" parse))
Parsing: (SENTENCE (SUBJECT SPOT) (VERB RUNS))
@
@end example

@node 23-5 A Sample ATN,  , 23-4 An ATN Compiler, 23 Parsing with ATNs
@comment  node-name,  next,  previous,  up
@section 23-5 Пример ATN
@cindex 23-5 A Sample ATN

Теперь, когда был описан весь компилятор ATN, мы можем попробовать некоторые 
синатксические разборы, используя примеры сетей. Чтобы синтаксический анализатор
ATN обрабатывал более разнообразные предложения, вы усложняеете сам ATN, а
не компилятор ATN. Представленный здесь компилятор, представляет собой игрушку,
в основом в том смысле, что он медленный, а не в смысле ограниченной мощности.

Мощь (в отиличие от скорости) синтаксического анализатора заключается в граматике,
и здесь ограниченное пространство действительно заставляет нас использовать
игрушечную версию. Рисунки с 23-8 по 23-11 определяют ATN (или набор ATNs) представленную
на Рисунке 23-6. Эта сеть достаточно велика, чтобы можно было выполнить несколько
разборов для классического корма парсеров "Время летит как стрела"("Time flies like an arrow.")

@cartouche
                      Рисунок 23-6: Грав большой ATN.
@end cartouche

@cartouche
@lisp
 (defun types (word)
    (case word
        ((do does did) '(aux v))
        ((time times) '(n v))
        ((fly flies) '(n v))
        ((like) '(v prep))
        ((liked likes) '(v))
        ((a an the) '(det))
        ((arrow arrows) '(n))
        ((i you he she him her it) '(pron))))
@end lisp

                        Рисунок 23-7: Номинальный словарь
@end cartouche

Нам нужен немного больший словарь для разбора более сложного ввода. Функция
types (Рисунок 23-7) предоставляет словарь самого примитивного вида. Он определяет
словарь из 22-слов, и связывает каждое слово со списком одной или нескольких
простых граматических ролей.

@cartouche
@lisp
     (defnode mods
       (cat n mods/n
         (setr mods *)))

     (defnode mods/n
       (cat n mods/n
         (pushr mods *))
       (up `(n-group ,(getr mods))))
@end lisp

                   Рисунок 23-8: Подсеть для модификаторов строк.
@end cartouche

Компоненты ATN сами являются ATNs. Самый маленький ATN в нашем наборе - тот, что
на рисунке 23-8. Он анализирует строковые модификаторы, что в данном случае означает
стороки существительных. Первый узел, mods, принимает существительное. Второй узел,
mods/n, может либо искать больше существительных, или возвращать разбор.

В разделе 3-4 объясняется как написание программ в функциональном стиле облегчает
их тестирование:

@enumerate
@item
В функциональной программе компоненты можно тестировать индивидуально.
@item
В Lisp, функции можно тестировать интерактивно, в цикле верхнего уровня.
@end enumerate

Вместе эти два принципа позволяют проводить интерактивную разработку: когда 
мы пишем функциональные программы на Lisp, мы можем тестировать каждый 
фрагмент по мере его написания.

ATNs настолько похожи на функциональные программы - в этой реализации они 
макрорасширяются в функциональные прогарммы, так что возможноть интерактивной
разработки распространяется и на них. Мы можем проверить ATN начиная с любого
узла, просто указав его имя в качестве первого аргумента with-parses:

@example
> (with-parses mods '(time arrow)
        (format t "Parsing: ~A~%" parse))
Parsing: (N-GROUP (ARROW TIME))
@
@end example

Следующие два сети должны обсуждаться вместе, потому что они взаимно рекурсивны.
Сеть определенная на рисунке 23-9, которая начинается с узла np, используется для
разбора фраз существительных(noun phrases). Сеть определенная на рисунке 23-10 анализирует
предлоги(prepositional phrases). Фразы существительных могут содержать фразы предлоги и
наоборот, поэтому каждая из двух сетей содержит push дугу, которая вызывает другую сеть.

Сеть существительных фраз содержит шесть узлов. Первый узел np имеет три варианта.
Если он читает метоимение(pronoun), он может перейти к узлу местоимению(pron), 
которое является выходом из сети:

@cartouche
@lisp
     (defnode np
      (cat det np/det
         (setr det *))
      (jump np/det
         (setr det nil))
      (cat pron pron
         (setr n *)))

     (defnode pron
      (up `(np (pronoun ,(getr n)))))

     (defnode np/det
      (down mods np/mods
         (setr mods *))
      (jump np/mods
         (setr mods nil)))

     (defnode np/mods
      (cat n np/n
         (setr n *)))

     (defnode np/n
      (up `(np (det ,(getr det))
                (modifiers ,(getr mods))
                (noun ,(getr n))))
      (down pp np/pp
         (setr pp *)))

     (defnode np/pp
      (up `(np (det ,(getr det))
                (modifiers ,(getr mods))
                (noun ,(getr n))
                ,(getr pp))))
@end lisp

                       Рисунок 23-9: Подсеть фраз существительных.
@end cartouche

@example
> (with-parses np '(it)
        (format t "Parsing: ~A~%" parse))
Parsing: (NP (PRONOUN IT))
@
@end example

@cartouche
@lisp
     (defnode pp
       (cat prep pp/prep
           (setr prep *)))

     (defnode pp/prep
       (down np pp/np
           (setr op *)))

     (defnode pp/np
       (up `(pp (prep ,(getr prep))
                   (obj ,(getr op)))))
@end lisp

                    Рисунок 23-10: подсеть фраз предлогов.
@end cartouche

Обе другие дуги ведут к узлу np/det: одна дуга считывает определитель (например "the"),
и другае дуга просто переходит(jumps), не считывая ввод. В узле np/det, обе дуги
ведут к np/mods; У np/det есть возможность входа(pushing) в подсеть модификаторво(mods)
чтобы получить строку модификаторов, или переход. Узел np-mods читает существительное и
продлжает np/n. Этот узел может либо выдать(pop) результат, либо войти(push) в сеть
фраз предлогов, чтобы попытаться подобрать фразу предлог. Последний узел, np/pp,
выдает(pop) результат.

Различные типы существительных фраз буду иметь различные пути синтаксичекского
анализа. Вот два анализа в сети фраз существительных:

@example
> (with-parses np '(arrows)
        (pprint parse))
(NP (DET NIL)
        (MODIFIERS NIL)
        (NOUN ARROWS))
@@> (with-parses np '(a time fly like him)
        (pprint parse))
(NP (DET A)
        (MODIFIERS (N-GROUP TIME))
        (NOUN FLY)
        (PP (PREP LIKE)
             (OBJ (NP (PRONOUN HIM)))))
@
@end example

Первый анализ завершается успешно, если перейти к np/det, снова перейти к np/mods,
прочитать существительнрое, а затем выйти через np/n. Второй никогда не переходит
(jumps), входя(pushing) вначале для поиска модификаторов строки в сеть mods

@cartouche
@lisp
 (defnode s
    (down np s/subj
        (setr mood 'decl)
        (setr subj *))
    (cat v v
        (setr mood 'imp)
        (setr subj '(np (pron you)))
        (setr aux nil)
        (setr v *)))

 (defnode s/subj
    (cat v v
        (setr aux nil)
        (setr v *)))

 (defnode v
    (up `(s (mood ,(getr mood))
               (subj ,(getr subj))
               (vcl (aux ,(getr aux))
                     (v ,(getr v)))))
    (down np s/obj
        (setr obj *)))

 (defnode s/obj
    (up `(s (mood ,(getr mood))
               (subj ,(getr subj))
               (vcl (aux ,(getr aux))
                     (v ,(getr v)))
               (obj ,(getr obj)))))
@end lisp

                        Рисунок 23-11: Сеть предложений.
@end cartouche

@noindent
и возвращаясь снова к фразе предлогов. Как часто случается с синтаксическими
анаолизаторами, выражение котоыре правильно синтаксически сформированы, 
семантически настолько бессмысленны, что людям даже трудно обнаружить в них
синтаксическую структуру.
Здесь фраза существительного "a time fly like him" имеет ту же форму, что и
"a Lisp hacker like him."

Теперь все, что нам нужно, это сеть для распознавания структуры предложений.
Сеть показанная на Риснуке 23-11 анализирует как команды, так и операторы.
Начальный узел, покидающий ее, входит в сеть фраз существительных,

@cartouche
@example
 > (with-parses s '(time flies like an arrow)
          (pprint parse))

 (S (MOOD DECL)
        (SUBJ (NP (DET NIL)
                      (MODIFIERS (N-GROUP TIME))
                      (NOUN FLIES)))
        (VCL (AUX NIL)
               (V LIKE))
        (OBJ (NP (DET AN)
                     (MODIFIERS NIL)
                     (NOUN ARROW))))

 (S (MOOD IMP)
        (SUBJ (NP (PRON YOU)))
        (VCL (AUX NIL)
               (V TIME))
        (OBJ (NP (DET NIL)
                     (MODIFIERS NIL)
                     (NOUN FLIES)
                     (PP (PREP LIKE)
                          (OBJ (NP (DET AN)
                                      (MODIFIERS NIL)
                                      (NOUN ARROW)))))))
 @
@end example

                      Рисунок 23-12: Два анализа для предложения.
@end cartouche

@noindent
которое будет предметом предложения. Вторая исходящая дуга читает глагол.
Когда предложение синтаксически не однозначно, обе дуги могут быть успешными,
в конечно итоге приводя к двум разборам, как на Рисунке 23-12. Первый разбор
аналогичен "Island nations like a navy,"(островные нации, подобны флоту) и
второй аналогичен "Find someone like a policeman."(найти кото-то похожего
на полицейского). Более сложные ATN могут найти шесть или более разборов для
"Time flies like an arrow."

Компилятор ATN в этой главе представлен скорее как воплощение идеи ATN, чем как
производственная программа. Несколько очевидных изменений сделают это код намного
более эффективным. Когда важна скорость, ама идея симуляции недетерминизма с
помощью замыканий может быть слишком медленной. Но когда это не важно, описанные
здесь методы программирования приводят к очень кратки программам.