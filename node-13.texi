@node 13 Computation at Compile-Time, 14 Anaphoric Macros, 12 Generalized Variables, Top
@comment  node-name,  next,  previous,  up
@chapter 13 Вычисления во время компиляции
@cindex 13 Computation at Compile-Time

В предыдущих главах описано несколько типов операторов, которые должны быть
реализованы макросами. Они описывают класс проблем, которые должны решаться
функциями, но где макросы более эффективны. Раздел 8-2 перечисляет плюсы и
минусы использования макросов в данной ситуации. Среди плюсов был пункт
"вычисление во время компиляции." Определив оператор как макрос, вы можете
иногда заставить выполнить часть своей работы, во время его расширения. Эта
глава рассматривает макросы, которые используют эту возможность.
@menu
* 13-1 New Utilities::          
* 13-2 Example Bezier Curves::  
* 13-3 Applications::           
@end menu

@node 13-1 New Utilities, 13-2 Example Bezier Curves, 13 Computation at Compile-Time, 13 Computation at Compile-Time
@comment  node-name,  next,  previous,  up
@section 13-1 Новые Утилиты
@cindex 13-1 New Utilities

В разделе 8-2 упоминается возможность при использовании макросов перенести вычисления
на время компиляции программы. Там, в качестве примера, у нас был макрос avg, который
возвращал среднее значение своих аргументов:

@example
> (avg pi 4 5)
4.047...
@end example

На рисунке 13-1 показано определение avg, сначала как функции и затем как макроса.
Когда он определяется как макрос, вызов length может быть сделан во время компиляции.
В версии макроса, мы также избегаем затрат на разбор параметров &rest во время выполнения.
Во многих реализациях, avg будет скорее всего написан как макрос.

Тип экономии, который достигается за счет знания количества аргументов во время
расширения макроса может быть объединен, с типом, который мы получаем из in 
(стр. 152), где удалось избежать даже вычисления некоторых аргументов. Рисунок 13-2
содержит две версии most-of, который возвращает истину если большинство его
аргументов истина:

@cartouche
@lisp
     (defun avg (&rest args)
       (/ (apply #'+ args) (length args)))

     (defmacro avg (&rest args)
       `(/ (+ ,@@args) ,(length args)))
@end lisp

            Рисунок 13-1: Перемещение вычислений при поиске среднего значения.
@end cartouche

@cartouche
@lisp
     (defun most-of (&rest args)
       (let ((all 0)
             (hits 0))
        (dolist (a args)
          (incf all)
          (if a (incf hits)))
        (> hits (/ all 2))))

     (defmacro most-of (&rest args)
       (let ((need (floor (/ (length args) 2)))
             (hits (gensym)))
        `(let ((,hits 0))
           (or ,@@(mapcar #'(lambda (a)
                                   `(and ,a (> (incf ,hits) ,need)))
                              args)))))
@end lisp

                Рисунок 13-2: Перемещение и избегание вычислений.
@end cartouche

@example
> (most-of t t t nil)
T
@end example

Весрсия макроса расширяется в код, подобный in, вычисляет только столько аргументов,
сколько надо. Например, (most-of (a) (b) (c)) расширяется в эквивалент:

@lisp
(let ((count 0))
     (or (and (a) (> (incf count) 1))
         (and (b) (> (incf count) 1))
         (and (c) (> (incf count) 1))))
@end lisp

В лучшем случае, вычисляется чуть больше половины аргументов.

@cartouche
@lisp
 (defun nthmost (n lst)
   (nth n (sort (copy-list lst) #'>)))

 (defmacro nthmost (n lst)
   (if (and (integerp n) (< n 20))
         (with-gensyms (glst gi)
            (let ((syms (map0-n #'(lambda (x) (gensym)) n)))
                `(let ((,glst ,lst))
                  (unless (< (length ,glst) ,(1+ n))
                    ,@@(gen-start glst syms)
                    (dolist (,gi ,glst)
                      ,(nthmost-gen gi syms t))
                    ,(car (last syms))))))
         `(nth ,n (sort (copy-list ,lst) #'>))))

 (defun gen-start (glst syms)
   (reverse
        (maplist #'(lambda (syms)
                      (let ((var (gensym)))
                        `(let ((,var (pop ,glst)))
                            ,(nthmost-gen var (reverse syms)))))
                  (reverse syms))))

 (defun nthmost-gen (var vars &optional long?)
   (if (null vars)
         nil
         (let ((else (nthmost-gen var (cdr vars) long?)))
            (if (and (not long?) (null else))
                 `(setq ,(car vars) ,var)
                 `(if (> ,var ,(car vars))
                      (setq ,@@(mapcan #'list
                                          (reverse vars)
                                          (cdr (reverse vars)))
                             ,(car vars) ,var)
                      ,else)))))
@end lisp

            Рисунок 13-3: Использование аргументов, известных во время компиляциии.
@end cartouche

Макрос также может быть в состоянии перенести вычисления на время компиляции,
есил значения конкретных аргументов известны. На рисунке 13-3 приведен пример
такого макроса. Функцияn nthmost принимает чисмло n и список чисел и возвращает
n-й по величине из них; как и другие функции работающие с последовательноостями 
индекс начинается с нуля:

@example
> (nthmost 2 '(2 6 1 5 3 4))
4
@end example

Функциональная версия написана очень просто. Она сортирует список и вызывает nth
для результата. Поскольку сортировка деструктивна, nthmost копирует список перед
его сортировкой. Такое написание nthmost не эффективно в двум причинам: оно выполняет
создание списка и оно сортирует весь список аргументов, хотя все, что нас волнует это
старшие  n элементов.

Если мы знаем n во время компиляции, мы можем по другому подойти к проблеме. Оставшаяся
часть кода на Рисунке 13-3 определяет версию nthmost в виде макроса. Первая вещь,
которую делает этот макрос, это посмотреть на свой первый аргумент. Если первый аргумент
не является буквальным числом(т.е записанным не переменной, а цифрами), макрос расширяется
в тот же код, что приведен выше. Если первый аргумент это число, мы можем пойти по другому
пути. Скажем, если вы хотели найти третье по величине самое большое печенье на тарелке, вы
могли бы это сделать посмотрев на каждое печенье по очереди, всегда держа в своих руках три 
самых больших печенины найденных до сих пор. Когда бы вы осмотрели все печенье, самое маленькое
печенье в ваших руках - это то, что вы ищите. Если n это небольшая константа, не пропорциональная
количеству печенин, то этот метод даст вам необходимую печенину с меньшими усилиями, чем та
которая требует предварительной сортировки всех печенин.

Это стратегия, которой можно придерживатсья когда  n известно во время расширения
макроса. После своего расширения, макрос создает n переменных, а затем вызовав 
nthmost-gen генерирует код который должен вычисляться при просмотре каждой печенины.
Рисунок 13-4 показывает пример расширения макроса. Макрос nthmost ведет себя так же,
как оригинальная функция, за исключением того, что он не может быть передан в качестве
аргумента для применения(apply). Обоснование для применения макроса это обычная 
эффективность: версия макроса не выполняет конструирования списка, и если  n небольшая
константа, выполняет меньше сравнений.

Чтобы иметь эффективные программы, нужно потрудиться чтобы написать такоие
огромные макросы? В этом случае, вероятно нет. Две версии nthmost приведены
как пример общего принципа: когда некоторые аргументы известны во время
компиляции, вы можете использовать марос для генерации более эффективного кода.
Будете вы пользоваться этой возможностью или нет, будет зависеть от того, сколько
вы выиграете, и сколько еще усилий потербуется, чтобы написать эффективную версию
макроса. Версия nthmost реализованная в виде макроса, длинная и сложная, ее стоит
писать только в крайних случаях. Однако информация, известная во время компиляции,
всегда является фактором, который стоит учитывать, даже если вы решите не использовать
её в своих интересах.

@cartouche
@lisp
 (nthmost 2 nums)
@end lisp

@noindent
expands into:

@lisp
 (let ((#:g7 nums))
    (unless (< (length #:g7) 3)
        (let ((#:g6 (pop #:g7)))
         (setq #:g1 #:g6))
        (let ((#:g5 (pop #:g7)))
         (if (> #:g5 #:g1)
              (setq #:g2 #:g1 #:g1 #:g5)
              (setq #:g2 #:g5)))
        (let ((#:g4 (pop #:g7)))
         (if (> #:g4 #:g1)
              (setq #:g3 #:g2 #:g2 #:g1 #:g1 #:g4)
              (if (> #:g4 #:g2)
                   (setq #:g3 #:g2 #:g2 #:g4)
                   (setq #:g3 #:g4))))
        (dolist (#:g8 #:g7)
         (if (> #:g8 #:g1)
              (setq #:g3 #:g2 #:g2 #:g1 #:g1 #:g8)
              (if (> #:g8 #:g2)
                   (setq #:g3 #:g2 #:g2 #:g8)
                   (if (> #:g8 #:g3)
                          (setq #:g3 #:g8)
                          nil))))
        #:g3))
@end lisp

                        Рисунок 13-4: Расширение nthmost.
@end cartouche

@node 13-2 Example Bezier Curves, 13-3 Applications, 13-1 New Utilities, 13 Computation at Compile-Time
@comment  node-name,  next,  previous,  up
@section 13-2 Example Кривые Безье(Bezier)
@cindex 13-2 Example Bezier Curves

Как и макрос with- (Раздел 11-2), макрос для вычислений во время компиляции вероятнее
всего, будет написан для конкретного приложения, чем как утилита общего назначения.
Что может знать утилита общего назначения во время компиляции? Количество переданных
ей аргументов , и возможно некоторые из их значений. Если мы хотим использовать другие
ограничения, они, вероятно, должны быть индивидуальными программами.

В качестве примера в этом разделе показано, как макросы могут ускорить генерацию
кривых Безье. Кривые должны генерироваться быстро, если ими управляют в интерактивном
режиме. Оказывается, что если количество сегментов в кривой известно заранее, большая 
часть вычислений может быть выполнена во время компиляции. Написав наш генератор кривых
curve-generator в виде макроса, мы можем вшивать предварительно вычисленные значения
прямо в код. Это должно быть даже более быстрым, чем обычная оптимизация с их хранением
в массиве.

Кривая Безье определяется в терминах четырех точек - двух конечных точек и двух
котнрольных(управляющих) точек. Когда мы работаем в двух измерениях, эти точки
определяют параметрическоие уравнения для координат x и y точек на кривой. Если
две конечные точки это (x0, y0) и (x3, y3) и две управляющие точки это (x1, y1) и
(x2, y2), то уравнения определяющие точки на кривой будут:

@example
                                      3                         3
          x =(x3 - 3*x2 + 3*x1 - x0)*u  + (3*x2 - 6*x1 + 3*x0)*u + (3*x1 - 3*x0)*u + x0

                                      3                        2
          y =(y3 - 3*y2 + 3*y1 - y0)*u + (3*y2 - 6*y1 + 3*y0)*u  + (3*y1 - 3*y0)*u + y0
@end example

Если мы вычислим эти уравнения для n значений u между 0 и 1, мы получим n точек на
кривой. Например, если мы хотим нарисовать кривую как 20 сегментов, то мы бы вычислили
уравнения для u = .05, .1,..., .95. Нет небходимости вычислять их для u равных 0 или 1, 
поскольку если u = 0 они дадут просто первую конечную точку (x 0, y0), и
если u = 1 они дадут вторую конечную точку (x3, y3).

Очевидная оптимизация состоит в том, чтобы сделать n фиксированным, предварительно
расчитать степень u и сохранить их в массиве размером (n-1) × 3. Определив генератор
кривой(curve-generator) как макрос, мы можем сделать еще лучше! Если n изветсно во
время расширения, программа может просто расшириться до n команд рисующих линии. 
Предварительно вычисленные степени u, вместо того чтобы храниться в массиве, могут
быть вставлены в виде буквальных значений прямо в код расширения макроса.

На рисунке 13-5 приведен макрос curve-generating,  который реализует эту стратегию.
Вместо того, чтобы рисовать линии сразу, он создает массив сгенерированных точек.
Когда кривая перемещается в интерактивном режиме, каждый экземпляр должен быть нарисован
дважды: один раз чтобы показать её, и снова стереть её прежде чем нарисавать ее ещё. Тем
временем точки должны где то храниться.

С n = 20, genbez расширяется до 21 setf. Так как степени u вшиваются непосредственно
в код, мы экономим на затратах по их поиску во время выполнения, и на стоимости 
вычисления их при запуске. Подобно степеням u, индексы массива представляются в виде
констант в расширении, поэтому проверка границ для (setf aref)  может быть
выполнена так же во время компиляции.

@node 13-3 Applications,  , 13-2 Example Bezier Curves, 13 Computation at Compile-Time
@comment  node-name,  next,  previous,  up
@section 13-3 Применения
@cindex 13-3 Applications

Последующие главы содержат несколько других макросов, которые используют информацию,
доступную во время компиляции. Хорошим примером является if-match (стр. 242). 
Сопоставитель-шаблонов сравнивающий две последовательности, возможно содержащие
переменные, чтобы увидеть, есть ли какой-то способ присвоения значениий переменным,
который сделает эти две последовательности равными.

@cartouche
@lisp
 (defconstant *segs* 20)
 (defconstant *du*       (/ 1-0 *segs*))
 (defconstant *pts* (make-array (list (1+ *segs*) 2)))

 (defmacro genbez (x0 y0 x1 y1 x2 y2 x3 y3)
   (with-gensyms (gx0 gx1 gy0 gy1 gx3 gy3)
        `(let ((,gx0 ,x0) (,gy0 ,y0)
              (,gx1 ,x1) (,gy1 ,y1)
              (,gx3 ,x3) (,gy3 ,y3))
           (let ((cx (* (- ,gx1 ,gx0) 3))
                (cy (* (- ,gy1 ,gy0) 3))
                (px (* (- ,x2 ,gx1) 3))
                (py (* (- ,y2 ,gy1) 3)))
            (let ((bx (- px cx))
                   (by (- py cy))
                   (ax (- ,gx3 px ,gx0))
                   (ay (- ,gy3 py ,gy0)))
              (setf (aref *pts* 0 0) ,gx0
                     (aref *pts* 0 1) ,gy0)
              ,@@(map1-n #'(lambda (n)
                                (let* ((u (* n *du*))
                                         (u^2 (* u u))
                                         (u^3 (expt u 3)))
                                  `(setf (aref *pts* ,n 0)
                                           (+ (* ax ,u^3)
                                                (* bx ,u^2)
                                                (* cx ,u)
                                                ,gx0)
                                           (aref *pts* ,n 1)
                                           (+ (* ay ,u^3)
                                                (* by ,u^2)
                                                (* cy ,u)
                                                ,gy0))))
                             (1- *segs*))
                (setf (aref *pts* *segs* 0) ,gx3
                        (aref *pts* *segs* 1) ,gy3))))))
@end lisp

              Рисунок 13-5: Макрос для генерации кривых Безье.
@end cartouche

Конструкция if-match показывает, что если одна из последовательностей известна
во время компиляции и только она содержит переменные, тогда сопоставление может
быть сделано более эффективно. Весто сравнения двух последовательностей во время
выполнения и создания списков для хранения привязок переменных, установленных в
процессе сравнения, мы можем макросом сгенерировать код для выполнения точных
сравнений, продиктованных известной последовательностью и можем хранить все привязки
в реальных переменных Lisp-а.

Встраиваемые языки описываемые в Главах 19-­24 также, по большей части, используют
информацию, доступную во время компиляциии. Так как встроенный язык является своего
рода компилятором, это вполне естественно, что он должен использовать такую информацию.
Как правило, чем сложнее макрос, тем больше ограничений он накладывает на аргументы,
и тем выше ваши шансы использовать эти ограничения для генерации эффективного кода.