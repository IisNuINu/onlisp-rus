#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-04.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-06-27 16:32+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-04.texi:5
msgid ""
"@node 4 Utility Functions, 5 Returning Functions, 3 Functional Programming, "
"Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 4 Utility Functions\n"
"@cindex 4 Utility Functions"
msgstr ""
"@node 4 Utility Functions, 5 Returning Functions, 3 Functional Programming, "
"Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 4 Сервисные Функции\n"
"@cindex 4 Utility Functions"

#: texi/node-04.texi:14
msgid ""
"Common Lisp operators come in three types: functions and macros, which you\n"
"can write yourself, and special forms, which you can't. This chapter "
"describes\n"
"techniques for extending Lisp with new functions. But \"techniques\" here "
"means\n"
"something different from what it usually does. The important thing to know "
"about\n"
"such functions is not how they're written, but where they come from. An "
"extension\n"
"to Lisp will be written using mostly the same techniques you would use to "
"write\n"
"any other Lisp function. The hard part of writing these extensions is not "
"deciding\n"
"how to write them, but deciding which ones to write."
msgstr ""
"Операторы Common Lisp бывают трех типов: функции и макросы, которые вы "
"можете\n"
"написать, и специальные формы, которые вы написать не можете. Эта глава\n"
"описывает способы расширения Lisp новыми функциями. Но `способы` здесь "
"значат\n"
"нечто отличное от того, что они обычно значит слово `способы`. Важно знать "
"о\n"
"функциях не то, как они написаны, но откуда они появились. Расширения Lisp\n"
"должны быть написаны в-основном тем же способом, каким обычно пишутся любые\n"
"другие функции в Lisp. Сложность написания расширенией не в том, как писать\n"
"их, а в том, что бы решить что именно писать."

#: texi/node-04.texi:25
msgid ""
"@menu\n"
"* 4-1 Birth of a Utility::      \n"
"* 4-2 Invest in Abstraction::   \n"
"* 4-3 Operations on Lists::     \n"
"* 4-4 Search::                  \n"
"* 4-5 Mapping::                 \n"
"* 4-6 I/O::                     \n"
"* 4-7 Symbols and Strings::     \n"
"* 4-8 Density::                 \n"
"@end menu"
msgstr ""

#: texi/node-04.texi:30
msgid ""
"@node 4-1 Birth of a Utility, 4-2 Invest in Abstraction, 4 Utility "
"Functions, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-1 Birth of a Utility\n"
"@cindex 4-1 Birth of a Utility"
msgstr ""
"@node 4-1 Birth of a Utility, 4-2 Invest in Abstraction, 4 Utility "
"Functions, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-1 Рождение Утилиты(сервисной функции)\n"
"@cindex 4-1 Birth of a Utility"

#: texi/node-04.texi:35
msgid ""
"In its simplest form, bottom-up programming means second-guessing whoever\n"
"designed your Lisp. At the same time as you write your program, you also add "
"to\n"
"Lisp new operators which make your program easy to write. These new "
"operators\n"
"are called utilities."
msgstr ""
"В простейшем виде, программирование снизу вверх подразумевает попытку "
"обмануть\n"
"создателей Lisp. В то же время, когда вы пишите вашу программу вы так\n"
"же добавляете в Lisp новые операторы, которые делают вашу программу более\n"
"простой в написании. Эти новые операторы называются утилитами (стандартные\n"
"либы/API внутри программы)"

#: texi/node-04.texi:45
msgid ""
"The term \"utility\" has no precise definition. A piece of code can be "
"called\n"
"a utility if it seems too small to be considered as a separate application, "
"and too\n"
"general-purpose to be considered as part of a particular program. A "
"database\n"
"program would not be a utility, for example, but a function which performed "
"a\n"
"single operation on a list could be. Most utilities resemble the functions "
"and macros\n"
"that Lisp has already. In fact, many of Common Lisp's built-in operators "
"began\n"
"life as utilities. The function remove-if-not, which collects all the "
"elements of\n"
"a list satisfying some predicate, was defined by individual programmers for "
"years\n"
"before it became a part of Common Lisp."
msgstr ""
"Термин `утилита` не имеет точного определения. Кусок кода может быть назван\n"
"утилитой, если он слишком маленький, чтобы быть отдельным приложением и при\n"
"этом слишком общеупотребителен, чтобы быть частью одной программы. "
"Например,\n"
"база данных не может быть утилитой, но функция, которая производит некую\n"
"операцию над списком может. Большинство утилит напоминают функции и\n"
"макросы, которые уже есть в Lisp. Фактически, многие встроенные в CL "
"операторы\n"
"начали свою жизнь как утилиты. Функция remove-if-not, которая возвращает "
"все\n"
"элементы, удовлетворяющие некоторому условию, была определена "
"программистами\n"
"за годы до того, как она стала частью CL."

#: texi/node-04.texi:52
msgid ""
"Learning to write utilities would be better described as learning the habit "
"of\n"
"writing them, rather than the technique of writing them. Bottom-up "
"programming\n"
"means simultaneously writing a program and a programming language. To do "
"this\n"
"well, you have to develop a fine sense of which operators a program is "
"lacking.\n"
"You have to be able to look at a program and say, \"Ah, what you really mean "
"to\n"
"say is this.\""
msgstr ""
"Обучение написанию утилит может быть лучше описано как привитие привычки "
"писать\n"
"их, а не описание способов написания их. Программирование снизу вверх "
"означает\n"
"одновременное написание программы и языка программирования. Для того, чтобы\n"
"сделать это хорошо, вы должны ясно представить, каких операторов в "
"программе \n"
"не хватает. Вы должны быть способны взглянуть на программу и сказать: \n"
"\"Ого, да то, что ты имел ввиду, заключается в таком-то алгоритме!\""

#: texi/node-04.texi:57
msgid ""
"For example, suppose that nicknames is a function which takes a name\n"
"and builds a list of all the nicknames which could be derived from it. "
"Given\n"
"this function, how do we collect all the nicknames yielded by a list of "
"names?\n"
"Someone learning Lisp might write a function like:"
msgstr ""
"Например, представьте что nicknames - это функция которая получает имя и "
"строит\n"
"список всех псевдонимов(nicknames), которые могут быть получены из него. "
"Имея эту\n"
"функцию, как мы соберём все никнеймы, полученные из\n"
"списка имен? Некто изучающий Lisp может написать эту функцию подобным "
"образом:\n"

#: texi/node-04.texi:65
msgid ""
"@lisp\n"
"(defun all-nicknames (names)\n"
"  (if (null names)\n"
"           nil\n"
"           (nconc (nicknames (car names))\n"
"                    (all-nicknames (cdr names)))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun all-nicknames (names)\n"
"  (if (null names)\n"
"           nil\n"
"           (nconc (nicknames (car names))\n"
"                  (all-nicknames (cdr names)))))\n"
"@end lisp"

#: texi/node-04.texi:70
msgid ""
"A more experienced Lisp programmer can look at such a function and say "
"\"Ah,\n"
"what you really want is mapcan.\" Then instead of having to define and call "
"a\n"
"new function to find all the nicknames of a group of people, you can use a "
"single\n"
"expression:"
msgstr ""
"Более опытный Lisp-программист может посмотреть на подобную функцию и "
"сказать `Кхм...,\n"
"то что тебе действительно нужно так это mapcan.` В результате вместо "
"написания и\n"
"вызова новой функции нахождения всех никнеймов группы людей, ты сможешь\n"
"использовать одно выражение:\n"

#: texi/node-04.texi:74
msgid ""
"@lisp\n"
"(mapcan #'nicknames people)\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:78
msgid ""
"The definition of all-nicknames is reinventing the wheel. However, that's "
"not\n"
"all that's wrong with it: it is also burying in a specific function "
"something that\n"
"could be done by a general-purpose operator."
msgstr ""
"Определение all-nicknames это изобретение велосипеда. Кстати, это не "
"единственный косяк\n"
"этой функции: она также прячет в специальной функции нечто, что может быть\n"
"сделано оператором общего назначения."

#: texi/node-04.texi:84
msgid ""
"In this case the operator, mapcan, already exists. Anyone who knew about\n"
"mapcan would feel a little uncomfortable looking at all-nicknames. To be "
"good\n"
"at bottom-up programming is to feel equally uncomfortable when the missing\n"
"operator is one which hasn't been written yet. You must be able to say "
"\"what you\n"
"really want is x,\" and at the same time, to know what x should be."
msgstr ""
"В этом случае оператор, mapcan, уже существует. Любой, кто знает о mapcan \n"
"чувствует себя некомфортно, смотря на all-nicknames. Хорошо программировать\n"
"снизу вверх значит чувствовать такой же дискомфорт, когда необходимый "
"оператор\n"
"ещё не написан в стандартной библиотеке. Вы должны уметь сказать `то что "
"тебе\n"
"действительно нужно, это X` и в тоже время знать, что из себя представляет X."

#: texi/node-04.texi:91
msgid ""
"Lisp programming entails, among other things, spinning off new utilities as\n"
"you need them. The aim of this section is to show how such utilities are "
"born.\n"
"Suppose that towns is a list of nearby towns, sorted from nearest to "
"farthest, and\n"
"that bookshops is a function which returns a list of all the bookshops in a "
"city. If\n"
"we want to find the nearest town which has any bookshops, and the bookshops "
"in\n"
"it, we could begin with:"
msgstr ""
"Программирование на Lisp, кроме всего прочего, влечёт за собой водоворот "
"новых\n"
"утилит, создаваемых при первой же необходимости. Цель этого раздела - "
"показать\n"
"как такие утилиты рождаются. Представим, что towns - список близлежащих\n"
"городов, отсортированных от ближнего к дальнему и bookshops - функция, "
"которая\n"
"возвращает список всех книжных магазинов в городе. Если мы хотим найти "
"ближайший\n"
"город, в котором есть хоть один книжный магазин, и вернуть полученную "
"информацию\n"
"о городе и магазинах, мы можем начать с:\n"

#: texi/node-04.texi:96
msgid ""
"@lisp\n"
"(let ((town (find-if #'bookshops towns)))\n"
"  (values town (bookshops town)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:102
msgid ""
"But this is a bit inelegant: when find-if finds an element for which "
"bookshops\n"
"returns a non-nil value, the value is thrown away, only to be recomputed as "
"soon\n"
"as find-if returns. If bookshops were an expensive call, this idiom would "
"be\n"
"inefficient as well as ugly. To avoid unnecessary work, we could use the "
"following\n"
"function instead:"
msgstr ""
"Но это немного коряво: когда find-if находит элемент, для которого "
"bookshops\n"
"возвращает не nil значение, значение выбрасывается наружу, а затем мы вновь\n"
"производим операцию bookshops. Если вызов bookshops требует больших "
"ресурсов,\n"
"эта идиома будет неэффективна и убога. Для избежания этого, мы можем\n"
"использовать следующую функцию:"

#: texi/node-04.texi:112
msgid ""
"@lisp\n"
"(defun find-books (towns)\n"
"      (if (null towns)\n"
"           nil\n"
"           (let ((shops (bookshops (car towns))))\n"
"             (if shops\n"
"                   (values (car towns) shops)\n"
"                   (find-books (cdr towns))))))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:119
msgid ""
"Then calling (find-books towns) would at least get us what we wanted with\n"
"no more computation than necessary. But wait-isn't it likely that at some "
"time in\n"
"the future we will want to do the same kind of search again? What we really "
"want\n"
"here is a utility which combines find-if and some, returning both the "
"successful\n"
"element, and the value returned by the test function. Such a utility could "
"be defined\n"
"as:"
msgstr ""
"Вызов (find-books towns) будет возвращать как минимум то, что нам надо, без\n"
"лишних расчётов. Но подождите, мы же наверняка в будущем опять захотим "
"выполнить\n"
"подобный тип поиска? Да, то, что действительно нужно, так это утилита, "
"которая,\n"
"совмещая find-if и нечто, возвращает искомый элемент и значение проверочной\n"
"функции. Вот как может выглядеть такая утилита:\n"

#: texi/node-04.texi:129
msgid ""
"@lisp\n"
"(defun find2 (fn lst)\n"
"      (if (null lst)\n"
"           nil\n"
"           (let ((val (funcall fn (car lst))))\n"
"             (if val\n"
"                   (values (car lst) val)\n"
"                   (find2 fn (cdr lst))))))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:133
msgid ""
"Notice the similarity between find-books and find2. Indeed, the latter "
"could\n"
"be described as the skeleton of the former. Now, using the new utility, we "
"can\n"
"achieve our original aim with a single expression:"
msgstr ""
"Необходимо отметить сходство между find-books и find2. Фактически, find2 "
"можно\n"
"воспринимать как скелетон find-books. Сейчас, используя новую утилиту, мы "
"можем\n"
"добиться нашей изначальной цели в одно выражение:"

#: texi/node-04.texi:137
msgid ""
"@lisp\n"
"(find2 #'bookshops towns)\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:142
msgid ""
"One of the unique characteristics of Lisp programming is the important role\n"
"of functions as arguments. This is part of why Lisp is well-adapted to "
"bottom-up\n"
"programming. It's easier to abstract out the bones of a function when you "
"can\n"
"pass the flesh back as a functional argument."
msgstr ""
"Одно из уникальных свойств Lisp программирования состоит в важной роли\n"
"использования функции в качестве аргумента. Это часть причины, по которой "
"Lisp\n"
"хорошо адаптирован к программированию снизу вверх. Проще написать каркас\n"
"функции, когда ты можешь передать часть начинки в неё в качестве\n"
"функции-аргумента."

#: texi/node-04.texi:147
msgid ""
"Introductory programming courses teach early on that abstraction leads to "
"less\n"
"duplication of effort. One of the first lessons is: don't wire in behavior. "
"For\n"
"example, instead of defining two functions which do the same thing but for "
"one\n"
"or two constants, define a single function and pass the constants as "
"arguments."
msgstr ""
"Вводные курсы программирования ранее учили, что абстрагирование позволяет\n"
"избежать дублирования кода. Один из первых уроков: не будьте "
"прямолинейным. \n"
"Например, вместо определения двух функций, которые делают одно и тоже, но\n"
"отличаются одной-двумя константами, определите одну функцию и передавайте\n"
"константы как аргументы."

#: texi/node-04.texi:154
msgid ""
"In Lisp we can carry this idea further, because we can pass whole functions "
"as\n"
"arguments. In both of the previous examples we went from a specific function "
"to\n"
"a more general function which took a functional argument. In the first case "
"we\n"
"used the predefined mapcan and in the second we wrote a new utility, find2,"
"but\n"
"the general principle is the same: instead of mixing the general and the "
"specific,\n"
"define the general and pass the specific as an argument."
msgstr ""
"В Lisp мы можем развить эту идею дальше, потому как в качестве аргумента мы\n"
"можем передавать не только данные, но и код (функции). В предыдущих\n"
"примерах мы проходим путь от конкретной функции к более общей, которая в "
"качестве\n"
"аргумента получает другую функцию. В первом случае мы используем\n"
"предопределённый mapcan; во втором мы пишем новую утилиту, find2, но общий\n"
"принцип такой же: вместо смешивание общего и частного, определяем общее и\n"
"передаём частное в качестве аргумента."

#: texi/node-04.texi:158
msgid ""
"When carefully applied, this principle yields noticeably more elegant pro-\n"
"grams. It is not the only force driving bottom-up design, but it is a major "
"one. Of\n"
"the 32 utilities defined in this chapter, 18 take functional arguments."
msgstr ""
"При аккуратном использовании этот принцип порождает более элегантные "
"программы.\n"
"Это не единственная сила, поддерживающая архитектуру снизу вверх, но одна из "
"основных.\n"
"Из 32 утилит, определённых в этой главе, 18 получают аргументом функцию."

#: texi/node-04.texi:163
msgid ""
"@node 4-2 Invest in Abstraction, 4-3 Operations on Lists, 4-1 Birth of a "
"Utility, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-2 Invest in Abstraction\n"
"@cindex 4-2 Invest in Abstraction"
msgstr ""
"@node 4-2 Invest in Abstraction, 4-3 Operations on Lists, 4-1 Birth of a "
"Utility, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-2 Инвестируй в абстракции\n"
"@cindex 4-2 Invest in Abstraction"

#: texi/node-04.texi:167
msgid ""
"If brevity is the soul of wit, it is also, along with efficiency, the "
"essence of good\n"
"software. The cost of writing or maintaining a program increases with its "
"length.  \n"
"All other things being equal, the shorter program is the better."
msgstr ""
"Если краткость - сестра таланта, тогда эффективность это сущность хорошего\n"
"софта. Цена написания и поддержки программы растет вместе с её размером. "
"При\n"
"прочих равных условиях более короткая программа лучше."

#: texi/node-04.texi:173
msgid ""
"From this point of view, the writing of utilities should be treated as a "
"capital\n"
"expenditure. By replacing find-books with the utility find2, we end up with\n"
"just as many lines of code. But we have made the program shorter in one "
"sense,\n"
"because the length of the utility does not have to be charged against the "
"current\n"
"program."
msgstr ""
"С этой точки зрения, написание утилит можно рассматривать как капитальные "
"расходы.\n"
"Заменой find-books на find2 мы получили столько же строк кода. Но мы сделали "
"программу\n"
"короче в некотором смыссле, потому как длина утилиты не добавляется повторно "
"в\n"
"текущую программу."

#: texi/node-04.texi:178
msgid ""
"It is not just an accounting trick to treat extensions to Lisp as capital "
"expendi-\n"
"tures. Utilities can go into a separate file; they will not clutter our view "
"as we're\n"
"working on the program, nor are they likely to be involved if we have to "
"return\n"
"later to change the program in some respect."
msgstr ""
"Это не только трюк подсчета, считать расширения Lisp капитальными "
"вложениями. Утилиты\n"
"могут быть расположены в отдельном файле; они не будут засорять наш взор "
"пока мы работаем\n"
"над программой, да и не будут мешать впоследствии, если мы вернемся к "
"программе позже.\n"

#: texi/node-04.texi:188
msgid ""
"As capital expenditures, however, utilities demand extra attention. It is "
"espe-\n"
"cially important that they be well-written. They are going to be used "
"repeatedly,\n"
"so any incorrectness or inefficiency will be multiplied. Extra care must "
"also go\n"
"into their design: a new utility must be written for the general case, not "
"just for the\n"
"problem at hand. Finally, like any capital expenditure, we need not be in a "
"hurry\n"
"about it. If you're thinking of spinning off some new operator, but aren't "
"sure\n"
"that you will want it elsewhere, write it anyway, but leave it with the "
"particular\n"
"program which uses it. Later if you use the new operator in other programs, "
"you\n"
"can promote it from a subroutine to a utility and make it generally "
"accessible."
msgstr ""
"Как капитальные вложения, конечно же, утилиты требуют дополнительного "
"внимания.\n"
"Это особенно важно, что бы они были хорошо написаны. Они будут "
"использоваться неоднократно,\n"
"а значит любая некорректность или неэффективность будет преумножена. "
"Дополнительное внимание\n"
"так же должно быть уделено их проектированию: новая утилита должна быть "
"написана для общего\n"
"случая, не для текущей проблемы. В конце-концев, как и с любым другим "
"капитальное вложением,\n"
"мы не должны спешить с ней. Если Вы думаете о каком-то новом операторе, но "
"не\n"
"уверены что он понадобится где-то еще, напишите его все равно, но оставьте "
"его\n"
"в той программе, в которой он используется. Позже если вы будете "
"использовать его в\n"
"других программах вы можете преобразовать его в утилиту и открыть к нему "
"общий доступ."

#: texi/node-04.texi:193
msgid ""
"The utility find2 seems to be a good investment. By making a capital outlay\n"
"of 7 lines, we get an immediate savings of 7. The utility has paid for "
"itself in the\n"
"first use. A programming language, Guy Steele wrote, should \"cooperate "
"with\n"
"our natural tendency towards brevity:\""
msgstr ""
"Утилита find2 кажется неплохой инвестицией. Сделав вложение в 7 строк мы "
"тут\n"
"же сохранили столько же. Утилита окупила себя при первом использовании. "
"Язык, написанный\n"
"Гаем Стилом должен \"соотносится с нашим природным стремлением к краткости:\""

#: texi/node-04.texi:204
msgid ""
"@quotation\n"
"...we tend to believe that the expense of a programming construct\n"
"is proportional to the amount of writer's cramp that it causes us (by\n"
"\"belief\" I mean here an unconscious tendency rather than a fervent\n"
"conviction). Indeed, this is not a bad psychological principle for\n"
"language designers to keep in mind. We think of addition as cheap\n"
"partly because we can notate it with a single character: \"+\". Even if\n"
"we believe that a construct is expensive, we will often prefer it to a\n"
"cheaper one if it will cut our writing effort in half.\n"
"@end quotation"
msgstr ""
"@quotation\n"
"...мы склонны полагать, что издержки программной конструкции "
"пропорциональны\n"
"количеству усилий писателя (\"верить, полагать\" - здесь я\n"
"имею в виду, неосознанную тенденцию, а не горячую убежденность). \n"
"Действительно, это неплохой психологический принцип для разработчиков\n"
"языков, помнить о нем. Мы думаем о сложении, как о дешевом, отчасти\n"
"потому, что мы можем записать его одним символьным знаком: \"+\". Даже если\n"
"мы считаем, что  эта конструкция стоит дорого, мы часто предпочитаем ее, "
"если\n"
"она наполовину сократит наши усилия по написанию кода.\n"
"@end quotation"

#: texi/node-04.texi:209
msgid ""
"In any language, the \"tendency towards brevity\" will cause trouble unless "
"it is\n"
"allowed to vent itself in new utilities. The shortest idioms are rarely the "
"most\n"
"efficient ones. If we want to know whether one list is longer than another, "
"raw\n"
"Lisp will tempt us to write"
msgstr ""
"В любом языке \"тенденция к краткости\" будет вызывать проблемы, если язык "
"не позволяет\n"
"выражать себя в новых утилитах. Самые краткие идиомы редко бывают самыми "
"эффективными.\n"
"Если мы хотим знать какой из двух списков длиннее другого, чистый Lisp "
"склоняет нас \n"
"к написанию"

#: texi/node-04.texi:213
msgctxt "texi/node-04.texi:213"
msgid ""
"@lisp\n"
"(> (length x) (length y))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:216
msgid ""
"If we want to map a function over several lists, we will likewise be tempted "
"to join\n"
"them together first:"
msgstr ""
"Если мы хотим map функцию для нескольких списков, мы должны таким же образом "
"написать:"

#: texi/node-04.texi:220
msgid ""
"@lisp\n"
"(mapcar fn (append x y z))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:225
msgid ""
"Such examples show that it's especially important to write utilities for "
"situations\n"
"we might otherwise handle inefficiently. A language augmented with the "
"right\n"
"utilities will lead us to write more abstract programs. If these utilities "
"are properly\n"
"defined, it will also lead us to write more efficient ones."
msgstr ""
"Такие примеры показывают, что очень важно писать утилиты для ситуаций, "
"которые мы иным\n"
"способом можем решить неэффективно. Язык, расширенный правильными утилитами "
"должен\n"
"направлять нас к написанию более абстрактных программ. Если эти утилиты "
"правильно\n"
"определены, это так же будет способствовать к написанию более эффективных "
"программ.\n"

#: texi/node-04.texi:233
msgid ""
"A collection of utilities will certainly make programming easier. But they "
"can\n"
"do more than that: they can make you write better programs. The muses, like\n"
"cooks, spring into action at the sight of ingredients. This is why artists "
"like to\n"
"have a lot of tools and materials in their studios. They know that they are "
"more\n"
"likely to start something new if they have what they need ready at hand. The "
"same\n"
"phenomenon appears with programs written bottom-up. Once you have written a\n"
"new utility, you may find yourself using it more than you would have "
"expected."
msgstr ""
"Набор утилит несомненно сделает программирование проще. Но утилиты также "
"могут\n"
"сделать больше: вы можете начать писать лучшие программы. Они Вдохновляют, \n"
"подобно тому как, повара переходят к делу при виде ингридиентов. По этой "
"причине люди\n"
" искусства любят иметь большое количество инструментов и материалов в своих "
"студиях. \n"
"Они знают, что проще начать что-то новое, если они имеют то, что им нужно. "
"Тот же феномен\n"
"происходит с программами, которые написаны снизу вверх. Однажды написав "
"новую утилиту,\n"
"вы можете обнаружить, что вы используете её чаще, чем вы ожидали.\n"

# Notes:
# Add Note
#: texi/node-04.texi:238
msgid ""
"The following sections describe several classes of utility functions. They "
"do\n"
"not by any means represent all the different types of functions you might "
"add to\n"
"Lisp. However, all the utilities given as examples are ones that have proven "
"their\n"
"worth in practice."
msgstr ""
"Следующие разделы описывают некоторые классы функций-утилит. Это ни в коем "
"случае не значит,\n"
"что они показывают все возможные типы функций, которые вы можете добавить в "
"Lisp. Как бы\n"
"то ни было, все эти утилиты даны как образцы функций, которые доказали свою "
"пользу на практике."

#: texi/node-04.texi:243
msgid ""
"@node 4-3 Operations on Lists, 4-4 Search, 4-2 Invest in Abstraction, 4 "
"Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-3 Operations on Lists\n"
"@cindex 4-3 Operations on Lists"
msgstr ""
"@node 4-3 Operations on Lists, 4-4 Search, 4-2 Invest in Abstraction, 4 "
"Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-3 Операции над списками\n"
"@cindex 4-3 Operations on Lists"

#: texi/node-04.texi:248
msgid ""
"Lists were originally Lisp's main data structure. Indeed, the name \"Lisp\" "
"comes\n"
"from \"LISt Processing.\" It is as well not to be misled by this historical "
"fact,\n"
"however. Lisp is not inherently about processing lists any more than Polo "
"shirts\n"
"are for Polo. A highly optimized Common Lisp program might never see a list."
msgstr ""
"Списки изначально главная структура данных Lisp. Не зря же `Lisp` "
"расшифровывается как\n"
"\"LISt Processing\". Однако не стоит обманываться этим историческим фактом. "
"Lisp по своей\n"
"сути предназначен для обработки списков не более чем рубашка поло для игры в "
"поло.\n"
"Хорошо оптимизированная программа на Common Lisp может не использовать "
"списки."

#: texi/node-04.texi:251
msgid ""
"It would still be a list, though, at least at compile-time. The most "
"sophisti-\n"
"cated programs, which use lists less at runtime, use them proportionately "
"more at"
msgstr ""
"Это будут списки, хотя бы во время компиляции. Самые изощренные программы, "
"которые используют\n"
"списки меньше во время выполнения, используют их пропорционально больше\n"

#: texi/node-04.texi:254
msgid ""
"@lisp\n"
" (proclaim '(inline last1 single append1 conc1 mklist))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (proclaim '(inline last1 single append1 conc1 mklist))"

#: texi/node-04.texi:257
msgid ""
" (defun last1 (lst)\n"
"        (car (last lst)))"
msgstr ""

#: texi/node-04.texi:260
msgid ""
" (defun single (lst)\n"
"        (and (consp lst) (not (cdr lst))))"
msgstr ""

#: texi/node-04.texi:263
msgid ""
" (defun append1 (lst obj)\n"
"        (append lst (list obj)))"
msgstr ""

#: texi/node-04.texi:266
msgid ""
" (defun conc1 (lst obj)\n"
"        (nconc lst (list obj)))"
msgstr ""

#: texi/node-04.texi:270
msgid ""
" (defun mklist (obj)\n"
"        (if (listp obj) obj (list obj)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:272
msgid "                   Figure 4-1: Small functions which operate on lists."
msgstr ""
"                   Рисунок 4-1: Маленькие функцие работающие со списками.\n"
"@end cartouche"

#: texi/node-04.texi:277
msgid ""
"compile-time, when generating macro expansions. So although the role of "
"lists is\n"
"decreased in modern dialects, operations on lists can still make up the "
"greater part\n"
"of a Lisp program."
msgstr ""
"во время компиляции, когда происходит разворачивание макросов. Так что "
"несмотря на то, что\n"
"роль списков уменьшается в новейших диалектах, операции над списками может "
"всё еще составлять\n"
"большую часть программы на Lisp"

#: texi/node-04.texi:281
msgid ""
"Figures 4-1 and 4-2 contain a selection of functions which build or examine\n"
"lists. Those given in Figure 4-1 are among the smallest utilities worth "
"defining.\n"
"For efficiency, they should all be declared inline (page 26)."
msgstr ""
"Figures 4.1 и 4.2 содержат выборку функций, которые создают или "
"просматривают списки.\n"
"Те, которые в Figure 4.1 самые маленькие из полезных. Для эффективности, они "
"должны все\n"
"быть определены как inline (стр. 26)\n"

#: texi/node-04.texi:287
msgid ""
"The first, last1, returns the last element in a list. The built-in function "
"last\n"
"returns the last cons in a list, not the last element. Most of the time one "
"uses\n"
"it to get the last element, by saying (car (last ...)). Is it worth writing "
"a\n"
"new utility for such a case? Yes, when it effectively replaces one of the "
"built-in\n"
"operators."
msgstr ""
"Первая функция, last1, возвращает последний элемент в списке. Встроеная "
"функция last\n"
"возвращает последний cons в списке, но не последний элемент. Большую часть "
"времени\n"
"last используется для получения последнего элемента путем (car (last ...)). "
"Если толк\n"
"в написании новой утилиты для такого случая? Да, когда он эффективно "
"заменяет один из\n"
"встроенных операторов."

#: texi/node-04.texi:292
msgid ""
"Notice that last1 does no error-checking. In general, none of the code "
"defined\n"
"in this book will do error-checking. Partly this is just to make the "
"examples clearer.\n"
"But in shorter utilities it is reasonable not to do any error-checking "
"anyway. If we\n"
"try:"
msgstr ""
"Отметьте, что last1 не проводит проверок на ошибки. В общем, в этой книге "
"нет кода, который\n"
"проверяет на ошибки. Частично это потому, что это делает примеры яснее. Но в "
"коротких утилитах\n"
"имеет смысл вообще не делать проверок на ошибки. Если мы запустим:"

#: texi/node-04.texi:298
msgid ""
"@example\n"
"> (last1 \"blub\")\n"
">>Error: \"blub\" is not a list.\n"
"Broken at LAST...\n"
"@end example"
msgstr ""
"@example\n"
"> (last1 \"blub\")\n"
">>Error: \"blub\" is not a list.\n"
"Поломка в LAST...\n"
"@end example"

#: texi/node-04.texi:303
msgid ""
"the error will be caught by last itself. When utilities are small, they form "
"a layer\n"
"of abstraction so thin that it starts to be transparent. As one can see "
"through a thin\n"
"layer of ice, one can see through utilities like last1 to interpret errors "
"which arise\n"
"in the underlying functions."
msgstr ""
"ошибка будет вызвана в last. Когда утилиты маленькие, слой абстракции "
"настолько тонок,\n"
"что становится прозрачным. Как возможно видеть сквозь тонкий слой льда, так "
"же можно видеть\n"
"сквозь утилиты для интерпретации ошибок, возникающих во внутренних вызовах.\n"

#: texi/node-04.texi:307
msgid ""
"The function single tests whether something is a list of one element. Lisp\n"
"programs need to make this test rather often. At first one might be tempted "
"to use\n"
"the natural translation from English:"
msgstr ""
"Функция single проверяет состоит ли список из одного элемента. Программы на "
"Lisp зачастую\n"
"делают эту проверку часто. Первая попытка может быть попыткой перевести "
"single с английского:"

#: texi/node-04.texi:311
msgid ""
"@lisp\n"
"(= (length lst) 1)\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:314
msgid ""
"Written this way, the test would be very inefficient. We know all we need to "
"know\n"
"as soon as we've looked past the first element."
msgstr ""
"Написанная таким образом, проверка будет очень неэффективной. Мы узнаем всё, "
"что нам\n"
"нужно как только попытаемся заглянуть далее первого элемента."

#: texi/node-04.texi:319
msgid ""
"Next come append1 and conc1. Both attach a new element to the end of a\n"
"list, the latter destructively. These functions are small, but so frequently "
"needed\n"
"that they are worth defining. Indeed, append1 has been predefined in "
"previous\n"
"Lisp dialects."
msgstr ""
"Следующими идут append1 and conc1. Оба добавляют новый элемент в конец "
"списка, второй\n"
"деструктивен. Эти функции маленькие, но так часто нужны что их стоит "
"определить. Кстати,\n"
"append1 была предопределена в предыдущих диалектах Lisp.\n"

#: texi/node-04.texi:325
msgid ""
"So has mklist, which was predefined in (at least) Interlisp. Its purpose is "
"to\n"
"ensure that something is a list. Many Lisp functions are written to return "
"either a\n"
"single value or a list of values. Suppose that lookup is such a function, "
"and that\n"
"we want to collect the results of calling it on all the elements of a list "
"called data.\n"
"We can do so by writing:"
msgstr ""
"Так же есть mklist, которые уже есть (как минимум ) в Interlisp. Его "
"назначение в том,\n"
"что бы гарантировать, что нечто - список. Многие функции Lisp возвращают и "
"список или\n"
"одно значение. Предположим, что lookup такая функция, и мы хотим собрать "
"результаты её вызова\n"
"для всех элементов списка `data`. Мы можем сделать это написав:"

#: texi/node-04.texi:330
msgid ""
"@lisp\n"
"(mapcan #'(lambda (d) (mklist (lookup d)))\n"
"               data)\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:335
msgid ""
"Figure 4-2 contains some larger examples of list utilities. The first, "
"longer,is\n"
"useful from the point of view of efficiency as well as abstraction. It "
"compares two\n"
"sequences and returns true only if the first is longer. When comparing the "
"lengths\n"
"of two lists, it is tempting to do just that:"
msgstr ""
"Figure 4.2 содержит другие большие примеры списочных утилит. Первая, "
"longer,\n"
"удобна с точки зрения эффективности как и абстракции. Она сравнивает две "
"последовательности\n"
"и возвращает true если первая длиннее второй. Сравнивая длины двух списков, "
"есть\n"
"соблазнительная идея сделать это в лоб:"

#: texi/node-04.texi:339
msgctxt "texi/node-04.texi:339"
msgid ""
"@lisp\n"
"(> (length x) (length y))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:344
msgid ""
"This idiom is inefficient because it requires the program to traverse the "
"entire\n"
"length of both lists. If one list is much longer than the other, all the "
"effort of\n"
"traversing the difference in their lengths will be wasted. It is faster to "
"do as\n"
"longer does and traverse the two lists in parallel."
msgstr ""
"Эта идиома неэффективна так как она требует прохождения обоих списков для "
"нахождения длины.\n"
"Если один из списков сильно длиннее другого, проход разницы в длине списков "
"будет лишним. \n"
"Быстрее проходить их параллельно."

#: texi/node-04.texi:350
msgid ""
"Embedded within longer is a recursive function to compare the lengths of\n"
"two lists. Since longer is for comparing lengths, it should work for "
"anything\n"
"that you could give as an argument to length. But the possibility of "
"comparing\n"
"lengths in parallel only applies to lists, so the internal function is only "
"called if\n"
"both arguments are lists."
msgstr ""
"Встроенная в longer рекурсивная функция compare сравнивает длины списков. "
"Так как\n"
"longer предназначен для сравнения длин, он должен работать со всем, что вы "
"можете передать\n"
"в length в качестве аргумента. Но возможность сравнения длин параллельно "
"возможно только\n"
"для списков, следовательно compare вызывается только если оба аргумента "
"списки."

#: texi/node-04.texi:356
msgid ""
"The next function, filter,istosome what remove-if-not is to find-if.\n"
"The built-in remove-if-not returns all the values that might have been "
"returned\n"
"if you called find-if with the same function on successive cdrs of a list. "
"Analo-\n"
"gously, filter returns what some would have returned for successive cdrs of "
"the\n"
"list:"
msgstr ""
"Следующая функция, filter, как remove-if-not по отношении к функции find-if. "
"Встроенный метод remove-if-not \n"
"возвращает все значения, которые могли бы быть возвращены, если вызвов find-"
"if c \n"
"той же функцией успешен для последующих сdrs списка. Аналогично, filter "
"возвращает то, что \n"
"должно быть возвращено для последующих crds в списке:\n"

#: texi/node-04.texi:366
msgid ""
"@lisp\n"
" (defun longer (x y)\n"
"       (labels ((compare (x y)\n"
"                     (and (consp x)\n"
"                            (or (null y)\n"
"                                 (compare (cdr x) (cdr y))))))\n"
"         (if (and (listp x) (listp y))\n"
"               (compare x y)\n"
"               (> (length x) (length y)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun longer (x y)\n"
"       (labels ((compare (x y)\n"
"                     (and (consp x)\n"
"                            (or (null y)\n"
"                                 (compare (cdr x) (cdr y))))))\n"
"         (if (and (listp x) (listp y))\n"
"               (compare x y)\n"
"               (> (length x) (length y)))))"

#: texi/node-04.texi:373
msgid ""
" (defun filter (fn lst)\n"
"       (let ((acc nil))\n"
"         (dolist (x lst)\n"
"            (let ((val (funcall fn x)))\n"
"               (if val (push val acc))))\n"
"         (nreverse acc)))"
msgstr ""

#: texi/node-04.texi:383
msgid ""
" (defun group (source n)\n"
"       (if (zerop n) (error \"zero length\"))\n"
"       (labels ((rec (source acc)\n"
"                     (let ((rest (nthcdr n source)))\n"
"                        (if (consp rest)\n"
"                             (rec rest (cons (subseq source 0 n) acc))\n"
"                             (nreverse (cons source acc))))))\n"
"         (if source (rec source nil) nil)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:385
msgid "                  Figure 4-2: Larger functions that operate on lists."
msgstr ""
"                  Рисунок 4-2: Большие функции работающие со списками.\n"
"@end cartouche"

#: texi/node-04.texi:392
msgid ""
"@example\n"
"> (filter #'(lambda (x) (if (numberp x) (1+ x)))\n"
"                '(a12b3cd4))\n"
"(2345)\n"
"@end example"
msgstr ""
"@example\n"
"> (filter #'(lambda (x) (if (numberp x) (1+ x)))\n"
"                '(a 1 2 b 3 c d 4))\n"
"(2 3 4 5)\n"
"@end example"

#: texi/node-04.texi:395
msgid ""
"You give filter a function and a list, and get back a list of whatever non-"
"nil\n"
"values are returned by the function as it is applied to the elements of the "
"list."
msgstr ""
"Вы даете filter функцию и список, и получаете назад список не nil значений\n"
"возвращенных функцией, применённой к элементам входного списка.\n"

#: texi/node-04.texi:403
msgid ""
"Notice that filter uses an accumulator in the same way as the tail-"
"recursive\n"
"functions described in Section 2-8. Indeed, the aim in writing a tail-"
"recursive\n"
"function is to have the compiler generate code in the shape of\n"
"filter.  For\n"
"filter, the straightforward iterative definition is simpler than the tail-"
"recursive\n"
"one. The combination of push and nreverse in the definition of filter is "
"the\n"
"standard Lisp idiom for accumulating a list."
msgstr ""
"Заметьте, что filter использует аккумулятор тем же способом, как функции с\n"
"хвостовой рекурсией, описанной в разделе 2.8. Цель написания функции\n"
"с хвостовой рекурсией в том, что бы компилятор генерировал код в форме "
"фильтра.\n"
"Для filter, простая итеративная реализация проще, чем версия с хвостовой\n"
"рекурсией. Комбинация push и nreverse в filter является стандартной идиомой\n"
"Lisp для накопления значений в списке."

#: texi/node-04.texi:408
msgid ""
"The last function in Figure 4-2 is for grouping lists into sublists. You "
"give\n"
"group a list l and a number n, and it will return a new list in which the "
"elements\n"
"of l are grouped into sublists of length n. The remainder is put in a final "
"sublist.\n"
"Thus if we give 2 as the second argument, we get an assoc-list:"
msgstr ""
"Последняя функция в Figure 4-2 предназначена для группировки списков в "
"подсписки.\n"
"Вы даете group список l и число n, и она вернет новый список, в котором "
"элементы\n"
"l сгруппированы в подсписки длины n. Остальная часть помещается в последний "
"подсписок.\n"
"Таким образом, если мы дадим 2 в качестве второго аргумента, мы получим\n"
"ассоциативный список(assoc-list):"

#: texi/node-04.texi:413
msgid ""
"@example\n"
"> (group '(abcdefg)2)\n"
"((A B) (C D) (E F) (G))\n"
"@end example"
msgstr ""

#: texi/node-04.texi:423
msgid ""
"This function is written in a rather convoluted way in order to make it "
"tail-\n"
"recursive (Section 2-8). The principle of rapid prototyping applies to "
"individual\n"
"functions as well as to whole programs. When writing a function like flatten,"
"it\n"
"can be a good idea to begin with the simplest possible implementation. Then, "
"once\n"
"the simpler version works, you can replace it if necessary with a more "
"efficient\n"
"tail-recursive or iterative version. If it's short enough, the initial "
"version could be\n"
"left as a comment to describe the behavior of its replacement. (Simpler "
"versions\n"
"of group and several other functions in Figures 4-2 and 4-3 are included in "
"the\n"
"note on page 389.)"
msgstr ""
"Эта функция написана довольно запутанно, чтобы сделать ее хвостовой "
"рекусией\n"
"(Section 2-8). Принцип быстрого прототипирования применим к индивидуальным\n"
"функциям, а также к целым программам. При написании такой функции, как "
"flatten,\n"
"может быть хорошей идеей начать с самой простой реализации. Потом, когда\n"
"простая версия работает, вы можете заменить ее, при необходимости на более \n"
"эффективной версией с хвостовой рекурсией или итеративной. Если она "
"достаточно\n"
"коротка, начальная версия может быть оставлена в качестве комментария для "
"описания\n"
"поведения ее замены. (Более простые версии group и некоторых других "
"функций \n"
"на Рисунках 4-2 и 4-3 включены в примечания на странице 389.)"

#: texi/node-04.texi:427
msgid ""
"The definition of group is unusual in that it checks for at least one error: "
"a\n"
"second argument of 0, which would otherwise send the function into an "
"infinite\n"
"recursion."
msgstr ""
"Определение group необычно тем, что оно проверяет, по крайней мере одну "
"ошибку:\n"
"второй аргумент на 0, который в противном случае отправил бы функцию в "
"бесконечную\n"
"рекурсию."

#: texi/node-04.texi:432
msgid ""
"In one respect, the examples in this book deviate from usual Lisp practice: "
"to\n"
"make the chapters independent of one another, the code examples are as much "
"as\n"
"possible written in raw Lisp. Because it is so useful in defining macros, "
"group is\n"
"an exception, and will reappear at several points in later chapters."
msgstr ""
"В одном отношении, примеры в этой книге отличаются от обычной практики "
"Лисп:\n"
"сделать главы независимыми друг от друга, примеры кода возможными к "
"написанию\n"
"на чистом Лиспе. Поскольку эти функции так полезны при определении "
"макросов,\n"
"group как исключенение, появиться в нескольких местах в следующих главах."

#: texi/node-04.texi:437
msgid ""
"The functions in Figure 4-2 all work their way along the top-level structure "
"of\n"
"a list. Figure 4-3 shows two examples of functions that descend into nested "
"lists.\n"
"The first, flatten, was also predefined in Interlisp. It returns a list of "
"all the\n"
"atoms that are elements of a list, or elements of its elements, and so on:"
msgstr ""
"Все функции на рисунке 4-2 работают по структуре верхнего уровня списка.\n"
"На Рисунке 4-3 показано два примера , которые спускаются во вложенные "
"списки.\n"
"Первый, flatten, также предопределен в Interlisp. Он возвращает список всех\n"
"атомов, которые являются элементами списка, или элементами его элементов и \n"
"так далее:"

#: texi/node-04.texi:442
msgid ""
"@example\n"
"> (flatten '(a (b c) ((d e) f)))\n"
"(ABCDEF)\n"
"@end example"
msgstr ""
"@example\n"
"> (flatten '(a (b c) ((d e) f)))\n"
"(A B C D E F)\n"
"@end example"

#: texi/node-04.texi:445
msgid ""
"The other function in Figure 4-3, prune,istoremove-if as copy-tree is to\n"
"copy-list. That is, it recurses down into sublists:"
msgstr ""
"Другая функция на рисунке 4-3, prune, это как remove-if работающий\n"
"вместе copy-tree при копировании списка. То есть, он рекурсивно\n"
"спускается вниз в подсписки:"

#: texi/node-04.texi:450
msgid ""
"@example\n"
"> (prune #'evenp '(1 2 (3 (4 5) 6) 7 8 (9)))\n"
"(1 (3 (5)) 7 (9))\n"
"@end example"
msgstr ""

#: texi/node-04.texi:452
msgid "Every leaf for which the function returns true is removed."
msgstr "Каждый лист для которого функция возвращает истину - удаляется."

#: texi/node-04.texi:457
msgid ""
"@node 4-4 Search, 4-5 Mapping, 4-3 Operations on Lists, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-4 Search\n"
"@cindex 4-4 Search"
msgstr ""
"@node 4-4 Search, 4-5 Mapping, 4-3 Operations on Lists, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-4 Поиск\n"
"@cindex 4-4 Search"

#: texi/node-04.texi:460
msgid ""
"This section gives some examples of functions for searching lists. Common\n"
"Lisp provides a rich set of built-in operators for this purpose, but some "
"tasks"
msgstr ""
"В этом разделе приведены некоторые примеры функий для поиска в списках. "
"Common\n"
"Lisp предоставляет для этого богатый набор встроенных операторов. но\n"
"некоторые задачи"

#: texi/node-04.texi:468
msgid ""
"@lisp\n"
"  (defun flatten (x)\n"
"        (labels ((rec (x acc)\n"
"                       (cond ((null x) acc)\n"
"                               ((atom x) (cons x acc))\n"
"                               (t (rec (car x) (rec (cdr x) acc))))))\n"
"           (rec x nil)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"  (defun flatten (x)\n"
"      (labels ((rec (x acc)\n"
"                 (cond ((null x) acc)\n"
"                       ((atom x) (cons x acc))\n"
"                       (t (rec (car x) (rec (cdr x) acc))))))\n"
"       (rec x nil)))"

#: texi/node-04.texi:481
msgid ""
"  (defun prune (test tree)\n"
"        (labels ((rec (tree acc)\n"
"                       (cond ((null tree) (nreverse acc))\n"
"                               ((consp (car tree))\n"
"                                 (rec (cdr tree)\n"
"                                        (cons (rec (car tree) nil) acc)))\n"
"                               (t (rec (cdr tree)\n"
"                                          (if (funcall test (car tree))\n"
"                                                acc\n"
"                                                (cons (car tree) acc)))))))\n"
"           (rec tree nil)))\n"
"@end lisp"
msgstr ""
"  (defun prune (test tree)\n"
"     (labels ((rec (tree acc)\n"
"                (cond ((null tree) \n"
"                        (nreverse acc))\n"
"                      ((consp (car tree))\n"
"                        (rec (cdr tree)\n"
"                             (cons (rec (car tree) nil) acc)))\n"
"                      (t \n"
"                        (rec (cdr tree)\n"
"                             (if (funcall test (car tree))\n"
"                                 acc\n"
"                                 (cons (car tree) acc)))))))\n"
"      (rec tree nil)))\n"
"@end lisp"

#: texi/node-04.texi:483
msgid "                        Figure 4-3: Doubly-recursive list utilities."
msgstr ""
"              Рисунок 4-3: Утилиты двойной рекурсии для работы со списками.\n"
"@end cartouche"

#: texi/node-04.texi:488
msgid ""
"are still difficult-or at least difficult to perform efficiently. We saw "
"this in the\n"
"hypothetical case described on page 41. The first utility in Figure 4-4, "
"find2,is\n"
"the one we defined in response to it."
msgstr ""
"все еще трудно, или по крайней мере, трудно выполнить эффективно. Мы видели "
"это в\n"
"гипотетическом случае описанном на стр. 41. Первая утилита на рисунке 4-4, "
"find2,\n"
"так которую мы определеили в в ответ на это."

#: texi/node-04.texi:491
msgid ""
"The next utility, before, is written with similar intentions. It tells you "
"if one\n"
"object is found before another in a list:"
msgstr ""
"Следующая утилита, before, написана с похожими намереньями. Она говорит вам, "
"если один\n"
"объект найден перед другим в списке:"

#: texi/node-04.texi:496
msgid ""
"@example\n"
"   > (before 'b 'd '(abcd))\n"
"   (BCD)\n"
"@end example"
msgstr ""
"@example\n"
"   > (before 'b 'd '(a b c d))\n"
"   (B C D)\n"
"@end example"

#: texi/node-04.texi:498
msgid "It is easy enough to do this sloppily in raw Lisp:"
msgstr "Это довольно легко сделать в чистом Лиспе:"

#: texi/node-04.texi:502
msgid ""
"@lisp\n"
"   (< (position 'b '(a b c d)) (position 'd '(a b c d)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:507
msgid ""
"But the latter idiom is inefficient and error-prone: inefficient because we "
"don't\n"
"need to find both objects, only the one that occurs first; and error-prone "
"because\n"
"if either object isn't in the list, nil will be passed as an argument to <. "
"Using\n"
"before fixes both problems."
msgstr ""
"Но последняя идиома неэффективна и подвержена ошибкам: неэффективна, "
"поскольку нам не \n"
"нужно искать оба объекта, только тот который появляется первым; и подвержена "
"ошибкам,\n"
"поскольку если какого-либо объекта нет в списке, nil будет передан в  "
"качестве аргумента <.\n"
"Использование before решает обе эти проблемы."

#: texi/node-04.texi:511
msgid ""
"Since before is similar in spirit to a test for membership, it is written "
"to\n"
"resemble the built-in member function. Like member it takes an optional "
"test\n"
"argument, which defaults to eql. Also, instead of simply returning t, it "
"tries to"
msgstr ""
"Так как before похож на проверку для membership, он написан похоже на\n"
"встроенную функцию member. Подобно member он принимает необязательный\n"
"аргумент test, который по умолчанию является eql. Кроме того, вместо\n"
"простого возрвата t, он пытается"

#: texi/node-04.texi:520
msgid ""
"@lisp\n"
" (defun find2 (fn lst)\n"
"       (if (null lst)\n"
"           nil\n"
"           (let ((val (funcall fn (car lst))))\n"
"              (if val\n"
"                   (values (car lst) val)\n"
"                   (find2 fn (cdr lst))))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun find2 (fn lst)\n"
"       (if (null lst)\n"
"           nil\n"
"           (let ((val (funcall fn (car lst))))\n"
"              (if val\n"
"                   (values (car lst) val)\n"
"                   (find2 fn (cdr lst))))))"

#: texi/node-04.texi:527
msgid ""
" (defun before (x y lst &key (test #'eql))\n"
"       (and lst\n"
"            (let ((first (car lst)))\n"
"               (cond ((funcall test y first) nil)\n"
"                        ((funcall test x first) lst)\n"
"                        (t (before x y (cdr lst) :test test))))))"
msgstr ""

#: texi/node-04.texi:531
msgid ""
" (defun after (x y lst &key (test #'eql))\n"
"       (let ((rest (before y x lst :test test)))\n"
"        (and rest (member x rest :test test))))"
msgstr ""

#: texi/node-04.texi:535
msgid ""
" (defun duplicate (obj lst &key (test #'eql))\n"
"       (member obj (cdr (member obj lst :test test))\n"
"                  :test test))"
msgstr ""

#: texi/node-04.texi:543
msgid ""
" (defun split-if (fn lst)\n"
"       (let ((acc nil))\n"
"        (do ((src lst (cdr src)))\n"
"              ((or (null src) (funcall fn (car src)))\n"
"               (values (nreverse acc) src))\n"
"           (push (car src) acc))))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:545
msgid "                       Figure 4-4: Functions which search lists."
msgstr ""
"                       Рисунок 4-4: Функции которые ищут списки.\n"
"@end cartouche"

#: texi/node-04.texi:549
msgid ""
"return potentially useful information: the cdr beginning with the object "
"given as\n"
"the first argument."
msgstr ""
"вернуть потенциально полезную информацию: cdr начинающийся с объекта, "
"заданного\n"
"как первый аргумент."

#: texi/node-04.texi:553
msgid ""
"Note that before returns true if we encounter the first argument before en-\n"
"countering the second. Thus it will return true if the second argument "
"doesn't\n"
"occur in the list at all:"
msgstr ""
"Обратите внимание, что before возвращает истину, если мы находим первый "
"аргумент\n"
"перед вторым. Таким образом, он вернет истину, если второй аргумент не "
"появляется\n"
"вообще в списке:"

#: texi/node-04.texi:558
msgid ""
"@example\n"
"> (before 'a 'b '(a))\n"
"(A)\n"
"@end example"
msgstr ""

#: texi/node-04.texi:561
msgid ""
"We can peform a more exacting test by calling after, which requires that "
"both\n"
"its arguments occur in the list:"
msgstr ""
"Мы можем выполнить более точный тест, вызывав after, которые требует чтобы\n"
"оба его аргуемента были в списке:"

#: texi/node-04.texi:569
msgid ""
"@example\n"
"> (after 'a 'b '(b a d))\n"
"(A D)\n"
"> (after 'a 'b '(a))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-04.texi:574
msgid ""
"If (member ol) finds o in the list l, it also returns the cdr of l "
"beginning\n"
"with o. This return value can be used, for example, to test for duplication. "
"If o is\n"
"duplicated in l, then it will also be found in the cdr of the list returned "
"by member.\n"
"This idiom is embodied in the next utility, duplicate:"
msgstr ""
"Если (member o l) находит o в списке l, он также возвращает cdr из l "
"начинающийся с o. \n"
"Это возвращаемое значение можно использовать, например, для проверки на "
"дублирование. Если o \n"
"дублируется в l, тогда он также будет  найден в cdr списка возвращенного "
"функцией member.\n"
"Эта идиома воплощена в следующей утилите, duplicate:"

#: texi/node-04.texi:579
msgid ""
"@example\n"
"> (duplicate 'a '(abcad))\n"
"(A D)\n"
"@end example"
msgstr ""
"@example\n"
"> (duplicate 'a '(a b c a d))\n"
"(A D)\n"
"@end example"

#: texi/node-04.texi:581
msgid ""
"Other utilities to test for duplication could be written on the same "
"principle."
msgstr ""
"Другие утилиты для проверки на дублирование могут быть написаны по тому же\n"
"принципу."

#: texi/node-04.texi:586
msgid ""
"More fastidious language designers are shocked that Common Lisp uses nil\n"
"to represent both falsity and the empty list. It does cause trouble "
"sometimes (see\n"
"Section 14-2), but it is convenient in functions like duplicate. In "
"questions of\n"
"sequence membership, it seems natural to represent falsity as the empty "
"sequence."
msgstr ""
"Более привередливые разработчики языка шокриованы тем, что Common Lisp "
"использует nil\n"
"для представления как лжи так и пустого списка. Иногда это вызывает проблемы "
"(см\n"
"Раздел 14-2), но это удобно в таких функциях, как duplicate. В запросах о "
"членстве\n"
"в последовательности, кажется естественным представлять лож как пустую "
"последовательность."

#: texi/node-04.texi:591
msgid ""
"The last function in Figure 4-4 is also a kind of generalization of member.\n"
"While member returns the cdr of the list beginning with the element it "
"finds,\n"
"split-if returns both halves. This utility is mainly used with lists that "
"are\n"
"ordered in some respect:"
msgstr ""
"Последняя функция на рисунке 4-4 также является своего рода обобщением "
"member.\n"
"В то время как member возвращает cdr списка, начиная с найденного элемента, "
"split-if \n"
"возвращает обе половины. Эта утилита в основном используется со списками,\n"
"которые в некотором отношении упорядочены:"

#: texi/node-04.texi:598
msgid ""
"@example\n"
"> (split-if #'(lambda (x) (> x 4))\n"
"                  '(12345678910))\n"
"(1234)\n"
"(5678910)\n"
"@end example"
msgstr ""
"@example\n"
"> (split-if #'(lambda (x) (> x 4))\n"
"                  '(1 2 3 4 5 6 7 8 9 10))\n"
"(1 2 3 4)\n"
"(5 6 7 8 9 10)\n"
"@end example"

#: texi/node-04.texi:603
msgid ""
"Figure 4-5 contains search functions of another kind: those which compare\n"
"elements against one another. The first, most, looks at one element at a "
"time. It\n"
"takes a list and a scoring function, and returns the element with the "
"highest score.\n"
"In case of ties, the element occurring first wins."
msgstr ""
"Рисунок 4-5 содержит функции поиска другого типа: те которые сравнивают "
"элементы друг\n"
"против друга. Первая, most, смотрит на один элемент за раз. Она принимает "
"список и функцию\n"
"оценки, и возвращает элемент с наибольшим количеством очков. В случае "
"ничьей, элемент, \n"
"встреченный первым, выигрывает."

#: texi/node-04.texi:609
msgid ""
"@example\n"
"> (most #'length '((a b) (a b c) (a) (e f g)))\n"
"(ABC)\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-04.texi:611
msgid "For convenience, most also returns the score of the winner."
msgstr "Для удобства, most также возвращает и счет победителя."

#: texi/node-04.texi:615
msgid ""
"A more general kind of search is provided by best. This utility also takes "
"a\n"
"function and a list, but here the function must be a predicate of two "
"arguments. It\n"
"returns the element which, according to the predicate, beats all the others."
msgstr ""
"Более общий вид поиска обеспечивается функцией best. Эта утилита также "
"принимает\n"
"функцию и список, но здесь функция должна быть предикатом двух аргументов. "
"Она\n"
"возвращает элемент, который согласно предиката превосходит все остальные."

#: texi/node-04.texi:628
msgid ""
"@lisp\n"
"     (defun most (fn lst)\n"
"      (if (null lst)\n"
"          (values nil nil)\n"
"          (let* ((wins (car lst))\n"
"                   (max (funcall fn wins)))\n"
"            (dolist (obj (cdr lst))\n"
"                 (let ((score (funcall fn obj)))\n"
"                  (when (> score max)\n"
"                    (setq wins obj\n"
"                           max score))))\n"
"            (values wins max))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun most (fn lst)\n"
"      (if (null lst)\n"
"          (values nil nil)\n"
"          (let* ((wins (car lst))\n"
"                   (max (funcall fn wins)))\n"
"            (dolist (obj (cdr lst))\n"
"                 (let ((score (funcall fn obj)))\n"
"                  (when (> score max)\n"
"                    (setq wins obj\n"
"                           max score))))\n"
"            (values wins max))))"

#: texi/node-04.texi:637
msgid ""
"     (defun best (fn lst)\n"
"      (if (null lst)\n"
"          nil\n"
"          (let ((wins (car lst)))\n"
"            (dolist (obj (cdr lst))\n"
"                 (if (funcall fn obj wins)\n"
"                    (setq wins obj)))\n"
"            wins)))"
msgstr ""

#: texi/node-04.texi:652
msgid ""
"     (defun mostn (fn lst)\n"
"      (if (null lst)\n"
"          (values nil nil)\n"
"          (let ((result (list (car lst)))\n"
"                  (max (funcall fn (car lst))))\n"
"            (dolist (obj (cdr lst))\n"
"                 (let ((score (funcall fn obj)))\n"
"                  (cond ((> score max)\n"
"                          (setq max        score\n"
"                                  result (list obj)))\n"
"                         ((= score max)\n"
"                          (push obj result)))))\n"
"            (values (nreverse result) max))))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:654
msgid "             Figure 4-5: Search functions which compare elements."
msgstr ""
"             Рисунок 4-5: Функции поиска которые сравнивают элементы.\n"
"@end cartouche"

#: texi/node-04.texi:660
msgid ""
"@example\n"
"> (best #'> '(1 2 3 4 5))\n"
"5\n"
"@end example"
msgstr ""

#: texi/node-04.texi:662
msgid ""
"We can think of best as being equivalent to car of sort, but much more "
"efficient."
msgstr ""
"Мы можем думать о best как о эквиваленте car после sort, но более "
"эффективном."

#: texi/node-04.texi:667
msgid ""
"It is up to the caller to provide a predicate which defines a total order on "
"the\n"
"elements of the list. Otherwise the order of the elements will influence the "
"result;\n"
"as before, in case of ties, the first element wins."
msgstr ""
"Вызывающий должен предоставить предикат, который задает общий порядок на "
"элементах\n"
"списка. В противном случае порядок элементов будет влиять на результат;\n"
"как и для before, в случае ничьей выигрывает первый встреченный элемент."

#: texi/node-04.texi:670
msgid ""
"Finally, mostn takes a function and a list and returns a list of all the "
"elements\n"
"for which the function yields the highest score (along with the score "
"itself):"
msgstr ""
"Наконец, mostn берет функцию и список и возвращает список всех элементов для "
"которых\n"
"функция выдает высший бал (вместе с самим баллом):"

#: texi/node-04.texi:676
msgid ""
"@example\n"
"> (mostn #'length '((a b) (a b c) (a) (e f g)))\n"
"((A B C) (E F G))\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-04.texi:681
msgid ""
"@node 4-5 Mapping, 4-6 I/O, 4-4 Search, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-5 Mapping\n"
"@cindex 4-5 Mapping"
msgstr ""
"@node 4-5 Mapping, 4-6 I/O, 4-4 Search, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-5 Отображение\n"
"@cindex 4-5 Mapping"

#: texi/node-04.texi:687
msgid ""
"Another widely used class of Lisp functions are the mapping functions, "
"which\n"
"apply a function to a sequence of arguments. Figure 4-6 shows some examples "
"of\n"
"new mapping functions. The first three are for applying a function to a "
"range of\n"
"numbers without having to cons up a list to contain them. The first two, "
"map0-n\n"
"and map1-n, work for ranges of positive integers:"
msgstr ""
"Другим широко используемым классом функций Lisp являются функции "
"отображения\n"
"(mapping functions), которые применяют функцию к последовательности "
"аргументов.\n"
"Рисунок 4-6 показывает несколько примеров новых функций отображения.\n"
"Первые три предназначены для применения функции к диапазону чисел без "
"необходимости\n"
"составлять список, чтобы хранить их. Первые две, map0-n и map1-n, работают "
"для\n"
"диапазона положительных целых чисел:"

#: texi/node-04.texi:692
msgid ""
"@example\n"
"> (map0-n #'1+ 5)\n"
"(123456)\n"
"@end example"
msgstr ""
"@example\n"
"> (map0-n #'1+ 5)\n"
"(1 2 3 4 5 6)\n"
"@end example"

#: texi/node-04.texi:695
msgid ""
"Both are written using the more general mapa-b, which works for any range "
"of\n"
"numbers:"
msgstr ""
"Обе написаны с использованием более общей функции mapa-b, которая работает "
"для любого\n"
"диапазона номеров:"

#: texi/node-04.texi:700
msgid ""
"@example\n"
"> (mapa-b #'1+ -2 0 .5)\n"
"(-1 -0-5 0-0 0-5 1-0)\n"
"@end example"
msgstr ""
"@example\n"
"> (mapa-b #'1+ -2 0 .5)\n"
"(-1 -0.5 0.0 0.5 1.0)\n"
"@end example"

#: texi/node-04.texi:708
msgid ""
"Following mapa-b is the still more general map->, which works for sequences\n"
"of objects of any kind. The sequence begins with the object given as the "
"second\n"
"argument, the end of the sequence is defined by the function given as the "
"third\n"
"argument, and successors are generated by the function given as the fourth "
"argu-\n"
"ment. With map-> it is possible to navigate arbitrary data structures, as "
"well as\n"
"operate on sequences of numbers. We could define mapa-b in terms of map-> "
"as\n"
"follows:"
msgstr ""
"Следующая за mapa-b более общая функция map->, которая работает для "
"последовательностей\n"
"объектов любого вида. Последовательность начинается с объекта, данного как "
"второй аргумент,\n"
"конец последовательности определяется функцией заданной как третий аргумент, "
"приемники\n"
"(последующие объекты) генерируются функцией, заданной в качестве четвертого "
"аргумента. \n"
"С map-> можно перемещаться по произвольным структурам данных, а также "
"оперировать \n"
"последовательностями чисел. Мы могли бы определить mapa-b в терминах map-> "
"следующим\n"
"образом:"

#: texi/node-04.texi:714
msgid ""
"@lisp\n"
"(defun mapa-b (fn a b &optional (step 1))\n"
"     (map-> fn\n"
"               a#'(lambda (x) (> x b))\n"
"               #'(lambda (x) (+ x step))))"
msgstr ""
"@lisp\n"
"(defun mapa-b (fn a b &optional (step 1))\n"
"     (map-> fn\n"
"            a\n"
"            #'(lambda (x) (> x b))\n"
"            #'(lambda (x) (+ x step))))\n"
"@end lisp"

#: texi/node-04.texi:718
msgid ""
" (defun map0-n (fn n)\n"
"      (mapa-b fn 0 n))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun map0-n (fn n)\n"
"      (mapa-b fn 0 n))"

#: texi/node-04.texi:721
msgid ""
" (defun map1-n (fn n)\n"
"      (mapa-b fn 1 n))"
msgstr ""

#: texi/node-04.texi:727
msgid ""
" (defun mapa-b (fn a b &optional (step 1))\n"
"      (do ((i a (+ i step))\n"
"          (result nil))\n"
"         ((> i b) (nreverse result))\n"
"       (push (funcall fn i) result)))"
msgstr ""

#: texi/node-04.texi:733
msgid ""
" (defun map-> (fn start test-fn succ-fn)\n"
"      (do ((i start (funcall succ-fn i))\n"
"          (result nil))\n"
"         ((funcall test-fn i) (nreverse result))\n"
"       (push (funcall fn i) result)))"
msgstr ""
" (defun map-> (fn start test-fn step-fn)\n"
"      (do ((i start (funcall step-fn i))\n"
"          (result nil))\n"
"         ((funcall test-fn i) (nreverse result))\n"
"       (push (funcall fn i) result)))"

#: texi/node-04.texi:736
msgid ""
" (defun mappend (fn &rest lsts)\n"
"      (apply #'append (apply #'mapcar fn lsts)))"
msgstr ""

#: texi/node-04.texi:743
msgid ""
" (defun mapcars (fn &rest lsts)\n"
"      (let ((result nil))\n"
"       (dolist (lst lsts)\n"
"         (dolist (obj lst)\n"
"            (push (funcall fn obj) result)))\n"
"       (nreverse result)))"
msgstr ""

#: texi/node-04.texi:752
msgid ""
" (defun rmapcar (fn &rest args)\n"
"      (if (some #'atom args)\n"
"         (apply fn args)\n"
"         (apply #'mapcar\n"
"                #'(lambda (&rest args)\n"
"                    (apply #'rmapcar fn args))\n"
"                args)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:754
msgid "                     Figure 4-6: Mapping functions."
msgstr ""
"                     Рисунок 4-6: Отображающие функции.\n"
"@end cartouche"

#: texi/node-04.texi:756
msgid ""
"For efficiency, the built-in mapcan is destructive. It could be duplicated "
"by:"
msgstr ""
"Для эффективности, встроенный mapcan является разрушающим. Он может быть "
"дублирован как:"

#: texi/node-04.texi:761
msgid ""
"@lisp\n"
"(defun our-mapcan (fn &rest lsts)\n"
"  (apply #'nconc (apply #'mapcar fn lsts)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:769
msgid ""
"Because mapcan splices together lists with nconc, the lists returned by the "
"first\n"
"argument had better be newly created, or the next time we look at them they\n"
"might be altered. That's why nicknames (page 41) was defined as a function\n"
"which \"builds a list\" of nicknames. If it simply returned a list stored "
"elsewhere,\n"
"it wouldn't have been safe to use mapcan. Instead we would have had to "
"splice\n"
"the returned lists with append. For such cases, mappend offers a "
"nondestructive\n"
"alternative to mapcan."
msgstr ""
"Поскольку mapcan объединяет списки с помощью nconc, списки возвращаемые "
"первым\n"
"аргументом должны быть заново созданы, или в когда в следующий раз мы "
"посмотрим\n"
"на них, они могут быть изменены. Вот почему функция nicknames (стр 41) "
"была \n"
"определена как функция которая \"строит список\" псевдонимов(nicknames). "
"Если она\n"
"просто вернет хранящийся где-либо список, было бы не безопасно использовать\n"
"mapcan. Вместо этого нам пришлось бы склеить возвращенные списки с "
"использованием\n"
"append. Для таких случаев mappend предлагает неразрушающую альтернативу "
"mapcan."

#: texi/node-04.texi:773
msgid ""
"The next utility, mapcars, is for cases where we want to mapcar a function\n"
"over several lists. If we have two lists of numbers and we want to get a "
"single list\n"
"of the square roots of both, using raw Lisp we could say"
msgstr ""
"Следующая утилита, mapcars, предназначена для случаев, когда мы хотим "
"отобразить mapcar\n"
"функцию по нескольким спискам. Если у нас есть два списка чисел и мы хотим "
"получить один\n"
"список содержащий квадратный корни чисел из обоих этих списков, используя "
"чистый Lisp\n"
"мы могли бы сказать"

#: texi/node-04.texi:777
msgid ""
"@lisp\n"
"(mapcar #'sqrt (append list1 list2))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:780
msgid ""
"but this conses unnecessarily. We append together list1 and list2 only to\n"
"discard the result immediately. With mapcars we can get the same result from:"
msgstr ""
"но это создание нового списка append бессмысленно. Мы склеиваем  list1 и "
"list2 вместе\n"
"только для того чтобы отменить результат немедленно. С mapcars мы можем "
"получить тот же\n"
"результат из:"

#: texi/node-04.texi:784
msgid ""
"@lisp\n"
"(mapcars #'sqrt list1 list2)\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:786
msgid "and do no unnecessary consing."
msgstr "и не делает ненужных созданий списков."

#: texi/node-04.texi:790
msgid ""
"The final function in Figure 4-6 is a version of mapcar for trees. Its "
"name,\n"
"rmapcar, is short for \"recursive mapcar,\" and what mapcar does on flat "
"lists, it\n"
"does on trees:"
msgstr ""
"Последняя функция на рисунке 4-6 это версия mapcar для деревьев. Ее имя,\n"
"rmapcar, сокращение для \"рекурсивный mapcar,\" и то что mapcar делает на "
"плоских\n"
"списках, она делает на деревьях:"

#: texi/node-04.texi:796
msgid ""
"@example\n"
"> (rmapcar #'princ '(1 2 (3 4 (5) 6) 7 (8 9)))\n"
"123456789\n"
"(12(34(5)6)7(89))\n"
"@end example"
msgstr ""
"@example\n"
"> (rmapcar #'princ '(1 2 (3 4 (5) 6) 7 (8 9)))\n"
"123456789\n"
"(1 2 (3 4 (5) 6) 7 (8 9))\n"
"@end example"

#: texi/node-04.texi:798
msgid "Like mapcar, it can take more than one list argument."
msgstr "Как и mapcar, она может принимать более одного аргумента списка."

#: texi/node-04.texi:803
msgid ""
"@example\n"
"> (rmapcar #'+ '(1 (2 (3) 4)) '(10 (20 (30) 40)))\n"
"(11 (22 (33) 44))\n"
"@end example"
msgstr ""

#: texi/node-04.texi:806
msgid ""
"Several of the functions which appear later on ought really to call "
"rmapcar,\n"
"including rep on page 324."
msgstr ""
"Некоторые из функций, которые появяться позже, должны на самом деле\n"
"вызывать rmapcar, включая rep на стр. 324."

#: texi/node-04.texi:809
msgid ""
"To some extent, traditional list mapping functions may be rendered obsolete\n"
"by the new series macros introduced in CLTL2. For example,"
msgstr ""
"В некоторой степени, традиционные функции отображения списков могут быть "
"устаревшими\n"
"макросами новой серии, представленныой в CLTL2. Например,"

#: texi/node-04.texi:813
msgid ""
"@lisp\n"
"(mapa-b #'fn a b c)\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:815
msgid "could be rendered"
msgstr "можно представить"

#: texi/node-04.texi:822
msgid ""
"@lisp\n"
" (defun readlist (&rest args)\n"
"      (values (read-from-string\n"
"                   (concatenate 'string \"(\"\n"
"                                                 (apply #'read-line args)\n"
"                                                 \")\"))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun readlist (&rest args)\n"
"   (values (read-from-string\n"
"           (concatenate 'string \"(\"\n"
"                                (apply #'read-line args)\n"
"                                \")\"))))"

#: texi/node-04.texi:826
msgid ""
" (defun prompt (&rest args)\n"
"      (apply #'format *query-io* args)\n"
"      (read *query-io*))"
msgstr ""

#: texi/node-04.texi:835
msgid ""
" (defun break-loop (fn quit &rest args)\n"
"      (format *query-io* \"Entering break-loop.~%\")\n"
"      (loop\n"
"         (let ((in (apply #'prompt args)))\n"
"           (if (funcall quit in)\n"
"                 (return)\n"
"                 (format *query-io* \"~A~%\" (funcall fn in))))))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:837
msgid "                              Figure 4-7: I/O functions."
msgstr ""
"                              Figure 4-7: Функции ввода/вывода(I/O "
"functions).\n"
"@end cartouche"

#: texi/node-04.texi:842
msgid ""
"@lisp\n"
"(collect (#Mfn (scan-range :from a :upto b :by c)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:847
msgid ""
"However, there is still some call for mapping functions. A mapping function "
"may\n"
"in some cases be clearer or more elegant. Some things we could express with\n"
"map-> might be difficult to express using series. Finally, mapping "
"functions, as\n"
"functions, can be passed as arguments."
msgstr ""
"Тем не менее, есть еще некоторые вызовы для функций отображения. Функция "
"отображения\n"
"в некоторых случаях может быть более ясной и более элегантной. Некоторые "
"вещи, которые\n"
"можно выразить с map-> трудно выразить с помощью использования "
"последовательностей. \n"
"Наконец, функции отображения, могут быть переданы в качестве аргументов."

#: texi/node-04.texi:852
msgid ""
"@node 4-6 I/O, 4-7 Symbols and Strings, 4-5 Mapping, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-6 I/O\n"
"@cindex 4-6 I/O"
msgstr ""
"@node 4-6 I/O, 4-7 Symbols and Strings, 4-5 Mapping, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-6 Ввод/Вывод\n"
"@cindex 4-6 I/O"

#: texi/node-04.texi:857
msgid ""
"      Figure 4-7 contains three examples of I/O utilities. The need for this "
"kind of\n"
"utility varies from program to program. Those in Figure 4-7 are just a "
"represen-\n"
"tative sample. The first is for the case where you want users to be able to "
"type in\n"
"expressions without parentheses; it reads a line of input and returns it as "
"a list:"
msgstr ""
"      Рисунок 4-7 содержит три примера утилит ввода/вывода. Необходимость "
"такого рода\n"
"утилит варьируется от программы к программе. Те что на Рисунке 4-7 являются "
"просто\n"
"представительными образцами. Первая - для случая, когда вы хотите, чтобы "
"пользователи могли\n"
"вводить выражения без скобок; она читает строку ввода и возвращает ее в виде "
"списка:"

#: texi/node-04.texi:863
msgid ""
"@example\n"
"> (readlist)\n"
"Call me \"Ed\"\n"
"(CALL ME \"Ed\")\n"
"@end example"
msgstr ""

#: texi/node-04.texi:866
msgid ""
"The call to values ensures that we get only one value back (read-from-"
"string\n"
"itself returns a second value that is irrelevant in this case)."
msgstr ""
"Вызов values гарантирует что мы получаем только одно значение назад (read-"
"from-string\n"
"само возвращает второе значение которое не уместно в этом случае)."

#: texi/node-04.texi:870
msgid ""
"The function prompt combines printing a question and reading the answer. It\n"
"takes the arguments of format, except the initial stream argument."
msgstr ""
"Функция prompt сочетает печать вопроса и чтение ответа. Она принимает "
"аргументы\n"
"для функции format, кроме начального аргумента потока(stream)."

#: texi/node-04.texi:877
msgid ""
"@example\n"
"> (prompt \"Enter a number between ~A and ~A.~%>> \" 1 10)\n"
"Enter a number between 1 and 10.\n"
">> 3\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-04.texi:883
msgid ""
"Finally, break-loop is for situations where you want to imitate the Lisp "
"toplevel.\n"
"It takes two functions and an &rest argument, which is repeatedly given to\n"
"prompt. As long as the second function returns false for the input, the "
"first\n"
"function is applied to it. So for example we could simulate the actual Lisp\n"
"toplevel with:"
msgstr ""
"Наконец, break-loop предназначен для ситуаций, когда вы хотите имитировать "
"верхний\n"
"урвоень Lisp. Она принимает две функции и аргумент &rest, который повторно "
"передается\n"
"функции prompt. Пока вторая функция возвращает ложь для полученного ввода, "
"первая функция\n"
"применяется к нему(к введенному значению). Так, например, мы могли бы "
"имитировать настоящий\n"
"верхний уровень Lisp использовав вызов:"

#: texi/node-04.texi:891
msgid ""
"@example\n"
"> (break-loop #'eval #'(lambda (x) (eq x :q)) \">> \")\n"
"Entering break-loop.\n"
">> (+ 2 3)\n"
"5>> :q\n"
":Q\n"
"@end example"
msgstr ""

#: texi/node-04.texi:894
msgid ""
"This, by the way, is the reason Common Lisp vendors generally insist on "
"runtime\n"
"licenses. If you can call eval at runtime, then any Lisp program can include "
"Lisp."
msgstr ""
"Это кстати причина, по которой производители Common Lisp обычно настаивают "
"на лицензии\n"
"времени выполнения. Если вы можете вызвать eval во время выполнения, тогда "
"любая Lisp\n"
"программа может включать весь Lisp."

#: texi/node-04.texi:899
msgid ""
"@node 4-7 Symbols and Strings, 4-8 Density, 4-6 I/O, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-7 Symbols and Strings\n"
"@cindex 4-7 Symbols and Strings"
msgstr ""
"@node 4-7 Symbols and Strings, 4-8 Density, 4-6 I/O, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-7 Символы и Строки\n"
"@cindex 4-7 Symbols and Strings"

#: texi/node-04.texi:905
msgid ""
"Symbols and strings are closely related. By means of printing and reading\n"
"functions we can go back and forth between the two representations. Figure "
"4-8\n"
"contains examples of utilities which operate on this border. The first, "
"mkstr,\n"
"takes any number of arguments and concatenates their printed representations "
"into\n"
"a string:"
msgstr ""
"Символы и Строки тесно связаны. С помощью функций печати и чтения мы можем "
"идти\n"
"вперед и назад между этими двум представлениями. Рисунок 4-8 содержит "
"примеры\n"
"утилит, которые работают на этой границе. Первая, mkstr, принимает любое "
"количество\n"
"аргументов и объединяет их печатные представления в строку:"

#: texi/node-04.texi:910
msgid ""
"@example\n"
"> (mkstr pi \" pieces of \" 'pi)\n"
"\"3.141592653589793 pieces of PI\"\n"
"@end example"
msgstr ""

#: texi/node-04.texi:915
msgid ""
"Built upon it is symb, which is mostly used for building symbols. It takes "
"one or\n"
"more arguments and returns the symbol (creating one if necessary) whose "
"print-\n"
"name is their concatenation. It can take as an argument any object which has "
"a\n"
"printable representation: symbols, strings, numbers, even lists."
msgstr ""
"На ней(mkstr) строиться функция symb, которая в основном используется для "
"создания символов.\n"
"Она использует один или больше аргументов и возвращает символ (создавая его "
"при необходимости),\n"
"чье имя для печати это их(аргументов) объединение. Она может принимать в "
"качестве аргумента\n"
"любой объект, который имеет печатное представление: символы, строки, числа и "
"даже списки."

#: texi/node-04.texi:920
msgid ""
"@example\n"
"> (symb 'ar \"Madi\" #\\L #\\L 0)\n"
"|ARMadiLL0|\n"
"@end example"
msgstr ""

#: texi/node-04.texi:925
msgid ""
"@lisp\n"
"     (defun mkstr (&rest args)\n"
"       (with-output-to-string (s)\n"
"          (dolist (a args) (princ a s))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun mkstr (&rest args)\n"
"       (with-output-to-string (s)\n"
"          (dolist (a args) (princ a s))))"

#: texi/node-04.texi:928
msgid ""
"     (defun symb (&rest args)\n"
"       (values (intern (apply #'mkstr args))))"
msgstr ""

#: texi/node-04.texi:931
msgid ""
"     (defun reread (&rest args)\n"
"       (values (read-from-string (apply #'mkstr args))))"
msgstr ""

#: texi/node-04.texi:937
msgid ""
"     (defun explode (sym)\n"
"       (map 'list #'(lambda (c)\n"
"                               (intern (make-string 1:initial-element c)))\n"
"                         (symbol-name sym)))\n"
"@end lisp"
msgstr ""

#: texi/node-04.texi:939
msgid ""
"              Figure 4-8: Functions which operate on symbols and strings."
msgstr ""
"              Рисунок 4-8: Функции которые оперирует с символами и "
"строками.\n"
"@end cartouche"

#: texi/node-04.texi:945
msgid ""
"After calling mkstr to concatenate all its arguments into a single string, "
"symb\n"
"sends the string to intern. This function is Lisp's traditional symbol-"
"builder: it\n"
"takes a string and either finds the symbol which prints as the string, or "
"makes a\n"
"new one which does."
msgstr ""
"После вызова mkstr для объединения всех ее аргументов в одну строку, symb\n"
"отправляет строку в intern. Эта фунция Lisp традиционно является "
"построителем символов:\n"
"она принимает строку и либо находит символ, который печатается как эта "
"строка, или создает\n"
"новый."

#: texi/node-04.texi:951
msgid ""
"Any string can be the print-name of a symbol, even a string containing "
"lower-\n"
"case letters or macro characters like parentheses. When a symbol's name "
"contains\n"
"such oddities, it is printed within vertical bars, as above. In source code, "
"such\n"
"symbols should either be enclosed in vertical bars, or the offending "
"characters\n"
"preceded by backslashes:"
msgstr ""
"Любая строка может быть напечатана как имя символа, даже строка содержащая\n"
"символьный знаки нижнего регистра или макро-знаки, такие как скобки. Когда "
"имя символа\n"
"содержит такие странности, оно печатается внутри вертикальных полос, как "
"показано выше.\n"
"В исходном коде, такие символы должны быть заключены либо в вертикальные "
"черты, либо\n"
"неправильным символьным знакам должна предшествовать обратная косая черта.:"

#: texi/node-04.texi:957
msgid ""
"@example\n"
"> (let ((s (symb '(a b))))\n"
"         (and (eq s '|(A B)|) (eq s '\\(A\\ B\\))))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-04.texi:967
msgid ""
"The next function, reread, is a generalization of symb. It\n"
"takes a series of objects, and prints and rereads them. It can return\n"
"symbols like symb, but it can also return anything else that read\n"
"can. Read-macros will be invoked instead of being treated as part of a\n"
"symbol's name, and a:b will be read as the symbol b in package a,\n"
"instead of the symbol |a:b| in the current package. @footnote{For an\n"
"introduction to packages, see the Appendix beginning on page 381.} The\n"
"more general function is also pickier: reread will generate an error\n"
"if its arguments are not proper Lisp syntax."
msgstr ""
"Следующая функция reread является обобщением symb. Она получает "
"последовательность\n"
"объектов и печатает их и перепрочитывает их. Она может возвращать символ "
"подобно\n"
"symb, но она может возвратить также все, что можно прочитать.\n"
"Макрос чтения будет вызываться вместо рассматриваемого как часть имени "
"символа(?), и\n"
"a:b должно читаться как символ b в пакете a, вместо символа |a:b| в текущем "
"пакете.\n"
"@footnote{Для ознакомления с пакетами, см. Приложения для начинающих на стр. "
"381.} Чем более\n"
"общая функция, тем она более придирчива: reread вызовет ошибку, если ее "
"аргументы\n"
"не имеют правильного Lisp синтаксиса."

#: texi/node-04.texi:971
msgid ""
"The last function in Figure 4-8 was predefined in several earlier dialects:\n"
"explode takes a symbol and returns a list of symbols made from the "
"characters\n"
"in its name."
msgstr ""
"Последняя функция на рисунке 4-8 была предопределена в некоторых ранних "
"диалектах:\n"
"explode берет символ и возвращает список символов, составленный из "
"символьных знаков\n"
"в его имени."

#: texi/node-04.texi:976
msgid ""
"@example\n"
"> (explode 'bomb)\n"
"(BOMB)\n"
"@end example"
msgstr ""
"@example\n"
"> (explode 'bomb)\n"
"(B O M B)\n"
"@end example"

#: texi/node-04.texi:981
msgid ""
"It is no accident that this function wasn't included in Common Lisp. If you\n"
"find yourself wanting to take apart symbols, you're probably doing "
"something\n"
"inefficient. However, there is a place for this kind of utility in "
"prototypes, if not\n"
"in production software."
msgstr ""
"Не случайно эта функция не была включена в Common Lisp. Если вы хотите "
"разбирать\n"
"символы на части, то вы вероятно делаете чтото не эффективно. Тем не менее, "
"есть место\n"
"для такого рода утилиты в прототипах, если она не включается в "
"результирующее программное\n"
"обеспечение."

#: texi/node-04.texi:986
msgid ""
"@node 4-8 Density,  , 4-7 Symbols and Strings, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-8 Density\n"
"@cindex 4-8 Density"
msgstr ""
"@node 4-8 Density,  , 4-7 Symbols and Strings, 4 Utility Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 4-8 Компактность\n"
"@cindex 4-8 Density"

#: texi/node-04.texi:993
msgid ""
"If your code uses a lot of new utilities, some readers may complain that it "
"is hard to\n"
"understand. People who are not yet very fluent in Lisp will only be used to "
"reading\n"
"raw Lisp. In fact, they may not be used to the idea of an extensible "
"language at\n"
"all. When they look at a program which depends heavily on utilities, it may "
"seem\n"
"to them that the author has, out of pure eccentricity, decided to write the "
"program\n"
"in some sort of private language."
msgstr ""
"Если в вашем коде используется много новых утилит, некоторые читатели могут "
"жаловаться,\n"
"что его трудно понимать. Люди которые еще не очень свободно говорят на  "
"Lisp , привыкли\n"
"только чтению чистого  Lisp. На самом деле, они не могут привыкнуть к идее "
"расширяемого\n"
"языка для всего. Когда они смотрят на программу, которая сильно зависит от "
"утилит, для них\n"
"может показаться, что автор из чистой неординарности, решил написать "
"программу на каком-то\n"
"частном языке."

#: texi/node-04.texi:1007
msgid ""
"All these new operators, it might be argued, make the program harder to "
"read.\n"
"One has to understand them all before being able to read the program. To "
"see\n"
"why this kind of statement is mistaken, consider the case described on page "
"41,\n"
"in which we want to find the nearest bookshops. If you wrote the program "
"using\n"
"find2, someone could complain that they had to understand the definition of "
"this\n"
"new utility before they could read your program. Well, suppose you hadn't "
"used\n"
"find2. Then, instead of having to understand the definition of find2, the "
"reader\n"
"would have had to understand the definition of find-books, in which the "
"function\n"
"of find2 is mixed up with the specific task of finding bookshops. It is no "
"more\n"
"difficult to understand find2 than find-books. And here we have only used "
"the\n"
"new utility once. Utilities are meant to be used repeatedly. In a real "
"program, it\n"
"might be a choice between having to understand find2, and having to "
"understand\n"
"three or four specialized search routines. Surely the former is easier."
msgstr ""
"Можно утверждать, что все эти новые операторы затрудняют чтение программы. "
"Нужно\n"
"понять их все, прежде чем можно будет прочитать программу. Чтобы увидеть, "
"что\n"
"такое утверждение ошибочно, рассмотрим случай описанный на стр. 41, в "
"котором\n"
"мы хотим найти ближайшие книжные магазины. Если вы написали программу, "
"используя\n"
"find2, кто то может пожаловаться, что он должен понять определение этой "
"новой \n"
"утилиты, прежде чем он сможет прочитать вашу программу. Ну предположим, что "
"вы не\n"
"использовали утилиту find2. Тогда, вместо того чтобы понимать определение "
"find2, \n"
"читателю пришлось бы понимать определение функции find-books, в которой "
"функция\n"
"find2 смешена со специфической задачей поиска книжного магазина. Понимание "
"работы\n"
"find-books не менее трудная задача чем понимани работы find2. И здесь мы "
"имеем\n"
"только одну новую утилиту. Утилиты предназначены для многократного "
"использования.\n"
"В реальной программе, это может быть выбором между пониманием find2, и "
"пониманием\n"
"трех или четырех специализированных алгоритмов поиска. Конечно первое легче."

#: texi/node-04.texi:1011
msgid ""
"So yes, reading a bottom-up program requires one to understand all the new\n"
"operators defined by the author. But this will nearly always be less work "
"than\n"
"having to understand all the code that would have been required without them."
msgstr ""
"Так что да, чтение программы спроектированной по восходящему принципу, "
"требует\n"
"понимания всех новых операторов, определенных автором. Но это почти всегда "
"требует\n"
"меньшще работы, чем необходимость понимания весего кода, который был бы "
"необходим без\n"
"них."

#: texi/node-04.texi:1018
msgid ""
"If people complain that using utilities makes your code hard to read, they\n"
"probably don't realize what the code would look like if you hadn't used "
"them.\n"
"Bottom-up programming makes what would otherwise be a large program look\n"
"like a small, simple one. This can give the impression that the program "
"doesn't\n"
"do much, and should therefore be easy to read. When inexperienced readers "
"look\n"
"closer and find that this isn't so, they react with dismay."
msgstr ""
"Если люди жалуются, что использование утилит затрудняет чтение вашего кода, "
"они\n"
"возможно не понимают, как бы выглядел код, без использования этих утилит.\n"
"Восходящее программирование делает то, что иначе выглядело бы как большая "
"программа,\n"
"маленьким и простым. Поскольку код мал, это может создать впечатление, что "
"программа \n"
"не делает много, и поэтому должна легко читаться.  Когда неопытные читатели "
"изучают\n"
"ближе код и обнаруживают что это не так, они реагируют с тревогой."

#: texi/node-04.texi:1023
msgid ""
"We find the same phenomenon in other fields: a well-designed machine may\n"
"have fewer parts, and yet look more complicated, because it is packed into "
"a\n"
"smaller space. Bottom-up programs are conceptually denser. It may take an "
"effort\n"
"to read them, but not as much as it would take if they hadn't been written "
"that way."
msgstr ""
"Мы находим такое же явление в других областях, хорошо продуманная машина "
"может иметь\n"
"меньше частей, и все же выглядеть сложнее, потому что она занимает меньше "
"пространства.\n"
"Восходящие программы концептуально более плотные. Это может потребовать "
"усилий для их\n"
"чтения, но не столько, сколько потребовалось бы, если бы они не были "
"написаны таким\n"
"образом."

#: texi/node-04.texi:1028
msgid ""
"There is one case in which you might deliberately avoid using utilities: if\n"
"you had to write a small program to be distributed independently of the rest "
"of\n"
"your code. A utility usually pays for itself after two or three uses, but in "
"a small\n"
"program, a utility might not be used enough to justify including it."
msgstr ""
"Существует один случай, когда вы можете осознанно избегать утилит: если вы "
"должны\n"
"написать небольшую программу, которая будет распространяться независимо от "
"остального\n"
"вашего кода. Утилита, обычно окупается после двух или трех использований, но "
"в небольшой\n"
"программе, утилита может быть недостаточно использована, чтобы оправдать ее "
"включение."
