#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-08.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-07-03 08:56+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-08.texi:5
msgid ""
"@node 8 When to Use Macros, 9 Variable Capture, 7 Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 8 When to Use Macros\n"
"@cindex 8 When to Use Macros"
msgstr ""
"@node 8 When to Use Macros, 9 Variable Capture, 7 Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 8 Когда использовать Макросы\n"
"@cindex 8 When to Use Macros"

#: texi/node-08.texi:11
msgid ""
"How do we know whether a given function should really be a function, rather "
"than\n"
"a macro? Most of the time there is a clear distinction between the cases "
"which\n"
"call for macros and those which don't. By default we should use functions: "
"it is\n"
"inelegant to use a macro where a function would do. We should use macros "
"only\n"
"where they bring us some specific advantage."
msgstr ""
"Как нам узнать, должна ли данная функция действительно быть функцией, а не "
"макросом?\n"
"В большинстве случаев существует четкое различие между необходимостью вызова "
"макроса\n"
"и когда его использовать не надо. По умолчанию мы должены использовать "
"функции: т.е не\n"
"использовать макрос там, где работу может сделать функция. Мы должны "
"использовать\n"
"макросы, только там, где они приносят определенное преимущество."

#: texi/node-08.texi:21
msgid ""
"When do macros bring advantages? That is the subject of this chapter. "
"Usually\n"
"the question is not one of advantage, but necessity. Most of the things we "
"do with\n"
"macros, we could not do with functions. Section 8-1 lists the kinds of "
"operators\n"
"which can only be implemented as macros. However, there is also a small "
"(but\n"
"interesting) class of borderline cases, in which an operator might "
"justifiably be\n"
"written as a function or a macro. For these situations, Section 8-2 gives "
"the\n"
"arguments for and against macros. Finally, having considered what macros "
"are\n"
"capable of doing, we turn in Section 8-3 to a related question: what kinds "
"of things\n"
"do people do with them?"
msgstr ""
"Когда макросы приносят преимущества? Это предмет этой главы. Обычно вопрос "
"стоит\n"
"не о преимуществе, а в необходимости. Большинство вещей которые мы делаем с "
"помощью\n"
"макросов, мы не могли бы сделать используя функции. В разделе 8-1 "
"перечислены виды\n"
"операторов, которые можно реализовать только как макрос. Тем не менее, есть "
"небольшой\n"
"(но интересный) класс пограничных случаев, в которых оператор может записан "
"как функция\n"
"или как макрос. Для этих ситуаций, в разделе 8-2 приведены аргументы за и "
"против \n"
"использования макроса. Наконец, рассмотрев, что могут делать макросы, мы "
"обратимся в \n"
"разделе 8-3 к связанному с ним вопросу: Какие вещи люди делают используя их?"

#: texi/node-08.texi:27
msgid ""
"@menu\n"
"* 8-1 When Nothing Else Will Do::  \n"
"* 8-2 Macro or Function?::      \n"
"* 8-3 Applications for Macros::  \n"
"@end menu"
msgstr ""
"@menu\n"
"* 8-1 When Nothing Else Will Do::  \n"
"* 8-2 Macro or Function?::      \n"
"* 8-3 Applications for Macros::  \n"
"@end menu"

#: texi/node-08.texi:32
msgid ""
"@node 8-1 When Nothing Else Will Do, 8-2 Macro or Function?, 8 When to Use "
"Macros, 8 When to Use Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 8-1 When Nothing Else Will Do\n"
"@cindex 8-1 When Nothing Else Will Do"
msgstr ""
"@node 8-1 When Nothing Else Will Do, 8-2 Macro or Function?, 8 When to Use "
"Macros, 8 When to Use Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 8-1 Когда ничего другое не помогает\n"
"@cindex 8-1 When Nothing Else Will Do"

#: texi/node-08.texi:38
msgid ""
"It's a general principle of good design that if you find similar code "
"appearing at\n"
"several points in a program, you should write a subroutine and replace the "
"similar\n"
"sequences of code with calls to the subroutine. When we apply this principle "
"to\n"
"Lisp programs, we have to decide whether the \"subroutine\" should be a "
"function\n"
"or a macro."
msgstr ""
"Это общий принцип хорошего дизайна: если вы находите похожий код в "
"несокольих местах\n"
"программы, вы должны написать подпрограмму и заменить аналогичные "
"последовательности\n"
"кода на вызовы подпрограммы. Когда мы применяем этот принцип к Lisp "
"программам, мы\n"
"должны решить, должна ли \"подпрограмма\" быть функцией или макросом."

#: texi/node-08.texi:42
msgid ""
"In some cases it's easy to decide to write a macro instead of a function,\n"
"because only a macro can do what's needed. A function like 1+ could "
"conceivably\n"
"be written as either a function or a macro:"
msgstr ""
"В некоторых случаях легко выбрать написание макроса вместо функции, "
"поскольку\n"
"макрос может сделать то что нужно. Функцию, подобную 1+ можно записать как\n"
"функцию или как макрос:"

#: texi/node-08.texi:45
msgid ""
"@lisp\n"
"(defun 1+ (x) (+ 1 x))"
msgstr ""

#: texi/node-08.texi:48
msgid ""
"(defmacro 1+ (x) `(+ 1 ,x))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:50
msgid "But while, from Section 7-3, could only be defined as a macro:"
msgstr "Но while, из Раздела 7-3, можно определить только как макрос:"

#: texi/node-08.texi:57
msgid ""
"@lisp\n"
"(defmacro while (test &body body)\n"
"  `(do ()\n"
"             ((not ,test))\n"
"          ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:63
msgid ""
"There is no way to duplicate the behavior of this macro with a function. "
"The\n"
"definition of while splices the expressions passed as body into the body of "
"a\n"
"do, where they will be evaluated only if the test expression returns nil.No\n"
"function could do that; in a function call, all the arguments are evaluated "
"before\n"
"the function is even invoked."
msgstr ""
"Нет способа продублировать поведение этого макроса с помощью функции. "
"Определение\n"
"while \"вшивает\" переданные ему в качестве тела выражения в тело цикла do, "
"где они\n"
"будут вычисляться только, если тестовое выражение возвращает nil. Но нет "
"функции\n"
"спобоной сделать это; при вызове функции, все ее аргументы вычисляются до "
"того как\n"
"функция будет вызвана."

#: texi/node-08.texi:68
msgid ""
"When you do need a macro, what do you need from it? Macros can do two\n"
"things that functions can't: they can control (or prevent) the evaluation of "
"their\n"
"arguments, and they are expanded right into the calling context. Any "
"application\n"
"which requires macros requires, in the end, one or both of these properties."
msgstr ""
"Когда вам нужен макрос и что вам от него нужно? Макросы могут сделать только "
"две\n"
"вещи, которые не могут сделать функции: они могут контролировать (или "
"предотвращать)\n"
"вычисление своих аргументов, и они расширяются прямо в вызывающем контексте. "
"Любому\n"
"приложению, которому требуются макросы, в конце концов, требуется одно или "
"оба из \n"
"этих свойств."

#: texi/node-08.texi:74
msgid ""
"The informal explanation that \"macros don't evaluate their arguments\" is\n"
"slightly wrong. It would be more precise to say that macros control the "
"evaluation\n"
"of the arguments in the macro call. Depending on where the argument is "
"placed\n"
"in the macro's expansion, it could be evaluated once, many times, or not at "
"all.\n"
"Macros use this control in four major ways:"
msgstr ""
"Неформальное объяснение, что \"макросы не вычисляют своих аргументов\" "
"немного не\n"
"правильно. Точнее было бы сказать, что макросы контролируют вычисление "
"аргументов\n"
"переданных в вызове макроса. В зависимости от того, где находиться аргумент "
"в\n"
"расширении макроса, он будет вычислен, один раз, много раз или вообще не "
"будет\n"
"вычисляться. Макросы используют это управление четырьмя основными способами:"

#: texi/node-08.texi:104
msgid ""
"@enumerate\n"
"@item\n"
"       1. Transformation. The Common Lisp setf macro is one of a class of "
"macros\n"
"          which pick apart their arguments before evaluation. A built-in "
"access func-\n"
"          tion will often have a converse whose purpose is to set what the "
"access\n"
"          function retrieves. The converse of car is rplaca,ofcdr, rplacd, "
"and\n"
"          so on. With setf we can use calls to such access functions as if "
"they were\n"
"          variables to be set, as in (setf (car x) 'a), which could expand "
"into\n"
"          (progn (rplaca x 'a) 'a).\n"
"          To perform this trick, setf has to look inside its first argument. "
"To know\n"
"          that the case above requires rplaca, setf must be able to see that "
"the first\n"
"          argument is an expression beginning with car. Thus setf, and any "
"other\n"
"          operator which transforms its arguments, must be written as a "
"macro.\n"
"@item\n"
"       2. Binding. Lexical variables must appear directly in the source "
"code. The first\n"
"          argument to setq is not evaluated, for example, so anything built "
"on setq\n"
"          must be a macro which expands into a setq, rather than a function "
"which\n"
"        calls it. Likewise for operators like let, whose arguments are to "
"appear as\n"
"        parameters in a lambda expression, for macros like do which expand "
"into\n"
"        lets, and so on. Any new operator which is to alter the lexical "
"bindings of\n"
"        its arguments must be written as a macro.\n"
"@item\n"
"   3. Conditional evaluation. All the arguments to a function are evaluated. "
"In\n"
"        constructs like when, we want some arguments to be evaluated only "
"under\n"
"        certain conditions. Such flexibility is only possible with macros.\n"
"@item\n"
"   4. Multiple evaluation. Not only are the arguments to a function all "
"evaluated,\n"
"        they are all evaluated exactly once. We need a macro to define a "
"construct\n"
"        like do, where certain arguments are to be evaluated repeatedly."
msgstr ""
"@enumerate\n"
"@item\n"
"      Преобразование. Макрос Common Lisp setf является одним из класса "
"макросов,\n"
"          которые разбирают свои аргументы перед вычислением. Встроенной "
"функции\n"
"          доступа необходимо определить обратное, целью которого установить, "
"какой доступ\n"
"          производит функция. Обратное для car это rplaca, для cdr - rplacd, "
"и так \n"
"          далее. С помощью setf мы можем использовать вызовы таких функций, "
"как если бы\n"
"          они были переменными, значеня которых надо установить, как в (setf "
"(car x) 'a),\n"
"          которая расширяется в (progn (rplaca x 'a) 'a).\n"
"          Чтобы выполнить этот трюк, setf должен заглянуть внутрь первого "
"аргумента. Чтобы\n"
"          знать, что в приведенном выше случае требуется rplaca, setf должен "
"увидеть, что\n"
"          первый аргумент  - это выражение начинающееся с car. Таким образом "
"setf, и любой\n"
"          другой оператор, которые преобразует свои аргументы, должен быть "
"записан как\n"
"          макрос.\n"
"@item\n"
"      Связывание. Лексические переменные должны появляться непосредственно "
"в \n"
"          исходном коде. Например, первый аргумент для setq не вычисляется, "
"поэтому\n"
"          все что построено на setq должно быть макросом, который "
"расширяется в setq,\n"
"          а не функцией, которая его вызывает. Аналогично, для операторов "
"типа let, \n"
"          аргументы которых должны выглядеть как параметры в лямбда "
"выражении, для \n"
"          макросов типа do, которые расширяются в lets, и так далее. Любой "
"новый\n"
"          оператор, который должен изменять лексические привязки своих "
"аргументов\n"
"          должен быть написан в виде макроса.\n"
"@item\n"
"      Условное вычисление. Все аргументы функции - вычисляются. В таких "
"конструкциях,\n"
"          подобных when, когда мы хотим, чтобы некоторые аргументы "
"вычислялись только \n"
"          при определенных условиях. Такая гибкость возможна только при "
"использовании\n"
"          макросов.\n"
"@item\n"
"      Многократное вычисление. Аргументы функции не просто вычисляются, они "
"вычисляются\n"
"          только один раз. Нам необходим макрос для определения конструкции "
"подобной do, \n"
"          где определенные аргументы должны вычисляться повторно."

#: texi/node-08.texi:110
msgid ""
"@noindent\n"
"There are also several ways to take advantage of the inline expansion of "
"macros.\n"
"It's important to emphasize that the expansions thus appear in the lexical "
"context\n"
"of the macro call, since two of the three uses for macros depend on that "
"fact. They\n"
"are:"
msgstr ""
"@noindent\n"
"Есть также несколько способов получить пользу от встраиваемого расширения "
"макросов.\n"
"Важно подчеркнуть, что расширение появляются в лексическом контексте вызова "
"макроса,\n"
"поскольку два из трех вариантов использования макроса зависят от этого "
"факта. Они\n"
"являются:"

#: texi/node-08.texi:115
msgid ""
"@item\n"
"   5. Using the calling environment. A macro can generate an expansion con-\n"
"        taining a variable whose binding comes from the context of the macro "
"call.\n"
"        The behavior of the following macro:"
msgstr ""
"@item\n"
"    Использованием окружения вызова. Макрос может генерировать расширение, "
"содержащее\n"
"        переменные, которые связаны в контексте вызова макроса.\n"
"        Поведение следующего макроса:"

#: texi/node-08.texi:120
msgid ""
"@lisp\n"
"        (defmacro foo (x)\n"
"          `(+ ,x y))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:137
msgid ""
"        depends on the binding of y where foo is called.\n"
"        This kind of lexical intercourse is usually viewed more as a source "
"of con-\n"
"        tagion than a source of pleasure. Usually it would be bad style to "
"write such\n"
"        a macro. The ideal of functional programming applies as well to "
"macros:\n"
"        the preferred way to communicate with a macro is through its "
"parameters.\n"
"        Indeed, it is so rarely necessary to use the calling environment "
"that most\n"
"        of the time it happens, it happens by mistake. (See Chapter 9.) Of "
"all the\n"
"        macros in this book, only the continuation-passing macros (Chapter "
"20) and\n"
"        some parts of the ATN compiler (Chapter 23) use the calling "
"environment in\n"
"        this way.\n"
"@item\n"
"   6. Wrapping a new environment. A macro can also cause its arguments to\n"
"        be evaluated in a new lexical environment. The classic example is "
"let,\n"
"        which could be implemented as a macro on lambda (page 144). Within\n"
"        the body of an expression like (let ((y 2)) (+ x y)), y will refer "
"to a\n"
"        new variable."
msgstr ""
"        зависит от привязки y в месте, где вызывается foo.\n"
"        Этот вид лексического проникновения обычно рассматривается как "
"источник проблем,\n"
"        нежели как средство их решения. Обычно является плохим стилем "
"написание подобных\n"
"        макросов. Идеал функционального программирования применим и к "
"макросам: \n"
"        предпочтительный способ связи с макросом - через его параметры.\n"
"        Действительно, настолько редко требуется использовать окружение "
"вызова, что в \n"
"        большинстве случаев это приводит к ошибкам. (См. главу 9.) Из всех "
"макросов в этой \n"
"        книге, только  макросы передачи продолжений(continuation-passing) "
"(Глава 20) и \n"
"        некоторые части компилятора ATN (глава 23) используют среду вызова "
"таким способом.\n"
"@item\n"
"     Обертывание нового окружения. Макрос также может вызвать вычисление "
"своих аргументов в\n"
"        новом лексическом окружении. Классическй пример это  let, который "
"может быть \n"
"        реализован как макрос использущий лямбду (стр. 144). В теле "
"выражения, такого как\n"
"        (let ((y 2)) (+ x y)), y будет ссылаться на новую переменную."

#: texi/node-08.texi:144
msgid ""
"@item\n"
"       7. Saving function calls. The third consequence of the inline "
"insertion of\n"
"         macroexpansions is that in compiled code there is no overhead "
"associated\n"
"         with a macro call. By runtime, the macro call has been replaced by "
"its\n"
"         expansion. (The same is true in principle of functions declared "
"inline.)\n"
"@end enumerate"
msgstr ""
"@item\n"
"       Отсутствие затрат на вызов функции. Третье следствие от встраивания\n"
"         расширения макроса состоит в том, что в скомпилированном коде нет "
"никаких\n"
"         накладных расходов связанных с вызовом макроса. Во время выполнения "
"вызов\n"
"         макроса уже заменен расширением. (То же самое, в принципе, верно "
"для \n"
"         встраиваемых функций, объявленных inline.)\n"
"@end enumerate"

#: texi/node-08.texi:148
msgid ""
"Significantly, cases 5 and 6, when unintentional, constitute the problem of "
"variable\n"
"capture, which is probably the worst thing a macro writer has to fear. "
"Variable\n"
"capture is discussed in Chapter 9."
msgstr ""
"Примечательно, что случаи 5 и 6, когда непреднамеренно захватывается "
"переменная,\n"
"представляют собой проблему являющуюся худшей вещью, которой должен бояться\n"
"автор макроса. Захват переменной обсуждается в главе 9."

#: texi/node-08.texi:153
msgid ""
"Instead of seven ways of using macros, it might be better to say that there "
"are\n"
"six and a half. In an ideal world, all Common Lisp compilers would obey "
"inline\n"
"declarations, and saving function calls would be a task for inline "
"functions, not\n"
"macros. An ideal world is left as an exercise to the reader."
msgstr ""
"Вместо седьмого способа использования макросов, было бы лучше сказать что "
"есть\n"
"шесть с половиной способов. В идельном мире, все компиляторы Common Lisp "
"будут\n"
"подчиняться объявлениям inline, и сберегать расходы на вызов функций будет\n"
"задачей встраиваемых(inline) функций, а не макросов. Но идельный мир мы "
"оставим\n"
"читателю для рассмотрения в качестве упражнения."

#: texi/node-08.texi:158
msgid ""
"@node 8-2 Macro or Function?, 8-3 Applications for Macros, 8-1 When Nothing "
"Else Will Do, 8 When to Use Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 8-2 Macro or Function?\n"
"@cindex 8-2 Macro or Function?"
msgstr ""
"@node 8-2 Macro or Function?, 8-3 Applications for Macros, 8-1 When Nothing "
"Else Will Do, 8 When to Use Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 8-2 Макрос или Функция?\n"
"@cindex 8-2 Macro or Function?"

#: texi/node-08.texi:164
msgid ""
"The previous section dealt with the easy cases. Any operator that needs "
"access\n"
"to its parameters before they are evaluated should be written as a macro, "
"because\n"
"there is no other choice. What about those operators which could be written "
"either\n"
"way? Consider for example the operator avg, which returns the average of "
"its\n"
"arguments. It could be defined as a function"
msgstr ""
"В предыдущем разделе рассматривались простые случаи. Любой оператор, "
"которому нужен\n"
"доступ к его параметрам, прежде чем они будут вычислены, должен быть записан "
"как\n"
"макрос, потому что другого выбора нет. А как на счет операторов, которые "
"могут быть\n"
"записаны альтернативным способом(т.е как функции)? Рассмотрим для примера "
"оператор\n"
"avg, который возвращает среднее значение своих аргументов. Он может быть "
"определен\n"
"как функция"

#: texi/node-08.texi:169
msgid ""
"@lisp\n"
"(defun avg (&rest args)\n"
"  (/ (apply #'+ args) (length args)))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:172
msgid ""
"@noindent\n"
"but there is a good case for defining it as a macro,"
msgstr ""
"@noindent\n"
"но есть хороший способ определить его как макрос,"

#: texi/node-08.texi:177
msgid ""
"@lisp\n"
"(defmacro avg (&rest args)\n"
"  `(/ (+ ,@@args) ,(length args)))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:182
msgid ""
"because the function version would entail an unnecessary call to length each "
"time\n"
"avg was called. At compile-time we may not know the values of the "
"arguments,\n"
"but we do know how many there are, so the call to length could just as well "
"be\n"
"made then. Here are several points to consider when we face such choices:"
msgstr ""
"потому что версия функции, влечёт за собой использование ненужного вызова "
"length,\n"
"выполняемого каждый раз когда avg вызвается. Во время компиляции, вы можете "
"не знать\n"
"значения аргументов, но мы знаем, сколько их,  поэтому вызов length можно "
"сделать\n"
"в этот момент(в момент компиляции). Вот несколько моментов, на которые "
"следует \n"
"обратить внимание, когда мы сталкиваемся с таким выбором:"

#: texi/node-08.texi:219
msgid ""
"@center @heading THE PROS\n"
"@enumerate\n"
"@item\n"
"Computation at compile-time. A macro call involves computation at two\n"
"times: when the macro is expanded, and when the expansion is evaluated.\n"
"All the macroexpansion in a Lisp program is done when the program is\n"
"compiled, and every bit of computation which can be done at compile-time\n"
"is one bit that won't slow the program down when it's running. If an\n"
"operator could be written to do some of its work in the macroexpansion\n"
"stage, it will be more efficient to make it a macro, because whatever work "
"a\n"
"smart compiler can't do itself, a function has to do at runtime. Chapter 13\n"
"describes macros like avg which do some of their work during the expansion\n"
"phase.\n"
"@item\n"
"Integration with Lisp. Sometimes, using macros instead of functions will\n"
"make a program more closely integrated with Lisp. Instead of writing a\n"
"program to solve a certain problem, you may be able to use macros to\n"
"transform the problem into one that Lisp already knows how to solve. This\n"
"approach, when possible, will usually make programs both smaller and more\n"
"efficient: smaller because Lisp is doing some of your work for you, and\n"
"more efficient because production Lisp systems generally have had more\n"
"of the fat sweated out of them than user programs. This advantage appears\n"
"mostly in embedded languages, which are described starting in Chapter 19.\n"
"@item\n"
"Saving function calls. A macro call is expanded right into the code where\n"
"it appears. So if you write some frequently used piece of code as a macro,\n"
"you can save a function call every time it's used. In earlier dialects of "
"Lisp,\n"
"programmers took advantage of this property of macros to save function\n"
"calls at runtime. In Common Lisp, this job is supposed to be taken over by\n"
"functions declared inline.\n"
"By declaring a function to be inline, you ask for it to be compiled right\n"
"into the calling code, just like a macro. However, there is a gap between\n"
"theory and practice here; CLTL2 (p. 229) says that \"a compiler is free to\n"
"ignore this declaration,\" and some Common Lisp compilers do. It may still\n"
"be reasonable to use macros to save function calls, if you are compelled to\n"
"use such a compiler."
msgstr ""
"@center @titlefont{ЗА}\n"
"@enumerate\n"
"@item\n"
"Вычисления во время компиляции. Вызов макроса включает в себя вычисления\n"
"в два различных момента времени: Когда макрос расширяется и  когда\n"
"расширение вычисляется. Все расширения макросов в Lisp программах "
"выполняются\n"
"когда программа компилируется, и каждая часть вычислений, которые могут "
"быть\n"
"сделаны во время компиляции, это часть вычислений не будет замедлять "
"программу\n"
"когда она работает. Если оператор может быть написан, так чтобы сделать "
"некоторую\n"
"свою работу на стадии расширении макроса, будет более эффективным сделать "
"его\n"
"макросом, поскольку какую бы работу не мог выполнить умный компилятор, "
"функция\n"
"должна будет выполняться во время выполнения. Глава 13 описывает макросы, "
"такие\n"
"как avg, которые выполняют часть своей работы во время фазы расширения.\n"
"@item\n"
"Интеграция с Lisp. Иногда, использование макросов вместо функций делает\n"
"программу более тесно интегрированной с Lisp. Вместо того чтобы писать\n"
"программу для решения определенной проблемы, вы можете использовать\n"
"макросы, чтобы преобразовать проблему в такую проблему, которую Lisp \n"
"уже знает как решать. Это подход, когда он возможен, обычно делает "
"программы\n"
"меньше и более эффективными: меньше потому что Lisp делает часть вашей "
"работы\n"
"за вас, и более эффективными потому что производственная система Lisp имеет\n"
"более высокую производительность чем пользовательские программы. Это "
"преимущество\n"
"проявляется на встроенных языках, которые описываются начиная с главы 19.\n"
"@item\n"
"Экономия на вызовах функций. Вызов макроса расширяется прямо в код, в "
"котором \n"
"он находиться. Так что если вы напишите какой-то, часто используемый "
"фрагмент\n"
"кога в виде макроса, вы можете сэкономить на вызове функции, каждый раз "
"когда\n"
"он используется. В более ранних диалектах Lisp программисты пользовались "
"этим\n"
"свойством для экономии на вызове функций во время выполнения. В Common Lisp "
"эту\n"
"работу должны взять на себя функции объявленые встраиваемыми(inline).\n"
"Объявляя функцию встраиваемой(inline), вы запрашиваете ее вставку в "
"правильно\n"
"скомпилированный код, вызвавший её, как это было бы с макросом. Тем не "
"менее,\n"
"здесь существует разрыв между теорией и практикой; CLTL2 (стр. 229) говорит, "
"что\n"
"\"компилятор волен игнорировать эти объявления\", что и делают некоторые "
"компиляторы\n"
"Common Lisp. Возможно все еще разумно использовать макросы для экономии на "
"вызовах\n"
"функций, если вы вынуждены использовать подобный компилятор.\n"
"@end enumerate"

#: texi/node-08.texi:228
msgid ""
"@noindent\n"
"In some cases, the combined advantages of efficiency and close integration\n"
"with Lisp can create a strong argument for the use of macros. In the query\n"
"compiler of Chapter 19, the amount of computation which can be shifted "
"forward\n"
"to compile-time is so great that it justifies turning the whole program into "
"a\n"
"single giant macro. Though done for speed, this shift also brings the "
"program\n"
"closer to Lisp: in the new version, it's easier to use Lisp expressions-"
"arithmetic\n"
"expressions, for example-within queries."
msgstr ""
"@noindent\n"
"В некоторых случаях, объединяющих преимущества эффективности и тесной "
"интеграции\n"
"с помощью Lisp можно создать сильный аргумент для использования макросов. В "
"запросе\n"
"compiler Главы 19, объем вычислений, которые могут быть сдвинуты на время "
"компиляции\n"
"настолько велик, что оправдывает превращение всей программы в один гиганский "
"макрос. \n"
"Хотя это делается для скорости, это также приводит программу к более тесной "
"интеграции\n"
"с Lisp: в новой версии, проще использовать выражения работающие с "
"арифметикой Lisp, \n"
"например в запросах."

#: texi/node-08.texi:237
msgid ""
"@center @heading THE CONS\n"
"@item\n"
"Functions are data, while macros are more like instructions to the "
"compiler.\n"
"Functions can be passed as arguments (e.g. to apply),returned by functions,\n"
"or stored in data structures. None of these things are possible with "
"macros.\n"
"In some cases, you can get what you want by enclosing the macro call within\n"
"a lambda-expression. This works, for example, if you want to apply or\n"
"funcall certain macros:"
msgstr ""
"@center @titlefont{ПРОТИВ}\n"
"@enumerate\n"
"@item\n"
"Функции это данные, в то время как макросы больше похожи на инструкции для\n"
"компилятора. Функция может быть передана как аргумент(например в apply),\n"
"возвращена функцией или сохранена в структуре данных. Ничего из этого не \n"
"возможно с макросами. В некоторых случаях вы можете получить то, что "
"хотите,\n"
"заключив вызов макроса в лябда-выражение. Например, это работает, если вы\n"
"хотите использовать определение макроса в apply или  funcall:"

#: texi/node-08.texi:242
msgid ""
"@example\n"
"          > (funcall #'(lambda (x y) (avg x y)) 1 3)\n"
"          2\n"
"@end example"
msgstr ""

#: texi/node-08.texi:266
msgid ""
"However, this is an inconvenience. It doesn't always work, either: even if,\n"
"like avg, the macro has an &rest parameter, there is no way to pass it a\n"
"varying number of arguments.\n"
"@item\n"
"Clarity of source code. Macro definitions can be harder to read than the\n"
"equivalent function definitions. So if writing something as a macro would\n"
"only make a program marginally better, it might be better to use a function\n"
"instead.\n"
"@item\n"
"Clarity at runtime. Macros are sometimes harder to debug than functions.\n"
"If you get a runtime error in code which contains a lot of macro calls, the\n"
"code you see in the backtrace could consist of the expansions of all those\n"
"macro calls, and may bear little resemblance to the code you originally\n"
"wrote.\n"
"And because macros disappear when expanded, they are not accountable at\n"
"runtime. You can't usually use trace to see how a macro is being called.\n"
"If it worked at all, trace would show you the call to the macro's expander\n"
"function, not the macro call itself.\n"
"@item\n"
"Recursion. Using recursion in macros is not so simple as it is in "
"functions.\n"
"Although the expansion function of a macro may be recursive, the expansion\n"
"itself may not be. Section 10-4 deals with the subject of recursion in "
"macros.\n"
"@end enumerate"
msgstr ""
"Однако это не удобно. Это не всегда работает, т.к. даже если макрос, как и  "
"avg,\n"
"имеет параметр &rest, ему не всегда можно передать различное количество \n"
"аргументов.\n"
"@item\n"
"Ясность исходного кода. Определения макросов читать сложнее чем определения\n"
"эквивалентных определений функций. Так что если написать нечто как макрос,\n"
"делающий программу лишь незначительно лучше, тогда стоит подумать, на тем,\n"
"что может быть лучше использовать вместо него функцию.\n"
"@item\n"
"Ясность во время выполнения. Макросы иногда сложнее отлаживать, чем фунции.\n"
"Если вы получаете ошибку времени выполнения в коде, который содержит много\n"
"вызовов макросов, код который вы видите в обратной трассе, может состоять\n"
"из расширений вызовов всех этих макросов, и может иметь минимальное "
"сходство\n"
"с кодом, который вы изначально писали.\n"
"И поскольку макросы исчезают при расширении, они не способствуют "
"понимаемости\n"
"происходящего во время выполнения. Обычно вы не можете использовать "
"трассировку,\n"
"чтобы увидеть как вызывается макрос. Если бы это вообще сработало,  trace "
"покажет\n"
"вам вызов функции расширителя макроса, а не сам вызов макроса.\n"
"@item\n"
"Рекурсия. Использование рекурсии в макросах не так просто как в функциях. "
"Хотя\n"
"функция  расширения макроса может быть рекусривной, само расширение не "
"может\n"
"им быть. Раздел 10-4 посвящен теме рекусрии в макросах.\n"
"@end enumerate"

#: texi/node-08.texi:272
msgid ""
"All these considerations have to be balanced against one another in "
"deciding\n"
"when to use macros. Only experience can tell which will predominate. "
"However,\n"
"the examples of macros which appear in later chapters cover most of the "
"situations\n"
"in which macros are useful. If a potential macro is analogous to one given "
"here,\n"
"then it is probably safe to write it as such."
msgstr ""
"Все эти соображения должны быть учтены вместе при принятии решения, когда "
"использовать\n"
"макросы. Только опыт может сказать, что лучше. Тем не менее, примеры "
"макросов,которые\n"
"появляются в последующих главах, охватывают большинство ситуаций в которых "
"макросы полезны.\n"
"Если потенциальный макрос аналогичен приведенному здесь, тогда, вероятно, "
"безопасно написать\n"
"его написать как таковой."

#: texi/node-08.texi:280
msgid ""
"Finally, it should be noted that clarity at runtime (point 6) rarely becomes "
"an\n"
"issue. Debugging code which uses a lot of macros will not be as difficult as "
"you\n"
"might expect. If macro definitions were several hundred lines long, it might "
"be\n"
"unpleasant to debug their expansions at runtime. But utilities, at least, "
"tend to be\n"
"written in small, trusted layers. Generally their definitions are less than "
"15 lines\n"
"long. So even if you are reduced to poring over backtraces, such macros will "
"not\n"
"cloud your view very much."
msgstr ""
"Наконец, следует отметить, что ясность во время выполнения (пункт 6) редко "
"является\n"
"проблемой. Отладка кода, который использует многжество макросов, не будет "
"такой уж\n"
"сложной, как вы могли бы ожидать. Если бы определения макросов были длиной "
"несколько\n"
"сотен строк, неприятно было бы отлаживать их расширение во время выполнения. "
"Но по\n"
"крайней мере утилиты, имеют тенденцию быть написанными в небольших, "
"доверенных слоях.\n"
"Как правило их определения меньше 15 строк. Таким образом, даже если вы "
"остлеживаете\n"
"трассировку вызовов, такие макросы не сильно затуманивают ваш обзор."

#: texi/node-08.texi:285
msgid ""
"@node 8-3 Applications for Macros,  , 8-2 Macro or Function?, 8 When to Use "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 8-3 Applications for Macros\n"
"@cindex 8-3 Applications for Macros"
msgstr ""
"@node 8-3 Applications for Macros,  , 8-2 Macro or Function?, 8 When to Use "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 8-3 Приложения для Макросов\n"
"@cindex 8-3 Applications for Macros"

#: texi/node-08.texi:297
msgid ""
"Having considered what can be done with macros, the next question to ask "
"is:\n"
"in what sorts of applications can we use them? The closest thing to a "
"general\n"
"description of macro use would be to say that they are used mainly for\n"
"syntactic transformations. This is not to suggest that the scope for\n"
"macros is restricted.  Since Lisp programs are made from @footnote{Made\n"
"from, in the sense that lists are the input to the compiler. Functions\n"
"are no longer made of lists, as they used to be in some earlier\n"
"dialects.} lists, which are Lisp data structures, \"syntactic\n"
"transformation\" can go a long way indeed. Chapters 19­24 present whole\n"
"programs whose purpose could be described as syntactic transformation,\n"
"and which are, in effect, all macro."
msgstr ""
"Обдумав, что можно сделать с макросами, следующим вопросом будет:\n"
"в каких приложениях мы можем их использовать? Наиболее близким к общему\n"
"описанию использования макросов было бы сказать, что они используются в\n"
"основном для синтаксических преобразований. Это не означает, что область\n"
"применения макросов ограничена. Поскольку программы на Lisp состоят из \n"
"списков @footnote{Состоят из, исползуется в том смысле, что списки являются\n"
"входными данными для компилятора, Функии больше не состоят из списков, как\n"
"это было в более ранних диалектах}, которые представляют собой структуры\n"
"данных Lisp, \"синтаксические преобразования\"  действительно могут иметь\n"
"большое значение. Главы 19 - ­24 представляют целые программы, цель которых\n"
"может быть описана как синтаксическое преобразование, и которые, по сути\n"
"вся являются макросами."

#: texi/node-08.texi:307
msgid ""
"Macro applications form a continuum between small general-purpose macros\n"
"like while, and the large, special-purpose macros defined in the later "
"chapters. On\n"
"one end are the utilities, the macros resembling those that every Lisp has "
"built-in.\n"
"They are usually small, general, and written in isolation. However, you can "
"write\n"
"utilities for specific classes of programs too, and when you have a "
"collection of\n"
"macros for use in, say, graphics programs, they begin to look like a "
"programming\n"
"language for graphics. At the far end of the continuum, macros allow you to "
"write\n"
"whole programs in a language distinctly different from Lisp. Macros used in "
"this\n"
"way are said to implement embedded languages."
msgstr ""
"Приложения макросов образуют континуум от небольших макросов общего "
"назначения,\n"
"вроде while, и до больших специальных макросов, определяемых в последующих "
"главах.\n"
"На одном конце утилиты, макросы напоминающие те, которые встроены в каждый "
"Lisp.\n"
"Они обычно маленькие, общие и написаны изолированно. Тем не менее, вы можете "
"писать\n"
"утилиты для определенных классов программ, а также когда у вас есть "
"коллекция\n"
"макросов для использования, скажем, в графических программах, так что они "
"начинают\n"
"выглядеть как язык программирования графики. На дальнем конце конитинуума, "
"макросы,\n"
"позволяющие писать на языке отличном от Lisp. Про макросы, используемые "
"таким образом,\n"
"можно сказать, что они реализуют встроенный язык."

#: texi/node-08.texi:312
msgid ""
"Utilities are the first offspring of the bottom-up style. Even when a "
"program\n"
"is too small to be built in layers, it may still benefit from additions to "
"the lowest\n"
"layer, Lisp itself. The utility nil!, which sets its argument to nil, could "
"not be\n"
"defined except as a macro:"
msgstr ""
"Утилиты являются первым результатом стиля проектирования снизу-вверх. Даже "
"когда\n"
"программа слишком мала, чтобы быть построенной по слоям, она все равно может "
"извлечь\n"
"выгоду от дополнений к самым низким слоям, таким как сам Lisp. Утилита nil!, "
"которая\n"
"устанавливает свой аргумент в nil, не может быть определена иначе, чем как "
"макрос:"

#: texi/node-08.texi:317
msgid ""
"@lisp\n"
"(defmacro nil! (x)\n"
"   `(setf ,x nil))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:324
msgid ""
"Looking at nil!, one is tempted to say that it doesn't do anything, that it "
"merely\n"
"saves typing. True, but all any macro does is save typing. If one wants to\n"
"think of it in these terms, the job of a compiler is to save typing in "
"machine\n"
"language. The value of utilities should not be underestimated, because their "
"effect\n"
"is cumulative: several layers of simple macros can make the difference "
"between\n"
"an elegant program and an incomprehensible one."
msgstr ""
"Глядя на nil!, хочеться сказать, что она ничего не делает, а просто "
"уменьшает \n"
"ввод. И это верно, но все что делает любой макрос, это уменьшение ввода. "
"Если кто-то\n"
"хочет подумайте об этом в этих терминах, что работа компилятора заключается "
"в \n"
"уменьшении ввода на машинном языке. Значение утилит не следует "
"недооценивать,\n"
"поскольку их влияние является комулятивным: несколько слоев простых макросов "
"могут\n"
"создать различие между элегантной программой и непонятной программой."

#: texi/node-08.texi:330
msgid ""
"Most utilities are patterns embodied. When you notice a pattern in your "
"code,\n"
"consider turning it into a utility. Patterns are just the sort of thing "
"computers are\n"
"good at. Why should you bother following them when you could have a program\n"
"do it for you? Suppose that in writing some program you find yourself using "
"in\n"
"many different places do loops of the same general form:"
msgstr ""
"Большинство утилит являются воплощением шаблонов.  Когда вы заметили шаблон "
"в вашем\n"
"коде, рассмотрите возможность превратить его в утилиту. Шаблоны это просто "
"то, в\n"
"чем компьютеры хороши. Зачем вам следовать за ними(шаблонами), когда у вас "
"может быть\n"
"программа которая сделает это за вас? Предположим, при написании какой-то "
"программы вы\n"
"используете во многих разных местах циклы do имеющие одинаковую общую форму:"

#: texi/node-08.texi:336
msgid ""
"@lisp\n"
"(do ()\n"
"        ((not  condition ))\n"
"   .  body of code )\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:341
msgid ""
"When you find a pattern repeated through your code, that pattern often has a "
"name.\n"
"The name of this pattern is while. If we want to provide it in a new "
"utility, we will\n"
"have to use a macro, because we need conditional and repeated evaluation. If "
"we\n"
"define while using this definition from page 91:"
msgstr ""
"Когда вы обнаруживаете шаблон, повторящийся в вашем коде, этот шаблон часто "
"имеет\n"
"имя. Имя нашего шаблона это while. Если мы хотим представить его в виде "
"новой утилиты,\n"
"нам надо использовать макрос, потому что нам нужны условные и повторяющиеся "
"вычисления.\n"
"Если мы определим while используя определения со страницы 91:"

#: texi/node-08.texi:348
msgid ""
"@lisp\n"
"(defmacro while (test &body body)\n"
"  `(do ()\n"
"            ((not ,test))\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:351
msgid ""
"@noindent\n"
"then we can replace the instances of the pattern with"
msgstr ""
"@noindent\n"
"тогда мы сможем заменить экземпляры шаблона на"

#: texi/node-08.texi:356
msgid ""
"@lisp\n"
"(while  condition \n"
"  .  body of code )\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:359
msgid ""
"Doing so will make the code shorter and also make it declare in a clearer "
"voice\n"
"what it's doing."
msgstr ""
"Это сделает код короче, а также объявит то, что он делает, более ясным "
"голосом."

#: texi/node-08.texi:368
msgid ""
"The ability to transform their arguments makes macros useful in writing in-\n"
"terfaces. The appropriate macro will make it possible to type a shorter, "
"simpler\n"
"expression where a long or complex one would have been required. Although\n"
"graphic interfaces decrease the need to write such macros for end users, "
"program-\n"
"mers use this type of macro as much as ever. The most common example is\n"
"defun, which makes the binding of functions resemble, on the surface, a "
"function\n"
"definition in a language like Pascal or C. Chapter 2 mentioned that the "
"following\n"
"two expressions have approximately the same effect:"
msgstr ""
"Возможность преобразовывать свои аргументы делает макросы полезными при "
"написании\n"
"интерфейсов. Соответствующий макрос позволит набирать более короткий текст, "
"составлять\n"
"более простые и короткие выражения. Хотя графические интерфейсы уменьшают "
"необходимость\n"
"в написании таких макросов для конечных пользователй, программисты "
"используют этот\n"
"тип макросов как обычно. Самый распространенный пример это defun, который "
"делает\n"
"привязку функций, похожими на определения в языках Паскаль или Си. Глава 2 "
"упоминала,\n"
"что следующие два выражения имеют примерно одинаковый эффект:"

#: texi/node-08.texi:371
msgid ""
"@lisp\n"
"(defun foo (x) (* x 2))"
msgstr ""

#: texi/node-08.texi:375
msgid ""
"(setf (symbol-function 'foo)\n"
"           #'(lambda (x) (* x 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:378
msgid ""
"Thus defun can be implemented as a macro which turns the former into the "
"latter.\n"
"We could imagine it written as follows:@footnote{For clarity, this version "
"ignores all the bookkeeping that defun must perform.}"
msgstr ""
"Таким образом defun может быть реализован как макрос который превращает "
"первое выражение\n"
"во второе. Мы могли бы представить его следующим образом:@footnote{Для "
"ясности, эта\n"
"весрия игнорирует всю бухгалтерию, которую должен выполнять defun.}"

#: texi/node-08.texi:386
msgid ""
"@lisp\n"
"(defmacro our-defun (name parms &body body)\n"
"  `(progn\n"
"         (setf (symbol-function ',name)\n"
"                 #'(lambda ,parms (block ,name ,@@body)))\n"
"         ',name))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:389
msgid ""
"Macros like while and nil! could be described as general-purpose utilities.\n"
"Any Lisp program might use them. But particular domains can have their "
"utilities"
msgstr ""
"Макросы подобные while и nil! могут быть описаны как утилиты общего "
"назначения.\n"
"Любая программа Lisp может их использовать. Но определенные домены могут "
"иметь\n"
"свои утилиты"

#: texi/node-08.texi:399
msgid ""
"@lisp\n"
" (defun move-objs (objs dx dy)\n"
"       (multiple-value-bind (x0 y0 x1 y1) (bounds objs)\n"
"         (dolist (o objs)\n"
"            (incf (obj-x o) dx)\n"
"            (incf (obj-y o) dy))\n"
"         (multiple-value-bind (xa ya xb yb) (bounds objs)\n"
"            (redraw (min x0 xa) (min y0 ya)\n"
"                      (max x1 xb) (max y1 yb)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun move-objs (objs dx dy)\n"
"       (multiple-value-bind (x0 y0 x1 y1) (bounds objs)\n"
"         (dolist (o objs)\n"
"            (incf (obj-x o) dx)\n"
"            (incf (obj-y o) dy))\n"
"         (multiple-value-bind (xa ya xb yb) (bounds objs)\n"
"            (redraw (min x0 xa) (min y0 ya)\n"
"                      (max x1 xb) (max y1 yb)))))"

#: texi/node-08.texi:409
msgid ""
" (defun scale-objs (objs factor)\n"
"       (multiple-value-bind (x0 y0 x1 y1) (bounds objs)\n"
"         (dolist (o objs)\n"
"            (setf (obj-dx o) (* (obj-dx o) factor)\n"
"                   (obj-dy o) (* (obj-dy o) factor)))\n"
"         (multiple-value-bind (xa ya xb yb) (bounds objs)\n"
"            (redraw (min x0 xa) (min y0 ya)\n"
"                      (max x1 xb) (max y1 yb)))))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:411
msgid "                        Figure 8-1: Original move and scale."
msgstr ""
"                        Рисунок 8-1: Исходные move и scale.\n"
"@end cartouche"

#: texi/node-08.texi:417
msgid ""
"as well. There is no reason to suppose that base Lisp is the only level at "
"which\n"
"you have a programming language to extend. If you're writing a CAD program,\n"
"for example, the best results will sometimes come from writing it in two "
"layers: a\n"
"language (or if you prefer a more modest term, a toolkit) for CAD programs, "
"and\n"
"in the layer above, your particular application."
msgstr ""
"также. Нет оснований полагать, что базовый Lisp является единственным "
"уровнем,\n"
"на котором у вас есть язык программирования для расширений . Например, если "
"вы\n"
"пишете программу CAD, лучшие результаты иногда получаются при  написании ее "
"на\n"
"двух уровнях: языка (или, если вы предпочитаете более скромный термин,\n"
"инструментарий) для программ CAD, и в слоя выше, вашего конкретного "
"приложения."

#: texi/node-08.texi:427
msgid ""
"Lisp blurs many distinctions which other languages take for granted. In\n"
"other languages, there really are conceptual distinctions between compile-"
"time\n"
"and runtime, program and data, language and program. In Lisp, these "
"distinctions\n"
"exist only as conversational conventions. There is no line dividing, for "
"example,\n"
"language and program. You can draw the line wherever suits the problem at\n"
"hand. So it really is no more than a question of terminology whether to call "
"an\n"
"underlying layer of code a toolkit or a language. One advantage of "
"considering\n"
"it as a language is that it suggests you can extend this language, as you do "
"Lisp,\n"
"with utilities."
msgstr ""
"Lisp стирает множество различий, которые другие языки воспринимают как "
"должное.\n"
"В другоих языках действительно существует концептуальное различие между "
"временем\n"
"компиляции и временем выполнения, программой и данными, языком и программой. "
"В\n"
"Lisp эти различия существуют только как устные соглашения. В нем нет \n"
"разделительной линии, например, между языком и программой. Вы можете сами "
"нарисовать\n"
"разделительную линию соответствующую проблеме. Так что это не более чем "
"вопрос\n"
"терминологии, следует ли называть нижележащий слой кода инструментарием или "
"языком.\n"
"Одно преимущество рассмотрения его в качестве языка, предполагает, что вы "
"можете расширить\n"
"этот язык, как вы делаете это с Lisp-ом, создавая утилиты."

#: texi/node-08.texi:434
msgid ""
"Suppose we are writing an interactive 2D drawing program. For simplicity,\n"
"we will assume that the only objects handled by the program are line "
"segments,\n"
"represented as an origin  x,y  and a vector  dx,dy . One of the things such "
"a\n"
"program will have to do is slide groups of objects. This is the purpose of "
"the\n"
"function move-objs in Figure 8-1. For efficiency, we don't want to redraw "
"the\n"
"whole screen after each operation-only the parts which have changed. Hence"
msgstr ""
"Предположим, мы пишем интерактивную программу для 2D рисования. Для "
"простоты,\n"
"мы будем предполагать, что единственными объектами, обрабатываемыми "
"программой,\n"
"являются отрезки, представленные как начало x,y  и вектор смещения dx, dy. "
"Одна \n"
"из вещей, которую должна делать такая программа это слайд группы объектов. "
"Это\n"
"цель функции move-objs на Рисунке 8-1. Для эффективности мы не хотим "
"перерисовывать\n"
"весь экран после каждой операции - только те части, которые изменились. "
"Следовательно"

#: texi/node-08.texi:446
msgid ""
"@lisp\n"
" (defmacro with-redraw ((var objs) &body body)\n"
"       (let ((gob (gensym))\n"
"               (x0 (gensym)) (y0 (gensym))\n"
"               (x1 (gensym)) (y1 (gensym)))\n"
"         `(let ((,gob ,objs))\n"
"             (multiple-value-bind (,x0 ,y0 ,x1 ,y1) (bounds ,gob)\n"
"                (dolist (,var ,gob) ,@@body)\n"
"                (multiple-value-bind (xa ya xb yb) (bounds ,gob)\n"
"                      (redraw (min ,x0 xa) (min ,y0 ya)\n"
"                                (max ,x1 xb) (max ,y1 yb)))))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-redraw ((var objs) &body body)\n"
"       (let ((gob (gensym))\n"
"               (x0 (gensym)) (y0 (gensym))\n"
"               (x1 (gensym)) (y1 (gensym)))\n"
"         `(let ((,gob ,objs))\n"
"             (multiple-value-bind (,x0 ,y0 ,x1 ,y1) (bounds ,gob)\n"
"                (dolist (,var ,gob) ,@@body)\n"
"                (multiple-value-bind (xa ya xb yb) (bounds ,gob)\n"
"                      (redraw (min ,x0 xa) (min ,y0 ya)\n"
"                                (max ,x1 xb) (max ,y1 yb)))))))"

#: texi/node-08.texi:451
msgid ""
" (defun move-objs (objs dx dy)\n"
"       (with-redraw (o objs)\n"
"         (incf (obj-x o) dx)\n"
"         (incf (obj-y o) dy)))"
msgstr ""

#: texi/node-08.texi:457
msgid ""
" (defun scale-objs (objs factor)\n"
"       (with-redraw (o objs)\n"
"         (setf (obj-dx o) (* (obj-dx o) factor)\n"
"                      (obj-dy o) (* (obj-dy o) factor))))\n"
"@end lisp"
msgstr ""

#: texi/node-08.texi:459
msgid "                           Figure 8-2: Move and scale filleted."
msgstr ""
"                           Рисунок 8-2: Преобразованные move и scale.\n"
"@end cartouche"

#: texi/node-08.texi:465
msgid ""
"the two calls to the function bounds, which returns four coordinates (min x, "
"min\n"
"y, max x, max y) representing the bounding rectangle of a group of objects. "
"The\n"
"operative part of move-objs is sandwiched between two calls to bounds which\n"
"find the bounding rectangle before and then after the movement, and then "
"redraw\n"
"the entire affected region."
msgstr ""
"два вызова функции bounds, которая возвращает четыре координаты (min x, min "
"y, \n"
"max x, max y) представляют ограничивающий прямоугольник. Действующая часть\n"
"функции move-objs зажата между двумя вызовами bound, которые ищуют "
"ограничивающий\n"
"прямоугольник до и после выполнения перемещения, и затем "
"перерисовыем(redraw) весь\n"
"измененный регион."

#: texi/node-08.texi:471
msgid ""
"The function scale-objs is for changing the size of a group of objects.\n"
"Since the bounding region could grow or shrink depending on the scale "
"factor,\n"
"this function too must do its work between two calls to bounds. As we wrote\n"
"more of the program, we would see more of this pattern: in functions to "
"rotate,\n"
"flip, transpose, and so on."
msgstr ""
"Функция scale-objs предназначена для изменения размера группы объектов.\n"
"Поскольку ограничивающая область может увеличиваться или уменьшаться в "
"зависимости\n"
"от маштабирующего коэффициэнта, эта функция так же должна выполнять свою "
"работу\n"
"между двумя вызовами bounds. Если бы мы писали больше программ, мы бы "
"увидели больше\n"
"повторений этого шаблона: в функциях для поворота(rotate), "
"переворота(flip), \n"
"транспонирования(transpose), и так далее."

#: texi/node-08.texi:478
msgid ""
"With a macro we can abstract out the code that these functions would all "
"have\n"
"in common. The macro with-redraw in Figure 8-2 provides the skeleton that\n"
"the functions in Figure 8-1 share.@footnote{The definition of this macro "
"anticipates the next chapter by using gensyms. Their purpose will be "
"explained shortly.} As a result, they can now be defined in four\n"
"lines each, as at the end of Figure 8-2. With these two functions the new "
"macro\n"
"has already paid for itself in brevity. And how much clearer the two "
"functions  \n"
"become once the details of screen redrawing are abstracted away."
msgstr ""
"С помощью макроса, мы можем абстрагировать общий код, который имеют эти "
"функции.\n"
"Макрос with-redraw на Рисунке 8-2  предоставляет общий скелет функций "
"представленных\n"
"на Рисунке 8-1.@footnote{Определение этого макроса предвосхищает следующую "
"главу\n"
"использующу gensyms. Её назначение будет объяснено в ближайшее время.}. В "
"результате,\n"
"эти функции можно теперь определить в четыре строки, каждую, как в конце "
"рисунка 8-2. \n"
"С этими двумя функциями новый макрос уже окупил себя по краткости. И "
"насколько яснее\n"
"становяться две функции, когда мы абстрагируемся от деталей перерисовки "
"экрана, \n"
"скрываем их макросом."

#: texi/node-08.texi:484
msgid ""
"One way to view with-redraw is as a construct in a language for writing\n"
"interactive drawing programs. As we develop more such macros, they will come "
"to\n"
"resemble a programming language in fact as well as in name, and our "
"application\n"
"itself will begin to show the elegance one would expect in a program written "
"in a\n"
"language defined for its specific needs."
msgstr ""
"Один из способов посмотреть на with-redraw, рассматривать ее как "
"конструкцию\n"
"языка для написания интерактивных программ рисования. Поскольку мы "
"разрабатываем\n"
"много таких макросов, они будут напоминать язык программирования, как по "
"сути,\n"
"так и по названию, и само наше приложение начнет показывать элегантность, "
"которую\n"
"можно ожидать от программы, написанную на языке, определенном для этих "
"конкретных\n"
"потребностей."

#: texi/node-08.texi:491
msgid ""
"The other major use of macros is to implement embedded languages. Lisp\n"
"is an exceptionally good language in which to write programming languages,\n"
"because Lisp programs can be expressed as lists, and Lisp has a built-in "
"parser\n"
"(read) and compiler (compile) for programs so expressed. Most of the time "
"you\n"
"don't even have to call compile; you can have your embedded language "
"compiled\n"
"implicitly, by compiling the code which does the transformations (page 25)."
msgstr ""
"Другое основное использование макросов - реализация встроенных языков. Lisp\n"
"является исключительно хорошим языком для написания языков "
"программирования,\n"
"потому что программы на  Lisp могут быть выражены в виде списков, а  Lisp "
"имеет\n"
"встроенный парсер(читатель/read) и компилятор (compile) для программ "
"выраженных\n"
"таким образом. Большую часть времени вам даже не надо вызывать компиляцию; "
"Вы\n"
"можете скомпилировать встроенный язык неявно, путем компиляции кода, "
"который\n"
"выполняет преобразования (стр. 25)."

#: texi/node-08.texi:501
msgid ""
"An embedded language is one which is not written on top of Lisp so much\n"
"as commingled with it, so that the syntax is a mixture of Lisp and "
"constructs\n"
"specific to the new language. The naive way to implement an embedded "
"language\n"
"is to write an interpreter for it in Lisp. A better approach, when possible, "
"is\n"
"to implement the language by transformation: transform each expression into\n"
"the Lisp code that the interpreter would have run in order to evaluate it. "
"That's\n"
"where macros come in. The job of macros is precisely to transform one type\n"
"of expression into another, so they're the natural choice when writing "
"embedded\n"
"languages."
msgstr ""
"Встроенный язык, это язык написанный не столько поверх Lisp-а, сколько в\n"
"сочетании с ним, так что его синтаксис представляет собой смесь Lisp-а и\n"
"конструкций специфичных для нового языка. Наивный способ реализовать "
"встроенный\n"
"язык - это написать интерпретатор для него на Lisp-е. Лучший подход, когда "
"это\n"
"возможно, реализовать язык путем преобразований: преобразовывать каждое "
"выражение\n"
"в код Lisp, который интерпретатор должен был исполнить в порядке его "
"вычисления.\n"
"Это то место где используются макросы. Работа макросов состоит в том, чтобы "
"точно\n"
"преобразовать один тип выражений в другой, поэтому они являются естественным "
"выбором\n"
"при написании встроенных языков."

#: texi/node-08.texi:508
msgid ""
"In general, the more an embedded language can be implemented by transfor-\n"
"mation, the better. For one, it's less work. If the new language has "
"arithmetic,\n"
"for example, you needn't face all the complexities of representing and "
"manipu-\n"
"lating numeric quantities. If Lisp's arithmetic capabilities are sufficient "
"for your\n"
"purposes, then you can simply transform your arithmetic expressions into "
"the\n"
"equivalent Lisp ones, and leave the rest to the Lisp."
msgstr ""
"В целом, чем больше встроенный язык может быть реализован путем "
"преобразований,\n"
"тем лучше. С одной стороны, это уменьшает количество работы. Например, "
"если \n"
"новый язык имеет арифметику, вам не нужно сталкиваться со всеми сложностями\n"
"представления и манипулирования числовыми величинами. Если арифметические \n"
"возможности Lisp достаточны для ваших целей, то вы можете просто "
"преобразовать\n"
"свои арифметические выражения в эквивалентные выражения Lisp, а остальное \n"
"ставить Lisp-у."

#: texi/node-08.texi:521
msgid ""
"Using transformation will ordinarily make your embedded languages faster as\n"
"well. Interpreters have inherent disadvantages with respect to speed. When "
"code\n"
"occurs within a loop, for example, an interpreter will often have to do work "
"on each\n"
"iteration which in compiled code could have been done just once. An "
"embedded\n"
"language which has its own interpreter will therefore be slow,even if the "
"interpreter\n"
"itself is compiled. But if the expressions in the new language are "
"transformed into\n"
"Lisp, the resulting code can then be compiled by the Lisp compiler. A "
"language\n"
"so implemented need suffer none of the overheads of interpretation at "
"runtime.\n"
"Short of writing a true compiler for your language, macros will yield the "
"best\n"
"performance. In fact, the macros which transform the new language can be "
"seen\n"
"as a compiler for it-just one which relies on the existing Lisp compiler to "
"do\n"
"most of the work."
msgstr ""
"Также использование преобразований обычно делает встроенные языки быстрее. \n"
"Интерпретаторам присущи недостатки в отношении скорости.  Например, когда "
"код\n"
"исполняется в цикле, интерпретатору, часто, приходиться повторять работу по\n"
"преобразованию кода на каждой итерации, которая в скомпилированном коде "
"могла\n"
"быть выполнена только один раз. Поэтому, встроеный язык, который имеет "
"свой \n"
"собственный интерпретатор будет медленне, даже если интерпретатор сам "
"скомпилирован.\n"
"Но если выражения в новом языке превращаются в Lisp, полученный код может "
"быть\n"
"скомпилирован компилятором Lisp. Язык, реализованный таким образом, во время "
"выполнения\n"
"не страдает от накладных расходов на интерпретацию. Если не писать настоящий "
"компилятор\n"
"для вашего языка, макросы покажут лучшую скорость. Фактически, макросы "
"которые преобразуют\n"
"новый язык, можно рассматривать как компилятор для него - просто возлагающий "
"большую \n"
"часть работы на существующий компилятор Lisp."

#: texi/node-08.texi:526
msgid ""
"We won't consider any examples of embedded languages here, since Chap-\n"
"ters 19­25 are all devoted to the topic. Chapter 19 deals specifically with "
"the dif-\n"
"ference between interpreting and transforming embedded languages, and shows\n"
"the same language implemented by each of the two methods."
msgstr ""
"Мы не будем рассматривать примеры встроенных языков, так как глаы 19-­25 \n"
"целиком посвящены этой теме. Глава 19 конкретно рассматривает разницу между\n"
"интерпретацией и преобразованием встроенных языков и показывает один и тот "
"же\n"
"язык реализованный каждым из двух методов."

#: texi/node-08.texi:533
msgid ""
"One book on Common Lisp asserts that the scope for macros is limited, "
"citing\n"
"as evidence the fact that, of the operators defined in CLTL1, less than 10% "
"were\n"
"macros. This is like saying that since our house is made of bricks, our "
"furniture\n"
"will be too. The proportion of macros in a Common Lisp program will depend\n"
"entirely on what it's supposed to do. Some programs will contain no macros.\n"
"Some programs could be all macros."
msgstr ""
"Одна книга по Common Lisp утверждает что область применения макросов "
"ограничена,\n"
"ссылаясь в качестве доказательства на тот факкт, что из операторов "
"определенных в\n"
"CLTL1, менее 10% были макросами. Это все равно, что сказать, что поскольку "
"наш дом\n"
"сделан из кирпича, наша мебель должна быть сделана из него тоже. Доля "
"макросов в\n"
"программе Common Lisp будет зависеть полностью от того, что она должна "
"делать.\n"
"Некоторые программы не содержат макаросов, а некоторые программы целиком "
"могут быть\n"
"макросами."
