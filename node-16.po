#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-16.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-07-27 12:30+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-16.texi:5
msgid ""
"@node 16 Macro-Defining Macros, 17 Read-Macros, 15 Macros Returning "
"Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 16 Macro-Defining Macros\n"
"@cindex 16 Macro-Defining Macros"
msgstr ""
"@node 16 Macro-Defining Macros, 17 Read-Macros, 15 Macros Returning "
"Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 16 Макросы определяющие Макросы.\n"
"@cindex 16 Macro-Defining Macros"

#: texi/node-16.texi:12
msgid ""
"Patterns in code often signal the need for new abstractions. This rule holds "
"just as\n"
"much for the code in macros themselves. When several macros have "
"definitions\n"
"of a similar form, we may be able to write a macro-defining macro to "
"produce\n"
"them. This chapter presents three examples of macro-defining macros: one to\n"
"define abbreviations, one to define access macros, and a third to define "
"anaphoric\n"
"macros of the type described in Section 14-1."
msgstr ""
"Шаблоны в коде часто указывают на необходимость в новых абстракциях. Это "
"правило\n"
"выполняется так же, как для кода, так и для макросов. Когда несколько "
"макросов имеют\n"
"определения подобной формы, мы можем написать макрос для их "
"создания(генерации). \n"
"В этой главе представлены три примера макросов создающих макро-определения: "
"одно\n"
"для определения абревиатур, одно для определения макросов доступа, и третье "
"для\n"
"определения анафорических макросов, похожих на описанные в Разделе 14-1."

#: texi/node-16.texi:18
msgid ""
"@menu\n"
"* 16-1 Abbreviations::          \n"
"* 16-2 Properties::             \n"
"* Anaphoric Macros::            \n"
"@end menu"
msgstr ""

#: texi/node-16.texi:23
msgid ""
"@node 16-1 Abbreviations, 16-2 Properties, 16 Macro-Defining Macros, 16 "
"Macro-Defining Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 16-1 Abbreviations\n"
"@cindex 16-1 Abbreviations"
msgstr ""
"@node 16-1 Abbreviations, 16-2 Properties, 16 Macro-Defining Macros, 16 "
"Macro-Defining Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 16-1 Сокращения(Аббревиатуры)\n"
"@cindex 16-1 Abbreviations"

#: texi/node-16.texi:31
msgid ""
"The simplest use of macros is as abbreviations. Some Common Lisp operators\n"
"have rather long names. Ranking high among them (though by no means the\n"
"longest) is destructuring-bind, which has 18 characters. A corollary of  \n"
"Steele's principle (page 43) is that commonly used operators ought to have "
"short\n"
"names. (\"We think of addition as cheap partly because we can notate it with "
"a\n"
"single character: `+'.\") The built-in destructuring-bind macro introduces "
"a\n"
"new layer of abstraction, but the actual gain in brevity is masked by its "
"long name:"
msgstr ""
"Самое простое использование макросов - это сокращения. Некоторые операторы\n"
"Common Lisp имеют довольно длинные имена. Высокий рейтинг среди них (хотя ни "
"в коем\n"
"случе не самое длинное) у destructuring-bind, в котором 18 знаков. Следствие "
"из\n"
"принципа Стила(Steele's principle) (стр. 43) заключается в том, что часто "
"используемые\n"
"операторы должны иметь более короткие имена. (\"Мы думаем, что сложение "
"является\n"
"дешевой операцией, отчасти потому, что мы можем записать его одним знаком: `"
"+'.\") \n"
"Встроенный макрос destructuring-bind вводит новый уровень абстракции, но "
"фактический\n"
"выигрыш в краткости нивелируется его длинным именем:"

#: texi/node-16.texi:34
msgid ""
"@lisp\n"
"(let ((a (car x)) (b (cdr x))) ...)"
msgstr ""

#: texi/node-16.texi:37
msgid ""
"(destructuring-bind (a . b) x ...)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:41
msgid ""
"A program, like printed text, is easiest to read when it contains no more "
"than about\n"
"70 characters per line. We begin at a disadvantage when the lengths of "
"individual\n"
"names are a quarter of that."
msgstr ""
"Программу, также как и текст, легче всего читать, если она содержит не более "
"70 знаков\n"
"в строке. Мы с самого начала становимся в невыгодное положение, когда длина "
"отдельных\n"
"имен составляет четверть этой величины."

#: texi/node-16.texi:46
msgid ""
"@lisp\n"
" (defmacro abbrev (short long)\n"
"       `(defmacro ,short (&rest args)\n"
"           `(,',long ,@@args)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro abbrev (short long)\n"
"       `(defmacro ,short (&rest args)\n"
"           `(,',long ,@@args)))"

#: texi/node-16.texi:53
msgid ""
" (defmacro abbrevs (&rest names)\n"
"       `(progn\n"
"           ,@@(mapcar #'(lambda (pair)\n"
"                               `(abbrev ,@@pair))\n"
"                         (group names 2))))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:55
msgid "                  Figure 16-1: Automatic definition of abbreviations."
msgstr ""
"                  Рисунок 16-1: Автоматическое определение сокращений.\n"
"@end cartouche"

#: texi/node-16.texi:59
msgid ""
"Fortunately, in a language like Lisp you don't have to live with all the "
"decisions\n"
"of the designers. Having defined"
msgstr ""
"К счастью, в таком языке как Lisp, вам не нужно жить со всеми этими "
"решениями разработчиков.\n"
"Имея определение"

#: texi/node-16.texi:64
msgid ""
"@lisp\n"
"(defmacro dbind (&rest args)\n"
"  `(destructuring-bind ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:68
msgid ""
"@noindent\n"
"you need never use the long name again. Likewise for multiple-value-bind,\n"
"which is longer and more frequently used."
msgstr ""
"@noindent\n"
"вам больше никогда не будет нужно снова использовать длинное имя. "
"Аналогично\n"
"для multiple-value-bind, которое длиннее и чаще используется."

#: texi/node-16.texi:73
msgid ""
"@lisp\n"
"(defmacro mvbind (&rest args)\n"
"  `(multiple-value-bind ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:80
msgid ""
"Notice how nearly identical are the definitions of dbind and\n"
"mvbind. Indeed, this formula of &rest and comma-at will suffice to\n"
"define an abbreviation for any function,@footnote{Though the\n"
"abbreviation can't be passed to apply or funcall.} macro, or special\n"
"form. Why crank out more definitions on the model of mvbind when we\n"
"could have a macro do it for us?"
msgstr ""
"Обратите внимание, насколько близки определения dbind и mvbind. \n"
"В самом деле, этой формулы &rest и запятая с собакой(,@@) будет достаточно,\n"
"для того чтобы определить макрос сокращения(аббривиатуру) для любой "
"функции,\n"
"@footnote{Хотя аббревиатуру нельзя передать в apply или funcall.}, или \n"
"специальной формы. Зачем делать много определений по модели mvbind, когда\n"
"у нас есть макросы, которые мы можем использовать?"

#: texi/node-16.texi:88
msgid ""
"To define a macro-defining macro we will often need nested backquotes.\n"
"Nested backquotes are notoriously hard to understand. Eventually common "
"cases\n"
"will become familiar, but one should not expect to be able to look at an "
"arbitrary\n"
"backquoted expression and say what it will yield. It is not a fault in Lisp "
"that\n"
"this is so, any more than it is a fault of the notation that one can't just "
"look at\n"
"a complicated integral and know what its value will be. The difficulty is in "
"the\n"
"problem, not the notation."
msgstr ""
"Чтобы определить макрос определяющий макрос, нам часто нужны вложенные "
"обратные\n"
"кавычки. Вложенные обратные кавычки, как известно, трудно понять. В конце "
"концов\n"
"с общим случаем мы разберемся, но не стоит ожидать, что мы взглянув на "
"произвольное\n"
"выражение в обратных кавычках скажем, что оно выдает. Это не ошибка в Lisp, "
"что это\n"
"невозможно, и не ошибка в обозначениях, на которые нельзя просто посмотреть, "
"подобно,\n"
"сложному интегралу, и сказать, какое значение он имеет.  Трудность "
"заключается в\n"
"самой проблеме, а не в обозначениях."

#: texi/node-16.texi:93
msgid ""
"However, as we do when finding integrals, we can break up the analysis of\n"
"backquotes into small steps, each of which can easily be followed. Suppose "
"we\n"
"want to write a macro abbrev, which will allow us to define mvbind just by\n"
"saying"
msgstr ""
"Однако, как и при поиске интеграла, мы можем разбить анализ обратных "
"кавычек\n"
"на маленькие шаги, каждый из которых можно легко проследить. Предположим, "
"мы\n"
"хотим написать макрос abbrev, который позволит нам определить mvbind просто\n"
"сказав"

#: texi/node-16.texi:97
msgid ""
"@lisp\n"
"(abbrev mvbind multiple-value-bind)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:101
msgid ""
"Figure 16-1 contains a definition of this macro. Where did it come from? "
"The\n"
"definition of such a macro can be derived from a sample expansion. One "
"expansion\n"
"is:"
msgstr ""
"Рисунок 16-1 содержит определение этого макроса. Как мы его получили? "
"Определение\n"
"такого макроса может быть получено из примера расширения. Одним из его\n"
"расширений является:"

#: texi/node-16.texi:106
msgid ""
"@lisp\n"
"(defmacro mvbind (&rest args)\n"
"       `(multiple-value-bind ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:110
msgid ""
"The derivation will be easier if we pull multiple-value-bind from within "
"the\n"
"backquote, because we know it will be an argument to the eventual macro. "
"This\n"
"yields the equivalent definition"
msgstr ""
"Понять происхождение будет проще, если мы вынем multiple-value-bind из "
"обратных\n"
"кавычек, поскольку мы знаем что оно будет аргументом для возможного макроса. "
"Это\n"
"дает нам эквивалентное определение"

#: texi/node-16.texi:116
msgid ""
"@lisp\n"
"(defmacro mvbind (&rest args)\n"
"       (let ((name 'multiple-value-bind))\n"
"        `(,name ,@@args)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:119
msgid ""
"Now we take this expression and turn it into a template. We affix a "
"backquote,\n"
"and replace the expressions which will vary, with variables."
msgstr ""
"Теперь мы берем это выражение и превращаем его в шаблон. Мы добавляем к "
"нему\n"
"обратную кавычку и заменяем выражения, которые будут изменяться, на "
"переменные."

#: texi/node-16.texi:125
msgid ""
"@lisp\n"
"`(defmacro ,short (&rest args)\n"
"        (let ((name ',long))\n"
"         `(,name ,@@args)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:128
msgid ""
"The final step is to simplify this expression by substituting ',long for "
"name within\n"
"the inner backquote:"
msgstr ""
"Последний шаг состоит в том, чтобы упростить это выражение путем "
"замены(подстановки)\n"
"вместо name поставить ',long внутри выражения с обратной кавычкой:"

#: texi/node-16.texi:133
msgid ""
"@lisp\n"
"`(defmacro ,short (&rest args)\n"
"        `(,',long ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:135
msgid "which yields the body of the macro defined in Figure 16-1."
msgstr "который и даст нам тело макроса определенного на Рисунке 16-1."

#: texi/node-16.texi:138
msgid ""
"Figure 16-1 also contains abbrevs, for cases where we want to define "
"several\n"
"abbreviations in one shot."
msgstr ""
"Рисунок 16-1 также содержит abbrevs, для случаев, когда мы хотим "
"определить \n"
"несколько сокращений за один раз."

#: texi/node-16.texi:144
msgid ""
"@lisp\n"
"(abbrevs dbind destructuring-bind\n"
"              mvbind multiple-value-bind\n"
"              mvsetq multiple-value-setq)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:149
msgid ""
"The user of abbrevs doesn't have to insert additional parentheses because\n"
"abbrevs calls group (page 47) to group its arguments by twos. It's gener-\n"
"ally a good thing for macros to save users from typing logically "
"unnecessary\n"
"parentheses, and group will be useful to most such macros."
msgstr ""
"Пользователь abbrevs не должен вставлять дополнительные скобки, потому что\n"
"abbrevs вызывает group (стр. 47) для группировки аргументов по два. Это\n"
"вообще хорошая вещь для макросов - избавить пользователей от логически "
"ненужного\n"
"ввода скобок и group будет полезна для большинства таких макросов."

#: texi/node-16.texi:154
msgid ""
"@lisp\n"
" (defmacro propmacro (propname)\n"
"       `(defmacro ,propname (obj)\n"
"           `(get ,obj ',',propname)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro propmacro (propname)\n"
"       `(defmacro ,propname (obj)\n"
"           `(get ,obj ',',propname)))"

#: texi/node-16.texi:160
msgid ""
" (defmacro propmacros (&rest props)\n"
"       `(progn\n"
"           ,@@(mapcar #'(lambda (p) `(propmacro ,p))\n"
"                         props)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:162
msgid "                   Figure 16-2: Automatic definition of access macros."
msgstr ""
"                   Рисунок 16-2: Автоматическое определение макросов "
"доступа.\n"
"@end cartouche"

#: texi/node-16.texi:167
msgid ""
"@node 16-2 Properties, Anaphoric Macros, 16-1 Abbreviations, 16 Macro-"
"Defining Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 16-2 Properties\n"
"@cindex 16-2 Properties"
msgstr ""
"@node 16-2 Properties, Anaphoric Macros, 16-1 Abbreviations, 16 Macro-"
"Defining Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 16-2 Свойства\n"
"@cindex 16-2 Properties"

#: texi/node-16.texi:172
msgid ""
"Lisp offers many ways to associate properties with objects. If the object in "
"question\n"
"can be represented as a symbol, one of the most convenient (though least "
"efficient)\n"
"ways is to use the symbol's property list. To describe the fact that an "
"object o has\n"
"a property p, the value of which is v, we modify the property list of o:"
msgstr ""
"Lisp предлагает множество способов связать свойства с объектами. Если "
"рассматриваемый\n"
"объект может быть представлен как символ, один из самых удобных(хотя и "
"наименее \n"
"эффективных) способов, заключается в использовании списка свойств символа. \n"
"Чтобы описать тот факт, что объект o имеет свойство p, значение которого "
"равно v, \n"
"мы модифицируем список свойств o:"

#: texi/node-16.texi:176
msgid ""
"@lisp\n"
"(setf (get op) v)\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(setf (get o p) v)\n"
"@end lisp"

#: texi/node-16.texi:178
msgid "So to say that ball1 has color red, we say:"
msgstr ""
"Итак, чтобы сказать что ball1 имеет красный(red/значение) цвет(color/"
"свойство),\n"
"мы говорим:"

#: texi/node-16.texi:182
msgid ""
"@lisp\n"
"(setf (get 'ball1 'color) 'red)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:185
msgid ""
"If we're going to refer often to some property of objects, we can define a "
"macro\n"
"to retrieve it:"
msgstr ""
"Если мы будем часто ссылаться на некоторые свойства объектов, мы можем "
"определить\n"
"макрос, чтобы получать их:"

#: texi/node-16.texi:190
msgid ""
"@lisp\n"
"(defmacro color (obj)\n"
"   `(get ,obj 'color))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:192
msgid "and thereafter use color in place of get:"
msgstr "и затем использовать color вместо get:"

#: texi/node-16.texi:198
msgid ""
"@example\n"
"> (color 'ball1)\n"
"RED\n"
"@end example"
msgstr ""

#: texi/node-16.texi:200
msgid ""
"Since macro calls are transparent to setf (see Chapter 12) we can also say:"
msgstr ""
"Поскольку вызовы макросов прозрачны для setf (см. Главу 12) мы также можем \n"
"сказать:"

#: texi/node-16.texi:206
msgid ""
"@example\n"
"> (setf (color 'ball1) 'green)\n"
"GREEN\n"
"@end example"
msgstr ""

#: texi/node-16.texi:216
msgid ""
"Such macros have the advantage of hiding the particular way in which the\n"
"program represents the color of an object. Property lists are slow; a later "
"version\n"
"of the program might, for the sake of speed, represent color as a field in "
"a\n"
"structure, or an entry in a hash-table. When data is reached through a "
"facade of\n"
"macros like color, it becomes easy, even in a comparatively mature program,\n"
"to make pervasive changes to the lowest-level code. If a program switches "
"from\n"
"using property lists to structures, nothing above the facade of access "
"macros will\n"
"have to be changed; none of the code which looks upon the facade need even "
"be\n"
"aware of the rebuilding going on behind it."
msgstr ""
"Такие макросы имеют преимущество в том, что скрывают конкретный способ, "
"которым\n"
"программа представляет цвет(color) объекта. Списки свойств медленные: "
"дальнейшие\n"
"версии программы могут, для увеличения скорости, представлять свойства, "
"такие как\n"
"цвет(color) как поле в структуре, или как запись в хеш-таблице. Когда для "
"получения\n"
"данных используется фасад макроса, такого как color, становиться легким, "
"даже в\n"
"сравнительно зрелой программе, изменять код самого низкого уровня. Если "
"программа\n"
"переключается с использования списков свойств, на использование структур, "
"ничто не\n"
"выходит за рамки необходимости изменения макросов доступа; никакой код "
"который\n"
"видит только фасад, не должен знать о перестройке, происходящей за ним."

#: texi/node-16.texi:219
msgid ""
"For the weight property, we can define a macro similar to the one written "
"for\n"
"color:"
msgstr ""
"Для свойства weight мы можем определить макрос, аналогичный написанному для\n"
"color:"

#: texi/node-16.texi:224
msgid ""
"@lisp\n"
"(defmacro weight (obj)\n"
"  `(get ,obj 'weight))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:228
msgid ""
"Like the abbreviations in the previous section, the definitions of of color "
"and\n"
"weight are nearly identical. Here propmacro (Figure 16-2) can play the same\n"
"role as abbrev did."
msgstr ""
"Подобно сокращениям в предыдущем разделе, определения color и weight почти\n"
"одинаковы. Здесь propmacro (Рисунок 16-2) может играть ту же роль, что и\n"
"abbrev выше."

#: texi/node-16.texi:232
msgid ""
"A macro-defining macro can be designed by the same process as any other\n"
"macro: look at the macro call, then its intended expansion, then figure out "
"how to\n"
"transform the former into the latter. We want"
msgstr ""
"Макрос определяющий макросы может быть разработан тем же процессом, что и "
"любой другой\n"
"макрос: смотрим на вызов макроса, затем на его предполагаемое расширение, "
"затем выясняем\n"
"как превратить первое во второе. Мы хотим"

#: texi/node-16.texi:236
msgid ""
"@lisp\n"
"(propmacro color)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:238
msgid "to expand into"
msgstr "расширить в"

#: texi/node-16.texi:243
msgid ""
"@lisp\n"
"(defmacro color (obj)\n"
"  `(get ,obj 'color))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:248
msgid ""
"Though this expression is itself a defmacro, we can still make a template of "
"it,\n"
"by backquoting it and putting comma'd parameter names in place of instances\n"
"of color. As in the previous section, we begin by transforming it so that "
"no\n"
"instances of color are within existing backquotes:"
msgstr ""
"Хотя это выражение само по себе является определением макроса defmacro, мы "
"все же\n"
"можем создать его из шаблона, заключив его в обратные кавычки и поместив "
"перед\n"
"именами параметров запятую вместо экземпляра color. Как и в предыдущем "
"разделе,\n"
"мы начинаем с преобразования его таким образом, чтобы вынести все "
"экземпляры\n"
"color из под обратных кавычек:"

#: texi/node-16.texi:254
msgid ""
"@lisp\n"
"(defmacro color (obj)\n"
"  (let ((p 'color))\n"
"        `(get ,obj ',p)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:256
msgid "Then we go ahead and make the template,"
msgstr "Теперь мы идем вперед и делаем шаблон,"

#: texi/node-16.texi:262
msgid ""
"@lisp\n"
"`(defmacro ,propname (obj)\n"
"    (let ((p ',propname))\n"
"          `(get ,obj ',p)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:264
msgid ""
"which simplifies "
"to                                                                    "
msgstr ""
"который упрощается "
"до                                                                   "

#: texi/node-16.texi:269
msgid ""
"@lisp\n"
"`(defmacro ,propname (obj)\n"
"       `(get ,obj ',',propname))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:274
msgid ""
"For cases where a group of property-names all have to be defined as macros,\n"
"there is propmacros (Figure 16-2), which expands into a series of "
"individual\n"
"calls to propmacro. Like abbrevs, this modest piece of code is actually a\n"
"macro-defining-macro-defining macro."
msgstr ""
"Для случаев, когда вся группа  имен свойств должна быть определена как "
"макросы,\n"
"есть propmacros (Рисунок 16-2), который расширяется в ряд индивидуальных "
"вызовов\n"
"propmacro. Подобно abbrevs, этот скромный кусочек кода на самом деле "
"является\n"
"макросом определяющим макросы определяющие макросы(macro-defining-macro-"
"defining)."

#: texi/node-16.texi:277
msgid ""
"Though this section dealt with property lists, the technique described here "
"is a\n"
"general one. We could use it to define access macros on data stored in any "
"form."
msgstr ""
"Хотя в этом разделе рассматриваются списки свойств, техника описанная здесь "
"является\n"
"общей. Мы могли бы использовать её для определения макросов доступа к "
"данным, хранящимся\n"
"в любой форме."

#: texi/node-16.texi:282
msgid ""
"@node Anaphoric Macros,  , 16-2 Properties, 16 Macro-Defining Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 16-3 Anaphoric Macros\n"
"@cindex 16-3 Anaphoric Macros"
msgstr ""
"@node Anaphoric Macros,  , 16-2 Properties, 16 Macro-Defining Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 16-3 Анафорные Макросы\n"
"@cindex 16-3 Anaphoric Macros"

#: texi/node-16.texi:286
msgid ""
"Section 14-1 gave definitions of several anaphoric macros. When you use a "
"macro\n"
"like aif or aand, during the evaluation of some arguments the symbol it will "
"be\n"
"bound to the values returned by other ones. So instead of"
msgstr ""
"Раздел 14-1 дал определения нескольких анафорических макросов. когда вы "
"используете\n"
"макрос, подобные  aif или aand, при вычислении некоторых аргументов символ "
"it будет\n"
"привязан к значению возвращаемому одним из предыдущих выражений. Так что "
"вместо"

#: texi/node-16.texi:292
msgid ""
"@lisp\n"
"(let ((res (complicated-query)))\n"
"  (if res\n"
"           (foo res)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:295
msgid ""
"@noindent\n"
"you can use just"
msgstr ""
"@noindent\n"
"вы можете использовать просто"

#: texi/node-16.texi:300
msgid ""
"@lisp\n"
"(aif (complicated-query)\n"
"         (foo it))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:303
msgid ""
"@noindent\n"
"and instead of"
msgstr ""
"@noindent\n"
"и вместо"

#: texi/node-16.texi:309
msgid ""
"@lisp\n"
"(let ((o (owner x)))\n"
"  (and o (let ((a (address o)))\n"
"                  (and a (city a)))))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:312
msgid ""
"@noindent\n"
"simply"
msgstr ""
"@noindent\n"
"просто"

#: texi/node-16.texi:316
msgid ""
"@lisp\n"
"(aand (owner x) (address it) (city it))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:322
msgid ""
"Section 14-1 presented seven anaphoric macros: aif, awhen, awhile, acond,\n"
"alambda, ablock, and aand. These seven are by no means the only useful\n"
"anaphoric macros of their type. In fact, we can define an anaphoric variant "
"of just\n"
"about any Common Lisp function or macro. Many of these macros will be like\n"
"mapcon: rarely used, but indispensable when they are needed."
msgstr ""
"В разделе 14-1 представлены семь анафорических макросов: aif, awhen, awhile, "
"acond,\n"
"alambda, ablock, и aand. Эти семь ни в коем случае не являются единственными "
"полезными\n"
"анафорическими макросами этого типа. На самом деле, мы можем определить "
"анафорический\n"
"вариант любой функции или макроса Common Lisp. Многие из этих макросов будут "
"похожи\n"
"на mapcon: редко используемыми, но незаменимыми при необходимости."

#: texi/node-16.texi:326
msgid ""
"For example, we can define a+ so that, as with aand, it is always bound to\n"
"the value returned by the previous argument. The following function "
"calculates\n"
"the cost of dining out in Massachusetts:"
msgstr ""
"Например, мы можем определить a+ так, чтобы и с aand, it всегда был связан "
"со\n"
"значением, возвращаемым предыдущим аргументом.  Следующая функция "
"рассчитывает\n"
"стоимость обедов в Массачусетсе:"

#: texi/node-16.texi:330
msgid ""
"@lisp\n"
" (defmacro a+ (&rest args)\n"
"    (a+expand args nil))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro a+ (&rest args)\n"
"    (a+expand args nil))"

#: texi/node-16.texi:339
msgid ""
" (defun a+expand (args syms)\n"
"    (if args\n"
"         (let ((sym (gensym)))\n"
"            `(let* ((,sym ,(car args))\n"
"                         (it ,sym))\n"
"                ,(a+expand (cdr args)\n"
"                                 (append syms (list sym)))))\n"
"         `(+ ,@@syms)))"
msgstr ""

#: texi/node-16.texi:342
msgid ""
" (defmacro alist (&rest args)\n"
"    (alist-expand args nil))"
msgstr ""

#: texi/node-16.texi:352
msgid ""
" (defun alist-expand (args syms)\n"
"    (if args\n"
"         (let ((sym (gensym)))\n"
"            `(let* ((,sym ,(car args))\n"
"                         (it ,sym))\n"
"                ,(alist-expand (cdr args)\n"
"                                 (append syms (list sym)))))\n"
"         `(list ,@@syms)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:354
msgid "                   Figure 16-3: Definitions of a+ and alist."
msgstr ""
"                   Рисунок 16-3: Определение a+ и alist.\n"
"@end cartouche"

#: texi/node-16.texi:360
msgid ""
"@lisp\n"
"(defun mass-cost (menu-price)\n"
"  (a+ menu-price (* it .05) (* it 3)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:364
msgid ""
"The Massachusetts Meals Tax is 5%, and residents often calculate the tip by\n"
"tripling the tax. By this formula, the total cost of the broiled scrod at "
"Dolphin\n"
"Seafood is therefore:"
msgstr ""
"Налог на еду в Массачусетсе составляет 5%, и жители часто расчитывают "
"утроенный\n"
"налог. По этой формуле, общая стоимость жареных морепродуктов от Dolphin\n"
"Seafood будет:"

#: texi/node-16.texi:370
msgid ""
"@example\n"
"> (mass-cost 7-95)\n"
"9-54\n"
"@end example"
msgstr ""

#: texi/node-16.texi:372
msgid "but this includes salad and a baked potato."
msgstr "но это включает в себя салат и печный картофель."

#: texi/node-16.texi:377
msgid ""
"The macro a+,defined in Figure 16-3,relies on a recursive function,a"
"+expand,\n"
"to generate its expansion. The general strategy of a+expand is to cdr down "
"the\n"
"list of arguments in the macro call, generating a series of nested let "
"expressions;\n"
"each let leaves it bound to a different argument, but also binds a distinct "
"gensym"
msgstr ""
"Макрос a+, определенный на Рисунке 16-3, основан на рекурсивной функции  a"
"+expand,\n"
"генерирующей его расширение. Общая стратегия  a+expand состоит в том, чтобы "
"остаток\n"
"списка(cdr) передавался как аргумент в вызов макроса, генерируя "
"последовательность\n"
"вложенных выражений let; каждый let оставляет it связанным с другим "
"аргументов, но\n"
"также связывает определенный gensym"

#: texi/node-16.texi:383
msgid ""
"@lisp\n"
" (defmacro defanaph (name &optional calls)\n"
"        (let ((calls (or calls (pop-symbol name))))\n"
"         `(defmacro ,name (&rest args)\n"
"             (anaphex args (list ',calls)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro defanaph (name &optional calls)\n"
"        (let ((calls (or calls (pop-symbol name))))\n"
"         `(defmacro ,name (&rest args)\n"
"             (anaphex args (list ',calls)))))"

#: texi/node-16.texi:392
msgid ""
" (defun anaphex (args expr)\n"
"       (if args\n"
"            (let ((sym (gensym)))\n"
"               `(let* ((,sym ,(car args))\n"
"                         (it ,sym))\n"
"                   ,(anaphex (cdr args)\n"
"                                (append expr (list sym)))))\n"
"            expr))"
msgstr ""

#: texi/node-16.texi:396
msgid ""
" (defun pop-symbol (sym)\n"
"       (intern (subseq (symbol-name sym) 1)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:398
msgid "               Figure 16-4: Automatic definition of anaphoric macros."
msgstr ""
"               Рисунок 16-4: Автоматическое определение анафорических "
"макросов.\n"
"@end cartouche"

#: texi/node-16.texi:403
msgid ""
"to each argument. The expansion function accumulates a list of these "
"gensyms,\n"
"and when it reaches the end of the list of arguments it returns a + "
"expression with\n"
"the gensyms as the arguments. So the expression"
msgstr ""
"с каждым аргументом. Функция расширения накапливает список этих gensyms, и "
"когда он\n"
"достигает конца списка аргументов, она возвращает выражение + с gensyms в "
"качестве\n"
"аргументов. Итак, выражение"

#: texi/node-16.texi:407
msgid ""
"@lisp\n"
"(a+ menu-price (* it .05) (* it 3))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:409
msgid "yields the macroexpansion:"
msgstr "дает расширение макроса:"

#: texi/node-16.texi:416
msgid ""
"@lisp\n"
"(let* ((#:g2 menu-price) (it #:g2))\n"
"  (let* ((#:g3 (* it 0-05)) (it #:g3))\n"
"        (let* ((#:g4 (* it 3)) (it #:g4))\n"
"           (+ #:g2 #:g3 #:g4))))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:418
msgid "       Figure 16-3 also contains the definition of the analogous alist:"
msgstr "       Рисунок 16-3 также содержит аналогичное определение alist:"

#: texi/node-16.texi:424
msgid ""
"@example\n"
"> (alist 1 (+ 2 it) (+ 2 it))\n"
"(135)\n"
"@end example"
msgstr ""
"@example\n"
"> (alist 1 (+ 2 it) (+ 2 it))\n"
"(1 3 5)\n"
"@end example"

#: texi/node-16.texi:429
msgid ""
"Once again, the definitions of a+ and alist are almost identical. If we "
"want\n"
"to define more macros like them, these too will be mostly duplicate code. "
"Why\n"
"not have a program produce it for us? The macro defanaph in Figure 16-4 "
"will\n"
"do so. With defanaph, defining a+ and alist is as simple as"
msgstr ""
"Еща раз, определения a+ и alist почти идентичны. Если мы хотим, определить "
"больше\n"
"макросов подобных этим, они также будут в основном дублировать их код. "
"Зачем?\n"
"Разве у нас нет программ для их создания? Макрос defanaph на Рисунке 16-4 "
"будет\n"
"это делать. С defanaph, определение a+ и alist также просто как"

#: texi/node-16.texi:434
msgid ""
"@lisp\n"
"(defanaph a+)\n"
"(defanaph alist)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:442
msgid ""
"The expansions of a+ and alist so defined will be identical to the "
"expansions\n"
"made by the code in Figure 16-3. The macro-defining macro defanaph will "
"create\n"
"an anaphoric variant of anything whose arguments are evaluated according to "
"the\n"
"normal evaluation rule for functions. That is, defanaph will work for "
"anything\n"
"whose arguments are all evaluated, and evaluated left-to-right. So you "
"couldn't\n"
"use this version of defanaph to define aif or awhile, but you can use it to "
"define\n"
"an anaphoric variant of any function."
msgstr ""
"Расширения a+ и alist определенные таким образом, будут идентичны "
"расширениям\n"
"сделанным с помощью кода на Рисунке 16-3. Макрос defanaph создающий макро \n"
"определение создаст анафорический вариант чего-либо, чьи аргументы "
"вычисляются\n"
"в соответствии с обычным правилом вычисления для функций. То есть, defanaph "
"будет\n"
"работать на чем угодно, чьи аргументы все вычисляются и вычисляются с лева "
"на \n"
"право. Так что вы не можете использовать эту версию defanaph для "
"определения\n"
"aif или awhile, но вы можете использовать ее для определения анафорного "
"варианта\n"
"любой функции."

#: texi/node-16.texi:447
msgid ""
"    As a+ called a+expand to generate its expansion, defanaph defines a "
"macro\n"
"which will call anaphex to do so. The generic expander anaphex differs from\n"
"a+expand only in taking as an argument the function name to appear finally "
"in\n"
"the expansion. In fact, a+ could now be defined:"
msgstr ""
"    Как a+ вызывает a+expand для создания своего расширения, defanaph "
"определяет\n"
"макрос, который вызовет anaphex что бы сделать тоже самое. Общий "
"расширитель \n"
"anaphex отличается от a+expand только получением как аргумента имени "
"функции,\n"
"которое должно появиться в конце расширения. Фактически, a+ теперь можно\n"
"определить:"

#: texi/node-16.texi:452
msgid ""
"@lisp\n"
"(defmacro a+ (&rest args)\n"
"  (anaphex args '(+)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:457
msgid ""
"Neither anaphex nor a+expand need have been defined as distinct functions:\n"
"anaphex could have been defined with labels or alambda within defanaph.\n"
"The expansion generators are here broken out as separate functions only for "
"the\n"
"sake of clarity."
msgstr ""
"Ни для anaphex, ни для a+expand нет необходимости в определении их как "
"отдельных\n"
"функций: anaphex мог быть определен с помощью labels или alambda внутри "
"defanaph.\n"
"Генераторы расширения здесь разбиты на отдельные функции только лишь для "
"ясности."

#: texi/node-16.texi:463
msgid ""
"By default, defanaph determines what to call in the expansion by pulling "
"the\n"
"first letter (presumably an a) from the front of its argument. (This "
"operation is\n"
"performed by pop-symbol.) If the user prefers to specify an alternate name, "
"it\n"
"can be given as an optional argument. Although defanaph can build anaphoric\n"
"variants of all functions and some macros, it imposes some irksome "
"restrictions:"
msgstr ""
"По умолчанию, defanaph определяет, что вызывать при расширении откинув "
"первую\n"
"букву (предположительно a(анафор)) из своего первого аргумента. (Эту "
"операцию\n"
"выполняет pop-symbol.) Если пользователь предпочитает указать "
"альтернативное\n"
"имя, он может быть передан в качестве необязательного аргумента. Хотя "
"defanaph\n"
"может может создавать анафорические варианты всех функций и некоторых "
"макросов,\n"
"он накладывает некоторые досадные ограничения:"

#: texi/node-16.texi:475
msgid ""
"@enumerate\n"
"@item\n"
"It only works for operators whose arguments are all evaluated.\n"
"@item\n"
"In the macroexpansion, it is always bound to successive arguments. In\n"
"some cases-awhen, for example-we want it to stay bound to the value\n"
"of the first argument.\n"
"@item\n"
"It won't work for a macro like setf, which expects a generalized variable\n"
"as its first argument.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Он работает только для операторов, все аргументы которых вычисляются.\n"
"@item\n"
"В разложении макроса it всегда связывается с последовательными аргументами. "
"А в\n"
"некоторых случаях - например в awhen - мы хотим, чтобы it оставалось "
"связанным\n"
"со значением первого аргумента.\n"
"@item\n"
"Он не будет работать для такого макроса как setf, который ожидает "
"обобщенную\n"
"переменную в качестве первого аргумента.\n"
"@end enumerate"

#: texi/node-16.texi:480
msgid ""
"Let's consider how to remove some of these restrictions. Part of the first "
"problem\n"
"can be solved by solving the second. To generate expansions for a macro like "
"aif,\n"
"we need a modified version of anaphex which only replaces the first argument "
"in\n"
"the macro call:"
msgstr ""
"Давайте рассмотрим, как снять некоторые из этих ограничений. Часть первой "
"проблемы\n"
"может быть решена путем решения второй. Чтобы создать расширение для макроса "
"подобного\n"
"aif нам нужна модифицированная версяи anaphex, которая заменяет только "
"первый аргумент\n"
"в вызове макроса:"

#: texi/node-16.texi:486
msgid ""
"@lisp\n"
"(defun anaphex2 (op args)\n"
"  `(let ((it ,(car args)))\n"
"        (,op it ,@@(cdr args))))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:492
msgid ""
"This nonrecursive version of anaphex doesn't need to ensure that the "
"macroex-\n"
"pansion will bind it to successive arguments, so it can generate an "
"expansion\n"
"which won't necessarily evaluate all the arguments in the macro call. Only "
"the\n"
"first argument must be evaluated, in order to bind it to its value. So aif "
"could\n"
"be defined as:"
msgstr ""
"Эта не рекурсивная версия anaphex не должна гарантировать, что разложение "
"макроса\n"
"будет связывать it с результатами вычисления последовательных аргументов "
"макроса,\n"
"чтобы он мог генерировать расширение, которое не обязательно вычисляет все "
"аргументы\n"
"указванные в вызове макроса. Только первый аргумент должен быть вычислен, "
"чтобы \n"
"связать it с его значением. Так aif может быть определен как:"

#: texi/node-16.texi:497
msgid ""
"@lisp\n"
"(defmacro aif (&rest args)\n"
"       (anaphex2 'if args))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:501
msgid ""
"This definition would differ from the original on page 191 only in the point "
"where\n"
"it would complain if aif were given the wrong number of arguments; for "
"correct\n"
"macro calls, the two generate identical expansions."
msgstr ""
"Это определение будет отличаться от оригинала на странице 191 только в том "
"месте\n"
"где оно будет выдавать жалобу, если в aif будет переадано неправильное "
"количество\n"
"аргументов; для корректного вызова макроса, эти два определения создают "
"идентичные\n"
"расширения."

#: texi/node-16.texi:505
msgid ""
"The third problem, that defanaph won't work with generalized variables, can\n"
"be solved by using f (page 173) in the expansion. Operators like setf can "
"be\n"
"handled by a variant of anaphex2 defined as follows:"
msgstr ""
"Третья проблема, которая заключается в том, что defanaph не будет работать "
"с\n"
"обобщенными переменными, может быть решена с помощью использования в "
"расширении\n"
"функции _f (стр. 173). Операторы, такие как setf, могут быть обработаны\n"
"вариантом anaphex2 определяемым следующим образом:"

#: texi/node-16.texi:510
msgid ""
"@lisp\n"
"(defun anaphex3 (op args)\n"
"       `(_f (lambda (it) (,op it ,@@(cdr args))) ,(car args)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:513
msgid ""
"This expander assumes that the macro call will have one or more arguments, "
"the\n"
"first of which will be a generalized variable. Using it we could define "
"asetf thus:"
msgstr ""
"Этот расширитель предполагает, что вызов макроса будет иметь один или "
"несколько\n"
"аргументов, первый из которых будет обобщенной переменной. Используя его мы "
"можем\n"
"определить asetf таким образом:"

#: texi/node-16.texi:518
msgid ""
"@lisp\n"
"(defmacro asetf (&rest args)\n"
"       (anaphex3 'setf args))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:524
msgid ""
"Figure 16-5 shows all three expander functions yoked together under the\n"
"control of a single macro, the new defanaph. The user signals the type of "
"macro\n"
"expansion desired with the optional rule keyword parameter, which specifies "
"the\n"
"evaluation rule to be used for the arguments in the macro call. If this "
"parameter\n"
"is:"
msgstr ""
"На Рисунке 16-5 показаны все три функции расширители, объединенные под "
"управлением\n"
"одного макроса, нового defanaph. Пользователь сообщает тип требуемого "
"расширения \n"
"макроса с помощью необязательного параметра, ключевого слова, котоый "
"указывает\n"
"правило вычисления, которое будет использоваться аргументов в вызове "
"макроса. Если\n"
"этот параметр является:"

#: texi/node-16.texi:529
msgid ""
":all (the default) the macroexpansion will be on the model of alist. All "
"the\n"
"         arguments in the macro call will be evaluated, with it always bound "
"to the\n"
"         value of the previous argument."
msgstr ""
":all (по умолчанию) расширение макроса будет идти по модели alist. Все "
"аргументы в\n"
"         вызове макроса будут вычислены, причем it всегда будет связан со "
"значением\n"
"         предыдущего аргумента."

#: texi/node-16.texi:532
msgid ""
":first the macroexpansion will be on the model of aif. Only the first "
"argument\n"
"         will necessarily be evaluated, and it will be bound to its value."
msgstr ""
":first расширение макроса будет происходит по модели aif. Только первый "
"аргумент \n"
"         будет обязательно вычислен и it будет связано с его значением."

#: texi/node-16.texi:536
msgid ""
":place the macroexpansion will be on the model of asetf. The first argument\n"
"         will be treated as a generalized variable, and it will be bound to "
"its initial\n"
"         value."
msgstr ""
":place  разложение будет идти по модели asetf. Первый аргумент будет "
"рассматриваться как\n"
"         обобщенная переменная и  it будет связан с её первоначальным "
"значением."

#: texi/node-16.texi:539
msgid ""
"Using the new defanaph, some of the previous examples would be defined as\n"
"follows:"
msgstr ""
"Используя новый defanaph, некоторые из предыдущих примеров будут "
"определены \n"
"следующим образом:"

#: texi/node-16.texi:549
msgid ""
"@lisp\n"
" (defmacro defanaph (name &optional &key calls (rule :all))\n"
"    (let* ((opname (or calls (pop-symbol name)))\n"
"             (body (case rule\n"
"                        (:all       `(anaphex1 args '(,opname)))\n"
"                        (:first `(anaphex2 ',opname args))\n"
"                        (:place `(anaphex3 ',opname args)))))\n"
"        `(defmacro ,name (&rest args)\n"
"           ,body)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro defanaph (name &optional &key calls (rule :all))\n"
"    (let* ((opname (or calls (pop-symbol name)))\n"
"             (body (case rule\n"
"                        (:all       `(anaphex1 args '(,opname)))\n"
"                        (:first `(anaphex2 ',opname args))\n"
"                        (:place `(anaphex3 ',opname args)))))\n"
"        `(defmacro ,name (&rest args)\n"
"           ,body)))"

#: texi/node-16.texi:558
msgid ""
" (defun anaphex1 (args call)\n"
"    (if args\n"
"         (let ((sym (gensym)))\n"
"            `(let* ((,sym ,(car args))\n"
"                       (it ,sym))\n"
"                ,(anaphex1 (cdr args)\n"
"                                 (append call (list sym)))))\n"
"         call))"
msgstr ""

#: texi/node-16.texi:561
msgid ""
" (defun anaphex2 (op args)\n"
"    `(let ((it ,(car args))) (,op it ,@@(cdr args))))"
msgstr ""

#: texi/node-16.texi:565
msgid ""
" (defun anaphex3 (op args)\n"
"    `(_f (lambda (it) (,op it ,@@(cdr args))) ,(car args)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:567
msgid "                     Figure 16-5: More general defanaph."
msgstr ""
"                     Рисунок 16-5: Более общий defanaph.\n"
"@end cartouche"

#: texi/node-16.texi:574
msgid ""
"@lisp\n"
"(defanaph alist)\n"
"(defanaph aif :rule :first)\n"
"(defanaph asetf :rule :place)\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:578
msgid ""
"One of the advantages of asetf is that it makes it possible to define a "
"large class\n"
"of macros on generalized variables without worrying about multiple "
"evaluation.\n"
"For example, we could define incf as:"
msgstr ""
"Одним из преимуществ asetf явтяется то, что он позволяет определить большой "
"класс\n"
"макросов на обобщенных переменных, не беспокоясь о множественном "
"вычислении.\n"
"Например, мы можем определить incf как:"

#: texi/node-16.texi:583
msgid ""
"@lisp\n"
"(defmacro incf (place &optional (val 1))\n"
"  `(asetf ,place (+ it ,val)))\n"
"@end lisp"
msgstr ""

#: texi/node-16.texi:586
msgid ""
"@noindent\n"
"and, say, pull (page 173) as:"
msgstr ""
"@noindent\n"
"и описать pull (стр. 173) как:"

#: texi/node-16.texi:591
msgid ""
"@lisp\n"
"(defmacro pull (obj place &rest args)\n"
"  `(asetf ,place (delete ,obj it ,@@args)))\n"
"@end lisp"
msgstr ""
