#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-17.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 11:59+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-17.texi:5
msgid ""
"@node 17 Read-Macros, 18 Destructuring, 16 Macro-Defining Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 17 Read-Macros\n"
"@cindex 17 Read-Macros"
msgstr ""
"@node 17 Read-Macros, 18 Destructuring, 16 Macro-Defining Macros, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 17 Макросы Чтения\n"
"@cindex 17 Read-Macros"

#: texi/node-17.texi:10
msgid ""
"The three big moments in a Lisp expression's life are read-time, compile-"
"time,\n"
"and runtime. Functions are in control at runtime. Macros give us a chance "
"to\n"
"perform transformations on programs at compile-time. This chapter discusses\n"
"read-macros, which do their work at read-time."
msgstr ""
"Различают три больших момента в жизни Lisp выражения: время чтения, время \n"
"компиляции и время выполнения. Функции управлют во время выполнения. "
"Макросы\n"
"дают нам возможность выполнять преобразования в программах во время "
"компиляции.\n"
"В этой главе обсуждаются макросы чтения, которые выполняют свою работу во "
"время\n"
"чтения."

#: texi/node-17.texi:17
msgid ""
"@menu\n"
"* 17-1 Macro Characters::       \n"
"* 17-2 Dispatching Macro Characters::  \n"
"* 17-3 Delimiters::             \n"
"* 17-4 When What Happens::      \n"
"@end menu"
msgstr ""

#: texi/node-17.texi:22
msgid ""
"@node 17-1 Macro Characters, 17-2 Dispatching Macro Characters, 17 Read-"
"Macros, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-1 Macro Characters\n"
"@cindex 17-1 Macro Characters"
msgstr ""
"@node 17-1 Macro Characters, 17-2 Dispatching Macro Characters, 17 Read-"
"Macros, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-1 Макросы Знаки\n"
"@cindex 17-1 Macro Characters"

#: texi/node-17.texi:27
msgid ""
"In keeping with the general philosophy of Lisp, you have a great deal of "
"control\n"
"over the reader. Its behavior is controlled by properties and variables that "
"can\n"
"all be changed on the fly. The reader can be programmed at several levels. "
"The\n"
"easiest way to change its behavior is by defining new macro characters."
msgstr ""
"В соответствии с общей философией Lisp, у вас есть большой контроль над "
"читателем\n"
"(reader). Его поведение управляется свойствами и переменными, которые все "
"могут быть\n"
"изменены на лету. Читатель(reader) может быть запрограммирован на нескольких "
"уровнях.\n"
"Самый простой способ изменить его поведение - определить новые Макросы-Знаки."

#: texi/node-17.texi:34
msgid ""
"A macro character is a character which exacts special treatment from the "
"Lisp\n"
"reader. A lower-case a, for example, is ordinarily handled just like a lower-"
"case\n"
"b, but a left parenthesis is something different: it tells Lisp to begin "
"reading a list.\n"
"Each such character has a function associated with it that tells the Lisp "
"reader what\n"
"to do when the character is encountered. You can change the function "
"associated\n"
"with an existing macro character, or define new macro characters of your own."
msgstr ""
"Макрос-Знак это знак(литерал, буква), который требует особого отношения от "
"читателя\n"
"(reader) Lisp. Например, строчная буква a обычно обрабатывается так же как "
"строчная\n"
"буква b, но левая скобка \"(\" - это нечто совсем иное: она говорит Lisp-у "
"начать чтение\n"
"списка. Каждый такой знак имеет функцию связанную с ним, которая сообщает "
"Lisp читателю\n"
"(reader), что делать когда встречается этот знак. Вы можете изменить функцию "
"связанную\n"
"с существующим Макросом-Знаком или определить новые Макросы-Знаки "
"самостоятельно."

#: texi/node-17.texi:38
msgid ""
"The built-in function set-macro-character provides one way to define\n"
"read-macros. It takes a character and a function, and thereafter when read\n"
"encounters the character, it returns the result of calling the function."
msgstr ""
"Встроенная функция set-macro-character обеспечивает один из способов "
"определения\n"
"Макросов Чтения. Она требует знак и функцию, а заем при чтении встречая "
"указанный\n"
"знак возвращает результат вызова этой функции."

#: texi/node-17.texi:43
msgid ""
"One of the oldest read-macros in Lisp is ', the quote. You could do without\n"
"' by always writing (quote a) instead of 'a, but this would be tiresome and\n"
"would make your code harder to read. The quote read-macro makes it possible "
"to\n"
"use 'a as an abbreviation for (quote a). We could define it as in Figure "
"17-1."
msgstr ""
"Один из старейших макросов чтения в Lisp является  ', цитата/кавычка. Вы "
"можете\n"
"обойтись и без кавычки - ' , всегда записывая (quote a) вместо 'a, но это "
"будет\n"
"очень утомительно, и сделает ваш код сложнее для чтения. Макрос чтения "
"кавычка,\n"
"делает возможным использование 'a как аббревиатуру для (quote a). Мы могли "
"бы\n"
"определить его как на Рисунке 17-1."

#: texi/node-17.texi:49
msgid ""
"@lisp\n"
" (set-macro-character #\\'\n"
"       #'(lambda (stream char)\n"
"           (list 'quote (read stream t nil t))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (set-macro-character #\\'\n"
"       #'(lambda (stream char)\n"
"           (list 'quote (read stream t nil t))))\n"
"@end lisp"

#: texi/node-17.texi:51
msgid "                      Figure 17-1: Possible definition of '."
msgstr ""
"                      Рисунок 17-1: Возможное определение мароса знака - '.\n"
"@end cartouche"

#: texi/node-17.texi:57
msgid ""
"When read encounters an instance of ' in a normal context (e.g. not in \"a'b"
"\" or\n"
"|a'b|), it will return the result of calling this function on the current "
"stream and\n"
"character. (The function ignores this second parameter, which will always be "
"the\n"
"quote character.) So when read sees 'a, it will return (quote a)."
msgstr ""
"Когда читатель(read) встречается с экземпляром ' в обычном контексте (т.е не "
"в \"a'b\" \n"
"или |a'b|), он вернет результат вызова этой функции в текущий поток и знак. "
"(Функция\n"
"игнорирует этот второй параметр, который всегда будет знаком кавычки.) Таким "
"образом,\n"
"когда читатель(read) видит 'a, он вернет (quote a)."

#: texi/node-17.texi:62
msgid ""
"The last three arguments to read control respectively whether encountering\n"
"an end-of-file should cause an error, what value to return otherwise, and "
"whether\n"
"the call to read occurs within a call to read. In nearly all read-macros, "
"the second\n"
"and fourth arguments should be t, and the third argument is therefore "
"irrelevant."
msgstr ""
"Последние три аргумента для read, соответственно, управляют должен ли конец "
"файла\n"
"вызывать ошибку, какое значение вернуть в противном случае, и признак того "
"что\n"
"вызов read происходит внутри другого вызова read. Почти во всех макросах "
"чтения,\n"
"второй и четвертый аргументы должны быть t, и поэтому третий аргумент не "
"имеет\n"
"значения."

#: texi/node-17.texi:68
msgid ""
"Read-macros and ordinary macros are both functions underneath. And like\n"
"the functions that generate macro expansions, the functions associated with "
"macro\n"
"characters shouldn't have side-effects, except on the stream from which they "
"read.\n"
"Common Lisp explicitly makes no guarantees about when, or how often, the\n"
"function associated with a read-macro will be called. (See CLTL2, p. 543.)"
msgstr ""
"Макросы чтения и обычные макросы, оба типа являются функциями нижнего "
"уровня.\n"
"И как функции, которые генерируют расширения макросов, функци связанные с\n"
"Макросами-Знаками не должны иметь побочных эффектов, кроме как в  "
"потоке(stream)\n"
"из которого они производят чтение. Common Lisp явно не дает никаких "
"гарантий\n"
"относительно того, когда и как часто будет вызываться функция связанная с \n"
"макросом чтения (См. CLTL2, стр. 543.)"

#: texi/node-17.texi:74
msgid ""
"Macros and read-macros see your program at different stages. Macros get\n"
"hold of the program when it has already been parsed into Lisp objects by "
"the\n"
"reader, and read-macros operate on a program while it is still text. "
"However, by\n"
"invoking read on this text, a read-macro can, if it chooses, get parsed Lisp "
"objects\n"
"as well. Thus read-macros are at least as powerful as ordinary macros."
msgstr ""
"Макросы и макросы чтения смотрят на нашу программу на разных этапах. "
"Макросы\n"
"получают считанную программу, когда она уже была проанализирована и "
"разобрана\n"
"в Lisp обекты читателем(reader), и макросы чтения работают с программой, "
"когда\n"
"она еще является текстом. Тем не менее, вызывая read для этого текста, "
"макрос\n"
"чтения может, если захочет, получить проанализированные объекты Lisp. Таким\n"
"образом, макросы чтения, по крайней мере так же мощны, как и обычные макросы."

#: texi/node-17.texi:78
msgid ""
"Indeed, read-macros are more powerful in at least two ways. A read-macro\n"
"affects everything read by Lisp, while a macro will only be expanded in "
"code.\n"
"And since read-macros generally call read recursively, an expression like"
msgstr ""
"В действительности, макросы чтения являются даже более мощными, по крайней "
"мере,\n"
"в двух направлениях. Макрос чтения влияет на все, что читает Lisp, в то "
"время\n"
"как обычный макрос расширяется только в код. И так как макаросы чтения "
"обычно\n"
"вызывают read рекурсивно, выражения подобные"

#: texi/node-17.texi:82
msgid ""
"@lisp\n"
"''a\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:85
msgid ""
"@noindent\n"
"becomes"
msgstr ""
"@noindent\n"
"превращаются в"

#: texi/node-17.texi:89
msgid ""
"@lisp\n"
"(quote (quote a))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:92
msgid ""
"@noindent\n"
"whereas if we had tried to define an abbreviation for quote using a normal "
"macro,"
msgstr ""
"@noindent\n"
"тогда как, если бы мы попытались определить сокращение для кавычки используя "
"обычный\n"
"макрос,"

#: texi/node-17.texi:101
msgid ""
"@lisp\n"
"(defmacro q (obj)\n"
"  `(quote ,obj))\n"
"     (set-dispatch-macro-character #\\# #\\?\n"
"       #'(lambda (stream char1 char2)\n"
"            `#'(lambda (&rest ,(gensym))\n"
"                  ,(read stream t nil t))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defmacro q (obj)\n"
"  `(quote ,obj))\n"
"@end lisp\n"
"\n"
"@cartouche\n"
"@lisp\n"
"     (set-dispatch-macro-character #\\# #\\?\n"
"       #'(lambda (stream char1 char2)\n"
"            `#'(lambda (&rest ,(gensym))\n"
"                  ,(read stream t nil t))))\n"
"@end lisp"

#: texi/node-17.texi:103
msgid "                 Figure 17-2: A read-macro for constant functions."
msgstr ""
"                 Рисунок 17-2: Макросы чтения для постоянных функций.\n"
"@end cartouche"

#: texi/node-17.texi:106
msgid ""
"@noindent\n"
"it would work in isolation,"
msgstr ""
"@noindent\n"
"он будет работать изолированно,"

#: texi/node-17.texi:111
msgid ""
"@example\n"
"> (eq 'a (q a))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-17.texi:114
msgid ""
"@noindent\n"
"but not when nested. For example,"
msgstr ""
"@noindent\n"
"но не когда вложен. Например,"

#: texi/node-17.texi:118
msgid ""
"@lisp\n"
"(q (q a))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:121
msgid ""
"@noindent\n"
"would expand into"
msgstr ""
"@noindent\n"
"будет расширяться в"

#: texi/node-17.texi:125
msgid ""
"@lisp\n"
"(quote (q a))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:130
msgid ""
"@node 17-2 Dispatching Macro Characters, 17-3 Delimiters, 17-1 Macro "
"Characters, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-2 Dispatching Macro Characters\n"
"@cindex 17-2 Dispatching Macro Characters"
msgstr ""
"@node 17-2 Dispatching Macro Characters, 17-3 Delimiters, 17-1 Macro "
"Characters, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-2 Диспетчерские Макросы-Знаки\n"
"@cindex 17-2 Dispatching Macro Characters"

#: texi/node-17.texi:136
msgid ""
"The sharp-quote, like other read-macros beginning with #, is an example of "
"a\n"
"subspecies called dispatching read-macros. These appear as two characters, "
"the\n"
"first of which is called the dispatching character. The purpose of such read-"
"macros\n"
"is simply to make the most of the ASCII character set; one can only have so "
"many\n"
"one-character read-macros."
msgstr ""
"Решетка с кавычкой #', подобно другим маросам чтения начинающимся с решетки "
"#, \n"
"является примером подвида, называемым диспетчерскими макросами чтения. Они \n"
"появляются как два знака, первый из которых называется диспетчерским "
"знаком. \n"
"Цель таких макросов чтнения простая, чтобы можно было максимально "
"использовать\n"
"набор ASCII знаков;  один знак позволяет иметь столько макросов чтения, "
"сколько\n"
"всего одиночных знаков."

#: texi/node-17.texi:142
msgid ""
"You can (with make-dispatch-macro-character) define your own dis-\n"
"patching macro characters, but since # is already defined as one, you may as "
"well\n"
"use it. Some combinations beginning with # are explicitly reserved for your "
"use;\n"
"others are available in that they do not yet have a predefined meaning in "
"Common\n"
"Lisp. The complete list appears in CLTL2, p. 531."
msgstr ""
"Вы можете (с помощью make-dispatch-macro-character) определить свой "
"собственный\n"
"диспетчерский макрос-знак, но так как # уже определен как один из них, вы "
"можете\n"
"использовать его. Некоторые комбинации начинающиеся с # явно зарезервированы "
"для\n"
"использования вами; другие доступны, в том смысле, что они еще не имеют \n"
"предопределенного значения в Common Lisp. Полный список приведен в CLTL2, "
"стр. 531."

#: texi/node-17.texi:149
msgid ""
"New dispatching macro character combinations can be defined by calling\n"
"the function set-dispatch-macro-character, like set-macro-character\n"
"except that it takes two character arguments. One of the combinations "
"reserved\n"
"to the programmer is #?. Figure 17-2 shows how to define this combination "
"as\n"
"a read-macro for constant functions. Now #?2 will be read as a function "
"which\n"
"takes any number of arguments and returns 2. For example:"
msgstr ""
"Новые комбинации диспетчерских макро знаков могут быть определены путем "
"вызова\n"
"функции set-dispatch-macro-character, похожей на set-macro-character \n"
"за исключением того, что она принимает два знаковых аргумента. Одной из \n"
"зарезервированных комбинаций для программиста является  #?. На Рисунке "
"17-2 \n"
"показано, как определить эту комбинацию как макрос чтения для постоянных\n"
"функций.Теперь #?2 будет читаться как функция, которая принимает любое\n"
"количество аргументов и возвращает 2. Например:"

#: texi/node-17.texi:155
msgid ""
"@example\n"
"> (mapcar #?2 '(a b c))\n"
"(222)\n"
"@end example"
msgstr ""
"@example\n"
"> (mapcar #?2 '(a b c))\n"
"(2 2 2)\n"
"@end example"

#: texi/node-17.texi:161
msgid ""
"@lisp\n"
"     (set-macro-character #\\] (get-macro-character #\\)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (set-macro-character #\\] (get-macro-character #\\)))"

#: texi/node-17.texi:171
msgid ""
"     (set-dispatch-macro-character #\\# #\\[\n"
"      #'(lambda (stream char1 char2)\n"
"           (let ((accum nil)\n"
"                   (pair (read-delimited-list #\\] stream t)))\n"
"              (do ((i (ceiling (car pair)) (1+ i)))\n"
"                   ((> i (floor (cadr pair)))\n"
"                     (list 'quote (nreverse accum)))\n"
"                 (push i accum)))))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:173
msgid "                   Figure 17-3: A read-macro defining delimiters."
msgstr ""
"                   Рисунок 17-3: Макрос чтения определяющий разделители.\n"
"@end cartouche"

#: texi/node-17.texi:178
msgid ""
"This example makes the new operator look rather pointless, but in programs "
"that\n"
"use a lot of functional arguments, constant functions are often needed. In "
"fact,\n"
"some dialects provide a built-in function called always for defining them."
msgstr ""
"Этот пример создает новый оператор выглядящий довольно бессмысленным, но в "
"программах\n"
"которые используют много функциональных аргументов, постоянные функции часто "
"необходимы.\n"
"По факту, некоторые диалекты предоставляют встроенную функцию, которая "
"вызывается\n"
"всегда для их определения."

#: texi/node-17.texi:183
msgid ""
"Note that it is perfectly ok to use macro characters in the definition of "
"this\n"
"macro character: as with any Lisp expression, they disappear when the "
"definition\n"
"is read. It is also fine to use macro-characters after the #?. The "
"definition of #?\n"
"calls read, so macro-characters like ' and #' behave as usual:"
msgstr ""
"Обратите внимание, что вполне нормально использовать макросы-Знаки в "
"определении\n"
"этого макроса-знака: как и в любом Lisp выражении, они исчезают, когда "
"определение\n"
"будет прочитано. Так же хорошо использовать Макросы-Знаки после #?. "
"Определение #?\n"
"вызывает read, поэтому макросы-знаки, подобные ' и #' ведут себя как обычно:"

#: texi/node-17.texi:189
msgid ""
"@example\n"
"> (eq (funcall #?'a) 'a)\n"
"T> (eq (funcall #?#'oddp) (symbol-function 'oddp))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-17.texi:194
msgid ""
"@node 17-3 Delimiters, 17-4 When What Happens, 17-2 Dispatching Macro "
"Characters, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-3 Delimiters\n"
"@cindex 17-3 Delimiters"
msgstr ""
"@node 17-3 Delimiters, 17-4 When What Happens, 17-2 Dispatching Macro "
"Characters, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-3 Разделители\n"
"@cindex 17-3 Delimiters"

#: texi/node-17.texi:200
msgid ""
"After simple macro characters, the most commonly defined macro characters\n"
"are list delimiters. Another character combination reserved for the user is "
"#[.\n"
"Figure 17-3 gives an example of how this character might be defined as a "
"more\n"
"elaborate kind of left parenthesis. It defines an expression of the form #[x "
"y] to\n"
"read as a list of all the integers between x and y, inclusive:"
msgstr ""
"После простых макросов-знаков, наиболее часто определяемыми макросами-"
"знаками\n"
"являются разелители списка. Другой комбинацией зарезервированной для "
"пользователя,\n"
"является #[. На рисунке 17-3 приведен пример, как этот символ может быть "
"определен\n"
"как более сложный вид левой скобки. Он определяет выражения вида #[x y] для\n"
"читателя(read) как список всех целых чисел заключенных между x и y, "
"включительно:"

#: texi/node-17.texi:205
msgid ""
"@example\n"
"> #[2 7]\n"
"(234567)\n"
"@end example"
msgstr ""
"@example\n"
"> #[2 7]\n"
"(2 3 4 5 6 7)\n"
"@end example"

#: texi/node-17.texi:210
msgid ""
"The only new thing about this read-macro is the call to read-delimited-"
"list,\n"
"a built-in function provided just for such cases. Its first argument is the "
"character\n"
"to treat as the end of the list. For ] to be recognized as a delimiter, it "
"must first be\n"
"given this role, hence the preliminary call to set-macro-character."
msgstr ""
"Единственно новая вещь в этом макросе чтения это вызов read-delimited-list, "
"встроенной\n"
"функции предусмотренной, как раз для таких случаев. Её первый аргуентом "
"является знак,\n"
"рассматриваемый как конец списка. Чтобы ] был распознан как разделитель, он "
"должен быть\n"
"первым в этой роли, отсюда и предварительный вызов set-macro-character."

#: texi/node-17.texi:214
msgid ""
"@lisp\n"
"     (defmacro defdelim (left right parms &body body)\n"
"       `(ddfn ,left ,right #'(lambda ,parms ,@@body)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defmacro defdelim (left right parms &body body)\n"
"       `(ddfn ,left ,right #'(lambda ,parms ,@@body)))"

#: texi/node-17.texi:223
msgid ""
"     (let ((rpar (get-macro-character #\\) )))\n"
"       (defun ddfn (left right fn)\n"
"         (set-macro-character right rpar)\n"
"         (set-dispatch-macro-character #\\# left\n"
"            #'(lambda (stream char1 char2)\n"
"                 (apply fn\n"
"                          (read-delimited-list right stream t))))))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:225
msgid "              Figure 17-4: A macro for defining delimiter read-macros."
msgstr ""
"              Рисунок 17-4: Макрос для определения макросов чтения "
"разделителей.\n"
"@end cartouche"

#: texi/node-17.texi:237
msgid ""
"Most potential delimiter read-macro definitions will duplicate a lot of the\n"
"code in Figure 17-3. A macro could put a more abstract interface on all "
"this\n"
"machinery. Figure 17-4 shows how we might define a utility for defining "
"delimiter\n"
"read-macros. The defdelim macro takes two characters, a parameter list, and "
"a\n"
"body of code. The parameter list and the body of code implicitly define a "
"function.\n"
"A call to defdelim defines the first character as a dispatching read-macro "
"which\n"
"reads up to the second, then returns the result of applying this function to "
"what it\n"
"read.Incidentally,thebodyofthefunctioninFigure17-3alsocriesoutforautility-\n"
"for one we have already defined, in fact: mapa-b, from page 54. Using "
"defdelim\n"
"and mapa-b, the read-macro defined in Figure 17-3 could now be written:"
msgstr ""
"Большинство потенциальных определений макросов чтения разделителей будут "
"дублировать\n"
"большую часть кода на рисунке 17-3. Макрос можно поместить в более "
"абстрактный\n"
"интерфейс всего этого механизма. На Рисунке 17-4 показано, как мы можем "
"определить \n"
"утилитуs для определенения макросов чтения разделителя. Макрос defdelim "
"принимает\n"
"два знака, списко параметров и тело кода. Список параметров и тело кода "
"неявно\n"
"определяют функцию. Вызов defdelim определяет первый символ как "
"диспетчерский\n"
"макрос чтения, который выполняет чтение до второго указанного знака, а "
"затем\n"
"возвращает результат применения функции к тому, что он прочитал.\n"
"   Между прочим, тело функции на рисунке  17-3 также требует утилиты:  "
"которую\n"
"мы уже определили, фактически: mapa-b, со страницы 54. Используя defdelim\n"
"и mapa-b, макрос чтения определенный на Рисунке 17-3 может быть записан:"

#: texi/node-17.texi:242
msgid ""
"@lisp\n"
"(defdelim #\\[ #\\] (x y)\n"
"     (list 'quote (mapa-b #'identity (ceiling x) (floor y))))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:245
msgid ""
"Another useful delimiter read-macro would be one for functional "
"composition.\n"
"Section 5-4 defined an operator for functional composition:"
msgstr ""
"Другим полезным применением макроса чтения разделителей может быть "
"функциональная \n"
"композиция. Раздел 5-4 определяет оператор для функциональной композиции:"

#: texi/node-17.texi:252
msgid ""
"@example\n"
"> (let ((f1 (compose #'list #'1+))\n"
"             (f2 #'(lambda (x) (list (1+ x)))))\n"
"        (equal (funcall f1 7) (funcall f2 7)))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-17.texi:256
msgid ""
"When we are composing built-in functions like list and 1+, there is no "
"reason\n"
"to wait until runtime to evaluate the call to compose. Section 5-7 suggested "
"an\n"
"alternative; by prefixing the sharp-dot read-macro to a compose expression,"
msgstr ""
"Когда мы составляем встроенные функции, такие как list и 1+, нет причин "
"ждать\n"
"времени выполнения для того, чтобы выполнить вызов compose. Раздел 5-7 "
"предлагал,\n"
"алльтернативу; добавив макрос чтения решетка с точкой #. к выражению compose,"

#: texi/node-17.texi:262
msgid ""
"@lisp\n"
"#.(compose #'list #'1+)\n"
" (defdelim #\\@{ #\\@} (&rest args)\n"
"       `(fn (compose ,@@args)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"#.(compose #'list #'1+)\n"
" (defdelim #\\@{ #\\@} (&rest args)\n"
"       `(fn (compose ,@@args)))\n"
"@end lisp"

#: texi/node-17.texi:264
msgid "              Figure 17-5: A read-macro for functional composition."
msgstr ""
"              Рисунок 17-5: Макрос чтения для функциональной композиции.\n"
"@end cartouche"

#: texi/node-17.texi:267
msgid ""
"@noindent\n"
"we could cause it to be evaluated at read-time."
msgstr ""
"@noindent\n"
"мы могли бы заставить его выполниться во время чтения."

#: texi/node-17.texi:271
msgid ""
"Here we show a similar but cleaner solution. The read-macro in Figure 17-5\n"
"defines an expression of the form #@{f 1 f 2 ...fn@} to read as the "
"composition of\n"
"f 1, f 2,...,fn. Thus:"
msgstr ""
"Здесь мы показываем подробно, но более ясное решение. Макрос чтения на "
"Рисунке 17-5\n"
"определяет выражение вида #@{f 1 f 2 ...fn@} как чтение композиции функций\n"
"f 1, f 2,...,fn. Таким образом:"

#: texi/node-17.texi:276
msgid ""
"@example\n"
"> (funcall #@{list 1+@} 7)\n"
"(8)\n"
"@end example"
msgstr ""

#: texi/node-17.texi:279
msgid ""
"It works by generating a call to fn (page 202), which will create the "
"function at\n"
"compile-time."
msgstr ""
"Он работает путем генерации вызова функций до fn (стр. 202), которая создает "
"функцию\n"
"во время компиляции."

#: texi/node-17.texi:283
msgid ""
"@menu\n"
"* 17-4 When What Happens::      \n"
"@end menu"
msgstr ""

#: texi/node-17.texi:288
msgid ""
"@node 17-4 When What Happens,  , 17-3 Delimiters, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-4 When What Happens\n"
"@cindex 17-4 When What Happens"
msgstr ""
"@node 17-4 When What Happens,  , 17-3 Delimiters, 17 Read-Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 17-4 Когда Что Происходит\n"
"@cindex 17-4 When What Happens"

#: texi/node-17.texi:292
msgid ""
"Finally, it might be useful to clear up a possibly confusing issue. If read-"
"macros are\n"
"invoked before ordinary macros, how is it that macros can expand into "
"expressions\n"
"which contain read-macros? For example, the macro:"
msgstr ""
"В заключении, может быть полезно разобраться в возможной путанице. Если "
"макросы чтения\n"
"вызываются до обычных макросов, как получается, что  эти макросы могут "
"расширяться в\n"
"выражения, которые содержат макросы чтения? Например, макрос:"

#: texi/node-17.texi:297
msgid ""
"@lisp\n"
"(defmacro quotable ()\n"
"  '(list 'able))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:301
msgid ""
"generates an expansion with a quote in it. Or does it? In fact, what happens "
"is\n"
"that both quotes in the definition of this macro are expanded when the "
"defmacro\n"
"expression is read, yielding"
msgstr ""
"генерирует расширение с кавычкой в нем. Или нет? На самом деле происходит "
"следующее,\n"
"обе кавычки в определении этого макроса раскрываются когда выражение "
"defmacro\n"
"читается, первращаясь в"

#: texi/node-17.texi:306
msgid ""
"@lisp\n"
"(defmacro quotable ()\n"
"  (quote (list (quote able))))\n"
"@end lisp"
msgstr ""

#: texi/node-17.texi:310
msgid ""
"Usually, there is no harm in acting as if macroexpansions could contain "
"read-\n"
"macros, because the definition of a read-macro will not (or should not) "
"change\n"
"between read-time and compile-time."
msgstr ""
"Обычно нет ничего плохого в том, что разложения макроса могут содержать\n"
"макросы чтения, потому что определение макроса чтения не (или не должно) \n"
"измениться, между временем чтения и временем компиляции."
