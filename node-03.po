#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-03.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-07-02 13:52+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-03.texi:5
msgid ""
"@node 3 Functional Programming, 4 Utility Functions, 2 Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 3 Functional Programming\n"
"@cindex 3 Functional Programming"
msgstr ""
"@node 3 Functional Programming, 4 Utility Functions, 2 Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 3 Функциональное программирование\n"
"@cindex 3 Functional Programming"

#: texi/node-03.texi:9
msgid ""
"The previous chapter explained how Lisp and Lisp programs are both built "
"out\n"
"of a single raw material: the function. Like any building material, its "
"qualities\n"
"influence both the kinds of things we build, and the way we build them."
msgstr ""
"В предыдущей главе рассказывалось о том, что Lisp и программы на нем\n"
"созданы из единственного материала: функций. Как и любому\n"
"строительному материалу, им присуще оказывать влияние как и на\n"
"свойства того, что мы создаем, так и на способ создания.\n"

#: texi/node-03.texi:15
msgid ""
"This chapter describes the kind of construction methods which prevail in\n"
"the Lisp world. The sophistication of these methods allows us to attempt "
"more\n"
"ambitious kinds of programs. The next chapter will describe one "
"particularly\n"
"important class of programs which become possible in Lisp: programs which\n"
"evolve instead of being developed by the old plan-and-implement method."
msgstr ""
"Эта глава описывает методы разработки, преобладающие в мире\n"
"Lisp. Изощренность этих методов позволит нам попытаться писать более\n"
"сложные программы. В следующей главе будет рассмотрен особенно важный\n"
"класс программ, который становится возможно реализовать в Лисп:\n"
"программы, которые эволюционируют вместо того, чтобы разрабатываться\n"
"старым способом \"спланируй и реализуй\"."

#: texi/node-03.texi:22
msgid ""
"@menu\n"
"* 3-1 Functional Design::       \n"
"* 3-2 Imperative Outside-In::   \n"
"* 3-3 Functional Interfaces::   \n"
"* 3-4 Interactive Programming::  \n"
"@end menu"
msgstr ""

#: texi/node-03.texi:27
msgid ""
"@node 3-1 Functional Design, 3-2 Imperative Outside-In, 3 Functional "
"Programming, 3 Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-1 Functional Design\n"
"@cindex 3-1 Functional Design"
msgstr ""
"@node 3-1 Functional Design, 3-2 Imperative Outside-In, 3 Functional "
"Programming, 3 Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-1 Функциональное проектирование\n"
"@cindex 3-1 Functional Design"

#: texi/node-03.texi:33
msgid ""
"The character of an object is influenced by the elements from which it is "
"made. A\n"
"wooden building looks different from a stone one, for example. Even when "
"you\n"
"are too far away to see wood or stone, you can tell from the overall shape "
"of the\n"
"building what it's made of. The character of Lisp functions has a similar "
"influence\n"
"on the structure of Lisp programs."
msgstr ""
"На свойства объекта влияют элементы, из которых он создан. Например,\n"
"деревянное здание на вид отличается от каменного. Даже находясь от\n"
"него на далеком расстоянии и не имея возможности отличить на взгляд\n"
"камень от дерева, вы сможете определить материал, из которого оно\n"
"выстроено, исходя из общей формы этого здания. Особенности функций\n"
"Lisp оказывают аналогичное влияние на структуру Lisp программ."

#: texi/node-03.texi:40
msgid ""
"Functional programming means writing programs which work by returning\n"
"values instead of by performing side-effects. Side-effects include "
"destructive\n"
"changes to objects (e.g. by rplaca) and assignments to variables (e.g. by "
"setq).\n"
"If side-effects are few and localized, programs become easier to read, test, "
"and\n"
"debug. Lisp programs have not always been written in this style, but over "
"time\n"
"Lisp and functional programming have gradually become inseparable."
msgstr ""
"Функциональное программирование означает написание программ, которые\n"
"работают за счет возврата значений, а не за счет побочных\n"
"действий. Побочные действия включают в себя деструктивные изменения\n"
"объектов (напр. rplaca) и присвоения переменным (напр. setq). Если\n"
"побочные действия немногочисленны и локализованы, то программы\n"
"становится легче читать, тестировать и отлаживать. Lisp-программисты\n"
"не всегда писали в таком стиле, но со временем Lisp и функциональное\n"
"программирование постепенно стали неразделимы."

#: texi/node-03.texi:43
msgid ""
"An example will show how functional programming differs from what you\n"
"might do in another language. Suppose for some reason we want the elements of"
msgstr ""
"Вот пример, который покажет, как функциональное программирование отличается "
"от\n"
"того, что можно делать при помощи другого языка. Допустим, нам нужно с\n"
"какой-то целью "

#: texi/node-03.texi:53
msgid ""
"@lisp\n"
" (defun bad-reverse (lst)\n"
"       (let* ((len (length lst))\n"
"                (ilimit (truncate (/ len 2))))\n"
"          (do ((i 0 (1+ i))\n"
"                (j (1- len) (1- j)))\n"
"               ((>= i ilimit))\n"
"            (rotatef (nth i lst) (nth j lst)))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun bad-reverse (lst)\n"
"       (let* ((len (length lst))\n"
"                (ilimit (truncate (/ len 2))))\n"
"          (do ((i 0 (1+ i))\n"
"                (j (1- len) (1- j)))\n"
"               ((>= i ilimit))\n"
"            (rotatef (nth i lst) (nth j lst)))))\n"
"@end lisp"

#: texi/node-03.texi:55
msgid "                         Figure 3-1: A function to reverse lists."
msgstr ""
"                         Рисунок 3-1: Функция, инвертирующая списки.\n"
"@end cartouche"

#: texi/node-03.texi:60
msgid ""
"a list in the reverse order. Instead of writing a function to reverse lists, "
"we write a\n"
"function which takes a list, and returns a list with the same elements in "
"the reverse\n"
"order."
msgstr ""
"изменить порядок элементов списка. Вместо написания функции,\n"
"инвертирующей списки, мы напишем функцию, которая принимает список, а\n"
"возвращает список с теми же элементами в обратном порядке."

#: texi/node-03.texi:63
msgid ""
"Figure 3-1 contains a function to reverse lists. It treats the list as an "
"array,\n"
"reversing it in place; its return value is irrelevant:"
msgstr ""
"На рисунке 3.1 представлена функция, инвертирующая списки. Она\n"
"обрабатывает списки как массивы, сразу переворачивая их; ее\n"
"возвращаемое значение неважно:"

#: texi/node-03.texi:72
msgid ""
"@example\n"
"> (setq lst '(a b c))\n"
"(ABC)\n"
"> (bad-reverse lst)\n"
"NIL\n"
"> lst\n"
"(CBA)\n"
"@end example"
msgstr ""
"@example\n"
"> (setq lst '(a b c))\n"
"(A B C)\n"
"> (bad-reverse lst)\n"
"NIL\n"
"> lst\n"
"(C B A)\n"
"@end example"

#: texi/node-03.texi:76
msgid ""
"As its name suggests, bad-reverse is far from good Lisp style. Moreover, "
"its\n"
"ugliness is contagious: because it works by side-effects, it will also draw "
"its callers\n"
"away from the functional ideal."
msgstr ""
"Её имя подсказывает, что bad-reverse далека от хорошего Lisp-стиля. \n"
"Кроме того, ее уродство заразно: так как она работает при\n"
"помощи побочных эффектов, то также уводит в сторону от функционального\n"
"идеала вызвавшие её функции.\n"

#: texi/node-03.texi:82
msgid ""
"Though cast in the role of the villain, bad-reverse does have one merit: it\n"
"shows the Common Lisp idiom for swapping two values. The rotatef macro\n"
"rotates the values of any number of generalized variables-that is, "
"expressions\n"
"you could give as the first argument to setf. When applied to just two "
"arguments,\n"
"the effect is to swap them."
msgstr ""
"Хотя, выступая в роли злодея, у bad-reverse есть одно достоинство: она\n"
"демонстрирует идиому Common Lisp для перестановки двух\n"
"значений. Макрос rotatef переворачивает значения любого числа\n"
"обобщенных переменных, то есть выражений, которые можно передать в setf\n"
"в качестве первого аргумента. Когда она примененяется просто к\n"
"двум аргументам, результатом будет их перестановка."

#: texi/node-03.texi:86
msgid ""
"In contrast, Figure 3-2 shows a function which returns reversed lists. With\n"
"good-reverse, we get the reversed list as the return value; the original "
"list is not\n"
"touched."
msgstr ""
"С другой стороны, на рисунке 3.2 показана функция, возвращающая\n"
"инвертированные списки. С помощью good-reverse мы получаем\n"
"инвертированный список в качестве возвращаемого значения; исходный\n"
"список остается прежним."

#: texi/node-03.texi:95
msgid ""
"@example\n"
"> (setq lst '(a b c))\n"
"(ABC)\n"
"> (good-reverse lst)\n"
"(CBA)\n"
"> lst\n"
"(ABC)\n"
"@end example"
msgstr ""
"@example\n"
"> (setq lst '(a b c))\n"
"(A B C)\n"
"> (good-reverse lst)\n"
"(C B A)\n"
"> lst\n"
"(A B C)\n"
"@end example"

#: texi/node-03.texi:104
msgid ""
"@lisp\n"
" (defun good-reverse (lst)\n"
"       (labels ((rev (lst acc)\n"
"                         (if (null lst)\n"
"                                acc\n"
"                                (rev (cdr lst) (cons (car lst) acc)))))\n"
"          (rev lst nil)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun good-reverse (lst)\n"
"   (labels ((rev (lst acc)\n"
"      (if (null lst)\n"
"          acc\n"
"          (rev (cdr lst) (cons (car lst) acc)))))\n"
"     (rev lst nil)))\n"
"@end lisp"

#: texi/node-03.texi:106
msgid ""
"                        Figure 3-2: A function to return reversed lists."
msgstr ""
"                        Рисунок 3-2: Функция, возвращающая инвертированные "
"списки\n"
"@end cartouche"

#: texi/node-03.texi:117
msgid ""
"It used to be thought that you could judge someone's character\n"
"by looking at the shape of his head. Whether or not this is true of\n"
"people, it is generally true of Lisp programs. Functional programs\n"
"have a different shape from imperative ones. The structure in a\n"
"functional program comes entirely from the composition of arguments\n"
"within expressions, and since arguments are indented, functional code\n"
"will show more variation in indentation. Functional code looks fluid\n"
"@footnote{For a characteristic example, see page 242.} on the page;\n"
"imperative code looks solid and blockish, like Basic."
msgstr ""
"Раньше считалось, что можно судить о чьем-то характере, глядя на форму\n"
"его головы. Относится ли это в самом деле к людям или нет, неизвестно, \n"
"но как правило, это применимо к Lisp-программам. Внешний вид функциональных\n"
"программ отличается от внешнего вида императивных. Структурно\n"
"функциональная программа -- это всегда композиция аргументов внутри\n"
"выражений, а так как аргументы можно размещать с отступом, то "
"функциональный\n"
"код оказывается более разнообразным в плане наглядности. Функциональный\n"
"код выглядит гибким @footnote{Типичный пример приведен на странице 242.},\n"
" а императивный код выглядит сплошным и блочным, как Basic."

#: texi/node-03.texi:121
msgid ""
"Even from a distance, the shapes of badand good-reverse suggest which\n"
"is the better program. And despite being shorter, good-reverse is also more\n"
"efficient: O(n) instead of O(n2)."
msgstr ""
"Мы видим, не вдаваясь в детали, исходя из внешнего вида bad- и\n"
"good-reverse, какая из программ лучше. Несмотря на то, что\n"
"good-reverse короче, она также более эффективна: O(n) вместо O(n^2).\n"

#: texi/node-03.texi:129
msgid ""
"We are spared the trouble of writing reverse because Common Lisp has\n"
"it built-in. It is worth looking briefly at this function, because it is one "
"that\n"
"often brings to the surface misconceptions about functional programming. "
"Like\n"
"good-reverse,the built-in reverse works by returning a value-it doesn't "
"touch\n"
"its arguments. But people learning Lisp may assume that, like bad-reverse,"
"it\n"
"works by side-effects. If in some part of a program they want a list lst to "
"be\n"
"reversed, they may write"
msgstr ""
"У нас нет проблем с написанием reverse, поскольку Common Lisp имеет\n"
"встроенную функцию. Имеет смысл ненадолго взглянуть на эту функцию, потому "
"что\n"
"она часто выявляет неправильные представления о функциональном\n"
"программировании. Как и good-reverse, встроенная reverse возвращает\n"
"значение, не изменяя аргументов. Но изучающие Lisp могут подумать, что\n"
"она, как и bad-reverse, работает за счет побочных эффектов. Если в \n"
"какой-либо части программы потребуется инвертировать список, можно написать"

#: texi/node-03.texi:133
msgid ""
"@lisp\n"
"(reverse lst)\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:137
msgid ""
"and wonder why the call seems to have no effect. In fact, if we want effects "
"from\n"
"such a function, we have to see to it ourselves in the calling code. That "
"is, we\n"
"need to write"
msgstr ""
"но к удивлению это не сработает. В действительности, если нам нужны\n"
"действия от такой функции, то придется сделать это самим в вызывающем\n"
"коде. Вот, что вместо этого необходимо написать:\n"

#: texi/node-03.texi:141
msgid ""
"@lisp\n"
"(setq lst (reverse lst))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:146
msgid ""
"instead. Operators like reverse are intended to be called for return values, "
"not\n"
"side-effects. It is worth writing your own programs in this style too-not "
"only for\n"
"its inherent benefits, but because, if you don't, you will be working "
"against the\n"
"language."
msgstr ""
"Такие операторы, как reverse, предназначены для вызова с целью\n"
"получения значений, а не побочных действий. Писать собственные\n"
"программы в таком стиле стоит не только из-за обязательно присущих ему\n"
"преимуществ, но и потому, что если этого не делать, вы будете работать\n"
"против языка."

#: texi/node-03.texi:153
msgid ""
"One of the points we ignored in the comparison of bad- and good-reverse is\n"
"that bad-reverse doesn't cons. Instead of building new list structure, it "
"operates\n"
"on the original list. This can be dangerous-the list could be needed "
"elsewhere\n"
"in the program-but for efficiency it is sometimes necessary. For such "
"cases,\n"
"Common Lisp provides an O(n) destructive reversing function called "
"nreverse.  "
msgstr ""
"Сравнивая bad- и good-reverse, мы не придали значения одной из\n"
"особенностей, заключающейся в том, что bad-reverse не создает\n"
"новый список. Вместо создания новой структуры списка, она работает\n"
"с исходным списком. Это может быть опасно: список может потребоваться\n"
"где-либо еще в программе, но это иногда бывает необходимо ради\n"
"производительности. Для таких случаев Common Lisp предоставляет O(n)\n"
"деструктивную инвертирующую функцию, которая называется nreverse."

#: texi/node-03.texi:159
msgid ""
"A destructive function is one that can alter the arguments passed to it. "
"However,\n"
"even destructive functions usually work by returning values: you have to "
"assume\n"
"that nreverse will recycle lists you give to it as arguments, but you still "
"can't\n"
"assume that it will reverse them. As before, the reversed list has to be "
"found in\n"
"the return value. You still can't write"
msgstr ""
"Деструктивной является та функция, которая может изменять передаваемые\n"
"ей аргументы. Тем не менее даже деструктивные функции работают при\n"
"помощи возвращаемых значений: вы должны считать, что nreverse\n"
"переработает списки, переданные ей в качестве аргументов, но\n"
"по-прежнему нельзя полагаться на то, что она их инвертирует. Как и\n"
"раньше, инвертированный список будет содержаться в возвращаемом\n"
"значении. Вы не можете написать"

#: texi/node-03.texi:163
msgid ""
"@lisp\n"
"(nreverse lst)\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:166
msgid ""
"in the middle of a function and assume that afterwards lst will be reversed. "
"This\n"
"is what happens in most implementations:"
msgstr ""
"в середине функции, полагая, что после этого lst будет инвертирован. Вот, "
"что \n"
"происходит в большинстве реализаций:"

#: texi/node-03.texi:175
msgid ""
"@example\n"
"> (setq lst '(a b c))\n"
"(ABC)\n"
"> (nreverse lst)\n"
"(CBA)\n"
"> lst\n"
"(A)\n"
"@end example"
msgstr ""
"@example\n"
"> (setq lst '(a b c))\n"
"(A B C)\n"
"> (nreverse lst)\n"
"(C B A)\n"
"> lst\n"
"(A)\n"
"@end example"

#: texi/node-03.texi:178
msgid ""
"To reverse lst, you have would have to set lst to the return value, as with "
"plain\n"
"reverse."
msgstr ""
"Для инвертирования lst можно было бы присвоить lst возвращаемое значение, "
"как в \n"
"случае с обычным reverse."

#: texi/node-03.texi:182
msgid ""
"If a function is advertised as destructive, that doesn't mean that it's "
"meant\n"
"to be called for side-effects. The danger is, some destructive functions "
"give the\n"
"impression that they are. For example,"
msgstr ""
"Если функция обозначена как деструктивная, то это вовсе не означает,\n"
"что ее предполагалось вызывать для побочных действий. Опасность\n"
"в том, что некоторые деструктивные функции создают впечатление\n"
"таковых. Например,"

#: texi/node-03.texi:186
msgid ""
"@lisp\n"
"(nconc x y)\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:188
msgid "almost always has the same effect as"
msgstr "почти всегда производит те же действия, что и"

#: texi/node-03.texi:192
msgid ""
"@lisp\n"
"(setq x (nconc x y))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:195
msgid ""
"If you wrote code which relied on the former idiom, it might seem to work "
"for\n"
"some time. However, it wouldn't do what you expected when x was nil."
msgstr ""
"Если вы написали код, зависящий от приведенной выше конструкции, то\n"
"он, вероятно, может работать некоторое время. Однако он не будет\n"
"делать то, что вы ожидали, когда x равно nil."

#: texi/node-03.texi:200
msgid ""
"Only a few Lisp operators are intended to be called for side-effects. In "
"general,\n"
"the built-in operators are meant to be called for their return values. Don't "
"be misled\n"
"by names like sort, remove,orsubstitute. If you want side-effects, use setq\n"
"on the return value."
msgstr ""
"Лишь несколько операторов Lisp предназначены для вызова с целью\n"
"получения побочных эффектов. Вообще, встроенные операторы задумывались\n"
"для вызова ради возращаемых ими значений. Такие названия, как sort,\n"
"remove или substitute, не должны вводить в заблуждение. Если вам нужны\n"
"побочные эффекты, применяйте setq к возвращаемому значению.\n"

#: texi/node-03.texi:204
msgid ""
"This very rule suggests that some side-effects are inevitable. Having "
"functional\n"
"programming as an ideal doesn't imply that programs should never have side-\n"
"effects. It just means that they should have no more than necessary."
msgstr ""
"Это самое правило предполагает, что побочные действия(эффекты) неизбежны. \n"
"Придерживаться функционального программирования как идеала,\n"
"не означает того, что программы никогда не должны осуществлять\n"
"побочных эффектов. Это означает, что они должны быть, но не более, чем это\n"
"необходимо."

#: texi/node-03.texi:212
msgid ""
"It may take time to develop this habit. One way to start is to treat the\n"
"following operators as if there were a tax on their use: set setq setf "
"psetf\n"
"psetq incf decf push pop pushnew rplaca rplacd rotatef shiftf remf remprop\n"
"remhash and also let*, in which imperative programs often lie\n"
"concealed. Treating these operators as taxable is only proposed as a help\n"
"toward, not a criterion for, good Lisp style. However, this alone can get "
"you\n"
"surprisingly far."
msgstr ""
"Чтобы развить такую привычку, возможно, потребуется время. Один из\n"
"способов состоит в том, чтобы использовать следующие операторы так,\n"
"как если бы был налог на их использование:\n"
"\n"
"set setq setf psetf psetq incf decf push pop pushnew rplaca rplacd rotatef \n"
"shiftf remf remprop remhash,  а также let* \n"
"\n"
"в которых нередко скрываются императивные программы. Применение этих \n"
"операторов, как облагаемых налогом, лишь помогает приблизиться к хорошему \n"
"Lisp-стилю, а не служит для него критерием. Тем не менее, лишь одно это \n"
"позволит вам удивительно далеко зайти."

#: texi/node-03.texi:217
msgid ""
"In other languages, one of the most common causes of side-effects is the "
"need\n"
"for a function to return multiple values. If functions can only return one "
"value,\n"
"they have to \"return\" the rest by altering their parameters. Fortunately, "
"this isn't\n"
"necessary in Common Lisp, because any function can return multiple values."
msgstr ""
"В других языках одной из наиболее частых причин возникновения побочных\n"
"эффектов является необходимость возврата функцией нескольких\n"
"значений. Если функции способны вернуть лишь одно значение, то они\n"
"должны \"возвращать\" оставшиеся путем изменения собственных\n"
"параметров. К счастью в Common Lisp в этом нет необходимости, так как любая\n"
"функция может вернуть несколько значений."

#: texi/node-03.texi:221
msgid ""
"The built-in function truncate returns two values, for example-the trun-\n"
"cated integer, and what was cut off in order to create it. A typical "
"implementation\n"
"will print both when truncate is called at the toplevel:"
msgstr ""
"Встроенная функция truncate возвращает два значения, например,\n"
"округленное целое и то, что было отрезано с целью его\n"
"создания. Типичная реализация напечатает оба, когда truncate\n"
"вызывается из верхнего уровня:\n"

#: texi/node-03.texi:227
msgid ""
"@example\n"
"> (truncate 26-21875)\n"
"26\n"
"0-21875\n"
"@end example"
msgstr ""
"@example\n"
"> (truncate 26.21875)\n"
"26\n"
"0.21875\n"
"@end example"

#: texi/node-03.texi:229
msgid "When the calling code only wants one value, the first one is used:"
msgstr "Когда вызывающий код требует одно значение, будет использовано первое:"

#: texi/node-03.texi:234
msgid ""
"@example\n"
"> (= (truncate 26-21875) 26)\n"
"T\n"
"@end example"
msgstr ""
"@example\n"
"> (= (truncate 26.21875) 26)\n"
"T\n"
"@end example"

#: texi/node-03.texi:238
msgid ""
"The calling code can catch both return values by using a multiple-value-"
"bind.\n"
"This operator takes a list of variables, a call, and a body of code. The "
"body is\n"
"evaluated with the variables bound to the respective return values from the "
"call:"
msgstr ""
"Вызывающий код может получить оба возвращаемых значения при помощи\n"
"multiple-value-bind. Этот оператор принимает список переменных, вызова,\n"
"а также тело программного кода. Код выполняется с привязкой переменных к\n"
"соответствующим значениям, возвращаемым вызовом:"

#: texi/node-03.texi:244
msgid ""
"@example\n"
"> (multiple-value-bind (int frac) (truncate 26-21875)\n"
"       (list int frac))\n"
"(26 0-21875)\n"
"@end example"
msgstr ""
"@example\n"
"> (multiple-value-bind (int frac) (truncate 26.21875)\n"
"       (list int frac))\n"
"(26 0.21875)\n"
"@end example"

#: texi/node-03.texi:246
msgid "Finally, to return multiple values, we use the values operator:"
msgstr ""
"Наконец, чтобы возвращать несколько значений, мы используем оператор\n"
"values:"

#: texi/node-03.texi:255
msgid ""
"@example\n"
"> (defun powers (x)\n"
"       (values x (sqrt x) (expt x 2)))\n"
"POWERS\n"
"> (multiple-value-bind (base root square) (powers 4)\n"
"       (list base root square))\n"
"(4 2-0 16)\n"
"@end example"
msgstr ""
"@example\n"
"> (defun powers (x)\n"
"       (values x (sqrt x) (expt x 2)))\n"
"POWERS\n"
"> (multiple-value-bind (base root square) (powers 4)\n"
"       (list base root square))\n"
"(4 2.0 16)\n"
"@end example"

#: texi/node-03.texi:266
msgid ""
"Functional programmingis a good idea in general. It is a particularly good "
"idea\n"
"in Lisp, because Lisp has evolved to support it. Built-in operators like "
"reverse\n"
"and nreverse are meant to be used in this way. Other operators, like values\n"
"and multiple-value-bind, have been provided specifically to make functional\n"
"programming easier.\n"
"@menu\n"
"* 3-2 Imperative Outside-In::   \n"
"* 3-3 Functional Interfaces::   \n"
"* 3-4 Interactive Programming::  \n"
"@end menu"
msgstr ""
"Вообще, функциональное программирование -- хорошая идея. И особенно\n"
"хорошая в Lisp, так как Lisp развивался для того, чтобы её\n"
"поддерживать. Встроенные операторы, такие как reverse и nreverse, \n"
"предполагается использовать в таком ключе. Другие операторы,\n"
"как values и multiple-value-bind, были разработаны как раз для того,\n"
"чтобы сделать функциональное программирование легче.\n"
"\n"
"@menu\n"
"* 3-2 Imperative Outside-In::   \n"
"* 3-3 Functional Interfaces::   \n"
"* 3-4 Interactive Programming::  \n"
"@end menu"

#: texi/node-03.texi:271
msgid ""
"@node 3-2 Imperative Outside-In, 3-3 Functional Interfaces, 3-1 Functional "
"Design, 3 Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-2 Imperative Outside-In\n"
"@cindex 3-2 Imperative Outside-In"
msgstr ""
"@node 3-2 Imperative Outside-In, 3-3 Functional Interfaces, 3-1 Functional "
"Design, 3 Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-2 Императивное программирование наизнанку\n"
"@cindex 3-2 Imperative Outside-In"

#: texi/node-03.texi:277
msgid ""
"The aims of functional programming may show more clearly when contrasted\n"
"with those of the more common approach, imperative programming. A "
"functional\n"
"program tells you what it wants; an imperative program tells you what to do. "
"A\n"
"functional program says \"Return a list of a and the square of the first "
"element of\n"
"x:\""
msgstr ""
"Возможно, цели функционального программирования станут более понятными\n"
"в процессе сравнения с другим, более распространенным подходом --\n"
"императивным программированием. Функциональная программа говорит вам\n"
"то, что она хочет; императивная же говорит вам, что\n"
"делать. Функциональная программа говорит: <<Вернуть список, состоящий\n"
"из a и квадрата первого элемента x>>:"

#: texi/node-03.texi:282
msgid ""
"@lisp\n"
"(defun fun (x)\n"
"  (list 'a (expt (car x) 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:285
msgid ""
"An imperative programs says \"Get the first element of x, then square it, "
"then return\n"
"a list of a and the square:\""
msgstr ""
"Императивная программа говорит: <<Взять первый элемент x, затем\n"
"возвести его в квадрат, затем вернуть список, состоящий из a и\n"
"квадрата>>:"

#: texi/node-03.texi:293
msgid ""
"@lisp\n"
"(defun imp (x)\n"
"  (let (y sqr)\n"
"        (setq y (car x))\n"
"        (setq sqr (expt y 2))\n"
"        (list 'a sqr)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:298
msgid ""
"Lisp users are fortunate in being able to write this program both ways. "
"Some\n"
"languages are only suited to imperative programming-notably Basic, along "
"with\n"
"most machine languages. In fact, the definition of imp is similar in form to "
"the\n"
"machine language code that most Lisp compilers would generate for fun."
msgstr ""
"Пользователям Lisp повезло в том, что они могут написать эту программу\n"
"любым из двух способов. Некоторые языки приспособлены только для\n"
"императивного программирования, среди большинства языков\n"
"программирования особенно выделяется Basic. В действительности,\n"
"определение imp по внешнему виду напоминает машинный код, который\n"
"генерирует большинство компиляторов? Вероятно, ради забавы.\n"

#: texi/node-03.texi:305
msgid ""
"Why write such code when the compiler could do it for you? For many\n"
"programmers, this question does not even arise. A language stamps its "
"pattern on\n"
"our thoughts: someone used to programming in an imperative language may "
"have\n"
"begun to conceive of programs in imperative terms, and may actually find it "
"easier\n"
"to write imperative programs than functional ones. This habit of mind is "
"worth\n"
"overcoming if you have a language that will let you."
msgstr ""
"Зачем писать такой код, который может сделать за вас компилятор? Для\n"
"многих программистов этот вопрос даже никогда не встает. Язык\n"
"накладывает шаблон на наши мысли: кто-то, кто привык программировать\n"
"на императивном языке, скорее всего, начнет планировать программу в\n"
"императивных выражениях и наверняка обнаружит, что написание\n"
"императивных программ легче, чем функциональных. Имеет смысл\n"
"перешагнуть через этот стереотип, если у вас есть язык, позволяющий\n"
"это сделать."

#: texi/node-03.texi:310
msgid ""
"For alumni of other languages, beginning to use Lisp may be like stepping\n"
"onto a skating rink for the first time. It's actually much easier to get "
"around on\n"
"ice than it is on dry land-if you use skates. Till then you will be left "
"wondering\n"
"what people see in this sport."
msgstr ""
"Те, кто изучил другие языки, начав использовать лисп, будут походить\n"
"на ступивших в первый раз на каток. Вообще-то, если использовать\n"
"коньки, то намного легче выйти на лед, чем на землю. А до тех пор вам\n"
"останется лишь гадать о том, что люди находят в этом спорте.\n"

#: texi/node-03.texi:316
msgid ""
"What skates are to ice, functional programming is to Lisp. Together the two\n"
"allow you to travel more gracefully, with less effort. But if you are "
"accustomed\n"
"to another mode of travel, this may not be your experience at first. One of\n"
"the obstacles to learning Lisp as a second language is learning to program "
"in a\n"
"functional style."
msgstr ""
"Функциональное программирование означает для Lisp то же, что и коньки\n"
"для льда. Вместе они позволят передвигаться более изящно и с меньшими\n"
"усилиями. Но если вам привычен иной способ перемещения, то этот стиль \n"
"не будет вашим первым опытом. Одно из препятствий к изучению Lisp в\n"
"качестве второго языка заключается в том, чтобы научиться\n"
"программировать в функциональном стиле."

#: texi/node-03.texi:321
msgid ""
"Fortunately there is a trick for transforming imperative programs into "
"func-\n"
"tional ones. You can begin by applying this trick to finished code. Soon you "
"will\n"
"begin to anticipate yourself, and transform your code as you write it. Soon "
"after\n"
"that, you will begin to conceive of programs in functional terms from the "
"start."
msgstr ""
"К счастью, есть хитрость, позволяющая преобразовать императивные\n"
"программы в функциональные. Можно начать с применения этой хитрости к\n"
"законченному коду. Вскоре вы начнете себя предвосхищать и\n"
"преобразовывать код по мере его написания. Вслед за этим, вы начнете\n"
"думать о программах в функциональном плане с самого начала."

#: texi/node-03.texi:325
msgid ""
"The trick is to realize that an imperative program is a functional program\n"
"turned inside-out. To find the functional program implicit in our imperative "
"one,\n"
"we just turn it outside-in. Let's try this technique on imp."
msgstr ""
"Хитрость заключается в том, чтобы понять, что императивная программа\n"
"представляет собой вывернутую на изнанку функциональную. Чтобы\n"
"отыскать запрятанную функциональную программу, мы просто вывернем ее\n"
"еще раз. Давайте попробуем этот метод на imp."

#: texi/node-03.texi:331
msgid ""
"The first thing we notice is the creation of y and sqr in the initial let. "
"This is\n"
"a sign that bad things are to follow. Like eval at runtime, uninitialized "
"variables\n"
"are so rarely needed that they should generally be treated as a symptom of "
"some\n"
"illness in the program. Such variables are often used like pins which hold "
"the\n"
"program down and keep it from coiling into its natural shape."
msgstr ""
"Первое, что мы замечаем -- это создание y и sqr в начальном let. Это\n"
"признак того, что плохие вещи впереди. Как eval во время выполнения,\n"
"неинициализированные переменные необходимы настолько редко, что они в\n"
"большинстве случаев должны рассматриваться как симптом некоторых\n"
"заболеваний программы. Такие переменные часто используются как\n"
"булавки, удерживающие программу от скручивания в естественную форму."

#: texi/node-03.texi:338
msgid ""
"However, we ignore them for the time being, and go straight to the end of\n"
"the function. What occurs last in an imperative program occurs outermost in "
"a\n"
"functional one. So our first step is to grab the final call to list and "
"begin stuffing\n"
"the rest of the program inside it-just like turning a shirt inside-out. We "
"continue\n"
"by applying the same transformation repeatedly, just as we would with the "
"sleeves\n"
"of the shirt, and in turn with their cuffs."
msgstr ""
"Несмотря на это, мы на время оставим их в покое и перейдем прямо в\n"
"конец функции. То, что в императивной программе происходит последним,\n"
"в функциональной происходит вначале. Таким образом, наш первый шаг -- \n"
"взять последний вызов создания списка(list) и начать набивать туда "
"оставшуюся часть\n"
"программы в точности, как выворачивают рубашку наизнанку. Мы\n"
"продолжим многократно применять такое же преобразование так же, как\n"
"поступили бы с рукавами рубашки, а затем и с манжетами.\n"

#: texi/node-03.texi:340
msgid "Starting at the end, we replace sqr with (expt y 2), yielding:"
msgstr "Начиная с конца, мы переместим sqr вместе с (expt y 2):"

#: texi/node-03.texi:344
msgid ""
"@lisp\n"
"(list 'a (expt y 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:346
msgid "Then we replace y by (car x):"
msgstr "Затем заменим y на (car x):"

#: texi/node-03.texi:350
msgid ""
"@lisp\n"
"(list 'a (expt (car x) 2))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:354
msgid ""
"Now we can throw away the rest of the code, having stuffed it all into the "
"last\n"
"expression. In the process we removed the need for the variables y and sqr,"
"so\n"
"we can discard the let as well."
msgstr ""
"Теперь мы можем выкинуть оставшийся код, который полностью вошел в\n"
"последнее выражение. В ходе этого процесса мы убрали необходимость в\n"
"переменных y и sqr, так что мы можем также избавиться и от let."

#: texi/node-03.texi:359
msgid ""
"The final result is shorter than what we began with, and easier to "
"understand.\n"
"In the original code, we're faced with the final expression (list 'a sqr), "
"and\n"
"it's not immediately clear where the value of sqr comes from. Now the source "
"of\n"
"the return value is laid out for us like a road map."
msgstr ""
"Окончательный результат короче, чем тот, с которого мы начинали, и\n"
"легче для понимания. В первоначальном коде мы столкнулись с последним\n"
"выражением (list 'a sqr), но не сразу понятно, откуда берется значение\n"
"sqr. Теперь источник возвращаемого значения открыт нашему взору, как\n"
"дорожная карта."

#: texi/node-03.texi:364
msgid ""
"The example in this section was a short one, but the technique scales up.\n"
"Indeed, it becomes more valuable as it is applied to larger functions. Even\n"
"functions which perform side-effects can be cleaned up in the portions "
"which\n"
"don't."
msgstr ""
"Пример в этом разделе был коротким, но технология масштабируется. В\n"
"самом деле, она становится более ценной, если применяется к функциям\n"
"большего размера. Даже функции, осуществляющие побочные действия,\n"
"можно разобрать на части, которые не будут этого делать.\n"

#: texi/node-03.texi:369
msgid ""
"@node 3-3 Functional Interfaces, 3-4 Interactive Programming, 3-2 Imperative "
"Outside-In, 3 Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-3 Functional Interfaces\n"
"@cindex 3-3 Functional Interfaces"
msgstr ""
"@node 3-3 Functional Interfaces, 3-4 Interactive Programming, 3-2 Imperative "
"Outside-In, 3 Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-3 Функциональные интерфейсы\n"
"@cindex 3-3 Functional Interfaces"

#: texi/node-03.texi:372
msgid ""
"Some side-effects are worse than others. For example, though this function "
"calls\n"
"nconc"
msgstr ""
"Некоторые побочные действия хуже, чем другие. Например, хотя эта\n"
"функция вызывает nconc\n"

#: texi/node-03.texi:377
msgid ""
"@lisp\n"
"(defun qualify (expr)\n"
"  (nconc (copy-list expr) (list 'maybe)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:384
msgid ""
"it preserves referential transparency.@footnote{A definition of\n"
"referential transparency appears on page 198.} If you call it with a\n"
"given argument, it will always return the same (equal) value. From the\n"
"caller's point of view, qualify might as well be purely functional\n"
"code. We can't say the same for bad-reverse (page 29), which actually\n"
"modifies its argument."
msgstr ""
"она оставляет ссылочную прозрачность.@footnote{ Определение ссылочной \n"
"прозрачности приводится на странице 198} Если вы вызовете ее с \n"
"заданным аргументом, то она всегда будет возвращать такое же (равное)\n"
"значение. С точки зрения вызывающего, qualify также может считаться\n"
"чисто функциональным кодом. Чего нельзя сказать того же о bad-reverse\n"
"(стр. 29), которая фактически модифицирует свои аргументы."

#: texi/node-03.texi:390
msgid ""
"Instead of treating all side-effects as equally bad, it would be helpful if "
"we had\n"
"some way of distinguishing between such cases. Informally, we could say that "
"it's\n"
"harmless for a function to modify something that no one else owns. For "
"example,\n"
"the nconc in qualify is harmless because the list given as the first "
"argument is\n"
"freshly consed. No one else could own it."
msgstr ""
"Вместо того, чтобы рассматривать побочные действия как одинаково\n"
"плохие, было бы полезно, если бы мы каким-то образом могли находить\n"
"различия между такими случаями. Неформально можно сказать, что для\n"
"функции безвредно модифицировать что-то, чем никто не\n"
"владеет. Например, nconc в qualify является безвредной потому, что\n"
"список, переданный в качестве первого аргумента, только что\n"
"создан (consed). Больше никто не может быть его владельцем."

#: texi/node-03.texi:393
msgid ""
"In the general case, we have to talk about ownership not by functions, but "
"by\n"
"invocations of functions. Though no one else owns the variable x here,"
msgstr ""
"В общем случае, следует говорить не о том, чем владеют сами функции, а\n"
"о том, чем владеют вызовы функций. Хотя здесь никто не владеет\n"
"переменной x:"

#: texi/node-03.texi:399
msgid ""
"@lisp\n"
"(let ((x 0))\n"
"  (defun total (y)\n"
"        (incf x y)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:402
msgid ""
"the effects of one call will be visible in succeeding ones. So the rule "
"should be: a\n"
"given invocation can safely modify what it uniquely owns."
msgstr ""
"эффекты одного вызова будут видны в последующих. Поэтому правило\n"
"должно быть таким: данный вызов может безопасно изменять лишь то, чем\n"
"владеет только он."

#: texi/node-03.texi:408
msgid ""
"Who owns arguments and return values? The convention in Lisp seems to be\n"
"that an invocation owns objects it receives as return values, but not "
"objects passed\n"
"to it as arguments. Functions that modify their arguments are distinguished "
"by the\n"
"label \"destructive,\" but there is no special name for functions that "
"modify objects\n"
"returned to them."
msgstr ""
"Кто владеет аргументами и возвращаемыми значениями? По соглашению в\n"
"Lisp считается, что вызов владеет объектами, полученными в качестве\n"
"возвращаемых значений, но не объектами, переданными ему в качестве\n"
"аргументов. Функции, изменяющие свои аргументы, определяются с помощью\n"
"метки \"деструктивный\", но нет никакого специального названия для\n"
"функций, изменяющих возвращенные им объекты."

#: texi/node-03.texi:410
msgid "This function adheres to the convention, for example:"
msgstr "Например, эта функция придерживается соглашения:"

#: texi/node-03.texi:415
msgid ""
"@lisp\n"
"(defun ok (x)\n"
"  (nconc (list 'a x) (list 'c)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:418
msgid ""
"It calls nconc, which doesn't, but since the list spliced by nconc will "
"always be\n"
"freshly made rather than, say, a list passed to ok as an argument, ok itself "
"is ok."
msgstr ""
"Она вызывает nconc, который не придерживается [соглашения], но\n"
"поскольку список, объединяемый с помощью nconc будет всегда создаваться "
"заново, в отличие,\n"
"например, от списка, переданного ok в качестве аргумента, ok сам по\n"
"себе будет придеживаться функционального интерфейса."

#: texi/node-03.texi:420
msgid "If it were written slightly differently, however,"
msgstr "Тем не менее, если она была бы написана несколько иначе, "

#: texi/node-03.texi:425
msgid ""
"@lisp\n"
"(defun not-ok (x)\n"
"  (nconc (list 'a) x (list 'c)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:427
msgid "then the call to nconc would be modifying an argument passed to not-ok."
msgstr "вызов nconc изменил бы аргумент, переданный not-ok."

#: texi/node-03.texi:432
msgid ""
"Many Lisp programs violate this convention, at least locally. However, as "
"we\n"
"saw with ok, local violations need not disqualify the calling function. And "
"func-\n"
"tions which do meet the preceding conditions will retain many of the "
"advantages\n"
"of purely functional code."
msgstr ""
"Многие Lisp программисты нарушают это соглашение, по крайней мере\n"
"локально. Однако, как мы видели в ok, локальные нарушения не должны\n"
"делать негодной вызывающую функцию. И функции, действительно\n"
"отвечающие предыдущим условиям, будут содержать в себе множество\n"
"преимуществ чисто функционального кода."

#: texi/node-03.texi:437
msgid ""
"To write programs that are really indistinguishable from functional code, "
"we\n"
"have to add one more condition. Functions can't share objects with other "
"code\n"
"that doesn't follow the rules. For example, though this function doesn't "
"have\n"
"side-effects,"
msgstr ""
"Чтобы писать программы, действительно не отличимые от функционального\n"
"кода, мы должны добавить еще одно условие. Функции не могут совместно\n"
"использовать объекты с кодом, который не следует установленным нами "
"правилам. \n"
"Например, хотя эта функция и не имеет побочных эффектов,"

#: texi/node-03.texi:442
msgid ""
"@lisp\n"
"(defun anything (x)\n"
"      (+ x *anything*))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:445
msgid ""
"its return value depends on the global variable *anything*. So if any other\n"
"function can alter the value of this variable, anything could return "
"anything."
msgstr ""
"ее значение зависит от глобальной переменной *anything*. Так, если\n"
"любая другая функция может изменять значение этой переменной, то\n"
"anything может возвращать что угодно."

#: texi/node-03.texi:451
msgid ""
"Code written so that each invocation only modifies what it owns is almost "
"as\n"
"good as purely functional code. A function that meets all the preceding "
"conditions\n"
"at least presents a functional interface to the world: if you call it twice "
"with the\n"
"same arguments, you should get the same results. And this, as the next "
"section\n"
"will show, is a crucial ingredient in bottom-up programming."
msgstr ""
"Код, написанный в стиле, когда каждый вызов изменяет лишь только\n"
"то, чем он владеет, почти так же хорош, как и чисто функциональный\n"
"код. Функция, удовлетворяющая всем приведенным выше условиям,\n"
"представляет миру функциональный интерфейс: если вызвать ее дважды с\n"
"теми же аргументами, то вы должны получить одинаковые результаты. И\n"
"это, как будет показано в следующем разделе, является важным\n"
"ингредиентом в программировании снизу-вверх."

#: texi/node-03.texi:457
msgid ""
"One problem with destructive operations is that, like global variables, they "
"can\n"
"destroy the locality of a program. When you're writing functional code, you "
"can\n"
"narrow your focus: you only need consider the functions that call, or are "
"called\n"
"by, the one you're writing. This benefit disappears when you want to modify\n"
"something destructively. It could be used anywhere."
msgstr ""
"Одна из проблем с деструктивными операциями заключается в том, что,\n"
"как и глобальные переменные, они могут разрушить локальность программы. \n"
"Во время написания функционального кода, вы можете сузить свое поле \n"
"зрения: необходимо рассмотреть лишь функции, которые вызывают ту или \n"
"вызываются той, которую вы пишете. Данное преимущество исчезает, \n"
"если вы хотите изменить что-то деструктивно. Это может быть\n"
"использовано где угодно."

#: texi/node-03.texi:461
msgid ""
"The conditions above do not guarantee the perfect locality you get with "
"purely\n"
"functional code, though they do improve things somewhat. For example, "
"suppose\n"
"that f calls g as below:"
msgstr ""
"Приведенные выше условия не гарантируют, что вы получите идеальную\n"
"локальность вместе с чисто функциональным кодом, хотя они несколько\n"
"улучшают положение вещей. Например, предположим, что f вызывает g, как\n"
"показано ниже:\n"

#: texi/node-03.texi:468
msgid ""
"@lisp\n"
"(defun f (x)\n"
"      (let ((val (g x)))\n"
"       ; safe to modify val here?\n"
"       ))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:471
msgid ""
"Is it safe for f to nconc something onto val? Not if g is identity: then we\n"
"would be modifying something originally passed as an argument to f itself."
msgstr ""
"Безопасно ли для f присоединить что-нибудь к val с помощью nconc? Нет,\n"
"если g тождество(простое переименование переменных): тогда мы бы изменяли "
"что-то,\n"
"изначально переданное самой f в качестве аргумента."

#: texi/node-03.texi:476
msgid ""
"So even in programs which do follow the convention, we may have to look\n"
"beyond f if we want to modify something there. However, we don't have to\n"
"look as far: instead of worrying about the whole program, we now only have "
"to\n"
"consider the subtree beginning with f."
msgstr ""
"Поэтому, даже в программах, которые следуют соглашению, нам, возможно,\n"
"придется выйти за пределы f в том случае, если мы захотим там что-то\n"
"изменить. Тем не менее, не придется идти слишком далеко: вместо того,\n"
"чтобы беспокоиться о всей программе, теперь только лишь нужно\n"
"рассмотреть поддерево, начиная с f."

#: texi/node-03.texi:481
msgid ""
"A corollary of the convention above is that functions shouldn't return "
"anything\n"
"that isn't safe to modify. Thus one should avoid writing functions whose "
"return\n"
"values incorporate quoted objects. If we define exclaim so that its return "
"value\n"
"incorporates a quoted list,"
msgstr ""
"Следствием приведенного выше соглашения является то, что те функции не\n"
"должны возвращать ничего, что небезопасно изменять. Таким образом,\n"
"следует избегать написания функций, возвращаемые значения которых\n"
"включают в себя квотированные объекты. Если мы определим excalaim так,\n"
"что его возвращаемые значения включают в себя квотированный список, то"

#: texi/node-03.texi:486
msgid ""
"@lisp\n"
"(defun exclaim (expression)\n"
"  (append expression '(oh my)))\n"
"@end lisp"
msgstr ""
"@anchor{page-037}\n"
"@lisp\n"
"(defun exclaim (expression)\n"
"  (append expression '(oh my)))\n"
"@end lisp"

#: texi/node-03.texi:488
msgid "Then any later destructive modification of the return value"
msgstr "Тогда любое последующее деструктивное изменение возвращаемого значения"

#: texi/node-03.texi:495
msgid ""
"@example\n"
"> (exclaim '(lions and tigers and bears))\n"
"(LIONS AND TIGERS AND BEARS OH MY)\n"
"> (nconc * '(goodness))\n"
"(LIONS AND TIGERS AND BEARS OH MY GOODNESS)\n"
"@end example"
msgstr ""

#: texi/node-03.texi:497
msgid "could alter the list within the function:"
msgstr "может изменить список внутри функции!!!:"

#: texi/node-03.texi:502
msgid ""
"@example\n"
"> (exclaim '(fixnums and bignums and floats))\n"
"(FIXNUMS AND BIGNUMS AND FLOATS OH MY GOODNESS)\n"
"@end example"
msgstr ""

#: texi/node-03.texi:504
msgid "To make exclaim proof against such problems, it should be written:"
msgstr ""
"Для того чтобы сделать exclaim защищенной от такого рода проблем, ее\n"
"следовало написать так:"

#: texi/node-03.texi:509
msgid ""
"@lisp\n"
"(defun exclaim (expression)\n"
"  (append expression (list 'oh 'my)))\n"
"@end lisp"
msgstr ""

#: texi/node-03.texi:514
msgid ""
"There is one major exception to the rule that functions shouldn't return "
"quoted\n"
"lists: the functions which generate macro expansions. Macro expanders can\n"
"safely incorporate quoted lists in the expansions they generate, if the "
"expansions\n"
"are going straight to the compiler."
msgstr ""
"Существует одно важное исключение из того правила, что функции не\n"
"должны возвращать квотированные списки: это функции, которые генерируют\n"
"макрорасширения. Макрорасширители могут без проблем включать\n"
"квотированные списки в порождаемые ими расширения в том случае, если\n"
"макрорасширения прямо передаются компилятору."

#: texi/node-03.texi:518
msgid ""
"Otherwise, one might as well be a suspicious of quoted lists generally. "
"Many\n"
"other uses of them are likely to be something which ought to be done with a "
"macro\n"
"like in (page 152)."
msgstr ""
"С другой стороны, можно было бы также с подозрением относиться к\n"
"квотированным спискам в целом. Можно придумать им и множество других\n"
"применений, которые скорее всего будут выполнены с помощью макросов\n"
"наподобие in."

#: texi/node-03.texi:523
msgid ""
"@node 3-4 Interactive Programming,  , 3-3 Functional Interfaces, 3 "
"Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-4 Interactive Programming\n"
"@cindex 3-4 Interactive Programming"
msgstr ""
"@node 3-4 Interactive Programming,  , 3-3 Functional Interfaces, 3 "
"Functional Programming\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 3-4 Интерактивное программирование\n"
"@cindex 3-4 Interactive Programming"

#: texi/node-03.texi:529
msgid ""
"The previous sections presented the functional style as a good way of "
"organizing\n"
"programs. But it is more than this. Lisp programmers did not adopt the "
"functional\n"
"style purely for aesthetic reasons. They use it because it makes their work "
"easier.\n"
"In Lisp's dynamic environment, functional programs can be written with "
"unusual\n"
"speed, and at the same time, can be unusually reliable."
msgstr ""
"Предыдущие разделы представляли функциональное программирование как\n"
"хороший способ организации программ. Но это нечто  большее. \n"
"Lisp-программисты приняли функциональный стиль не только из\n"
"эстетических соображений. Они используют его потому, что он облегчает\n"
"им работу. В динамическом окружении Lisp функциональные программы\n"
"могут быть написаны с необыкновенной быстротой и в то же время\n"
"необычайно надёжны."

#: texi/node-03.texi:535
msgid ""
"In Lisp it is comparatively easy to debug programs. A lot of information is\n"
"available at runtime, which helps in tracing the causes of errors. But even "
"more\n"
"important is the ease with which you can test programs. You don't have to "
"compile\n"
"a program and test the whole thing at once. You can test functions "
"individually\n"
"by calling them from the toplevel loop."
msgstr ""
"В Lisp относительно легко отлаживать программы. Очень много информации, \n"
"помогающей найти причины возникновения ошибок, можно получить во время \n"
"выполнения. Но еще более важным является легкость, с которой вы можете \n"
"тестировать программы. Нет необходимости компилировать программу и \n"
"тестировать все целиком за один раз. Вы  можете протестировать функции \n"
"по отдельности, вызывая их из цикла верхнего уровня."

#: texi/node-03.texi:544
msgid ""
"Incremental testing is so valuable that Lisp style has evolved to take "
"advantage\n"
"of it. Programs written in the functional style can be understood one "
"function at a\n"
"time, and from the point of view of the reader this is its main advantage. "
"However,\n"
"the functional style is also perfectly adapted to incremental testing: "
"programs\n"
"written in this style can also be tested one function at a time. When a "
"function\n"
"neither examines nor alters external state, any bugs will appear "
"immediately. Such\n"
"a function can affect the outside world only through its return values. "
"Insofar as\n"
"these are what you expected, you can trust the code which produced them."
msgstr ""
"Инкрементное тестирование настолько значимо, что для того, чтобы получить "
"выигрыш \n"
"от его использоывания, Lisp стиль эволюционировал. Программы, написанные в \n"
"функциональном стиле, можно воспринимать по одной функции за раз, и с точки "
"зрения\n"
"читающего, это и есть его главное достоинство. Тем не менее, функциональный "
"стиль\n"
"прекрасно приспособлен к инкрементному тестированию: программы, написанные в "
"этом \n"
"стиле, можно также протестировать по одной функции за раз. Когда функция "
"не \n"
"анализирует и не изменяет внешнего состояния, любые ошибки немедленно "
"проявятся. \n"
"Такая функция может влиять на внешний мир только через свои возвращаемые "
"значения. \n"
"В тех же пределах, в каких вы полагаетесь на эти значения, вы можете "
"доверять\n"
"вернувшему их коду."

#: texi/node-03.texi:547
msgid ""
"Experienced Lisp programmers actually design their programs to be easy to\n"
"test:"
msgstr ""
"Опытные Lisp-программисты фактически делают свои программы удобными\n"
"для тестирования:"

#: texi/node-03.texi:558
msgid ""
"@enumerate\n"
"@item\n"
"They try to segregate side-effects in a few functions, allowing the greater\n"
"part of the program to be written in a purely functional style.\n"
"@item\n"
"If a function must perform side-effects, they try at least to give it a\n"
"functional interface.\n"
"@item\n"
"They give each function a single, well-defined purpose.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Они пытаются отделить побочные действия в несколько функций, позволяющих \n"
"большей части программы быть написанной в чисто функциональном стиле.\n"
"@item\n"
"Если функция должна осуществлять побочные действия, они по крайней\n"
"мере пытаются дать ей функциональный интерфейс.\n"
"@item\n"
"Они дают каждой функции единственную, четко определенную цель.\n"
"@end enumerate"

#: texi/node-03.texi:562
msgid ""
"When a function is written, they can test it on a selection of "
"representative cases,\n"
"then move on to the next one. If each brick does what it's supposed to do, "
"the wall\n"
"will stand."
msgstr ""
"Когда функция написана, они могут проверить ее на выборке из типичных "
"случаев, а \n"
"затем перейти к следующей. Если каждый кирпич делает то же, что и "
"предполагалось \n"
"делать, то стена будет стоять."

#: texi/node-03.texi:571
msgid ""
"In Lisp, the wall can be better-designed as well. Imagine the kind of "
"conver-\n"
"sation you would have with someone so far away that there was a "
"transmission\n"
"delay of one minute. Now imagine speaking to someone in the next room. You\n"
"wouldn't just have the same conversation faster, you would have a different "
"kind\n"
"of conversation. In Lisp, developing software is like speaking face-to-face. "
"You\n"
"can test code as you're writing it. And instant turnaround has just as "
"dramatic an\n"
"effect on development as it does on conversation. You don't just write the "
"same\n"
"program faster; you write a different kind of program."
msgstr ""
"С таким же успехом в Lisp стену можно спроектировать лучшим образом. "
"Представьте себе,\n"
"что если бы вы разговаривали с кем-то, находящимся настолько далеко, что "
"задержки \n"
"передачи составляли бы одну минуту. Теперь представьте разговор с кем-то, "
"находящимся\n"
"в соседней комнате. Это бы не сделало прежний разговор быстрее, это был бы "
"другой\n"
"вид разговора. В Lisp разработка программ похожа на разговор лицом к  "
"лицу. \n"
"Можно проверять код по мере его написания. И стоит вам отвернуться, и это "
"возымеет\n"
"такие же резкие последствия на разработку, какие оказало бы на беседу. \n"
"Вы не просто пишете ту же программу быстрее, вы пишете программу иного вида."

#: texi/node-03.texi:580
msgid ""
"How so? When testing is quicker you can do it more often. In Lisp, as in "
"any\n"
"language, development is a cycle of writing and testing. But in Lisp the "
"cycle is\n"
"very short: single functions, or even parts of functions. And if you test "
"everything\n"
"as you write it, you will know where to look when errors occur: in what you\n"
"wrote last. Simple as it sounds, this principle is to a large extent what "
"makes\n"
"bottom-up programming feasible. It brings an extra degree of confidence "
"which\n"
"enables Lisp programmers to break free, at least part of the time, from the "
"old\n"
"plan-and-implement style of software development."
msgstr ""
"Как так? Когда тестирование быстрее, его можно делать чаще. В Lisp, как и в "
"любом \n"
"языке, разработка - это цикл написания и тестирования. Но в Lisp этот цикл "
"очень\n"
"короткий: одиночная функция или части функций. А если проверять все по "
"мере \n"
"написания, то в случае возникновения ошибки, вы будете знать, где искать: в "
"конце\n"
"написанного. Как бы просто это ни выглядело, но именно этот принцип, в\n"
"большей степени, позволяет программированию снизу-вверх быть возможным. \n"
"Это приносит дополнительную степень уверенности, позволяющую Lisp-"
"программистам \n"
"свободно отдыхать, по крайней мере часть времени, от старого стиля "
"разработки \n"
"программного обеспечения \"спланируй и реализуй\"."

#: texi/node-03.texi:586
msgid ""
"Section 1-1 stressed that bottom-up design is an evolutionary process. You\n"
"build up a language as you write a program in it. This approach can work "
"only\n"
"if you trust the lower levels of code. If you really want to use this layer "
"as a\n"
"language, you have to be able to assume, as you would with any language, "
"that\n"
"any bugs you encounter are bugs in your application and not in the language "
"itself."
msgstr ""
"В раздел 1.1 отмечено, что проектирование снизу-вверх -- эволюционный\n"
"процесс. Вы создаете язык по мере написания на нем программы. Такой\n"
"подход может работать, только если вы доверяете нижним слоям\n"
"кода. Если вы действительно хотите использовать этот слой как язык, то\n"
"вы должны уметь допускать, как и в случае с любым языком, что любые\n"
"обнаруженные ошибки -- это ошибки приложения, а не самого языка.\n"

#: texi/node-03.texi:592
msgid ""
"So your new abstractions are supposed to bear this heavy burden of "
"responsi-\n"
"bility, and yet you're supposed to just spin them off as the need arises? "
"Just so; in\n"
"Lisp you can have both. When you write programs in a functional style and "
"test\n"
"them incrementally, you can have the flexibility of doing things on the spur "
"of the\n"
"moment, plus the kind of reliability one usually associates with careful "
"planning."
msgstr ""
"Итак, ваши новые абстракции должны нести это тяжелое бремя "
"ответственности, \n"
"и все же вы собираетесь создавать на их основе новые?\n"
"Именно так, в Lisp это возможно одновременно. Когда вы пишете\n"
"программы в функциональном стиле и инкрементно тестируете их, можно\n"
"получить гибкость создания вещей под влиянием момента вдобавок к\n"
"некоторой надежности, обычно ассоциируемой с тщательным планированием."
