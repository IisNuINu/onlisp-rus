#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-24.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-17 23:37+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-24.texi:5
msgid ""
"@node 24 Prolog, 25 Object-Oriented Lisp, 23 Parsing with ATNs, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 24 Prolog\n"
"@cindex 24 Prolog"
msgstr ""
"@node 24 Prolog, 25 Object-Oriented Lisp, 23 Parsing with ATNs, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 24 Пролог\n"
"@cindex 24 Prolog"

#: texi/node-24.texi:12
msgid ""
"This chapter describes how to write Prolog as an embedded language. Chapter "
"19\n"
"showed how to write a program which answered complex queries on databases.\n"
"Here we add one new ingredient: rules, which make it possible to infer facts "
"from\n"
"those already known. A set of rules defines a tree of implications. In order "
"to use\n"
"rules which would otherwise imply an unlimited number of facts, we will "
"search\n"
"this implication tree nondeterministically."
msgstr ""
"В этой главе описывается как написать  Prolog как встроенный язык. Глава 19\n"
"показала как написать программу, которая отвечала бы на сложные запросы в "
"базах\n"
"данных. Здесь мы добавляем один новый инградиент: правила, которые позволяют "
"выводить\n"
"факты из уже известных. Набор правил определяет дерево следствий. Чтобы "
"использовать\n"
"правила, котоыре в противном случае подразумевали бы неограниченное "
"количество\n"
"фактов, мы будем искать это дерево следствий недетерминированным образом."

#: texi/node-24.texi:19
msgid ""
"Prolog makes an excellent example of an embedded language. It combines\n"
"three ingredients: pattern-matching, nondeterminism, and rules. Chapters 18\n"
"and 22 give us the first two independently. By building Prolog on top of "
"the\n"
"pattern-matching and nondeterministic choice operators we have already, we "
"will\n"
"have an example of a real, multi-layer bottom-up system. Figure 24-1 shows "
"the\n"
"layers of abstraction involved."
msgstr ""
"Prolog дает отличный пример встроенного языка. Он объединяет три "
"компонента:\n"
"сопоставление с образцом(pattern-matching), недетерминизм и правила. Главы "
"18\n"
"и 22 дают нам первые два независимо. Посторив Prolog поверх уже "
"существующих\n"
"операторов сопоставления с образцом и недетермининованного выбора, мы "
"получим\n"
"пример реальной многослойной(уровневой) восходящей системы. На рисунке "
"24-1 \n"
"показаны соответствующие уровни абстракци."

#: texi/node-24.texi:24
msgid ""
"The secondary aim of this chapter is to study Prolog itself. For "
"experienced\n"
"programmers, the most convenient explanation of Prolog may be a sketch of "
"its\n"
"implementation. Writing Prolog in Lisp is particularly interesting, because "
"it\n"
"brings out the similarities between the two languages."
msgstr ""
"Вторичной целью этой главы является изучение самого пролога. Для опытных "
"программистов\n"
"наиболее удобным объяснением Prolog-а может быть набросок его реализации.\n"
"Написание Пролога на Лиспе особенно интересно, потому что оно выявляет "
"сходство\n"
"между двумя языками."

#: texi/node-24.texi:35
msgid ""
"@menu\n"
"* 24-1 Concepts::               \n"
"* 24-2 An Interpreter::         \n"
"* 24-3 Rules::                  \n"
"* 24-4 The Need for Nondeterminism::  \n"
"* 24-5 New Implementation::     \n"
"* 24-6 Adding Prolog Features::  \n"
"* 24-7 Examples::               \n"
"* 24-8 The Senses of Compile::  \n"
"@end menu"
msgstr ""

#: texi/node-24.texi:40
msgid ""
"@node 24-1 Concepts, 24-2 An Interpreter, 24 Prolog, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-1 Concepts\n"
"@cindex 24-1 Concepts"
msgstr ""
"@node 24-1 Concepts, 24-2 An Interpreter, 24 Prolog, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-1 Концепции(идеи)\n"
"@cindex 24-1 Concepts"

#: texi/node-24.texi:45
msgid ""
"Chapter 19 showed how to write a database system which would accept complex\n"
"queries containing variables, and generate all the bindings which made the "
"query\n"
"true in the database. In the following example, (after calling clear-db) we "
"assert\n"
"two facts and then query the database:"
msgstr ""
"Глава 19 показала, как написать систему базы данных, которая будет принимать "
"сложные\n"
"запросы, содержащие переменные, и генерировать все привязки, которые сделали "
"запрос\n"
"истинным в базе данных. В следующем примере (после вызова clear-db) мы "
"утверждаем\n"
"два факта и затем запрашиваем базу данных:"

#: texi/node-24.texi:63
msgid "                              Figure 24-1: Layers of abstraction."
msgstr ""
"@cartouche\n"
"                              Рисунок 24-1: Уровни абстракции.\n"
"@end cartouche"

#: texi/node-24.texi:77
msgid ""
"@example\n"
"> (fact painter reynolds)\n"
"(REYNOLDS)\n"
"> (fact painter gainsborough)\n"
"(GAINSBOROUGH)\n"
"> (with-answer (painter ?x)\n"
"         (print ?x))\n"
"GAINSBOROUGH\n"
"REYNOLDS\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-24.texi:81
msgid ""
"Conceptually, Prolog is the database program with the addition of rules, "
"which\n"
"make it possible to satisfy a query not just by looking it up in the "
"database, but by\n"
"inferring it from other known facts. For example, if we have a rule like:"
msgstr ""
"Концептуально Prolog  - это программа базы данных с добавлением правил, "
"которые позволяют\n"
"удовлетворить запрос не только путем поиска его в базе данных, но и путем "
"вывода его\n"
"из других известных фактов. Например, если у на есть правило, подобное:"

#: texi/node-24.texi:86
msgid ""
"@example\n"
"If       (hungry ?x) and (smells-of ?x turpentine)\n"
"Then (painter ?x)\n"
"@end example"
msgstr ""
"@example\n"
"If       (hungry ?x) and (smells-of ?x turpentine)\n"
"Then (painter ?x)\n"
"если ?х голодный и пахнет скипидаром, тогда он художник! (глубокомысленно)\n"
"\n"
"@end example"

#: texi/node-24.texi:91
msgid ""
"@noindent\n"
"then the query (painter ?x) will be satisfied for ?x = raoul when the "
"database\n"
"contains both (hungry raoul) and (smells-of raoul turpentine),even\n"
"if it doesn't contain (painter raoul)."
msgstr ""
"@noindent\n"
"тогда запрос (painter ?x) будет удовлетворен для ?x = raoul, если база "
"данных\n"
"содержит как (hungry raoul), так  и (smells-of raoul turpentine), даже если\n"
"она не содержит (painter raoul)."

#: texi/node-24.texi:99
msgid ""
"In Prolog, the if-part of a rule is called the body, and the then-part the "
"head.\n"
"(In logic, the names are antecedent and consequent, but it is just as well "
"to have\n"
"separate names, to emphasize that Prolog inference is not the same as "
"logical\n"
"implication.) When trying to establish bindings@footnote{Many of the "
"concepts used in this chapter, including this sense of bindings, are "
"explained in Section 18-4.} for a query, the program looks\n"
"first at the head of a rule. If the head matches the query that the program "
"is trying\n"
"to answer, the program will then try to establish bindings for the body of "
"the rule.\n"
"Bindings which satisfy the body will, by definition, satisfy the head."
msgstr ""
"В Prolog-е, if-часть правила(условие) называется телом, а then-"
"часть(следствие) - головой.\n"
"(В логике, имена антседент(antecedent)/предшествие и "
"консекуент(consequent)последствие, \n"
"но с тем же успехом можно было присвоить и другие имена, подчеркивают то, "
"что в  Prolog\n"
"логический вывод это не тоже самое что логический.) При попытке установить "
"привязки\n"
"@footnote{Многие понятия, используемые в этой главе, включая значение "
"привязка, объяснены\n"
"в Главе 18-4.} для запроса, программа смотрит вначале на голову правила. "
"Если голова \n"
"соответствует запросу, на который пытается ответить программа, она "
"попытается установить\n"
"привязки для тела правила. Привязки которые удовлетворяют тело, по "
"определению, удовлетворяют\n"
"и голову."

#: texi/node-24.texi:101
msgid ""
"The facts used in the body of the rule may in turn be inferred from other "
"rules:"
msgstr ""
"Факты используемые в теле правила, могут быть в свою очередь, выведены из "
"других\n"
"правил:"

#: texi/node-24.texi:106
msgid ""
"@example\n"
"If      (gaunt ?x) or (eats-ravenously ?x)\n"
"Then (hungry ?x)\n"
"@end example"
msgstr ""

#: texi/node-24.texi:108
msgid "and rules may be recursive, as in:"
msgstr "и правила могут быть рекурсивными, как в:"

#: texi/node-24.texi:113
msgid ""
"@example\n"
"If      (surname ?f ?n) and (father ?f ?c)\n"
"Then (surname ?c ?n)\n"
"@end example"
msgstr ""

#: texi/node-24.texi:118
msgid ""
"Prolog will be able to establish bindings for a query if it can find some "
"path\n"
"through the rules which leads eventually to known facts. So it is "
"essentially a\n"
"search engine: it traverses the tree of logical implications formed by the "
"rules,\n"
"looking for a successful path."
msgstr ""
"Prolog сможет установить привязки для запроса, если он сможет найти какой-"
"то\n"
"путь через правила, который в конечном итоге приведет к известным фактам. "
"Таким\n"
"образом, это по сути поисковая система: она обходит дерево логических "
"следствий,\n"
"сформированных правилами, ища успешный путь."

#: texi/node-24.texi:124
msgid ""
"Though rules and facts sound like distinct types of objects, they are "
"conceptu-\n"
"ally interchangeable. Rules can be seen as virtual facts. If we want our "
"database\n"
"to reflect the discovery that big, fierce animals are rare, we could look "
"for all the\n"
"x such that there are facts (species x), (big x), and (fierce x), and add a\n"
"new fact (rare x). However, by defining a rule to say"
msgstr ""
"Хотя правила и факты звучат как отдельные типы объектов, концептуально они \n"
"взаимозаменяемы. Правила можно рассматривать как виртуальные факты. Если "
"мы \n"
"хотим, чтобы наша база данных отражала открытие, что большие(big), жестокие\n"
"(fierce) животные(animals) встречаются редко(rare), мы могли бы найти\n"
"все x, такие, что все факты (species x), (big x), и (fierce x), и добавить\n"
"новый факт (rare x). Однако, определив правило говорящее"

#: texi/node-24.texi:129
msgid ""
"@example\n"
"If      (species ?x) and (big ?x) and (fierce ?x)\n"
"Then (rare ?x)\n"
"@end example"
msgstr ""

#: texi/node-24.texi:134
msgid ""
"we get the same effect, without actually having to add all the (rare x) to "
"the\n"
"database. We can even define rules which imply an infinite number of facts. "
"Thus\n"
"rules make the database smaller at the expense of extra processing when it "
"comes\n"
"time to answer questions."
msgstr ""
"мы получаем тот же самый эффект, фактически не добавляя всем признак (rare "
"x) в\n"
"базу данных. Мы даже можем определить правила, которые подразумевают "
"бесконечное\n"
"количество фактов. Таким образом, правила уменьшают базу данных за счет "
"дополнительной\n"
"обработки, когда приходит время отвечать на вопросы."

#: texi/node-24.texi:137
msgid ""
"Facts, meanwhile, are a degenerate case of rules. The effect of any fact F\n"
"could be duplicated by a rule whose body was always true:"
msgstr ""
"Тем временем, Факты, являются вырожденным случаем правил. Эффект от любого\n"
"факта F может дублироваться правилом, тело которого всегда истинно:"

#: texi/node-24.texi:142
msgid ""
"@example\n"
"If      true\n"
"Then F\n"
"@end example"
msgstr ""

#: texi/node-24.texi:145
msgid ""
"To simplify our implementation, we will take advantage of this principle "
"and\n"
"represent facts as bodyless "
"rules.                                                        "
msgstr ""
"Чтобы упростить нашу реализацию, мы воспользуемся этим принципом и "
"представим факты\n"
"в виде правил не имеющих "
"тела.                                                        "

#: texi/node-24.texi:150
msgid ""
"@node 24-2 An Interpreter, 24-3 Rules, 24-1 Concepts, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-2 An Interpreter\n"
"@cindex 24-2 An Interpreter"
msgstr ""
"@node 24-2 An Interpreter, 24-3 Rules, 24-1 Concepts, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-2 Интерпретатор\n"
"@cindex 24-2 An Interpreter"

#: texi/node-24.texi:156
msgid ""
"Section 18-4 showed two ways to define if-match. The first was simple but\n"
"inefficient. Its successor was faster because it did much of its work at "
"compile-\n"
"time. We will follow a similar strategy here. In order to introduce some of "
"the\n"
"topics involved, we will begin with a simple interpreter. Later we will show "
"how\n"
"to write the same program much more efficiently."
msgstr ""
"Раздел 18-4 показывает два способа определения if-match. Первый был простым, "
"но\n"
"неэффективным. Его преемник был быстрее, потому что делал большую часть "
"своей \n"
"работы во время компиляции. Мы будем следовать аналогичной стратегии и "
"здесь. Чтобы\n"
"предоставить некоторые из затронутых тем, мы начнем с простого "
"интерпретатора.\n"
"Позже мы покажем, как написать ту же программу более эффективно."

#: texi/node-24.texi:170
msgid ""
"@lisp\n"
" (defmacro with-inference (query &body body)\n"
"  `(progn\n"
"         (setq *paths* nil)\n"
"         (=bind (binds) (prove-query ',(rep_ query) nil)\n"
"            (let ,(mapcar #'(lambda (v)\n"
"                                   `(,v (fullbind ',v binds)))\n"
"                              (vars-in query #'atom))\n"
"              ,@@body\n"
"              (fail)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-inference (query &body body)\n"
"  `(progn\n"
"         (setq *paths* nil)\n"
"         (=bind (binds) (prove-query ',(rep_ query) nil)\n"
"            (let ,(mapcar #'(lambda (v)\n"
"                                   `(,v (fullbind ',v binds)))\n"
"                              (vars-in query #'atom))\n"
"              ,@@body\n"
"              (fail)))))"

#: texi/node-24.texi:175
msgid ""
" (defun rep_ (x)\n"
"       (if (atom x)\n"
"            (if (eq x '_) (gensym \"?\") x)\n"
"            (cons (rep_ (car x)) (rep_ (cdr x)))))"
msgstr ""

#: texi/node-24.texi:183
msgid ""
" (defun fullbind (x b)\n"
"       (cond ((varsym? x) (aif2 (binding x b)\n"
"                                       (fullbind it b)\n"
"                                       (gensym)))\n"
"              ((atom x) x)\n"
"              (t (cons (fullbind (car x) b)\n"
"                          (fullbind (cdr x) b)))))"
msgstr ""

#: texi/node-24.texi:187
msgid ""
" (defun varsym? (x)\n"
"       (and (symbolp x) (eq (char (symbol-name x) 0) #\\?)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:189
msgid "                            Figure 24-2: Toplevel macro."
msgstr ""
"                            Рисунок 24-2: Макрос верхнего уровня.\n"
"@end cartouche"

#: texi/node-24.texi:198
msgid ""
"Figures 24-2­24-4 contain the code for a simple Prolog interpreter. It ac-\n"
"cepts the same queries as the query interpreter of Section 19-3, but uses "
"rules\n"
"instead of the database to generate bindings. The query interpreter was "
"invoked\n"
"through a macro called with-answer. The interface to the Prolog interpreter\n"
"will be through a similar macro, called with-inference. Like with-answer,\n"
"with-inference is given a query and a series of Lisp expressions. Variables "
"in\n"
"the query are symbols beginning with a question mark:"
msgstr ""
"Рисунки 24-2­24-4 содержат код для простого интерпретатора Prolog-а. Он "
"принимает\n"
"те же запросы, что и интерпретатор запросов в Разделе 19-3, но использует\n"
"правила вместо базы данных для генерации привязок. Интерпретатор запросов\n"
"вызывался с помощью макроса названного with-answer. Интерфейсом для "
"интерпретатора\n"
"Prolog-а будет похожий макрос, называемый with-inference. Подобно with-"
"answer,\n"
"with-inference предоставляется запрос и последовательность выражений Lisp. "
"Переменные\n"
"в запросе - это символы, начинающиеся со знака вопроса:"

#: texi/node-24.texi:203
msgid ""
"@lisp\n"
"(with-inference (painter ?x)\n"
"  (print ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:207
msgid ""
"A call to with-inference expands into code that will evaluate the Lisp "
"expres-\n"
"sions for each set of bindings generated by the query. The call above, for "
"example,\n"
"will print each x for which it is possible to infer (painter "
"x).                          "
msgstr ""
"Вызов with-inference расширяется до кода, который будет вычислять врыважения "
"Lisp\n"
"длял каждого набора привязок, сгенерированных запросом. Например, "
"приведенный выше\n"
"вызов напечатает каждый  x для которого можно сделать вывод, что (painter "
"x).                          "

#: texi/node-24.texi:215
msgid ""
"Figure 24-2 shows the definition of with-inference, together with the func-\n"
"tion it calls to retrieve bindings. One notable difference between with-"
"answer\n"
"and with-inference is that the former simply collected all the valid "
"bindings.\n"
"The new program searches nondeterministically. We see this in the definition "
"of\n"
"with-inference: instead of expanding into a loop, it expands into code "
"which\n"
"will return one set of bindings, followed by a fail to restart the search. "
"This\n"
"gives us iteration implicitly, as in:"
msgstr ""
"На Рисунке 24-2 показано определение with-inference, вместе с функцией, "
"которую\n"
"он вызывает для получения привязок. Одно заметное отличие между with-answer "
"и\n"
"with-inference заключается в том, что первый просто собирал все допустимые \n"
"привязки. Новая программа ищет недетерминированно. Мы видим это в "
"определении\n"
"with-inference: вместо расширения в цикл, оно расширяется в код, который "
"возвращает\n"
"один набор привязок, следующий за ним fail перезапускает поиск. Это дает "
"нам,\n"
"неявно, итерацию, как в:"

#: texi/node-24.texi:223
msgid ""
"@example\n"
"> (choose-bind x '(0 1 2 3456789)\n"
"        (princ x)\n"
"        (if (= x 6) x (fail)))\n"
"0123456\n"
"6\n"
"@end example"
msgstr ""

#: texi/node-24.texi:229
msgid ""
"The function fullbind points to another difference between with-answer\n"
"and with-inference. Tracing back through a series of rules can build up "
"binding\n"
"lists in which the binding of a variable is a list of other variables. To "
"make use of\n"
"the results of a query we now need a recursive function for retrieving "
"bindings.\n"
"This is the purpose of fullbind:"
msgstr ""
"Функция fullbind указывает на другое различие между  with-answer и with-"
"inference. \n"
"Обратная трассировака последовательности правил може тсоздать списки "
"привязок, \n"
"в которых привязка переменной является списком других переменных. Чтобы "
"использовать\n"
"результаты запроса, нам теперь нужна рекурсивная функция для плучения "
"привязок.\n"
"Это цель  fullbind:"

#: texi/node-24.texi:238
msgid ""
"@example\n"
"> (setq b '((?x . (?y . ?z)) (?y . foo) (?z . nil)))\n"
"((?X ?Y . ?Z) (?Y . FOO) (?Z))\n"
"> (values (binding '?x b))\n"
"(?Y . ?Z)\n"
"> (fullbind '?x b)\n"
"(FOO)\n"
"@end example"
msgstr ""

#: texi/node-24.texi:245
msgid ""
"Bindings for the query are generated by a call to prove-query in the "
"expansion\n"
"of with-inference. Figure 24-3 shows the definition of this function and "
"the\n"
"functions it calls. This code is structurally isomorphic to the query "
"interpreter\n"
"described in Section 19-3. Both programs use the same functions for "
"matching,\n"
"but where the query interpreter used mapping or iteration, the Prolog "
"interpreter\n"
"uses equivalent chooses."
msgstr ""
"Привязки для запроса генерируются вызовом prove-query в расширении with-"
"inference.\n"
"На Рисунке 24-3 показано определение этой функции и функций, которые она "
"вызывает.\n"
"Этот код структурно изоморфен интерпретатору запросов, описанному в разделе "
"19-3. \n"
"Обе программы используют одинаковые функции для сопоставления, но там где "
"интерпретатор\n"
"запросов использовал отображение(mapping) или итеарцию, интерпретатор Prolog-"
"а использует\n"
"эквивалентные варианты chooses."

#: texi/node-24.texi:248
msgid ""
"Using nondeterministic search instead of iteration does make the "
"interpretation\n"
"of negated queries a bit more complex. Given a query like"
msgstr ""
"Использование недетерминированного поиска вместо итерации делает "
"интерпретацию\n"
"отритцающих(negated) запросов немного более сложной. Данный запрос, подобный"

#: texi/node-24.texi:252
msgid ""
"@lisp\n"
"(not (painter ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:258
msgid ""
"@noindent\n"
"the query interpreter could just try to establish bindings for (painter ?"
"x),\n"
"returning nil if any were found. With nondeterministic search we have to be\n"
"more careful: we don't want the interpretation of (painter ?x) to fail back\n"
"outside the scope of the not, nor do we want it to leave saved paths that "
"might"
msgstr ""
"@noindent\n"
"интерперетатор запросов может просто попытаться установить привязки для\n"
"(painter ?x) возвращающие nil, если таковые были найдены. При "
"недетерминированном\n"
"поиске мы должны быть более осторожными: мы не хотим, чтобы интерепретация\n"
"(painter ?x) в ложь возвращалась за пределы действия области "
"отритцания(not), \n"
"и поэтому мы не хотим, чтобы она оставляла сохраненные пути, которые могли бы"

#: texi/node-24.texi:266
msgid ""
"@lisp\n"
" (=defun prove-query (expr binds)\n"
"       (case (car expr)\n"
"         (and (prove-and (cdr expr) binds))\n"
"         (or     (prove-or (cdr expr) binds))\n"
"         (not (prove-not (cadr expr) binds))\n"
"         (t      (prove-simple expr binds))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (=defun prove-query (expr binds)\n"
"       (case (car expr)\n"
"         (and (prove-and (cdr expr) binds))\n"
"         (or     (prove-or (cdr expr) binds))\n"
"         (not (prove-not (cadr expr) binds))\n"
"         (t      (prove-simple expr binds))))"

#: texi/node-24.texi:272
msgid ""
" (=defun prove-and (clauses binds)\n"
"       (if (null clauses)\n"
"            (=values binds)\n"
"            (=bind (binds) (prove-query (car clauses) binds)\n"
"                (prove-and (cdr clauses) binds))))"
msgstr ""

#: texi/node-24.texi:276
msgid ""
" (=defun prove-or (clauses binds)\n"
"       (choose-bind c clauses\n"
"         (prove-query c binds)))"
msgstr ""

#: texi/node-24.texi:286
msgid ""
" (=defun prove-not (expr binds)\n"
"       (let ((save-paths *paths*))\n"
"         (setq *paths* nil)\n"
"         (choose (=bind (b) (prove-query expr binds)\n"
"                      (setq *paths* save-paths)\n"
"                      (fail))\n"
"                    (progn\n"
"                      (setq *paths* save-paths)\n"
"                      (=values binds)))))"
msgstr ""

#: texi/node-24.texi:291
msgid ""
" (=defun prove-simple (query binds)\n"
"       (choose-bind r *rlist*\n"
"         (implies r query binds)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:293
msgid "                        Figure 24-3: Interpretation of queries."
msgstr ""
"                        Рисунок 24-3: Интерпретация запросов.\n"
"@end cartouche"

#: texi/node-24.texi:298
msgid ""
"@noindent\n"
"be restarted later. So now the test for (painter ?x) is done with a "
"temporarily\n"
"empty list of saved states, and the old list is restored on the way out."
msgstr ""
"@noindent\n"
"быть перезапущены позже. Итак, теперь тест для (painter ?x) выполняется с "
"временно\n"
"пустым списком сохраненных состояний, а старый список восстанавливается при "
"выходе."

#: texi/node-24.texi:304
msgid ""
"Another difference between this program and the query interpreter is in the\n"
"interpretation of simple patterns-expressions such as (painter ?x) which "
"con-\n"
"sist just of a predicate and some arguments. When the query interpreter "
"generated\n"
"bindings for a simple pattern, it called lookup (page 251). Now, instead of "
"calling\n"
"lookup, we have to get any bindings implied by the rules."
msgstr ""
"Другое отличие между этой программой и интерпретатором запросов заключается "
"в \n"
"интерпретации простых образцов - выражений таких как (painter ?x) которые "
"состоят\n"
"только из предиката и несокльких аргументов. Когда интерпретатор запросов "
"генерировал\n"
"привязки для простых образцов, он вызывал lookup (стр. 251). Теперь, вместо "
"вызова\n"
"lookup, мы должны получить любые привязки , подразумеваемые правилами."

#: texi/node-24.texi:307
msgid ""
"@lisp\n"
" (defvar *rlist* nil)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *rlist* nil)"

#: texi/node-24.texi:313
msgid ""
" (defmacro <- (con &rest ant)\n"
"    (let ((ant (if (= (length ant) 1)\n"
"                       (car ant)\n"
"                       `(and ,@@ant))))\n"
"        `(length (conc1f *rlist* (rep_ (cons ',ant ',con))))))"
msgstr ""

#: texi/node-24.texi:319
msgid ""
" (=defun implies (r query binds)\n"
"    (let ((r2 (change-vars r)))\n"
"        (aif2 (match query (cdr r2) binds)\n"
"              (prove-query (car r2) it)\n"
"              (fail))))"
msgstr ""

#: texi/node-24.texi:326
msgid ""
" (defun change-vars (r)\n"
"    (sublis (mapcar #'(lambda (v)\n"
"                                (cons v (symb '? (gensym))))\n"
"                            (vars-in r #'atom))\n"
"              r))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:328
msgid "                       Figure 24-4: Code involving rules."
msgstr ""
"                       Рисунок 24-4: Code involving rules.\n"
"@end cartouche"

#: texi/node-24.texi:341
msgid ""
"@lisp\n"
"  rule        : (<-  sentence  query )\n"
"  query       : (not  query )\n"
"              : (and  query *)\n"
"              : (or  query *)\n"
"              :  sentence \n"
"  sentence  : ( symbol  argument *)\n"
"  argument  :  variable \n"
"              :  symbol \n"
"              :  number \n"
"  variable  : ? symbol \n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"  rule        : (<-  sentence  query )\n"
"  query       : (not  query )\n"
"              : (and  query *)\n"
"              : (or  query *)\n"
"              :  sentence \n"
"  sentence  : ( symbol  argument *)\n"
"  argument  :  variable \n"
"              :  symbol \n"
"              :  number \n"
"  variable  : ? symbol \n"
"@end lisp"

#: texi/node-24.texi:343
msgid "                            Figure 24-5: Syntax of rules."
msgstr ""
"                            Рисунок 24-5: Синтаксис правил.\n"
"@end cartouche"

#: texi/node-24.texi:348
msgid ""
"Code for defining and using rules is shown in Figure 24-4. The rules are "
"kept\n"
"in a global list, *rlist*. Each rule is represented as a dotted pair of body "
"and\n"
"head. At the time a rule is defined, all the underscores are replaced with "
"unique\n"
"variables."
msgstr ""
"Код для определения и использования правил показан на рисунке 24-4. Правила "
"храняться\n"
"в глобальном списке *rlist*. Каждое правило представлено в виде точечной "
"пары тела и\n"
"головы. Во время определения правила все подчеркивания заменяются "
"уникальными \n"
"переменными."

#: texi/node-24.texi:351
msgid ""
"The definition of <- follows three conventions often used in programs of "
"this\n"
"type:"
msgstr ""
"Определение <- следует трем соглашениям, часто используемым в программах "
"подобного\n"
"типа:"

#: texi/node-24.texi:362
msgid ""
"@enumerate\n"
"@item\n"
"New rules are added to the end rather than the front of the list, so that "
"they\n"
"         will be applied in the order that they were defined.\n"
"@item\n"
"Rules are expressed head first, since that's the order in which the program\n"
"         examines them.\n"
"@item\n"
"Multiple expressions in the body are within an implicit and.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Новые правила добавляются в конец, а не в начало списка, так что они будут "
"применяться\n"
"         в том порядке, в котором они были определены.\n"
"@item\n"
"Правила выражены так, что голова(head) стоит первой, так как это порядок в "
"котором программа\n"
"         их проверяет(рассматривает).\n"
"@item\n"
"Множественные выражения в теле находятся внутри неявных и(and).\n"
"@end enumerate"

#: texi/node-24.texi:365
msgid ""
"The outermost call to length in the expansion of <- is simply to avoid "
"printing a\n"
"huge list when <- is called from the toplevel."
msgstr ""
"Самый внешний вызов length в расширении <- нужен просто для того, чтобы не "
"печатать\n"
"длинный список, когда <- вызывается из верхнего уровня."

#: texi/node-24.texi:370
msgid ""
"The syntax of rules is given in Figure 24-5. The head of a rule must be a "
"pattern\n"
"for a fact: a list of a predicate followed by zero or more arguments. The "
"body\n"
"may be any query that could be handled by the query interpreter of Chapter "
"19.\n"
"Here is the rule from earlier in this chapter:"
msgstr ""
"Синтаксис правил приведен на Рисунке 24-5. Голова(head) правила должна быть "
"образцом\n"
"для факта: список предиката, за которым следует ноль или более аргументов. "
"Тело(body)\n"
"может быть любым запросом, который может быть обработан интерпретатором "
"запросов\n"
"главы 19. Вот правило ранее упоминавшееся в данной главе:"

#: texi/node-24.texi:375
msgid ""
"@lisp\n"
"(<- (painter ?x) (and (hungry ?x)\n"
"                                 (smells-of ?x turpentine)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:378
msgid ""
"@noindent\n"
"or just"
msgstr ""
"@noindent\n"
"или просто"

#: texi/node-24.texi:383
msgid ""
"@lisp\n"
"(<- (painter ?x) (hungry ?x)\n"
"                           (smells-of ?x turpentine))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:386
msgid ""
"As in the query interpreter, arguments like turpentine do not get evaluated, "
"so\n"
"they don't have to be quoted."
msgstr ""
"Как и в интерпретаторе запросов, аргументы типа turpentine(скипидара) не "
"вычисляются,\n"
"поэтому их надо квотировать(ставить кавычку)."

#: texi/node-24.texi:392
msgid ""
"When prove-simple is asked to generate bindings for a query, it nondeter-\n"
"ministically chooses a rule and sends both rule and query to implies. The "
"latter\n"
"function then tries to match the query with the head of the rule. If the "
"match\n"
"succeeds, implies will call prove-query to establish bindings for the body.\n"
"Thus we recursively search the tree of implications."
msgstr ""
"Когда prove-simple запрашивается для создания привязко для запроса, он \n"
"недетерминированно выбирает правило и посылает как правило, так и запрос\n"
"в implies. Последняя функция(implies) затем пытается сопоставить(найти "
"соответсвие)\n"
"запрос с головой(head) правила. Если сопоставление выполнено успешно,\n"
"implies вызовет prove-query, чтобы установить привязки для тела(body).\n"
"Таким образом, мы рекурсивно ищем дерево следствий."

#: texi/node-24.texi:397
msgid ""
"The function change-vars replaces all the variables in a rule with fresh "
"ones.\n"
"An ?x used in one rule is meant to be independent of one used in another. In "
"order\n"
"to avoid conflicts with existing bindings, change-vars is called each time a "
"rule\n"
"is used."
msgstr ""
"Функция change-vars заменяет все переменные в правиле на новые. ?x "
"используемый в\n"
"одном правиле, должен быть независимым от ?x используемого в другом правиле. "
"Чтобы\n"
"измежать конфликтов с существующими привязками, change-vars вызывается "
"каждый раз,\n"
"когда используется правило."

#: texi/node-24.texi:402
msgid ""
"For the convenience of the user, it is possible to use (underscore)as a "
"wildcard\n"
"variable in rules. When a rule is defined, the function rep is called to "
"change\n"
"each underscore into a real variable. Underscores can also be used in the "
"queries\n"
"given to with-inference."
msgstr ""
"Для удобства пользователя в правлах можно использовать _(подчеркивание) в "
"качестве\n"
"безразличной переменной в правиле. Когда правило определено, вызывается "
"функция rep_is\n"
"чтобы изменить подчерквивание на реальную переменную. Подчеркивания также "
"могут\n"
"использоваться в запросах, переданных with-inference."

#: texi/node-24.texi:408
msgid ""
"@node 24-3 Rules, 24-4 The Need for Nondeterminism, 24-2 An Interpreter, 24 "
"Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-3 Rules\n"
"@cindex 24-3 Rules"
msgstr ""
"@node 24-3 Rules, 24-4 The Need for Nondeterminism, 24-2 An Interpreter, 24 "
"Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-3 Правила\n"
"@cindex 24-3 Rules"

#: texi/node-24.texi:411
msgid ""
"This section shows how to write rules for our Prolog. To start with, here "
"are the\n"
"two rules from Section 24-1:"
msgstr ""
"В этом разделе показано, как написать правила для нашего Prolog-а. В начале, "
"вот\n"
"два правилаа из Раздела 24-1:"

#: texi/node-24.texi:415
msgid ""
"@lisp\n"
"(<- (painter ?x) (hungry ?x)\n"
"                       (smells-of ?x turpentine))"
msgstr ""

#: texi/node-24.texi:418
msgid ""
"(<- (hungry ?x) (or (gaunt ?x) (eats-ravenously ?x)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:420
msgid "If we also assert the following facts:"
msgstr "Если мы также утвердим следующие факты:"

#: texi/node-24.texi:426
msgid ""
"@lisp\n"
"(<- (gaunt raoul))\n"
"(<- (smells-of raoul turpentine))\n"
"(<- (painter rubens))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:429
msgid ""
"Then we will get the bindings they generate according to the order in which "
"they\n"
"were defined:"
msgstr ""
"Тогда мы получим привязки, которые они генериуют в соответствии с порядком, "
"в котором\n"
"они были определены:"

#: texi/node-24.texi:437
msgid ""
"@example\n"
"> (with-inference (painter ?x)\n"
"        (print ?x))\n"
"RAOUL\n"
"RUBENS\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:440
msgid ""
"The with-inferencemacro has exactly the same restrictions on variable "
"binding\n"
"as with-answer. (See Section 19-4.)"
msgstr ""
"Макрос with-inference имеет те же ограничения на привязку переменных, что и\n"
"with-answer. (См. Раздел 19-4.)"

#: texi/node-24.texi:444
msgid ""
"We can write rules which imply that facts of a given form are true for all\n"
"possible bindings. This happens, for example, when some variable occurs in "
"the\n"
"head of a rule but not in the body. The rule"
msgstr ""
"Мы можем написать правила, которые подразумевают, что факты данной формы "
"верны\n"
"для всех возможных привязок. Это происходит, например, когда некоторая "
"переменная\n"
"встречается в голове(head) правила, но не в его теле. Правило"

#: texi/node-24.texi:448
msgid ""
"@lisp\n"
"(<- (eats ?x ?f) (glutton ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:453
msgid ""
"Says that if ?x is a glutton, then ?x eats everything. Because ?f doesn't "
"occur in\n"
"the body, we can prove any fact of the form (eats ?x y) simply by "
"establishing\n"
"a binding for ?x. If we make a query with a literal value as the second "
"argument\n"
"to eats,"
msgstr ""
"говорит, что если ?x это glutton(обжора), то ?x есть всё(eats everything). "
"Поскольку ?f \n"
"не встречается в теле, мы можем доказать любой факт вида (eats ?x y), просто "
"установив\n"
"привязк для ?x. Если мы сделаем запрос с буквальным значением в качестве "
"второго аргумента\n"
"в eats(есть),"

#: texi/node-24.texi:461
msgid ""
"@example\n"
"> (<- (glutton hubert))\n"
"7> (with-inference (eats ?x spinach)\n"
"        (print ?x))\n"
"HUBERT\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:464
msgid ""
"@noindent\n"
"then any literal value will work. When we give a variable as the second "
"argument:"
msgstr ""
"@noindent\n"
"тогда любое литеральное значение будет работать. Когда мы дадим переменную "
"в \n"
"качестве второго аргумента:"

#: texi/node-24.texi:471
msgid ""
"@example\n"
"> (with-inference (eats ?x ?y)\n"
"        (print (list ?x ?y)))\n"
"(HUBERT #:G229)\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:476
msgid ""
"@noindent\n"
"we get a gensym back. Returning a gensym as the binding of a variable in "
"the\n"
"query is a way of signifying that any value would be true there. Programs "
"can be\n"
"written explicitly to take advantage of this convention:"
msgstr ""
"@noindent\n"
"мы получаем gensym назад. Возврат gensym в качестве привязки переменной в "
"запросе -\n"
"это способ показать, что любое значение будет истинным. Программы могут быть "
"написаны\n"
"явно, чтобы использовать в своих интересах это соглашение:"

#: texi/node-24.texi:490
msgid ""
"@example\n"
"> (progn\n"
"        (<- (eats monster bad-children))\n"
"        (<- (eats warhol candy)))\n"
"9> (with-inference (eats ?x ?y)\n"
"        (format t \"~A eats ~A.~%\"\n"
"                  ?x\n"
"                  (if (gensym? ?y) 'everything ?y)))\n"
"HUBERT eats EVERYTHING.\n"
"MONSTER eats BAD-CHILDREN.\n"
"WARHOL eats CANDY.\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:495
msgid ""
"Finally, if we want to specify that facts of a certain form will be true for "
"any\n"
"arguments, we make the body a conjunction with no arguments. The expression\n"
"(and) will always behave as a true fact. In the macro <- (Figure 24-4), the "
"body\n"
"defaults to (and), so for such rules we can simply omit the body:"
msgstr ""
"Наконец, если мы хотим указать, что факты определенной формы будут верны "
"для\n"
"любых аргументов, мы делаем тело соединением(conjunction) без аргументов. \n"
"Выражение и(and) всегда будет вести себя как истинный факт. В макросе <- \n"
"(рисунок 24-4), тело по умолчанию имеет значение (and), поэтому для таких\n"
"правил мы можем просто опустить(не писать) тело:"

#: texi/node-24.texi:504
msgid ""
"@example\n"
"> (<- (identical ?x ?x))\n"
"10\n"
"> (with-inference (identical a ?x)\n"
"        (print ?x))\n"
"A@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:513
msgid ""
"For readers with some knowledge of Prolog, Figure 24-6 shows the "
"translation\n"
"from Prolog syntax into that of our program. The traditional first Prolog "
"program\n"
"is append, which would be written as at the end of Figure 24-6. In an "
"instance of\n"
"appending, two shorter lists are joined together to form a single larger "
"one. Any\n"
"two of these lists define what the third should be. The Lisp function append "
"takes\n"
"the two shorter lists as arguments and returns the longer one. Prolog append "
"is\n"
"more general; the two rules in Figure 24-6 define a program which, given any "
"two\n"
"of the lists involved, can find the third."
msgstr ""
"Для читателей знакомых с Prolog-ом, на Рисунке 24-6 показан перевод "
"синтаксиса\n"
"Prolog-а в синтаксис нашей программы. Традиционно, первая программа пролога "
"Prolog\n"
"это append, которая будет написана в конце рисунка 24-6. В случае "
"добавления, \n"
"два коротких списка объединяются в один более длинны. Любые два из этих "
"списков\n"
"определяют, каким должен быть третий. Функция Lisp append принимает два "
"коротких\n"
"списка как аргументы и возвращает более длинный. append из Пролога является "
"более\n"
"общим; два правила на Рисунке 24-6 определяют программу, которая, учитывая "
"любые \n"
"два из задействованных списков, может найти третий."

#: texi/node-24.texi:515
msgid "     Our syntax differs from traditional Prolog syntax as follows:"
msgstr ""
"@cartouche\n"
"     Наш синтаксис отличается от традиционного синтаксиса Prolog-а следующим:"

#: texi/node-24.texi:531
msgid ""
"@enumerate\n"
"@item\n"
"Variables are represented by symbols beginning with question marks\n"
"           instead of capital letters. Common Lisp is not case-sensitive by "
"default,\n"
"           so it would be more trouble than it's worth to use capitals.\n"
"@item\n"
"[]becomes nil.\n"
"@item\n"
"Expressions of the form [x | y] become (x . y).\n"
"@item\n"
"Expressions of the form [x, y, ...] become (xy...).\n"
"@item\n"
"Predicates are moved inside parentheses, and no commas separate argu-\n"
"           ments: pred(x, y, ...) becomes (pred x y ...).\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Переменные представлены символами, начинающимися с вопросительных знаков "
"вместо\n"
"           заглавных букв. Common Lisp по умолчанию не учитывает регистр "
"букв,\n"
"           поэтому от использования заглавных букв было бы больше проблем.\n"
"@item\n"
"[] становиться nil.\n"
"@item\n"
"Выражения вида [x | y] становятся (x . y).\n"
"@item\n"
"Выражения вида [x, y, ...] становятся (x y . . .).\n"
"@item\n"
"Предикаты перемещаются внутрь круглых скобок, и запятые не являются "
"разделителями\n"
"           аргументов: pred(x, y, ...) становится (pred x y ...).\n"
"@end enumerate"

#: texi/node-24.texi:533
msgid "Thus the Prolog definition of append:"
msgstr "Таким образом Prolog определение append:"

#: texi/node-24.texi:538
msgid ""
"@example\n"
"     append([ ], Xs, Xs).\n"
"     append([X | Xs], Ys, [X | Zs]) <- append(Xs, Ys, Zs).\n"
"@end example"
msgstr ""

#: texi/node-24.texi:540
msgid "     becomes:"
msgstr "     становится:"

#: texi/node-24.texi:546
msgid ""
"@lisp\n"
"     (<- (append nil ?xs ?xs))\n"
"     (<- (append (?x . ?xs) ?ys (?x . ?zs))\n"
"          (append ?xs ?ys ?zs))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:548
msgid "                        Figure 24-6: Prolog syntax equivalence."
msgstr ""
"                        Рисунок 24-6: синтаксическая эквивалентность Prolog-"
"а\n"
"@end cartouche"

#: texi/node-24.texi:561
msgid ""
"@example\n"
"> (with-inference (append ?x (c d) (a b c d))\n"
"        (format t \"Left: ~A~%\" ?x))\n"
"Left: (A B)\n"
"@@> (with-inference (append (a b) ?x (a b c d))\n"
"        (format t \"Right: ~A~%\" ?x))\n"
"Right: (C D)\n"
"@@> (with-inference (append (a b) (c d) ?x)\n"
"        (format t \"Whole: ~A~%\" ?x))\n"
"Whole: (ABCD)\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:564
msgid ""
"Not only that, but given only the last list, it can find all the "
"possibilities for the\n"
"first two:"
msgstr ""
"Мало того, учитывая последний список, он может найти всеп возможности для "
"первых двух:"

#: texi/node-24.texi:574
msgid ""
"@example\n"
"> (with-inference (append ?x ?y (a b c))\n"
"        (format t \"Left: ~A Right: ~A~%\" ?x ?y))\n"
"Left: NIL Right: (A B C)\n"
"Left: (A) Right: (B C)\n"
"Left: (A B) Right: (C)\n"
"Left: (A B C) Right: NIL\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:580
msgid ""
"       The case of append points to a great difference between Prolog and "
"other\n"
"languages. A collection of Prolog rules does not have to yield a specific "
"value. It\n"
"can instead yield constraints, which, when combined with constraints "
"generated\n"
"by other parts of the program, yield a specific value. For example, if we "
"define\n"
"member thus:"
msgstr ""
"       Случай append указывает на большую разницу между Prolog-ом и другими "
"языками.\n"
"Набор правил Prolog-а  не обязательно должен давать конкретное значение. "
"Вместо этого\n"
"он может давать ограничения(constraints), которые в сочетании с "
"ограничениями \n"
"генерируемыми другими частями программы, дают конкретное значение. Например, "
"если мы\n"
"определим member таким образом:"

#: texi/node-24.texi:585
msgid ""
"@lisp\n"
"(<- (member ?x (?x . ?rest)))\n"
"(<- (member ?x (_ . ?rest)) (member ?x ?rest))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:589
msgid ""
"@noindent\n"
"then we can use it to test for list membership, as we would use the Lisp "
"function\n"
"member:"
msgstr ""
"@noindent\n"
"тогда мы сможем использовать его для проверки членства(membership) в списке, "
"как \n"
"если бы использовали функцию Lisp member:"

#: texi/node-24.texi:594
msgid ""
"@example\n"
"> (with-inference (member a (a b)) (print t))\n"
"T@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:598
msgid ""
"@noindent\n"
"but we can also use it to establish a constraint of membership, which, "
"combined\n"
"with other constraints, yields a specific list. If we also have a predicate "
"cara"
msgstr ""
"@noindent\n"
"но мы также можем использовать ее для установления ограничения на членство, "
"которе\n"
"в сочетании с другими ограничениями приводит к определенному списку. Если "
"мы\n"
"так же имеем предикат cara"

#: texi/node-24.texi:602
msgid ""
"@lisp\n"
"(<- (cara (a _)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:606
msgid ""
"@noindent\n"
"which is true of any two-element list whose car is a, then between that and "
"member\n"
"we have enough constraint for Prolog to construct a definite answer:"
msgstr ""
"@noindent\n"
"который истинен для двух-элементного списка, чье начало(car) равно a, тогда "
"между\n"
"ним и member у нас достаточно ограничений для Prolog-а, чтобы построить\n"
"определенный ответ:"

#: texi/node-24.texi:613
msgid ""
"@example\n"
"> (with-inference (and (cara ?lst) (member b ?lst))\n"
"        (print ?lst))\n"
"(A B)\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:619
msgid ""
"This is a rather trivial example, but bigger programs can be constructed on "
"the\n"
"same principle. Whenever we want to program by combining partial solutions,\n"
"Prolog may be useful. Indeed, a surprising variety of problems can be "
"expressed\n"
"in such terms: Figure 24-14, for example, shows a sorting algorithm "
"expressed as\n"
"a collection of constraints on the solution."
msgstr ""
"Это довольно тривиальный пример, но большие программы могут быть построены "
"по тому\n"
"же принципу. Когда мы хотим программировать, комбинируя частичные решения, "
"Prolog\n"
"может быть полезен. Действительно, удивительное разнообразие проблем может "
"быть\n"
"выражено в таких терминах: например, на рисунке 24-14 показан алгоритм "
"сортировки,\n"
"выраженный в виде набора ограничений на решение."

#: texi/node-24.texi:624
msgid ""
"@node 24-4 The Need for Nondeterminism, 24-5 New Implementation, 24-3 Rules, "
"24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-4 The Need for Nondeterminism\n"
"@cindex 24-4 The Need for Nondeterminism"
msgstr ""
"@node 24-4 The Need for Nondeterminism, 24-5 New Implementation, 24-3 Rules, "
"24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-4 Необходимость Недетерминизма\n"
"@cindex 24-4 The Need for Nondeterminism"

#: texi/node-24.texi:630
msgid ""
"Chapter 22 explained the relation between deterministic and "
"nondeterministic\n"
"search. A deterministic search program could take a query and generate all "
"the\n"
"solutions which satisfied it. A nondeterministic search program will use "
"choose\n"
"to generate solutions one at a time, and if more are needed, will call fail "
"to restart\n"
"the search."
msgstr ""
"Глава 22 объяснила связь между детерминированным и недетерминированным "
"поиском.\n"
"Детерминированная поисковая программа может принять запрос и сгенерировать "
"все\n"
"решения, которые его удовлетворяют. Недетерминированная программа поиска "
"будет\n"
"использовать выбор(choose) для генерации решений по одному, или если "
"потребуется\n"
"больше, вызовет fail для перезапуска поиска."

#: texi/node-24.texi:636
msgid ""
"When we have rules which all yield finite sets of bindings, and we want all "
"of\n"
"them at once, there is no reason to prefer nondeterministic search. The "
"difference\n"
"between the two strategies becomes apparent when we have queries which "
"would\n"
"generate an infinite number of bindings, of which we want a finite subset. "
"For\n"
"example, the rules"
msgstr ""
"Когда у нас есть правила, которые все дают конечные наборы привязок, и мы "
"хотим,\n"
"чтобы они были все сразу, нет причин предпочитать недетерминированный поиск. "
"Разница\n"
"межды этими двумя стратегиями становиться очевидной, когда у нас есть "
"запросы, которые\n"
"генерируют бесконечное количество привязок, из которых мы хотим получить "
"конечное\n"
"подмножество. Например, правила"

#: texi/node-24.texi:642
msgid ""
"@lisp\n"
"(<- (all-elements ?x nil))\n"
"(<- (all-elements ?x (?x . ?rest))\n"
"        (all-elements ?x ?rest))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:646
msgid ""
"@noindent\n"
"imply all the facts of the form (all-elements xy), where every member of y\n"
"is equal to x. Without backtracking we could handle queries like:"
msgstr ""
"@noindent\n"
"подразумевают все факты вида (all-elements x y), где каждый член y\n"
"равен x. Без обратной трассировки мы могли бы обрабатывать такие запросы,\n"
"подобно:"

#: texi/node-24.texi:652
msgid ""
"@lisp\n"
"(all-elements a (a a a))\n"
"(all-elements a (a a b))\n"
"(all-elements ?x (a a a))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:659
msgid ""
"However, the query (all-elements a ?x) is satisfied for an infinite number "
"of\n"
"possible ?x: nil, (a), (a a), and so on. If we try to generate answers for "
"this\n"
"query by iteration, the iteration will never terminate. Even if we only "
"wanted one\n"
"of the answers, we would never get a result from an implementation which had "
"to\n"
"generate all the bindings for the query before it could begin to iterate "
"through the\n"
"Lisp expressions following it."
msgstr ""
"Тем не менее, запрос (all-elements a ?x) выполняется для бесконечного числа "
"возможных\n"
"?x: nil, (a), (a a), и т.д. Если мы попытаемся сгенерировать ответы для "
"этого запроса\n"
"с помощью итерации, итерация никогда не прекратиться. Даже если бы нам нужен "
"был\n"
"только один из ответов, мы бы никогда не получили разультата от реализации, "
"которая\n"
"должна была бы сгенерировать все привязки для запроса, прежде чем он мог бы "
"начать\n"
"перебирать выражения Lisp, следующие за ним."

#: texi/node-24.texi:665
msgid ""
"This is why with-inference interleaves the generation of bindings with the\n"
"evaluation of its body. Where queries could lead to an infinite number of "
"answers,\n"
"the only successful approach will be to generate answers one at a time, and "
"return\n"
"to pick up new ones by restarting the suspended search. Because it uses "
"choose\n"
"and fail, our program can handle this case:"
msgstr ""
"Вот почему with-inference перемежает генерацию привязок с вычислением своего "
"тела.\n"
"Там, где запросы могут привести к бесконечному количеству ответов, "
"единственным\n"
"успешным подходом будет генерировать ответы по одному и возвращаться, чтобы "
"получить\n"
"новые ответы, перезапустив приостановленный поиск. Поскольку он использует "
"choose\n"
"и fail, наша программа может обработать этот случай:"

#: texi/node-24.texi:676
msgid ""
"@example\n"
"> (block nil\n"
"        (with-inference (all-elements a ?x)\n"
"          (if (= (length ?x) 3)\n"
"               (return ?x)\n"
"               (princ ?x))))\n"
"NIL(A)(A A)\n"
"(AAA)\n"
"@end example"
msgstr ""

#: texi/node-24.texi:682
msgid ""
"Like any other Prolog implementation, ours simulates nondeterminism by\n"
"doing depth-first search with backtracking. In theory, \"logic programs\" "
"run under\n"
"true nondeterminism. In fact, Prolog implementations always use depth-first\n"
"search. Far from being inconvenienced by this choice, typical Prolog "
"programs\n"
"depend on it. In a truly nondeterministic world, the query"
msgstr ""
"Как и любая другая реализация Prolog-а, наша имитирует недетерминизм, "
"выполняя\n"
"поиск в глубину с возвратами. В теории, \"логические программы\" работают в\n"
"условиях истинного недетерминизма. По факту, реализации Prolog-а всегда "
"используют\n"
"поиск в глубину. Отнюдь не будучи скованными этим выбором, обычные программы "
"на \n"
"Prolog-е зависят от него. В истинно недетерминированном мире, запрос"

#: texi/node-24.texi:686
msgid ""
"@lisp\n"
"(and (all-elements a ?x) (length ?x 3))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:689
msgid ""
"@noindent\n"
"has an answer, but it takes you arbitrarily long to find out what it is."
msgstr ""
"@noindent\n"
"имеет ответ, но вам понадобится сколь угодно времени, чтобы выяснить, что\n"
"это такое."

#: texi/node-24.texi:695
msgid ""
"Not only does Prolog use the depth-first implementation of nondeterminism,\n"
"it uses a version equivalent to that defined on page 293. As explained "
"there, this\n"
"implementation is not always guaranteed to terminate. So Prolog programmers\n"
"must take deliberate steps to avoid loops in the search space. For example, "
"if we\n"
"had defined member in the reverse order"
msgstr ""
"Prolog не только использует поиск в глубину реализованны на основе "
"недетерминированности,\n"
"он также использует версию эквивалентну определенной на странице 293. Как "
"объяснялось\n"
"там, данная реализация не всегда гарантирует прекращение. Поэтому "
"программисты Prologо-а\n"
"должны предпринять преднамеренные шаги, чтобы избежать петель в пространстве "
"поиска.\n"
"Например, если мы определим member в обратном порядке"

#: texi/node-24.texi:700
msgid ""
"@lisp\n"
"(<- (member ?x (_ . ?rest)) (member ?x ?rest))\n"
"(<- (member ?x (?x . ?rest)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:706
msgid ""
"@noindent\n"
"then logically it would have the same meaning, but as a Prolog program it "
"would\n"
"have a different effect. The original definition of member would yield an "
"infinite\n"
"stream of answers in response to the query (member 'a ?x), but the reversed\n"
"definition will yield an infinite recursion, and no answers."
msgstr ""
"@noindent\n"
"тогда логически это будет иметь то же значение, но как программа на Prolog-е "
"это\n"
"будет иметь другой эффект. Первоначальное определение member дало бы "
"бесконечный \n"
"поток ответов на запрос(member 'a ?x), но обратное определение даст "
"бесконечную\n"
"рекурсию, и никаких ответов."

#: texi/node-24.texi:711
msgid ""
"@node  24-5 New Implementation, 24-6 Adding Prolog Features, 24-4 The Need "
"for Nondeterminism, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-5 New Implementation\n"
"@cindex 24-5 New Implementation"
msgstr ""
"@node  24-5 New Implementation, 24-6 Adding Prolog Features, 24-4 The Need "
"for Nondeterminism, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-5 Новая Реализация\n"
"@cindex 24-5 New Implementation"

#: texi/node-24.texi:719
msgid ""
"In this section we will see another instance of a familiar pattern. In "
"Section 18-4,\n"
"we found after writing the initial version that if-match could be made much\n"
"faster. By taking advantage of information known at compile-time, we were\n"
"able to write a new version which did less work at runtime. We saw the same\n"
"phenomenon on a larger scale in Chapter 19. Our query interpreter was "
"replaced\n"
"by an equivalent but faster version. The same thing is about to happen to "
"our\n"
"Prolog interpreter."
msgstr ""
"В этом разделе мы увидим еще один пример знакомого шаблона. В разделе 18-4,\n"
"мы обнаружили после написания исходной версиии, что if-match может работать\n"
"намного быстрее. Используюя информацию известную во время компилияции, мы\n"
"смогли написать новую версию, которая выполняла меньше работы во время "
"выполнения.\n"
"Мы увидели то же явление в более широком маштабе в главе 19. Наш "
"интерпретатор \n"
"запросов был заменен эквивалентной, но более быстрой версией. То же самое\n"
"случиться и с нашим интерпретатором Prolog-а."

#: texi/node-24.texi:725
msgid ""
"Figures 24-7, 24-8, and 24-10 define Prolog in a different way. The macro\n"
"with-inference used to be just the interface to a Prolog interpreter. Now it "
"is\n"
"most of the program. The new program has the same general shape as the old "
"one,\n"
"but of the functions defined in Figure 24-8, only prove is called at "
"runtime. The\n"
"others are called by with-inference in order to generate its expansion."
msgstr ""
"Рисунки 24-7, 24-8, и 24-10 определяют Prolog новым способом. Макрос\n"
"with-inference был просто интерфейсом для интерпретатора Prolog-а. Сейчас "
"он, это\n"
"большая часть программы. Новая программа имеет ту же общую форму, что и "
"старая,\n"
"но из функций определенных на Рисунке 24-8, только prove вызывается во "
"время\n"
"выполнения. Другие вызываются с помощью with-inference, чтобы сгенерировать\n"
"его расширение."

#: texi/node-24.texi:731
msgid ""
"Figure 24-7 shows the new definition of with-inference.Asinif-match\n"
"or with-answer, pattern variables are initially bound to gensyms to "
"indicate\n"
"that they haven't yet been assigned real values by matching. Thus the "
"function\n"
"varsym?, which match and fullbind use to detect variables, has to be "
"changed\n"
"to look for gensyms."
msgstr ""
"На рисунке 24-7 показано новое определение with-inference. Как в случае с if-"
"match\n"
"и with-answer, переменные образца изначально связаны с gensyms, чтобы "
"указать, что\n"
"им не были присвоены реальные значения при сопоставлении. Таким образом "
"функция\n"
"varsym?, которую используют match и fullbind для обнраружения переменных, "
"должна\n"
"быть изменена для поиска gensyms."

#: texi/node-24.texi:743
msgid ""
"@lisp\n"
" (defmacro with-inference (query &rest body)\n"
"    (let ((vars (vars-in query #'simple?)) (gb (gensym)))\n"
"        `(with-gensyms ,vars\n"
"           (setq *paths* nil)\n"
"           (=bind (,gb) ,(gen-query (rep_ query))\n"
"                (let ,(mapcar #'(lambda (v)\n"
"                                      `(,v (fullbind ,v ,gb)))\n"
"                                vars)\n"
"                 ,@@body)\n"
"                (fail)))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-inference (query &rest body)\n"
"    (let ((vars (vars-in query #'simple?)) (gb (gensym)))\n"
"        `(with-gensyms ,vars\n"
"           (setq *paths* nil)\n"
"           (=bind (,gb) ,(gen-query (rep_ query))\n"
"                (let ,(mapcar #'(lambda (v)\n"
"                                      `(,v (fullbind ,v ,gb)))\n"
"                                vars)\n"
"                 ,@@body)\n"
"                (fail)))))"

#: texi/node-24.texi:747
msgid ""
" (defun varsym? (x)\n"
"    (and (symbolp x) (not (symbol-package x))))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:749
msgid "                        Figure 24-7: New toplevel macro."
msgstr ""
"                        Рисунок 24-7: Новый макрос верхнего уровня.\n"
"@end cartouche"

#: texi/node-24.texi:759
msgid ""
"To generate the code to establish bindings for the query, with-inference\n"
"calls gen-query (Figure 24-8). The first thing gen-query does is look to "
"see\n"
"whether its first argument is a complex query beginning with an operator "
"like and\n"
"or or. This process continues recursively until it reaches simple queries, "
"which\n"
"are expanded into calls to prove. In the original implementation, such "
"logical\n"
"structure was analyzed at runtime. A complex expression occurring in the "
"body\n"
"of a rule had to be analyzed anew each time the rule was used. This is "
"wasteful\n"
"because the logical structure of rules and queries is known beforehand. The "
"new\n"
"implementation decomposes complex expressions at compile-time."
msgstr ""
"Чтобы сгенерировать код для установления привязок для запроса, with-"
"inference\n"
"вызывает gen-query (Рисунок 24-8). Первое что делает gen-query, это "
"проверяет,\n"
"является ли первый аргумент сложным запросом, начинающимся с оператора "
"подобного\n"
"and или or. Этот процесс продолжается рекурсивно, пока не достигнет простых\n"
"запросов, которые расширяются в вызовы prove. В первоначальной реализации\n"
"такая логическая струкутра, анализировалась во время выполнения. Сложное "
"выражение,\n"
"встречающееся в теле правила, нужно было анализировать заново, каждый раз, "
"когда\n"
"оно использовалось. Это расточительно, потому что логическая структура "
"правил и\n"
"запросов известна заранее. Новая реализация разбирает(декопозирует) сложные "
"выражения\n"
"во время компиляции."

#: texi/node-24.texi:764
msgid ""
"As in the previous implementation, a with-inference expression expands\n"
"into code which iterates through the Lisp code following the query with the "
"pattern\n"
"variables bound to successive values established by the rules. The expansion "
"of\n"
"with-inference concludes with a fail, which will restart any saved states."
msgstr ""
"Как и в предыдущей реализации, выражение with-inference расширяется в код, "
"который\n"
"выполняет итерацию по Lisp коду следующему за запросом с переменными "
"образца,\n"
"связываемыми с последовательными значениями, устанавливаемыми правилами. "
"Расширение\n"
"with-inference завершается с fail, который перезапускает любые сохраненные \n"
"состояния."

#: texi/node-24.texi:768
msgid ""
"The remaining functions in Figure 24-8 generate expansions for complex\n"
"queries-queries joined together by operators like and, or, and not.Ifwehave\n"
"a query like"
msgstr ""
"Остальные функции на Рисунке 24-8 генерируют расширения для сложных запросов "
"-\n"
"запросов, объединенных с помощью операторов подобных and, or, и not. Если у\n"
"нас есть запрос подобный"

#: texi/node-24.texi:772
msgid ""
"@lisp\n"
"(and (big ?x) (red ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:779
msgid ""
"@noindent\n"
"then we want the Lisp code to be evaluated only with those ?x for which "
"both\n"
"conjuncts can be proved. So to generate the expansion of an and, we nest\n"
"the expansion of the second conjunct within that of the first. When (big ?"
"x)\n"
"succeeds we try (red ?x), and if that succeeds, we evaluate the Lisp "
"expressions.\n"
"So the whole expression expands as in Figure 24-9."
msgstr ""
"@noindent\n"
"мы хотим, чтобы код на Lisp-е вычислялся только с теми ?x, для которых могут "
"быть\n"
"доказаны оба коньюнкта(conjuncts/члена выражения and). Таким образом, чтобы "
"создать\n"
"расширение and, мы вкладываем расширение второго коньюнкта в расширение "
"первого.\n"
"Когда (big ?x) успешно, мы попытаемся вычислить (red ?x), и если оно тоже "
"успешно,\n"
"мы вычисллим выражения Lisp. Таким образом, всё выражение расширяется, как "
"показано\n"
"на Рисунке 24-9."

#: texi/node-24.texi:789
msgid ""
"@lisp\n"
" (defun gen-query (expr &optional binds)\n"
"       (case (car expr)\n"
"        (and (gen-and (cdr expr) binds))\n"
"        (or (gen-or (cdr expr) binds))\n"
"        (not (gen-not (cadr expr) binds))\n"
"        (t     `(prove (list ',(car expr)\n"
"                                 ,@@(mapcar #'form (cdr expr)))\n"
"                        ,binds))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun gen-query (expr &optional binds)\n"
"       (case (car expr)\n"
"        (and (gen-and (cdr expr) binds))\n"
"        (or (gen-or (cdr expr) binds))\n"
"        (not (gen-not (cadr expr) binds))\n"
"        (t     `(prove (list ',(car expr)\n"
"                                 ,@@(mapcar #'form (cdr expr)))\n"
"                        ,binds))))"

#: texi/node-24.texi:796
msgid ""
" (defun gen-and (clauses binds)\n"
"       (if (null clauses)\n"
"          `(=values ,binds)\n"
"          (let ((gb (gensym)))\n"
"               `(=bind (,gb) ,(gen-query (car clauses) binds)\n"
"                   ,(gen-and (cdr clauses) gb)))))"
msgstr ""

#: texi/node-24.texi:801
msgid ""
" (defun gen-or (clauses binds)\n"
"       `(choose\n"
"         ,@@(mapcar #'(lambda (c) (gen-query c binds))\n"
"                       clauses)))"
msgstr ""

#: texi/node-24.texi:812
msgid ""
" (defun gen-not (expr binds)\n"
"       (let ((gpaths (gensym)))\n"
"        `(let ((,gpaths *paths*))\n"
"              (setq *paths* nil)\n"
"              (choose (=bind (b) ,(gen-query expr binds)\n"
"                        (setq *paths* ,gpaths)\n"
"                        (fail))\n"
"                       (progn\n"
"                        (setq *paths* ,gpaths)\n"
"                        (=values ,binds))))))"
msgstr ""

#: texi/node-24.texi:815
msgid ""
" (=defun prove (query binds)\n"
"        (choose-bind r *rules* (=funcall r query binds)))"
msgstr ""

#: texi/node-24.texi:821
msgid ""
" (defun form (pat)\n"
"       (if (simple? pat)\n"
"          pat\n"
"          `(cons ,(form (car pat)) ,(form (cdr pat)))))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:823
msgid "                       Figure 24-8: Compilation of queries."
msgstr ""
"                       Рисунок 24-8: Компиляция запросов.\n"
"@end cartouche"

#: texi/node-24.texi:831
msgid ""
"@lisp\n"
" (with-inference (and (big ?x) (red ?x))\n"
"    (print ?x))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (with-inference (and (big ?x) (red ?x))\n"
"    (print ?x))\n"
"@end lisp"

#: texi/node-24.texi:834
msgid ""
"@noindent\n"
"expands into:"
msgstr ""
"@noindent\n"
"расширяется в:"

#: texi/node-24.texi:845
msgid ""
"@lisp\n"
" (with-gensyms (?x)\n"
"    (setq *paths* nil)\n"
"    (=bind (#:g1) (=bind (#:g2) (prove (list 'big ?x) nil)\n"
"                           (=bind (#:g3) (prove (list 'red ?x) #:g2)\n"
"                              (=values #:g3)))\n"
"        (let ((?x (fullbind ?x #:g1)))\n"
"           (print ?x))\n"
"        (fail)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:847
msgid "                     Figure 24-9: Expansion of a conjunction."
msgstr ""
"                     Рисунок 24-9: Расширение коньюнкции(соединения - and).\n"
"@end cartouche"

#: texi/node-24.texi:850
msgid "An and means nesting; an or means a choose. Given a query like"
msgstr ""
"and означает вложение; а or означает выбор(choose). Получая запрос, подобный"

#: texi/node-24.texi:854
msgid ""
"@lisp\n"
"(or (big ?x) (red ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:860
msgid ""
"@noindent\n"
"we want the Lisp expressions to be evaluated for values of ?x established by "
"either\n"
"subquery. The function gen-or expands into a choose over the gen-query of\n"
"each of the arguments. As for not, gen-not is almost identical to prove-not\n"
"(Figure 24-3)."
msgstr ""
"@noindent\n"
"мы хотим, чтобы выражения Lisp вычислялись для значений ?x установленных\n"
"любым из подзапросов. Функция gen-or расширяется в choose поверх gen-query \n"
"каждого из аргументов. Что касается not, gen-not почти идентичен prove-not\n"
"(Рисунок 24-3)."

#: texi/node-24.texi:864
msgid ""
"Figure 24-10 shows the code for defining rules. Rules are translated "
"directly\n"
"into Lisp code generated by rule-fn. Since <- now expands rules into Lisp "
"code,\n"
"compiling a file full of rule definitions will cause rules to be compiled "
"functions."
msgstr ""
"На рисунке 24-10 показан код для определения правил. Правила переводятся "
"непосредственно\n"
"в код Lisp сгенерированный rule-fn. Поскольку <- теперь расширет правила в "
"код на Lisp-е,\n"
"компиляция фала, содержащего определения правил, приведет к тому, что "
"правила будут\n"
"скомпилироваными функциями."

#: texi/node-24.texi:871
msgid ""
"When a rule-function is sent a pattern, it tries to match it with the head "
"of\n"
"the rule it represents. If the match succeeds, the rule-function will then "
"try\n"
"to establish bindings for the body. This task is essentially the same as "
"that\n"
"done by with-inference, and in fact rule-fn ends by calling gen-query. The\n"
"rule-function eventually returns the bindings established for the variables\n"
"occurring in the head of the rule."
msgstr ""
"Когда rule-function отправляет шаблон, она пытается сопоставить его "
"головой(head)\n"
"правила, которое он представляет.  Если сопоставление выполнено успешно, \n"
"rule-function пытается установить привязки для тела. Эта задача, по сути, та "
"же,\n"
"что и with-inference, и на самом деле  rule-fn заканчивается вызовом gen-"
"query. \n"
"В конечном итоге, rule-function возвращает привязки, установленные для "
"переменных,\n"
"встречающихся в  начале(head) правила."

#: texi/node-24.texi:876
msgid ""
"@node 24-6 Adding Prolog Features, 24-7 Examples, 24-5 New Implementation, "
"24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-6 Adding Prolog Features\n"
"@cindex 24-6 Adding Prolog Features"
msgstr ""
"@node 24-6 Adding Prolog Features, 24-7 Examples, 24-5 New Implementation, "
"24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-6 Добавление свойств(функций) Prolog-а\n"
"@cindex 24-6 Adding Prolog Features"

#: texi/node-24.texi:879
msgid ""
"The code already presented can run most \"pure\" Prolog programs. The final "
"step\n"
"is to add extras like cuts, arithmetic, and I/O."
msgstr ""
"Уже представленный код может запускать большинство \"чистых\" Prolog "
"программ. Последний\n"
"шаг - добавить такие дополнения, как cuts, arithmetic, и ввод/вывод(I/O)."

#: texi/node-24.texi:882
msgid ""
"Putting a cut in a Prolog rule causes the search tree to be pruned. "
"Ordinarily,\n"
"when our program encounters a fail, it backtracks to the last choice point. "
"The"
msgstr ""
"Помещение cut в правило Prolog-а приводит к обрезке/сокращению дерева "
"поиска. \n"
"Обычно, когда наша программа сталкиваестя с fail, он возвращется к последней "
"точке\n"
"выбора(choice)."

#: texi/node-24.texi:885
msgid ""
"@lisp\n"
" (defvar *rules* nil)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *rules* nil)"

#: texi/node-24.texi:892
msgid ""
" (defmacro <- (con &rest ant)\n"
"       (let ((ant (if (= (length ant) 1)\n"
"                          (car ant)\n"
"                          `(and ,@@ant))))\n"
"         `(length (conc1f *rules*\n"
"                               ,(rule-fn (rep_ ant) (rep_ con))))))"
msgstr ""

#: texi/node-24.texi:907
msgid ""
" (defun rule-fn (ant con)\n"
"       (with-gensyms (val win fact binds)\n"
"         `(=lambda (,fact ,binds)\n"
"             (with-gensyms ,(vars-in (list ant con) #'simple?)\n"
"                (multiple-value-bind\n"
"                     (,val ,win)\n"
"                     (match ,fact\n"
"                              (list ',(car con)\n"
"                                     ,@@(mapcar #'form (cdr con)))\n"
"                              ,binds)\n"
"                  (if ,win\n"
"                       ,(gen-query ant val)\n"
"                       (fail)))))))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:909
msgid "                       Figure 24-10: Code for defining rules."
msgstr ""
"                       Рисунок 24-10: Код для определиния правил.\n"
"@end cartouche"

#: texi/node-24.texi:917
msgid ""
"@noindent\n"
"implementation of choose in Section 22-4 stores choice points in the global "
"variable\n"
"*paths*. Calling fail restarts the search at the most recent choice point, "
"which\n"
"is the car of *paths*. Cuts introduce a new complication. When the program\n"
"encounters a cut, it will throw away some of the most recent choice points "
"stored\n"
"on *paths*-specifically, all those stored since the last call to prove."
msgstr ""
"@noindent\n"
"Реализация choose в Разделе 22-4 хранит точки выбора в глобальной "
"переменной\n"
"*paths*. Вызов fail возобновляет поиск с самой последней точки выбора, "
"которая \n"
"является началом(car) списка *paths*. Оператор Cut вносит новое усложнение. "
"Когда\n"
"программа встречает cut, он отбрасывает некоторые самые последние точки "
"выбора,\n"
"хранящиеся в *paths*, в частности, все те, котоыре были сохранены с момента\n"
"последнего вызова prove."

#: texi/node-24.texi:921
msgid ""
"The effect is to make rules mutually exclusive. We can use cuts to get the\n"
"effect of a case statement in Prolog programs. For example, if we define "
"minimum\n"
"this way:"
msgstr ""
"Эффект состоит в том, чтобы сделать правила взаимоисключающими. Мы можем "
"использвать\n"
"cut, чтобы получить эффект оператора  case в программах Prolog. Например, "
"если мы\n"
"пределим minimum следующим образом:"

#: texi/node-24.texi:926
msgid ""
"@lisp\n"
"(<- (minimum ?x ?y ?x) (lisp (<= ?x ?y)))\n"
"(<- (minimum ?x ?y ?y) (lisp (> ?x ?y)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:929
msgid ""
"@noindent\n"
"it will work correctly, but inefficiently. Given the query"
msgstr ""
"@noindent\n"
"он будет работать правильно, но не эффективно. Получив запрос"

#: texi/node-24.texi:933
msgid ""
"@lisp\n"
"(minimum 1 2 ?x)\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:939
msgid ""
"Prolog will immediately establish that ?x = 1 from the first rule. A human "
"would\n"
"stop here, but the program will waste time looking for more answers from "
"the\n"
"second rule, because it has been given no indication that the two rules are "
"mutually\n"
"exclusive. On the average, this version of minimum will do 50% more work "
"than\n"
"it needs to. We can fix the problem by adding a cut after the first test:"
msgstr ""
"Prolog сразу установит, что ?x = 1 из первого правила. Человек на этом "
"остановится, но\n"
"программа будет тратить время на поиск овтетов для второго правила, потому "
"что небыло\n"
"никаких указаний, на то, что эти два правила взаимоисключающие. В среднем "
"эта \n"
"версия minimum будет выполнять на 50% больше работы, чем нужно. Мы можем "
"решить проблему,\n"
"добавив cut после первого теста:"

#: texi/node-24.texi:944
msgid ""
"@lisp\n"
"(<- (minimum ?x ?y ?x) (lisp (<= ?x ?y)) (cut))\n"
"(<- (minimum ?x ?y ?y))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:947
msgid ""
"Now when Prolog has finished with the first rule, it will fail all the way "
"out of the\n"
"query instead of moving on to the next rule."
msgstr ""
"Теперь, когда Prolog завершит работу с первым правилом, он потерпит неудачу\n"
"обрабатывая все возможные пути, не переходя к следующему правилу."

#: texi/node-24.texi:953
msgid ""
"It is trivially easy to modify our program to handle cuts. On each call to\n"
"prove, the current state of *paths* is passed as a parameter. If the "
"program\n"
"encounters a cut, it just sets *paths* back to the old value passed in the "
"parameter.\n"
"Figures 24-11 and 24-12 show the code which has to be modified to handle "
"cuts.\n"
"(Changed lines are marked with semicolons. Not all the changes are due to "
"cuts.)"
msgstr ""
"Очень легко изменить нашу программу для обработки cut. При каждом вызове "
"prove\n"
"текущее состояние *paths* передается в качестве параметра. Если программа "
"встречает\n"
"cut, она просто устанавливает *paths* обратно на старое значение, переданное "
"в параметре.\n"
"На рисунках 24-11 и 24-12 показан код, который необходимо изменить для "
"обработки cut.\n"
"(Измененные строки отмечены точкой с запятой. Не все изменения происходят из-"
"за cut.)"

#: texi/node-24.texi:957
msgid ""
"Cuts which merely make a program more efficient are called green cuts. The\n"
"cut in minimum was a green cut. Cuts which make a program behave "
"differently\n"
"are called red cuts. For example, if we define the predicate artist as "
"follows:"
msgstr ""
"Cut(срезы), которые просто делают программу более эффективной, называются \n"
"зелеными cut. Cut как минимум будет зеленым cut. Cut, которые заставляют \n"
"программу вести себя по-другому, называются красными cut. Например, если \n"
"мы определим предикат artist следующим образом:"

#: texi/node-24.texi:962
msgid ""
"@lisp\n"
"(<- (artist ?x) (sculptor ?x) (cut))\n"
"(<- (artist ?x) (painter ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:966
msgid ""
"@noindent\n"
"the result is that, if there are any sculptors, then the query can end "
"there. If there\n"
"are no sculptors then painters get to be considered as artists:"
msgstr ""
"@noindent\n"
"результат состоит в том, что, если есть какие-либо sculptor, тогда запрос "
"может \n"
"на этом и закончиться. Если sculptor нет, тогда painter будет "
"рассматриваться \n"
"как artist:"

#: texi/node-24.texi:976
msgid ""
"@example\n"
"> (progn (<- (painter 'klee))\n"
"            (<- (painter 'soutine)))\n"
"4> (with-inference (artist ?x)\n"
"        (print ?x))\n"
"KLEE\n"
"SOUTINE\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:978
msgid ""
"But if there are sculptors, the cut stops inference with the first rule:"
msgstr "Но если есть sculptor, cut останавливает вывод на первом правиле:"

#: texi/node-24.texi:987
msgid ""
"@example\n"
"> (<- (sculptor 'hepworth))\n"
"5> (with-inference (artist ?x)\n"
"        (print ?x))\n"
"HEPWORTH\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:1003
msgid ""
"@lisp\n"
" (defun rule-fn (ant con)\n"
"       (with-gensyms (val win fact binds paths)                     ;\n"
"        `(=lambda (,fact ,binds ,paths)                             ;\n"
"              (with-gensyms ,(vars-in (list ant con) #'simple?)\n"
"               (multiple-value-bind\n"
"                   (,val ,win)\n"
"                   (match ,fact\n"
"                             (list ',(car con)\n"
"                                    ,@@(mapcar #'form (cdr con)))\n"
"                             ,binds)\n"
"                 (if ,win\n"
"                      ,(gen-query ant val paths)                    ;\n"
"                      (fail)))))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun rule-fn (ant con)\n"
"       (with-gensyms (val win fact binds paths)                     ;\n"
"        `(=lambda (,fact ,binds ,paths)                             ;\n"
"              (with-gensyms ,(vars-in (list ant con) #'simple?)\n"
"               (multiple-value-bind\n"
"                   (,val ,win)\n"
"                   (match ,fact\n"
"                             (list ',(car con)\n"
"                                    ,@@(mapcar #'form (cdr con)))\n"
"                             ,binds)\n"
"                 (if ,win\n"
"                      ,(gen-query ant val paths)                    ;\n"
"                      (fail)))))))"

#: texi/node-24.texi:1014
msgid ""
" (defmacro with-inference (query &rest body)\n"
"       (let ((vars (vars-in query #'simple?)) (gb (gensym)))\n"
"        `(with-gensyms ,vars\n"
"              (setq *paths* nil)\n"
"              (=bind (,gb) ,(gen-query (rep_ query) nil '*paths*) ;\n"
"               (let ,(mapcar #'(lambda (v)\n"
"                                     `(,v (fullbind ,v ,gb)))\n"
"                                vars)\n"
"                 ,@@body)\n"
"               (fail)))))"
msgstr ""

#: texi/node-24.texi:1027
msgid ""
" (defun gen-query (expr binds paths)                                ;\n"
"       (case (car expr)\n"
"        (and (gen-and (cdr expr) binds paths))                      ;\n"
"        (or      (gen-or (cdr expr) binds paths))                   ;\n"
"        (not (gen-not (cadr expr) binds paths))                     ;\n"
"        (lisp (gen-lisp (cadr expr) binds))                         ;\n"
"        (is      (gen-is (cadr expr) (third expr) binds))           ;\n"
"        (cut `(progn (setq *paths* ,paths)                          ;\n"
"                         (=values ,binds)))                         ;\n"
"        (t       `(prove (list ',(car expr)\n"
"                                 ,@@(mapcar #'form (cdr expr)))\n"
"                         ,binds *paths*))))                         ;"
msgstr ""

#: texi/node-24.texi:1032
msgid ""
" (=defun prove (query binds paths)                                  ;\n"
"        (choose-bind r *rules*\n"
"          (=funcall r query binds paths)))                          ;\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1034
msgid "                 Figure 24-11: Adding support for new operators."
msgstr ""
"                 Рисунок 24-11: Добавление поддержки для новых операторов.\n"
"@end cartouche"

#: texi/node-24.texi:1042
msgid ""
"@lisp\n"
" (defun gen-and (clauses binds paths)                              ;\n"
"   (if (null clauses)\n"
"         `(=values ,binds)\n"
"         (let ((gb (gensym)))\n"
"          `(=bind (,gb) ,(gen-query (car clauses) binds paths);\n"
"             ,(gen-and (cdr clauses) gb paths)))))                 ;"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun gen-and (clauses binds paths)                              ;\n"
"   (if (null clauses)\n"
"         `(=values ,binds)\n"
"         (let ((gb (gensym)))\n"
"          `(=bind (,gb) ,(gen-query (car clauses) binds paths);\n"
"             ,(gen-and (cdr clauses) gb paths)))))                 ;"

#: texi/node-24.texi:1047
msgid ""
" (defun gen-or (clauses binds paths)                               ;\n"
"   `(choose\n"
"         ,@@(mapcar #'(lambda (c) (gen-query c binds paths))        ;\n"
"                    clauses)))"
msgstr ""

#: texi/node-24.texi:1058
msgid ""
" (defun gen-not (expr binds paths)                                 ;\n"
"   (let ((gpaths (gensym)))\n"
"        `(let ((,gpaths *paths*))\n"
"          (setq *paths* nil)\n"
"          (choose (=bind (b) ,(gen-query expr binds paths)         ;\n"
"                      (setq *paths* ,gpaths)\n"
"                      (fail))\n"
"                    (progn\n"
"                      (setq *paths* ,gpaths)\n"
"                      (=values ,binds))))))"
msgstr ""

#: texi/node-24.texi:1063
msgid ""
" (defmacro with-binds (binds expr)\n"
"   `(let ,(mapcar #'(lambda (v) `(,v (fullbind ,v ,binds)))\n"
"                      (vars-in expr))\n"
"         ,expr))"
msgstr ""

#: texi/node-24.texi:1068
msgid ""
" (defun gen-lisp (expr binds)\n"
"   `(if (with-binds ,binds ,expr)\n"
"          (=values ,binds)\n"
"          (fail)))"
msgstr ""

#: texi/node-24.texi:1074
msgid ""
" (defun gen-is (expr1 expr2 binds)\n"
"   `(aif2 (match ,expr1 (with-binds ,binds ,expr2) ,binds)\n"
"            (=values it)\n"
"            (fail)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1076
msgid "               Figure 24-12: Adding support for new operators."
msgstr ""
"               Рисунок 24-12: Добавление поддержки для новых операторов.\n"
"@end cartouche"

#: texi/node-24.texi:1091
msgid ""
"@example\n"
"       rule       : (<-  sentence  query )\n"
"       query      : (not  query )\n"
"                  : (and  query *)\n"
"                  : (lisp  lisp expression )\n"
"                  : (is  variable  lisp expression )\n"
"                  : (cut)\n"
"                  : (fail)\n"
"                  :  sentence \n"
"       sentence  : ( symbol  argument *)\n"
"       argument  :  variable \n"
"                  :  lisp expression \n"
"       variable  : ? symbol \n"
"@end example"
msgstr ""
"@cartouche\n"
"@example\n"
"       rule       : (<-  sentence  query )\n"
"       query      : (not  query )\n"
"                  : (and  query *)\n"
"                  : (lisp  lisp expression )\n"
"                  : (is  variable  lisp expression )\n"
"                  : (cut)\n"
"                  : (fail)\n"
"                  :  sentence \n"
"       sentence  : ( symbol  argument *)\n"
"       argument  :  variable \n"
"                  :  lisp expression \n"
"       variable  : ? symbol \n"
"@end example"

#: texi/node-24.texi:1093
msgid "                             Figure 24-13: New syntax of rules."
msgstr ""
"                             Рисунок 24-13: Новый синтаксис правил.\n"
"@end cartouche"

#: texi/node-24.texi:1101
msgid ""
"The cut is sometimes used in conjunction with the Prolog fail operator. Our\n"
"function fail does exactly the same thing. Putting a cut in a rule makes it "
"like a\n"
"one-way street: once you enter, you're committed to using only that rule. "
"Putting\n"
"a cut-fail combination in a rule makes it like a one-way street in a "
"dangerous\n"
"neighborhood: once you enter, you're committed to leaving with nothing. A\n"
"typical example is in the implementation of not-equal:"
msgstr ""
"Иногда cut используется вместе с оператором Prolog fail. Наша функция fail \n"
"делает то же самое. Помещение cut в правило превращает его в улицу с \n"
"односторонним движением: когда вы входите, вы обязуетесь использовать \n"
"только это правило. Помещение в правило комбинации cut-fail превращает ее \n"
"в улицу с односторонним движением в опасном районе: как только вы входите, \n"
"вы полны решимости уйти ни с чем. Типичный пример - реализация not-equal:"

#: texi/node-24.texi:1106
msgid ""
"@lisp\n"
"(<- (not-equal ?x ?x) (cut) (fail))\n"
"(<- (not-equal ?x ?y))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1111
msgid ""
"The first rule here is a trap for impostors. If we're trying to prove a fact "
"of the\n"
"form (not-equal 1 1), it will match with the head of the first rule and thus "
"be\n"
"doomed. The query (not-equal 1 2), on the other hand, will not match the\n"
"head of the first rule, and will go on to the second, where it succeeds:"
msgstr ""
"Первое правило здесь - ловушка для самозванцев. Если мы пытаемся доказать "
"факт в \n"
"виде (not-equal 1 1), он будет соответствовать голове(head) первого правила "
"и\n"
"таким образом, будет обречен. Запрос (not-equal 1 2), с другой стороны, не "
"будет \n"
"соответствовать голове(head) первого правила и перейдет ко второму, где он \n"
"завершится успешно:"

#: texi/node-24.texi:1120
msgid ""
"@example\n"
"> (with-inference (not-equal 'a 'a)\n"
"         (print t))\n"
"@@> (with-inference (not-equal '(a a) '(a b))\n"
"         (print t))\n"
"T@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:1124
msgid ""
"The code shown in Figures 24-11 and 24-12 also gives our program "
"arithmetic,\n"
"I/O, and the Prolog is operator. Figure 24-13 shows the complete syntax of "
"rules\n"
"and queries."
msgstr ""
"Код, показанный на рисунках 24-11 и 24-12, также дает нашей программе "
"арифметику, \n"
"ввод-вывод и оператор Prolog is. На рисунке 24-13 показан полный синтаксис \n"
"правил и запросов."

#: texi/node-24.texi:1133
msgid ""
"We add arithmetic (and more) by including a trapdoor to Lisp. Now in "
"addition\n"
"to operators like and and or,wehavethelisp operator. This may be followed\n"
"by any Lisp expression, which will be evaluated with the variables within it "
"bound\n"
"to the bindings established for them by the query. If the expression "
"evaluates to\n"
"nil, then the lisp expression as a whole is equivalent to a (fail); "
"otherwise it\n"
"is equivalent to (and)."
msgstr ""
"Мы добавляем арифметику (и многое другое), добавляя люк в Лисп. Теперь в "
"дополнение \n"
"к таким операторам, как and и or, у нас есть оператор lisp. После него может "
"следовать\n"
"любое выражение Lisp, которое будет вычисляться с переменными внутри границ "
"привязок, \n"
"установленными для них запросом. Если выражение вычисляется как nil, тогда "
"Lisp выражение\n"
"в целом эквивалентно (fail); в противном случае оно эквивалентно (and)."

#: texi/node-24.texi:1142
msgid ""
"As an example of the use of the lisp operator, consider the Prolog "
"definition\n"
"of ordered, which is true of lists whose elements are arranged in ascending "
"order:\n"
"@lisp\n"
"(<- (ordered (?x)))\n"
"(<- (ordered (?x ?y . ?ys))\n"
"        (lisp (<= ?x ?y))\n"
"        (ordered (?y . ?ys)))\n"
"@end lisp"
msgstr ""
"В качестве примера использования оператора lisp рассмотрим определение "
"ordered\n"
"в Прологе, которое верно для списков, элементы которых расположены в "
"порядке \n"
"возрастания:\n"
"@lisp\n"
"(<- (ordered (?x)))\n"
"(<- (ordered (?x ?y . ?ys))\n"
"        (lisp (<= ?x ?y))\n"
"        (ordered (?y . ?ys)))\n"
"@end lisp"

#: texi/node-24.texi:1146
msgid ""
"In English, a list of one element is ordered, and a list of two or more "
"elements is\n"
"ordered if the first element of the list is less than or equal to the "
"second, and the\n"
"list from the second element on is ordered."
msgstr ""
"В английском языке список одного элемента упорядочен, а список двух или "
"более элементов \n"
"упорядочен, если первый элемент списка меньше или равен второму, а список из "
"второго \n"
"элемента упорядочен."

#: texi/node-24.texi:1155
msgid ""
"@example\n"
"> (with-inference (ordered '(1 2 3))\n"
"        (print t))\n"
"T@@> (with-inference (ordered '(1 3 2))\n"
"        (print t))\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:1161
msgid ""
"By means of the lisp operator we can provide other features offered by\n"
"typical Prolog implementations. Prolog I/O predicates can be duplicated by "
"putting\n"
"Lisp I/O calls within lisp expressions. The Prolog assert, which as a side-\n"
"effect defines new rules, can be duplicated by calling the <- macro within "
"lisp\n"
"expressions."
msgstr ""
"С помощью оператора lisp мы можем предоставить другие функции, предлагаемые\n"
"Типичными реализациями Пролога. Предикаты ввода/вывода Prolog-а можно "
"дублировать, \n"
"помещая вызовы Lisp I/O в выражение lisp. Утверждение Prolog-а, которое в "
"качестве \n"
"побочного эффекта определяет новые правила, может быть продублировано путем "
"вызова \n"
"макроса <- в выражениях lisp."

#: texi/node-24.texi:1168
msgid ""
"The is operator offers a form of assignment. It takes two arguments, a "
"pattern\n"
"and a Lisp expression, and tries to match the pattern with the result "
"returned by the\n"
"expression. If the match fails, then the program calls fail; otherwise it "
"proceeds\n"
"with the new bindings. Thus, the expression (is ?x 1) has the effect of "
"setting\n"
"?x to 1, or more precisely, insisting that ?x be 1. We need is to calculate-"
"for\n"
"example, to calculate factorials:"
msgstr ""
"Оператор is предлагает форму присваивания. Он принимает два аргумента, "
"образец и \n"
"выражение Lisp, и пытается сопоставить образец с результатом, возвращаемым "
"выражением. \n"
"Если совпадение не удается, то вызовы программы завершаются неудачно; в "
"противном \n"
"случае оно продолжается с новыми привязками. Таким образом, выражение (is? X "
"1) \n"
"имеет эффект установки ?X в 1, или, точнее, настаивая на том, чтобы ?X было "
"1. \n"
"Нам нужно вычислить, например, factorials(факториалы):"

#: texi/node-24.texi:1177
msgid ""
"@lisp\n"
"(<- (factorial 0 1))\n"
"(<- (factorial ?n ?f)\n"
"        (lisp (> ?n 0))\n"
"        (is ?n1 (- ?n 1))\n"
"        (factorial ?n1 ?f1)\n"
"        (is ?f (* ?n ?f1)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1180
msgid ""
"We use this definition by making a query with a number n as the first "
"argument\n"
"and a variable as the second:"
msgstr ""
"Мы используем это определение, делая запрос с номером n в качестве первого "
"аргумента \n"
"и переменной в качестве второго:"

#: texi/node-24.texi:1187
msgid ""
"@example\n"
"> (with-inference (factorial 8 ?x)\n"
"             (print ?x))\n"
"40320\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:1191
msgid ""
"Note that the variables used in a lisp expression, or in the second argument "
"to\n"
"is, must have established bindings for the expression to return a value. "
"This\n"
"restriction holds in any Prolog. For example, the query:"
msgstr ""
"Обратите внимание, что переменные, используемые в выражении lisp или во "
"втором \n"
"аргументе is, должны иметь привязки, чтобы выражение возвращало значение. \n"
"Это ограничение действует в любом Прологе. Например, запрос:"

#: texi/node-24.texi:1196
msgid ""
"@lisp\n"
"(with-inference (factorial ?x "
"120)                                          ; wrong\n"
"     (print ?x))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1200
msgid ""
"won't work with this definition of factorial, because ?n will be unknown "
"when\n"
"the lisp expression is evaluated. So not all Prolog programs are like "
"append:\n"
"many insist, like factorial, that certain of their arguments be real values."
msgstr ""
"не будет работать с этим определением факториала, потому что ?n будет "
"неизвестно \n"
"при вычислении выражения lisp. Так что не все программы Prolog похожи на "
"append: \n"
"многие настаивают, как факториал, на том, что некоторые их аргументы "
"являются \n"
"реальными значениями."

#: texi/node-24.texi:1205
msgid ""
"@node 24-7 Examples, 24-8 The Senses of Compile, 24-6 Adding Prolog "
"Features, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-7 Examples\n"
"@cindex 24-7 Examples"
msgstr ""
"@node 24-7 Examples, 24-8 The Senses of Compile, 24-6 Adding Prolog "
"Features, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-7 Примеры\n"
"@cindex 24-7 Examples"

#: texi/node-24.texi:1211
msgid ""
"This final section shows how to write some example Prolog programs in our\n"
"implementation. The rules in Figure 24-14 define quicksort. These rules "
"imply\n"
"facts of the form (quicksort xy), where x is a list and y is a list of the "
"same\n"
"elements sorted in ascending order. Variables may appear in the second "
"argument\n"
"position:"
msgstr ""
"В этом последнем разделе показано, как написать несколько примеров программ "
"на\n"
"Prolog в нашей реализации. Правила на Рисунке 24-14 определяют быструю "
"сортировку\n"
"- quicksort. Эти правила подразумевают факты вида (quicksort xy), где x это "
"список,\n"
"а y это список тех же элементов, отсортированных в порядке возрастания. "
"Переменные\n"
"могут появляться в позиции второго аргумента:"

#: texi/node-24.texi:1218
msgid ""
"@example\n"
"     > (with-inference (quicksort '(3 2 1) ?x)\n"
"             (print ?x))\n"
"     (123)\n"
"     @\n"
"@end example"
msgstr ""

#: texi/node-24.texi:1227
msgid ""
"An I/O loop is a test for our Prolog, because it makes use of the cut, lisp, "
"and\n"
"is operators. The code is shown in Figure 24-15. These rules should be "
"invoked\n"
"by trying to prove (echo), with no arguments. That query will match the "
"first\n"
"rule, which will bind ?x to the result returned by read, and then try to "
"establish\n"
"(echo ?x). The new query can match either of the second two rules. If ?x =\n"
"done, then the query will terminate in the second rule. Otherwise the query "
"will\n"
"only match the third rule, which prints the value read, and starts the "
"process over\n"
"again."
msgstr ""
"Цикл ввода/вывода является тестом для нашего Prolog, поскольку он "
"использует\n"
"операторы cut, lisp, и is. Код показан на рисунке 24-15. Эти правила "
"следует\n"
"вызывать, пытаясь доказать (echo), без аргументов. Этот запрос будет "
"соответствовать\n"
"первому правилу, которое связывает ?x с результатом возвращенным read, и "
"затем \n"
"пытаестя установить (echo ?x). Новый запрос может соответствовать любому из\n"
"двух вторых правил. Если ?x = done, то запрос завершиться на втором правиле. "
"В\n"
"противном случае запрос будет соответствовать только третьему правилу,\n"
"котое печатает прочитанное значение и запускает процесс заново."

#: texi/node-24.texi:1230
msgid ""
"@lisp\n"
" (setq *rules* nil)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (setq *rules* nil)"

#: texi/node-24.texi:1234
msgid ""
" (<- (append nil ?ys ?ys))\n"
" (<- (append (?x . ?xs) ?ys (?x . ?zs))\n"
"        (append ?xs ?ys ?zs))"
msgstr ""

#: texi/node-24.texi:1241
msgid ""
" (<- (quicksort (?x . ?xs) ?ys)\n"
"        (partition ?xs ?x ?littles ?bigs)\n"
"        (quicksort ?littles ?ls)\n"
"        (quicksort ?bigs ?bs)\n"
"        (append ?ls (?x . ?bs) ?ys))\n"
" (<- (quicksort nil nil))"
msgstr ""

#: texi/node-24.texi:1250
msgid ""
" (<- (partition (?x . ?xs) ?y (?x . ?ls) ?bs)\n"
"        (lisp (<= ?x ?y))\n"
"        (partition ?xs ?y ?ls ?bs))\n"
" (<- (partition (?x . ?xs) ?y ?ls (?x . ?bs))\n"
"        (lisp (> ?x ?y))\n"
"        (partition ?xs ?y ?ls ?bs))\n"
" (<- (partition nil ?y nil nil))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1252
msgid "                            Figure 24-14: Quicksort."
msgstr ""
"                            Рисунок 24-14: Быстрая сортировка(Quicksort).\n"
"@end cartouche"

#: texi/node-24.texi:1265
msgid ""
"@lisp\n"
" (<- (echo)\n"
"        (is ?x (read))\n"
"        (echo ?x))\n"
" (<- (echo 'done)\n"
"        (cut))\n"
" (<- (echo ?x)\n"
"        (lisp (prog1 t (format t \"~A~%\" ?x)))\n"
"        (is ?y (read))\n"
"        (cut)\n"
"        (echo ?y))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (<- (echo)\n"
"        (is ?x (read))\n"
"        (echo ?x))\n"
" (<- (echo 'done)\n"
"        (cut))\n"
" (<- (echo ?x)\n"
"        (lisp (prog1 t (format t \"~A~%\" ?x)))\n"
"        (is ?y (read))\n"
"        (cut)\n"
"        (echo ?y))\n"
"@end lisp"

#: texi/node-24.texi:1267
msgid "                      Figure 24-15: An I/O loop in Prolog."
msgstr ""
"                      Рисунок 24-15: Цикл ввода/вывода(I/O) в Prolog-е.\n"
"@end cartouche"

#: texi/node-24.texi:1270
msgid ""
"Collectively, the rules define a program that will continue to echo what "
"you\n"
"type, until you type done:"
msgstr ""
"В совокупности правила определяют программу, которая будет продолжать "
"повторять, то\n"
"что вы печатаете, до тех пор, пока вы не напечатаете done:"

#: texi/node-24.texi:1280
msgid ""
"@example\n"
"> (with-inference (echo))\n"
"hi\n"
"HI\n"
"ho\n"
"HO\n"
"done\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-24.texi:1283
msgid ""
"Programs like this are difficult to read because they subvert the abstract "
"model of\n"
"Prolog. It might be easier to understand echo if we look at a literal Lisp "
"translation"
msgstr ""
"Такие программы трудно читать, потому что они разрушают абстрактную модель "
"Prolog-а. \n"
"Может быть, легче понять echo если мы посмотрим на буквальную трансляцию в "
"код Lisp."

#: texi/node-24.texi:1291
msgid ""
"@lisp\n"
"(defun echo (&rest args)\n"
"     (cond ((null args) (echo (read)))\n"
"             ((eq (car args) 'done) nil)\n"
"             (t (format t \"~A~%\" (car args))\n"
"                 (echo (read)))))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1294
msgid ""
"@noindent\n"
"which in idiomatic Common Lisp would be:"
msgstr ""
"@noindent\n"
"который в идиоматическом Common Lisp будет:"

#: texi/node-24.texi:1301
msgid ""
"@lisp\n"
"(defun echo (&optional (arg (read)))\n"
"     (unless (eq arg 'done)\n"
"        (format t \"~A~%\" arg)\n"
"        (echo)))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1306
msgid ""
"@node 24-8 The Senses of Compile,  , 24-7 Examples, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-8 The Senses of Compile\n"
"@cindex 24-8 The Senses of Compile"
msgstr ""
"@node 24-8 The Senses of Compile,  , 24-7 Examples, 24 Prolog\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 24-8 Смыслы Компиляции\n"
"@cindex 24-8 The Senses of Compile"

#: texi/node-24.texi:1311
msgid ""
"The word \"compile\" has several senses. In the most general sense, to "
"compile is\n"
"to transform some abstract description of a program into lower-level code. "
"The\n"
"program described in this chapter is certainly a compiler in this sense, "
"because it\n"
"translates rules into Lisp functions."
msgstr ""
"Слово \"компиляция\"(compile) имеет несколько смыслов. В самом общем смысле, "
"компиляция\n"
"это преобразование некоторого абстрактного описания программы в код более "
"низкого\n"
"уровня. Программа, описанная в этой главе, безусловно является компилятором, "
"в этом\n"
"смысле, потому что она переводит правила в функции Lisp."

#: texi/node-24.texi:1318
msgid ""
"In a more specific sense, to compile is to transform a program into machine\n"
"language. Good Common Lisps compile functions into native machine code. As\n"
"mentioned on page 25, if code which generates closures is compiled, it will "
"yield\n"
"compiled closures. Thus the program described here is a compiler in the "
"stricter\n"
"sense as well. In a good Lisp, our Prolog programs will get translated into "
"machine\n"
"language."
msgstr ""
"В более конкретном смысле, компиляция означает преобразование программы в "
"машинный\n"
"язык. Хороший Common Lisp-ы компилируют функции в машинный код. Как "
"упомянуто на\n"
"стр. 25, если код, который генерирует замыкания, скомпилирован, он даст "
"скомпилированные\n"
"замыкания. Таким образом, описанная здесь программа, также является более "
"строгим\n"
"компилятором. В хорошем Lisp, наши Prolog программы будут переведены на "
"машинный язык."

#: texi/node-24.texi:1324
msgid ""
"However, the program described here is still not a Prolog compiler. For\n"
"programming languages there is a still more specific sense of \"compile,\" "
"and\n"
"merely generating machine code is not enough to satisfy this definition. A "
"compiler\n"
"for a programming language must optimize as well as translate. For example, "
"if a\n"
"Lisp compiler is asked to compile an expression like"
msgstr ""
"Вместе с тем, описанная здесь программа, все еще не является компилятором "
"Prolog-а.\n"
"Для языков программирования существует еще более конкретный смысл "
"\"компиляции\", \n"
"и простого создания машинного кода недостаточно для удовлетворения этого "
"определения.\n"
"Компилятор для языка программирования должен как оптимизировать код, так и "
"транслировать\n"
"его. Например, если компилятору Lisp предлагается скомпилировать выражение "
"вроде"

#: texi/node-24.texi:1328
msgid ""
"@lisp\n"
"(+ x (+ 2 5))\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1333
msgid ""
"@noindent\n"
"it should be smart enough to realize that there is no reason to wait until "
"runtime\n"
"to evaluate (+ 2 5). The program can be optimized by replacing it with 7, "
"and\n"
"instead compiling"
msgstr ""
"@noindent\n"
"он должен быть достаточно умен, чтобы понять, что нет причин ждать, пока во "
"время\n"
"выполнения вычислиться (+ 2 5). Программу можно оптимизировать, заменив это "
"выражение\n"
"на 7, и вместо него компилировать"

#: texi/node-24.texi:1337
msgid ""
"@lisp\n"
"(+ x 7)\n"
"@end lisp"
msgstr ""

#: texi/node-24.texi:1344
msgid ""
"In our program, all the compiling is done by the Lisp compiler, and it is\n"
"looking for Lisp optimizations, not Prolog optimizations. Its optimizations "
"will\n"
"be valid ones, but too low-level. The Lisp compiler doesn't know that the "
"code\n"
"it's compiling is meant to represent rules. While a real Prolog compiler "
"would be\n"
"looking for rules that could be transformed into loops, our program is "
"looking for\n"
"expressions that yield constants, or closures that could be allocated on the "
"stack."
msgstr ""
"В нашей программе, вся компиляция выполняется компилятором Lisp, и он ищет\n"
"оптимизацию для Lisp-аs, а не оптимизацию Prolog-а. Ее оптимизация будет "
"действенной,\n"
"но слижком низкоуровневой. Компилятор Lisp не знает, что код, который он "
"компилирует,\n"
"предназначен для представления правил. В то время как настоящий компилятор "
"Prolog будет\n"
"искать правила, которые можно преобразовывать в циклы, наша программа ищет "
"выражения,\n"
"которые выдают констатны, или замыкания, которые могут быть размещены в "
"стеке."

#: texi/node-24.texi:1350
msgid ""
"Embedded languages allow you to make the most of available abstractions,\n"
"but they are not magic. If you want to travel all the way from a very "
"abstract\n"
"representation to fast machine code, someone still has to tell the computer "
"how to\n"
"do it. In this chapter we travelled a good part of that distance with "
"surprisingly\n"
"little code, but that is not the same as writing a true Prolog compiler."
msgstr ""
"Встроенные языки позволяют максимально использовать доступные абстракции, но "
"они\n"
"не волшебны. Если вы хотите пройти путь от очень абстрактного представления "
"до\n"
"быстрого машинного кода, кто-то еще длолжен сказать компьютеру, как это "
"сделать.\n"
"В этой главе мы прошли большую часть этого расстояния с удивительно "
"небольшим кодом,\n"
"но это не тоже самое, что написиать настоящий компилятор Prolog-а."
