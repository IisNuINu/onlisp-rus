@node 5 Returning Functions, 6 Functions as Representation, 4 Utility Functions, Top
@comment  node-name,  next,  previous,  up
@chapter 5 Возврат Функций
@cindex 5 Returning Functions

Предыдущая глава показала, как способность передавать функции в качестве аргументов
приводит к большим возможностям для абстрагирования. Чем больше мы можем использовать
функции, тем болье мы имеем возможностей. Определив функции для построения и возврата
новых функций, мы можем увеличить эффект от утилит, которые принимают функции как
аргументы.

Утилиты в этой главе работают с функциями. Это было бы более естественно, хотя бы
в  Common Lisp, чтобы написать множество из них для работы с выражениями, то есть
как макросы. Слой макросов будет накладываться на некоторые из этих операторов в
главе 15. Тем не менее, важно знать, какая часть задачи может быть сделана 
функциями, даже если мы в конечном итоге будем вызывать эти функции только через
макросы.

@menu
* 5-1 Common Lisp Evolves::     
* 5-2 Orthogonality::           
* 5-3 Memoizing::               
* 5-4 Composing Functions::     
* 5-5 Recursion on Cdrs::       
* 5-6 Recursion on Subtrees::   
* 5-7 When to Build Functions::  
@end menu

@node 5-1 Common Lisp Evolves, 5-2 Orthogonality, 5 Returning Functions, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-1 Common Lisp Развивается
@cindex 5-1 Common Lisp Evolves

Common Lisp изначально предоставлял несколько пар взаимодополняющих функцй. Функции
remove-if и remove-if-not составляют одну такую пару. Если pred является предикатом
одного аргумента, то

@lisp
(remove-if-not #'pred lst)
@end lisp

является эквивалентным

@lisp
(remove-if #'(lambda (x) (not (pred x))) lst)
@end lisp

Изменяя функцию, заданную в качестве аргумента, мы можем продублировать эффект 
другой функции. В таком случае, почему существуют две функции? CLTL2 включает новую
функцию предназначенную для случаев, подобных этому: функция complement принимает
предикат p и возвращает функцию, которая всегда возвращает проитвоположное значение.
Когда p возвращает истину, complement возвращает ложь, и наоборот. Теперь мы можем
заменить

@lisp
(remove-if-not #'pred lst)
@end lisp

с эквивалентом

@lisp
(remove-if (complement #'pred) lst)
@end lisp

С complement, есть мало оснований для продолжения использования функций
-if-not. @footnote{За исключением, возможно remove-if-not, которая используется
чаще чем remove-if.}Действительно, CLTL2 (стр. 391) говорит, что
их использование сейчас устарело. Если они остаются в Common Lisp, это делается
только ради совместимости.

Новый оператор complement вершина важного айсберга: функций которые возвращают
функции. Это давно стало важной частью идиом на Scheme. Scheme была первым Lisp-ом
сделавшим функции лексическим замыканием, и это делает интересным использование
функций в качестве возвращаемых значений.

Не то чтобы мы не могли возвращать функции в динамческом области охвата связывания Lisp. 
Следующая функция будет работать одинаково как с использованием динамической области охвата,
так и с использованием лексического охвата связывания(контекта).

@lisp
(defun joiner (obj)
      (typecase obj
        (cons       #'append)
        (number #'+)))
@end lisp

Она берет объект и в зависимости от его типа, возвращает функцию для добавления таких
объектов. Мы могли бы использовать ее для определения полиморфной функции соединения(join),
которая бы работала для чисел или списков:

@lisp
(defun join (&rest args)
      (apply (joiner (car args)) args))
@end lisp

Тем не менее, возврат постоянных функций является пределом того, что мы можем сделать с
динамической областью охвата. Что мы не можем сделать(хорошо), так это строить функции
во время выполнения; joiner может вернуть одну из двух функций, но оба варианта фиксированные.

На странице 18 мы видели еще одну функцию для возврата функций, которая основывалась
на лексической области  охвата(лексическом связывании):

@lisp
(defun make-adder (n)
      #'(lambda (x) (+ x n)))
@end lisp

Вызов make-adder приводит к созданию замыкания, поведение которого зависит от значения
переданного как аргумент в функцию:

@example
> (setq add3 (make-adder 3))
#<Interpreted-Function BF1356>
> (funcall add3 2)
5
@end example

В лексическом контексте(лексической области охвата), вместо простого выбора из группы константных
функций, мы можем создавать новые замыкания во время выполнения. С динамической областью действия
привязок эта техника недоступна.@footnote{Под динамической областью, мы могли бы написать что то
вроде make-adder, но вряд ли это работало. Привязка n будет определяться средой, в которую будет 
возвращена функция и мы не имеем никакого контроля над этим.}  Если мы посмотрим, как написан
complement, мы увидим, что этот оператор возвращает замыкание:

@lisp
(defun complement (fn)
     #'(lambda (&rest args) (not (apply fn args))))
@end lisp

Функция возвращаемая complement использует значение параметра fn, который был
передан когда complement был вызван. Так что вместо того, чтобы просто выбирать из
группы постоянных функций, complement может создавать обратные функции для любой
переданной ей функции:

@example
> (remove-if (complement #'oddp) '(123456))
(135)
@end example

Возможность передавать функции в качестве аргументов является мощным инструментом для
абстракции. Возможность писать функции, которые возвращают функции, позволяет нам
максимально использовать это. Остальные разделы представляют несколько примеров утилит,
которые взвращают функции.

@node 5-2 Orthogonality, 5-3 Memoizing, 5-1 Common Lisp Evolves, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-2 Ортогональность
@cindex 5-2 Orthogonality

Ортогональный язык это язык, в котором вы можете выразить много, комбинируя маленькое
количество операторов во многими различными способами. Игрушечные блоки типа лего, очень
ортогональны, пластмассовая модель практически не ортогональна. Основное преимущество
complement в том, что он делает язык более ортогональным. До complement-а, Common
Lisp были пары функций, такие как remove-if и remove-if-not, subst-if и
subst-if-not, и так далее. С complement половина из них становитсья не нужной.

Макрос setf также улучшает ортогональность Lisp. Ранние диалекты Lisp часто имели
пары функций для чтений и записи данных. Например, с property - lists(списков свойств), 
будет одна функция для установки свойств и другая для запроса о нем(свойстве). В Common 
Lisp, у нас есть только последняя, get. Чтобы

@cartouche
@lisp
 (defvar *!equivs* (make-hash-table))

 (defun ! (fn)
      (or (gethash fn *!equivs*) fn))

 (defun def! (fn fn!)
      (setf (gethash fn *!equivs*) fn!))
@end lisp

                   Рисунок 5-1: Возвращение деструктивных(разрушающих) эквивалентов.
@end cartouche

установить(set) свойство, мы использжуем get в сочетании с setf:

@lisp
(setf (get 'ball 'color) 'red)
@end lisp

Возможно, мы не сможем сделать Common Lisp меньше, но мы можем кое что сделать
почти так же хорошо: использовать меньшее его подмножество. Можем ли мы определить
новые операторы, которые смогут, подобно complement и setf, помочь нам в достижении
этой цели? Есть хотя бы еще одно направление, по которому функции сгруппированы
в пары. Для многих функций существуют их разрушающие(деструктивные) версии: 
remove-if и delete-if, reverse и nreverse, append и nconc. Определив оператор,
чтоыбы возвращать разрушающий аналог функции, мы можем больше не обращаться к
разрушающим функциям напрямую.

Рисунок 5-1 содержит код для поддержки понятия деструктивных аналогов.
Глобальная хеш-таблица *!equivs* отображает функции на их деструктивные эквиваленты;
! возвращает деструктивный эквивалент; и def! устанавливает их. Имя оператора ! (банг)
происходит из Scheme соглашения добавлять ! к имени функции имеющей побочный(сторонний)
эффект. Теперь когда мы определили

@lisp
(def! #'remove-if #'delete-if)
@end lisp

тогда вместо

@lisp
(delete-if #'oddp lst)
@end lisp

мы бы сказали

@lisp
(funcall (! #'remove-if) #'oddp lst)
@end lisp

Здесь неловкость Common Lisp скрывает основную элегантность идеи, что было бы более
заметно на Scheme:

@lisp
((! remove-if) oddp lst)
@end lisp

@cartouche
@lisp
     (defun memoize (fn)
       (let ((cache (make-hash-table :test #'equal)))
          #'(lambda (&rest args)
               (multiple-value-bind (val win) (gethash args cache)
                  (if win
                       val
                       (setf (gethash args cache)
                                (apply fn args)))))))
@end lisp

                              Рисунок 5-2: Утилита запоминания результатов работы функции(Memoizing).
@end cartouche

Кроме великолепной ортогональности, оператор ! приносит пару других преимуществ.
Он делает программы понятнее, потому что мы сразу видим, что (! #'foo) это разрушающий
эквивалент foo. Кроме того, он придает разрушающим операциям отчетливую, узнаваемую
форму в исходном коде, что хорошо, потому что они должны получить особое внимание,
когда мы ищем ошибку.

Поскольку связь между функцией и ее разрушающим аналогом будет как правило известна
до выполнения программы, было бы наиболее эффективно определить (банг) ! как макрос,
или даже предоставить макрос чтения для него.

@node 5-3 Memoizing, 5-4 Composing Functions, 5-2 Orthogonality, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-3 Memoizing(Запоминание предыдущих результатов)
@cindex 5-3 Memoizing

Если какая-то функция является дорогой, в смысле вычилений,и мы ожидаем, что иногда один
и тот же вызов более одного раза, то стоит запоминать результаты(memoize): для кэширования
возвращаемых значений всех предыдущих значений, и каждый раз, когда функция будет вызываться,
в первую очередь будет просматриваться кэш, чтобы найти уже известное значение.

Рисунок 5-2 содержит обобщенную утилиту memoizing. Мы передаем не записывающую функцию,
в memoize, и она возвращает эквивалентную записыващую версию  - замыкание, содержащее
хеш-таблицу для хранения результатов предыдущих вызовов.

@example
> (setq slowid (memoize #'(lambda (x) (sleep 5) x)))
#<Interpreted-Function C38346>
> (time (funcall slowid 1))
Elapsed Time = 5-15 seconds
1> (time (funcall slowid 1))
Elapsed Time = 0-00 seconds
1
@end example

С функцией memoize, повторный вызов это просто поиск в хеш-таблице. Есть конечно
дополнительные затраты на поиск при каждом начальном вызове, но поскольку мы 

@cartouche
@lisp
        (defun compose (&rest fns)
         (if fns
              (let ((fn1 (car (last fns)))
                      (fns (butlast fns)))
                #'(lambda (&rest args)
                      (reduce #'funcall fns
                                   :from-end t
                                   :initial-value (apply fn1 args))))
              #'identity))
@end lisp

                    Рисунок 5-3: Оператор для композиции функций.
@end cartouche

запоминаем только функцию, достаточно дорогую для вычисления, разумно предположить,
что эти затраты сравнительно не велики.

Хотя это подходит для большинства применений, эта реализация memoize имеет несколько
ограничений. Она обрабатывает вызовы как идентичные, если они имеют одинаковые списки
аргументов; это может быть слишком строгим ограничением, если у функции есть ключевые
параметры. Так же она предназначена для работы только с с однозначными функциями и 
не может хранить или возвращать множественные значения.

@node 5-4 Composing Functions, 5-5 Recursion on Cdrs, 5-3 Memoizing, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-4 Композиция Функций(составные функции)
@cindex 5-4 Composing Functions

Дополнение(complement) к функции f обозначается ка  ~f. Раздел 5-1 показал, что
что замыкания делают  определение ~ как функции Lisp-а. Еще одна распространенная
операция над функциям это композиция(composition, составление функций), обозначаемая
оператором *. Если f и g функции, тогда композиция функций f * g также является 
функцией, и f * g(x) =f * (g(x)). Замыканя также позволяют определеить * как
функцию Лиспа.

Рисунок 5-3 определяет функцию compose которая принимает любое количество функций
и возвращает их композицию. Например

@lisp
(compose #'list #'1+)
@end lisp

возвращает функцию, эквивалентную

@lisp
#'(lambda (x) (list (1+ x)))
@end lisp

Все функции, приведенные в качестве аргументов для композиции, должно быть функциями
одного аргумента, за исключением последней. На последнюю функцию ограничений нет, и все
аргументы, которые она принимает, также принимает функция возвращаемая compose:

@example
> (funcall (compose #'1+ #'find-if) #'oddp '(2 3 4))
4
@end example

@cartouche
@lisp
 (defun fif (if then &optional else)
       #'(lambda (x)
           (if (funcall if x)
                  (funcall then x)
                  (if else (funcall else x)))))

 (defun fint (fn &rest fns)
       (if (null fns)
           fn
           (let ((chain (apply #'fint fns)))
                 #'(lambda (x)
                    (and (funcall fn x) (funcall chain x))))))

 (defun fun (fn &rest fns)
       (if (null fns)
           fn
           (let ((chain (apply #'fun fns)))
                 #'(lambda (x)
                    (or (funcall fn x) (funcall chain x))))))
@end lisp

                         Рисунок 5-4: Еще построители функций.
@end cartouche

Поскольку это не Lisp функция, complement является частным случаем compose. Она могла бы
быть определена как:

@lisp
(defun complement (pred)
  (compose #'not pred))
@end lisp

Мы можем комбинировать функции другими способами, а не просто составлять(composing) их.
Например, мы часто видим такие выражения как

@lisp
(mapcar #'(lambda (x)
                   (if (slave x)
                       (owner x)
                       (employer x)))
            people)
@end lisp

Мы могли бы определить оператор для автоматического создания таких функций, как эта.
Используя fif  из рисунка 5-4, мы моглли бы получить тот же эффект:

@lisp
(mapcar (fif #'slave #'owner #'employer)
            people)
@end lisp

Рисунок 5-4 содержин несколько других конструкторов для часто встречающихся типов
функций. Вторая, fint, для случаев подобных этому:

@lisp
(find-if #'(lambda (x)
                   (and (signed x) (sealed x) (delivered x)))
               docs)
@end lisp

Предикат, переданный как второй аргумент в find-if определяет пересечение трех
предикатов вызываемых в нем. С fint, чье имя означает "пересечение функций(function
intersection)" мы можем сказать:

@lisp
(find-if (fint #'signed #'sealed #'delivered) docs)
@end lisp

Мы можем определить аналогичный оператор, чтобы вернуть объединение набора предикатов.
Функция fun похожа на fint но исползует or вместо and.

@node 5-5 Recursion on Cdrs, 5-6 Recursion on Subtrees, 5-4 Composing Functions, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-5 Рекурсия на Cdrs
@cindex 5-5 Recursion on Cdrs

Рекурсивные функции настолько важны в программах на Lisp, что стоит иметь утилиты для
их строительства. Этот раздел и следующий описывают функции, которые строят
функции для двух наиболее распространенных типов. В Common Lisp, эти функции немного
неудобно использовать. Как только мы перейдем к теме макросов, мы увидим, как поставить
более элегантный фасад для этого механизма. Макросы для построения рекурсий обсуждаются
в разделах 15-2 и 15-3.

Повторяющиеся куски(образцы) кода в программе являются признаком того, что они
могли быть написана на более высоком уровне абстракции. Какой кусок кода чаще 
всего встречается в программах на  Lisp чем подобная функция?:

@lisp
(defun our-length (lst)
      (if (null lst)
            0(1+ (our-length (cdr lst)))))
@end lisp

или такая:

@lisp
(defun our-every (fn lst)
      (if (null lst)
            t(and (funcall fn (car lst))
                 (our-every fn (cdr lst)))))
@end lisp

Конструктивно эти две функции имеют много общего. Они обе работают рекурсивно
поочередно на последовательных cdrs списка, вычисляя одно и то же выражение на 
каждом шаге,

@cartouche
@lisp
 (defun lrec (rec &optional base)
       (labels ((self (lst)
                      (if (null lst)
                            (if (functionp base)
                                   (funcall base)
                                   base)
                            (funcall rec (car lst)
                                                 #'(lambda ()
                                                        (self (cdr lst)))))))
          #'self))
@end lisp

                   Рисунок 5-5: Функция для определения рекурсивных функций для плоских списков.
@end cartouche

исключая базовый случай, когда они возвращают различные значения. Эта картина появляется
так часто в программах на Лиспе, что опытные программисты могут читать и воспроизводить,
не переставая думать. Действительно, урок настолько быстро усваивается, что
вопрос о том, как упаковать шаблон в новую абстракцию, не возникает.

Впрочем, это все таки, образец(шаблон/закономерность). И вместо того, чтобы писать 
эти функции вручную мы можем написать функцию, которая будет генерировать их для нас.
Рисунок 5-5 содержит построитель функций с именем lrec ("list recurser"), который 
должен быть в состоянии сгенерировать большинство функций, которые используются на последовательных окончаниях(cdrs) списка.

Первый аргумент для lrec должен быть функцией двух аргументов: текущее
начало(car) списка и функция, которая может быть вызвана для продолжения 
рекурсии. Используя lrec мы могли бы выразить our-length как:

@lisp
(lrec #'(lambda (x f) (1+ (funcall f))) 0)
@end lisp

Чтобы найти длину списка, нам не нужно смотреть на элементы или на часть останавливающую рекурсию. Кстати, объект x всегда игнорируется, а функция f всегда вызывается. Тем не мение,
нам нужно воспользоваться обеими параметрами, чтобы выразить нашу функцию our-every, 
например oddp:@footnote{В одном широко используемом Common Lisp, функция ошибочно
возвращает истину для t и nil. В этой реализации он не будет работать в качестве второго
аргумента для lrec.}

@lisp
(lrec #'(lambda (x f) (and (oddp x) (funcall f))) t)
@end lisp

Определение lrec использует labels для построения локальной рекурсивной функции под названием self. В рекурсивый вариант функции rec передаются два аргумента, текущий
car списка, и функция, воплощающая рекурсивный вызов. На функции, такой как
our-every, где рекурсивный случай представляет собой and, если первый аргумент 
возвращает false мы хотим остановиться прямо здесь. Это означает, что аргумент 
передается в рекурсивном случае, должен быть не значением, а функцией, которую 
мы могли бы вызвать(если хотим), чтобы получить значение.


@cartouche
@lisp
 ; copy-list
 (lrec #'(lambda (x f) (cons x (funcall f))))

 ; remove-duplicates
 (lrec #'(lambda (x f) (adjoin x (funcall f))))

 ; find-if, for some function fn
 (lrec #'(lambda (x f) (if (fn x) x (funcall f))))

 ; some, for some function fn
 (lrec #'(lambda (x f) (or (fn x) (funcall f))))
@end lisp

                        Рисунок 5-6: Функции выраженные с помощью lrec.
@end cartouche

case must not be a value but a function, which we can call (if we want) in order to
get a value.

На рисунке 5.6 показаны некоторые функции существующие в Common Lisp, 
определенные с помощью lrec. @footnote{В некоторых реализациях может 
потребоваться установить *print-circle* в t перед отображением этих функций} 
Вызов lrec не всегда дает наиболее эффективную реализацию данного
функция. Действительно, lrec и другие генераторы рекурсивных функций 
определеные в этой главе, как правило, уводит нас от хвостовых рекурсивных решений. 
По этой причине они лучше всего подходят для использования в начальных версиях 
программы или в частях, где скорость не критична.

@node 5-6 Recursion on Subtrees, 5-7 When to Build Functions, 5-5 Recursion on Cdrs, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-6 Рекурсия на под деревьях(Subtrees)
@cindex 5-6 Recursion on Subtrees

Существует еще один рекурсивный шаблон, обычно встречающийся в программах на Лиспе: рекурсия
на поддеревьях. Эта картина наблюдается в тех случаях, когда вы начинаете с возможно вложенного списка, и вам надо спуститься в его начало(car) и его окончание(CDR).

Список Lisp - это универсальная структура. Списки могут представлять, помимо прочего,
последовательности, множества, отображения, массивы и деревья. Есть несколько разных способов интерпретировать список как дерево. Наиболее распространенным является рассматривать список как двоичное дерево, чья левая ветвь - car, и чья правая ветвь 
- cdr. (На самом деле это обычно внутреннее представление списков.) На рисунке 5-7 показаны три примера списков и деревья, которые они представляют. Каждый внутренний узел в таком дереве соответствует точке в представлении списка парой с точкой(a.b), поэтому древовидная структура может быть

@cartouche
@lisp
       (a.b)                   (abc)                             (ab(cd))
@end lisp

                              Рисунок 5-7: Списки как деревья.
@end cartouche

легче интерпретировать, если списки представлять в такой форме:

@lisp
       (a b c)           = (a . (b . (c . nil)))
       (a b (c d)) = (a . (b . ((c . (d . nil)) . nil)))
@end lisp

Любой список можно интерпретировать как двоичное дерево. Отсюда и различие между
парой функций из Common Lisp, таких как copy-list и copy-tree. Первый копирует
список как последовательность, т.е если список содержит подсписки, которые 
являют простыми элементами в последовательности, то они не копируются:

@example
> (setq x          '(a b)
           listx (list x 1))
((A B) 1)
> (eq x (car (copy-list listx)))
T
@end example

Напротив, copy-tree копирует список как дерево подсписков, поскольку подсписки дерева являются поддеревьями, и поэтому должны быть также скопированными:

@example
> (eq x (car (copy-tree listx)))
NIL
@end example

Мы могли бы определить версию  copy-tree следующим образом:

@lisp
(defun our-copy-tree (tree)
      (if (atom tree)
          tree
          (cons (our-copy-tree (car tree))
                  (if (cdr tree) (our-copy-tree (cdr tree))))))
@end lisp

Это определение оказывается одним из примеров общего паттерна. (Некоторые из
следующие функции написаны немного странно, чтобы сделать шаблон очевидным.)
Рассмотрим, например, утилиту для подсчета количества листьев в дереве:

@lisp
(defun count-leaves (tree)
      (if (atom tree)
          1(+ (count-leaves (car tree))
             (or (if (cdr tree) (count-leaves (cdr tree)))
                   1))))
@end lisp

Дерево имеет больше листьев, чем атомов, что вы можете видеть, когда оно представлено в виде списка:

@example
> (count-leaves '((a b (c d)) (e) f))
10
@end example

Листья дерева - это все атомы, которые вы можете видеть, когда вы смотрите на дерево в
его представлении в виде пар с точкой. В записи в виде пар с точкой список
 ((a b (c d)) (e) f) будет иметь четыре nils, которые не видны при представлении 
в виде списка (по одному для каждой пары круглых скобок), поэтому count-leaf 
возвращает 10.

В последней главе мы определили несколько утилит, которые работают на деревьях. 
Например, flatten (стр. 47) берет дерево и возвращает список всех атомов в нем.
То есть, если вы укажете вложенный список, вы получите  назад список, который выглядит 
так же за исключением того, что в нём отсутствуют скобки, кроме внешней пары скобок:

@example
> (flatten '((a b (c d)) (e) f ()))
(ABCDEF)
@end example

Эта функция также может быть определена (несколько неэффективно) следующим образом:

@lisp
(defun flatten (tree)
      (if (atom tree)
          (mklist tree)
          (nconc (flatten (car tree))
                   (if (cdr tree) (flatten (cdr tree))))))
@end lisp

Наконец, рассмотрим rfind-if, рекурсивную версию find-i, которая работает
на деревьях, а также на плоских списках:

@lisp
(defun rfind-if (fn tree)
     (if (atom tree)
           (and (funcall fn tree) tree)
           (or (rfind-if fn (car tree))
                 (if (cdr tree) (rfind-if fn (cdr tree))))))
@end lisp

Чтобы обобщить find-if для деревьев, мы должны решить, хотим ли мы искать только
для листьев, или еще для поддеревьев. Наш метод rfind-if использует первый подход,
поэтому вызывающая сторона может предположить, что функция, указанная в качестве 
первого аргумента, будет вызываться для атомов:

@example
> (rfind-if (fint #'numberp #'oddp) '(2 (3 4) 5))
3
@end example

Сейчас можно видеть насколько похожи эти четыре функции, copy-tree, count-leaves,
flatten, и rfind-if. Действительно, все они являются примерами архетипической 
функции для рекурсии на поддеревьях. Как и в случае рекурсии на cdrs(плоских списках),
нам не нужно предоставлять этот архетип, который может быть неопределенно изменчивым,
мы можем написать функцию для генерации экземпляров рекурсивных функций для него.

Чтобы получить сам архетип, давайте посмотрим на эти функции и увидим что не входит
шаблоном. По сути  our-copy-tree это два факта:

@enumerate
@item
В базовом случае она возвращает свой аргумент.
@item
В рекурсивном случае, она применяет cons к рекурсиям нижних поддеревьев левого(car) 
и правого (cdr).
@end enumerate

Таким образом, мы должны иметь возможность выразить это как вызвов построителя
с двумя аргументами:

@lisp
(ttrav #'cons #'identity)
@end lisp

Определение ttrav ("обходчик деревьев(tree traverser)") показано на рисунке 5-8. Вместо
перечачи одного значения в рекурсивном случае, мы передаем два, одно для левого поддерева
и одно для правого. Если базовый аргумент является функцией, она будет вызвана для текущего
листа. В рекурсии на плоском списке, базовый случай всегда nil, но рекурсии по дереву базовый
случай может быть интересным значением, и мы можем захотеть его использовать.

С помощью ttrav мы можем выразить все предыдущие функции, кроме rfind-if.
(Они показаны на рисунке 5-9.) Чтобы определить rfind-if нам нужен более общий
конструктор рекурсии по дереву, который даст нам контроль когда, и если, делать
рекурсивные вызовы. В качестве первого аргумента ttrav мы дали функцию, которая
берет результаты рекусивных вызовов. В общем случае, мы хотим использовать вместо
этого функцию, которая принимает два замыкания, представляющие сами вызовы. 
Тогда мы сможем написать рекурсеры, которые проходят по стольким деревьям, сколько им
будет надо.

@cartouche
@lisp
 (defun ttrav (rec &optional (base #'identity))
      (labels ((self (tree)
                     (if (atom tree)
                          (if (functionp base)
                                (funcall base tree)
                                base)
                          (funcall rec (self (car tree))
                                            (if (cdr tree)
                                                  (self (cdr tree)))))))
         #'self))
@end lisp

                     Рисунок 5-8: Функция для рекурсии на деревьях.
@end cartouche

@cartouche
@lisp
 ; our-copy-tree
 (ttrav #'cons)

 ; count-leaves
 (ttrav #'(lambda (l r) (+ l (or r 1))) 1)

 ; flatten
 (ttrav #'nconc #'mklist)
@end lisp

                     Рисунок 5-9: Функции выраженные с помощью ttrav.
@end cartouche

Функции, построенные  ttrav всегда проходят по всему дереву. Это хорошо для 
функций подобных подсчету листьев(count-leaves) или flatten(создающих плоский 
список), которые все равно должны проходить по всему дереву.
Но мы хотим, чтобы rfind-if останавливало поиск, как только она найдет то, что
ищет. Она должна быть построена по более общей схеме, показанной на рисунке 5-10. 
Второй аргумент trec должен быть функцией трех аргументов: текущего объектиа и
двух рекурсеров. Последние два будут замыканиями, представляющими рекурсии по
левому и правому поддервьям. С помощью  trec мы можем определить flatten как:

@lisp
(trec #'(lambda (o l r) (nconc (funcall l) (funcall r)))
          #'mklist)
@end lisp

Теперь мы можем так же выразить rfind-if например для oddp как:

@lisp
(trec #'(lambda (o l r) (or (funcall l) (funcall r)))
          #'(lambda (tree) (and (oddp tree) tree)))
@end lisp

@cartouche
@lisp
 (defun trec (rec &optional (base #'identity))
       (labels
         ((self (tree)
             (if (atom tree)
                   (if (functionp base)
                        (funcall base tree)
                        base)
                   (funcall rec tree
                                     #'(lambda ()
                                         (self (car tree)))
                                     #'(lambda ()
                                         (if (cdr tree)
                                              (self (cdr tree))))))))
         #'self))
@end lisp

                     Рисунок 5-10: Функция для рекурсии по деревьям.
@end cartouche

@node 5-7 When to Build Functions,  , 5-6 Recursion on Subtrees, 5 Returning Functions
@comment  node-name,  next,  previous,  up
@section 5-7 Когда создавать функции
@cindex 5-7 When to Build Functions

Выражение функций через вызовы конструкторов вместо шарп-квотированных('#) лямбда
выражений, к сожалению, может повлечь за собой ненужную работу во время выполнения.
шарп-квотированные лямбда выражения являются константами, но вызов функции конструктора
будет вычисляться во время выполнения программы. Если нам действительно нужно сделать
этот вызов во время выполнения, он может не стоить выполнения функции конструктора. 
Тем не менее, по крайней мере, иногда, мы можем вызвать конструктор заранее. 
Используя макрос чтения: #.(знак решетку совместно со знаком точка), мы можем 
создавать новые функции построенные во время ЧТЕНИЯ программы.  Например, мы можем
сказать, что пока читается это выражение определяются compose и ее аргументы:

@lisp
(find-if #.(compose #'oddp #'truncate) lst)
@end lisp

Тогда вызов compose будет вычислен читателем, и результирующая функция будет вставлена
как константа(постоянная) в наш код. Поскольку обе функции oddp и truncate являются
встроенными, можно с уверенностью предположить, что мы можем вычислить compose во
время чтения, до тех пор, пока compose уже будет загружена.

В вобщем, составление и объединени функций проще и эффективнее сделать макросами.
Это особенно верно в Common Lisp, с его отдельным пространством имен для функций.
После введения макросов, мы рассмотрим в главе 15 большую часть описанного здесь
материала, но с использоавнием более роскошных инструментов.