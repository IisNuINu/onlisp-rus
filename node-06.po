#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-06.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-07-01 10:32+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-06.texi:5
msgid ""
"@node 6 Functions as Representation, 7 Macros, 5 Returning Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 6 Functions as Representation\n"
"@cindex 6 Functions as Representation"
msgstr ""
"@node 6 Functions as Representation, 7 Macros, 5 Returning Functions, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 6 Функции как представление\n"
"@cindex 6 Functions as Representation"

#: texi/node-06.texi:14
msgid ""
"Generally, data structures are used to represent. An array could represent "
"a\n"
"geometric transformation; a tree could represent a hierarchy of command; a "
"graph\n"
"could represent a rail network. In Lisp we can sometimes use closures as a\n"
"representation. Within a closure, variable bindings can store information, "
"and can\n"
"also play the role that pointers play in constructing complex data "
"structures. By\n"
"making a group of closures which share bindings, or can refer to one "
"another, we\n"
"can create hybrid objects which combine the advantages of data structures "
"and\n"
"programs."
msgstr ""
"Как правило, для представления информации используются структуры данных. "
"Массив может\n"
"быть использован как представление геометрических преобразований; дерево "
"может\n"
"представлять иерархию команд; граф может представлять систему "
"железнодорожной сети.\n"
"В Лиспе, иногда мы можем использовать замыкания в роли представления чего-"
"либо.\n"
"Внутри замыкания, переменные могут хранить информацию, и могут также играют "
"роль,\n"
"которую играют указатели при построении сложных структур данных. Создав "
"группу\n"
"замыканий, которые предоставляют доступ к замкнутым переменным, или могут "
"ссылаться\n"
"друг на друга, мы можем создавать гибридные объекты, которые объединяют в "
"себе\n"
"преимущества структур данных и программ.\n"

#: texi/node-06.texi:19
msgid ""
"Beneath the surface, shared bindings are pointers. Closures just bring us "
"the\n"
"convenience of dealing with them at a higher level of abstraction. By using "
"closures\n"
"to represent something we would otherwise represent with static data "
"structures,\n"
"we can often expect substantial improvements in elegance and efficiency."
msgstr ""
"На более низком уровне, разделяемые связанные переменные представляют собой "
"указатели.\n"
"Замыкания просто предоставляют нам удобства взаимодействия с ними на более "
"высоком\n"
"уровне абстракции. Используя замыкания для представления чего-либо, где "
"обычно\n"
"используются статические структуры данных, мы можем получить более "
"элегантный и\n"
"эффективный код."

#: texi/node-06.texi:25
msgid ""
"@menu\n"
"* 6-1 Networks::                \n"
"* 6-2 Compiling Networks::      \n"
"* 6-3 Looking Forward::         \n"
"@end menu"
msgstr ""

#: texi/node-06.texi:30
msgid ""
"@node 6-1 Networks, 6-2 Compiling Networks, 6 Functions as Representation, 6 "
"Functions as Representation\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 6-1 Networks\n"
"@cindex 6-1 Networks"
msgstr ""
"@node 6-1 Networks, 6-2 Compiling Networks, 6 Functions as Representation, 6 "
"Functions as Representation\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 6-1 Сети\n"
"@cindex 6-1 Networks"

#: texi/node-06.texi:39
msgid ""
"Closures have three useful properties: they are active, they have local "
"state, and\n"
"we can make multiple instances of them. Where could we use multiple copies\n"
"of active objects with local state? In applications involving networks, "
"among\n"
"others. In many cases we can represent nodes in a network as closures. As "
"well as\n"
"having its own local state, a closure can refer to another closure. Thus a "
"closure\n"
"representing a node in a network can know of several other nodes (closures) "
"to\n"
"which it must send its output. This means that we may be able to translate "
"some\n"
"networks straight into code."
msgstr ""
"Замыкания имеют три полезных свойства: они активны, у них есть локальное "
"состояние, и\n"
"мы можем создавать много экземпляров при необходимости. Где нам нужно "
"использовать\n"
"несколько копий активных объектов с локальным состоянием? В приложениях с "
"сетями,\n"
"среди прочего. Во многих случаях мы можем представить узлы в сети как "
"замыкания.\n"
"Кроме наличия собственного состояния, замыкания могут ссылаться друг на "
"друга. Таким\n"
"образом узел сети ввиде замыкания может знать несколько других узлов "
"(замыканий)\n"
"которым он должен посылать свой вывод. Это означает, что у нас будет "
"возможность\n"
"переносить некоторые сети непосредственно в код."

#: texi/node-06.texi:54
msgid ""
"@example\n"
" > (run-node 'people)\n"
" Is the person a man?\n"
" >> yes\n"
" Is he living?\n"
" >> no\n"
" Was he American?\n"
" >> yes\n"
" Is he on a coin?\n"
" >> yes\n"
" Is the coin a penny?\n"
" >> yes\n"
" LINCOLN\n"
"@end example"
msgstr ""
"@cartouche\n"
"@example\n"
" > (run-node 'people)\n"
" Is the person a man?\n"
" >> yes\n"
" Is he living?\n"
" >> no\n"
" Was he American?\n"
" >> yes\n"
" Is he on a coin?\n"
" >> yes\n"
" Is the coin a penny?\n"
" >> yes\n"
" LINCOLN\n"
"@end example"

#: texi/node-06.texi:56
msgid "                       Figure 6-1: Session of twenty questions."
msgstr ""
"                       Рисунок 6.1: Пример игры \"20 вопросов\".\n"
"@end cartouche"

#: texi/node-06.texi:61
msgid ""
"In this section and the next we will look at two ways to traverse a "
"network.\n"
"First we will follow the traditional approach, with nodes defined as "
"structures, and\n"
"separate code to traverse the network. Then in the next section we'll show "
"how to\n"
"build the same program from a single abstraction."
msgstr ""
"В этом и следующем параграфах мы рассмотрим два способа обхода сети. "
"Сначала\n"
"мы будем следовать традиционному подходу, где узлы определяются как "
"структуры,\n"
"и существует отдельный код для обхода сети. Затем, в следующем разделе мы "
"покажем,\n"
"как написать такую же программу на основе одной абстракции."

#: texi/node-06.texi:69
msgid ""
"As an example, we will use about the simplest application possible: one of\n"
"those programs that play twenty questions. Our network will be a binary "
"tree.\n"
"Each non-leaf node will contain a yes/no question, and depending on the "
"answer\n"
"to the question, the traversal will continue down the left or right subtree. "
"Leaf\n"
"nodes will contain return values. When the traversal reaches a leaf node, "
"its value\n"
"will be returned as the value of the traversal. A session with this program "
"might\n"
"look as in Figure 6-1."
msgstr ""
"В качестве примера мы будем использовать самый простой случай: одну из тех\n"
"программ, которые играют в \"20 вопросов\". Наша сеть будет представлена "
"бинарным\n"
"деревом. Каждый нетерминальный узел будет содержать вопрос типа \"да/нет\", "
"и в\n"
"зависимости от ответа на вопрос, обход будет продолжаться по левому или "
"правому\n"
"поддереву. Терминальные узлы (листья) будут содержать результаты. Когда "
"будет\n"
"достигнут конечный узел, его значение будет возвращено в качестве результата "
"обхода.\n"
"Взаимодействие с этой программой может выглядеть как на рисунке 6.1."

#: texi/node-06.texi:81
msgid ""
"The traditional way to begin would be to define some sort of data structure "
"to\n"
"represent nodes. A node is going to have to know several things: whether it "
"is a\n"
"leaf; if so, which value to return, and if not, which question to ask; and "
"where to\n"
"go depending on the answer. A sufficient data structure is defined in Figure "
"6-2.\n"
"It is designed for minimal size. The contents field will contain either a "
"question\n"
"or a return value. If the node is not a leaf, the yes and no fields will "
"tell where to\n"
"go depending on the answer to the question; if the node is a leaf, we will "
"know it\n"
"because these fields are empty. The global *nodes* will be a hash-table in "
"which\n"
"nodes are indexed by name. Finally, defnode makes a new node (of either "
"type)\n"
"and stores it in *nodes*. Using these materials we could define the first "
"node of\n"
"our tree:"
msgstr ""
"Традиционный способ начать работу - это определить какую-то структуру данных "
"для\n"
"представления узлов сети. Узел должен хранить определенную информацию: если "
"это\n"
"лист дерева, то какое значение возвращать, а если нет, то какой вопрос "
"задать, и\n"
"куда идти в зависимости от ответа. Удовлетворяющая этим требования структура "
"данных\n"
"представлена на рисунке 6.2. Она рассчитана на минимальный размер. Поле "
"contents\n"
"будет содержать вопрос или возвращаемое значение. Если узел не терминальный, "
"поля\n"
"yes и no скажут, куда идти в зависимости от ответа на вопрос; если узел "
"является\n"
"листом, мы узнаем это, т.к. эти поля будут пустыми. Глобальная переменная "
"*nodes*\n"
"будет хэш-таблицей, в которой узлы будут индексированы по имени. Наконец, "
"функция\n"
"defnode будет создавать новый узел (любого типа) и сохраняет его в *nodes*.\n"
"Используя эти составные кирпичики, мы можем определить первый узел нашего "
"дерева:"

#: texi/node-06.texi:85
msgid ""
"@lisp\n"
"(defnode 'people \"Is the person a man?\"\n"
"               'male 'female)"
msgstr ""
"@lisp\n"
"(defnode 'people \"Is the person a man?\"\n"
"               'male 'female)\n"
"@end lisp"

#: texi/node-06.texi:88
msgid " (defstruct node contents yes no)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defstruct node contents yes no)"

#: texi/node-06.texi:90
msgid " (defvar *nodes* (make-hash-table))"
msgstr ""

#: texi/node-06.texi:97
msgid ""
" (defun defnode (name conts &optional yes no)\n"
"      (setf (gethash name *nodes*)\n"
"               (make-node :contents conts\n"
"                            :yes         yes\n"
"                            :no          no)))\n"
"@end lisp"
msgstr ""

#: texi/node-06.texi:99
msgid "                 Figure 6-2: Representation and definition of nodes."
msgstr ""
"                 Рисунок 6.2: Представление и определение узлов.\n"
"@end cartouche"

#: texi/node-06.texi:102
msgid ""
"@lisp\n"
" (defnode 'people \"Is the person a man?\" 'male 'female)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defnode 'people \"Is the person a man?\" 'male 'female)"

#: texi/node-06.texi:104
msgid " (defnode 'male \"Is he living?\" 'liveman 'deadman)"
msgstr ""

#: texi/node-06.texi:106
msgid " (defnode 'deadman \"Was he American?\" 'us 'them)"
msgstr ""

#: texi/node-06.texi:108
msgid " (defnode 'us \"Is he on a coin?\" 'coin 'cidence)"
msgstr ""

#: texi/node-06.texi:110
msgid " (defnode 'coin \"Is the coin a penny?\" 'penny 'coins)"
msgstr ""

#: texi/node-06.texi:113
msgid ""
" (defnode 'penny 'lincoln)\n"
"@end lisp"
msgstr ""

#: texi/node-06.texi:115
msgid "                            Figure 6-3: Sample network."
msgstr ""
"                            Рисунок 6.3: Пример сети.\n"
"@end cartouche"

#: texi/node-06.texi:119
msgid ""
"Figure 6-3 shows as much of the network as we need to produce the transcript "
"in\n"
"Figure 6-1."
msgstr "Рисунок 6.3 показывает все, что необходимо для примера из рисунка 6.1."

#: texi/node-06.texi:127
msgid ""
"Now all we need to do is write a function to traverse this network, "
"printing\n"
"out the questions and following the indicated path. This function, run-node,"
"is\n"
"shown in Figure 6-4. Given a name, we look up the corresponding node. If it "
"is\n"
"not a leaf, the contents are asked as a question, and depending on the "
"answer,\n"
"we continue traversing at one of two possible destinations. If the node is a "
"leaf,\n"
"run-node just returns its contents. With the network defined in Figure 6-3, "
"this\n"
"function produces the output shown in Figure 6-1."
msgstr ""
"Теперь все, что нужно сделать, это написать функцию для обхода этой сети, "
"вывода\n"
"вопросов и следования указанному пути. Эта функция, run-node, показана на\n"
"рисунке 6.4. Указывая имя, мы ищем соответствующий узел. Если это не лист,\n"
"задается вопрос из поля content, и в зависимости от ответа, мы продолжаем "
"обход\n"
"в одном из двух возможных направлений. Если узел терминальный, run-node "
"просто\n"
"возвращает значение поля content. При обходе сети с рисунка 6.3, эта "
"функция\n"
"производит результат, показанный на рисунке 6.1."

#: texi/node-06.texi:138
msgid ""
"@lisp\n"
" (defun run-node (name)\n"
"       (let ((n (gethash name *nodes*)))\n"
"          (cond ((node-yes n)\n"
"                   (format t \"~A~%>> \" (node-contents n))\n"
"                   (case (read)\n"
"                      (yes (run-node (node-yes n)))\n"
"                      (t     (run-node (node-no n)))))\n"
"                  (t (node-contents n)))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun run-node (name)\n"
"       (let ((n (gethash name *nodes*)))\n"
"          (cond ((node-yes n)\n"
"                   (format t \"~A~%>> \" (node-contents n))\n"
"                   (case (read)\n"
"                      (yes (run-node (node-yes n)))\n"
"                      (t     (run-node (node-no n)))))\n"
"                  (t (node-contents n)))))\n"
"@end lisp"

#: texi/node-06.texi:140
msgid "                     Figure 6-4: Function for traversing networks."
msgstr ""
"                     Рисунок 6.4: Функция обхода сети.\n"
"@end cartouche"

#: texi/node-06.texi:143
msgid ""
"@lisp\n"
" (defvar *nodes* (make-hash-table))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *nodes* (make-hash-table))"

#: texi/node-06.texi:154
msgid ""
" (defun defnode (name conts &optional yes no)\n"
"       (setf (gethash name *nodes*)\n"
"               (if yes\n"
"                     #'(lambda ()\n"
"                            (format t \"~A~%>> \" conts)\n"
"                            (case (read)\n"
"                             (yes (funcall (gethash yes *nodes*)))\n"
"                             (t     (funcall (gethash no *nodes*)))))\n"
"                     #'(lambda () conts))))\n"
"@end lisp"
msgstr ""

#: texi/node-06.texi:156
msgid "                     Figure 6-5: A network compiled into closures."
msgstr ""
"                     Рисунок 6.5: Сеть с использованием замыканий.\n"
"@end cartouche"

#: texi/node-06.texi:161
msgid ""
"@node 6-2 Compiling Networks, 6-3 Looking Forward, 6-1 Networks, 6 Functions "
"as Representation\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 6-2 Compiling Networks\n"
"@cindex 6-2 Compiling Networks"
msgstr ""
"@node 6-2 Compiling Networks, 6-3 Looking Forward, 6-1 Networks, 6 Functions "
"as Representation\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 6.2 Компиляция(Сборка) сетей\n"
"@cindex 6-2 Compiling Networks"

#: texi/node-06.texi:166
msgid ""
"In the preceding section we wrote a network program as it might have been "
"written\n"
"in any language. Indeed, the program is so simple that it seems odd to think "
"that\n"
"we could write it any other way. But we can-in fact, we can write it much "
"more\n"
"simply."
msgstr ""
"В предыдущем разделе мы написали программу для работы с сетью так, как она "
"могла бы\n"
"быть написана на любом другом языке. Действительно, программа настолько "
"проста, что\n"
"кажется странным рассчитывать на то, что ее можно написать по-другому. Но, "
"на самом\n"
"деле, мы можем реализовать ее гораздо проще."

#: texi/node-06.texi:172
msgid ""
"The code in Figure 6-5 illustrates this point. It's all we really need to "
"run our\n"
"network. Instead of having nodes as data structures and a separate function "
"to\n"
"traverse them, we represent the nodes as closures. The data formerly "
"contained in\n"
"the structures gets stored in variable bindings within the closures. Now "
"there is no\n"
"need for run-node; it is implicit in the nodes themselves. To start the "
"traversal,"
msgstr ""
"Код на рисунке 6.5 показывает такой пример. Это все, что нам действительно "
"нужно,\n"
"чтобы запустить нашу программу. Вместо того, чтобы иметь отдельно структуры "
"данных\n"
"для узлов, и отдельную функцию для их обхода, мы представляем узлы как "
"замыкания.\n"
"Данные, ранее хранимые в структурах, сохраняются в связанных переменных "
"внутри\n"
"замыканий. Теперь нет необходимости в функции run-node; эта "
"функциональность\n"
"заложена в самих узлах. Для того, чтобы начать обход,"

#: texi/node-06.texi:175
msgid ""
"@lisp\n"
" (defvar *nodes* nil)"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defvar *nodes* nil)"

#: texi/node-06.texi:179
msgid ""
" (defun defnode (&rest args)\n"
"      (push args *nodes*)\n"
"      args)"
msgstr ""

#: texi/node-06.texi:197
msgid ""
" (defun compile-net (root)\n"
"      (let ((node (assoc root *nodes*)))\n"
"        (if (null node)\n"
"               nil\n"
"               (let ((conts (second node))\n"
"                         (yes (third node))\n"
"                         (no (fourth node)))\n"
"                 (if yes\n"
"                         (let ((yes-fn (compile-net yes))\n"
"                                (no-fn (compile-net no)))\n"
"                           #'(lambda ()\n"
"                                (format t \"~A~%>> \" conts)\n"
"                                (funcall (if (eq (read) 'yes)\n"
"                                                  yes-fn\n"
"                                                  no-fn))))\n"
"                         #'(lambda () conts))))))\n"
"@end lisp"
msgstr ""
" (defun compile-net (root)\n"
"      (let ((node (assoc root *nodes*)))\n"
"        (if (null node)\n"
"               nil\n"
"               (let ((conts (second node))\n"
"                     (yes   (third node))\n"
"                     (no    (fourth node)))\n"
"                 (if yes\n"
"                     (let ((yes-fn (compile-net yes))\n"
"                           (no-fn  (compile-net no)))\n"
"                       #'(lambda ()\n"
"                            (format t \"~A~%>> \" conts)\n"
"                            (funcall (if (eq (read) 'yes)\n"
"                                         yes-fn\n"
"                                         no-fn))))\n"
"                 #'(lambda () conts))))))\n"
"@end lisp"

#: texi/node-06.texi:199
msgid "                      Figure 6-6: Compilation with static references."
msgstr ""
"                      Рисунок 6.6: Компиляция со статическими ссылками.\n"
"@end cartouche"

#: texi/node-06.texi:201
msgid "we just funcall the node at which we want to begin:"
msgstr ""
"мы просто делаем вызов(funcall) узла-замыкания, в котором мы хотим перейти:"

#: texi/node-06.texi:207
msgid ""
"@lisp\n"
"(funcall (gethash 'people *nodes*))\n"
"Is the person a man?\n"
">>\n"
"@end lisp"
msgstr ""

#: texi/node-06.texi:209
msgid ""
"From then on, the transcript will be just as it was with the previous "
"implementation."
msgstr "После этого, выполнение будет аналогичным предыдущей реализации."

#: texi/node-06.texi:216
msgid ""
"By representing the nodes as closures, we are able to transform our twenty-\n"
"questions network entirely into code. As it is, the code will have to look "
"up the\n"
"node functions by name at runtime. However, if we know that the network is\n"
"not going to be redefined on the fly, we can add a further enhancement: we "
"can\n"
"have node functions call their destinations directly, without having to go "
"through\n"
"a hash-table."
msgstr ""
"Представляя узлы как замыкания, мы можем превратить нашу сеть целиком в код. "
"Сейчас,\n"
"код должен искать узлы по имени во время выполнения. Однако, если мы знаем, "
"что сеть\n"
"не будет изменяться во время выполнения, мы можем добавить следующее "
"улучшение: мы\n"
"можем делать прямые вызовы функций-замыканий, без необходимости проходить по "
"хэш-таблице."

#: texi/node-06.texi:230
msgid ""
"Figure 6-6 contains a new version of the program. Now *nodes* is a\n"
"dis- posable list instead of a hash-table. All the nodes are defined\n"
"with defnode as before, but no closures are generated at this\n"
"point. After all the nodes have been defined, we call compile-net to\n"
"compile a whole network at once. This function recursively works its\n"
"way right down to the leaves of the tree, and on the way back up,\n"
"returns at each step the node/function for each of the two\n"
"subtrees. @footnote{This version assumes that the network is a tree,\n"
"which it must be in this application.} So now each node will have a\n"
"direct handle on its two destinations, instead of having only their\n"
"names. When the original call to compile-net returns, it will yield a\n"
"function representing the portion of the network we asked to have\n"
"compiled."
msgstr ""
"Рисунок 6.6 содержит новую версию программы. Теперь переменная *nodes* "
"представляет\n"
"собой одноразовый список, а не хэш-таблицу. Все узлы определяются в defnode "
"как\n"
"и раньше, но в этот раз никаких замыканий не создается. После того как все "
"узлы\n"
"определены, мы вызываем compile-net для компиляции всей сети сразу. Эта "
"функция\n"
"рекурсивно проходит свой путь вплоть до листьев дерева, и на пути обратно,\n"
"возвращает на каждом шаге узел-функцию для каждого из двух поддеревьев.\n"
"@footnote{Эта версия предполагает, что сеть представляет собой дерево, "
"которое\n"
"должно быть в этом приложении.}  Итак,\n"
"теперь каждый узел будет совершать прямой вызов обработчиков обоих "
"направлений,\n"
"а не искать их по имени. Когда первоначальный вызов compile-net завершается, "
"он\n"
"возвращает функцию, представляющую часть сети, которую мы попросили собрать."

#: texi/node-06.texi:238
msgid ""
"@example\n"
"> (setq n (compile-net 'people))\n"
"#<Compiled-Function BF3C06>\n"
"> (funcall n)\n"
"Is the person a man?\n"
">>\n"
"@end example"
msgstr ""

#: texi/node-06.texi:243
msgid ""
"Notice that compile-net compiles in both senses. It compiles in the general\n"
"sense, by translating the abstract representation of the network into code. "
"More-\n"
"over, if compile-net itself is compiled, it will return compiled functions. "
"(See\n"
"page 25.)"
msgstr ""
"Обратите внимание, что compile-net производит компиляцию в обоих смыслах. "
"Происходит\n"
"компиляция в общем смысле, путем трансляции абстрактного представления сети "
"в код.\n"
"Более того, если функция compile-net компилируется, она возвращает "
"скомпилированные\n"
"функции. (См. стр. 25.)"

#: texi/node-06.texi:247
msgid ""
"After compiling the network, we will no longer need the list made by "
"defnode.\n"
"It can be cut loose (e.g. by setting *nodes* to nil) and reclaimed by the "
"garbage\n"
"collector."
msgstr ""
"После компиляции сети, нам больше не нужен список, созданный с помощью "
"defnode. Он\n"
"может быть выброшен (например, путем установки *nodes* в nil) и удален "
"сборщиком\n"
"мусора."

#: texi/node-06.texi:252
msgid ""
"@node 6-3 Looking Forward,  , 6-2 Compiling Networks, 6 Functions as "
"Representation\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 6-3 Looking Forward\n"
"@cindex 6-3 Looking Forward"
msgstr ""
"@node 6-3 Looking Forward,  , 6-2 Compiling Networks, 6 Functions as "
"Representation\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 6.3 Заглядывая в будущее\n"
"@cindex 6-3 Looking Forward"

#: texi/node-06.texi:257
msgid ""
"Many programs involving networks can be implemented by compiling the nodes\n"
"into closures. Closures are data objects, and they can be used to represent "
"things\n"
"just as structures can. Doing so requires some unconventional thinking, but "
"the\n"
"rewards are faster and more elegant programs."
msgstr ""
"Многие программы, связанные с сетями могут быть реализованы путем "
"компиляции\n"
"узлов в замыкания. Замыкания представляют собой данные, и они могут быть\n"
"использованы для представления различных вещей так же, как и структуры. Это\n"
"требует некоторого нестандартного мышления, но наградой будут более быстрые\n"
"и элегантные программы."

#: texi/node-06.texi:263
msgid ""
"Macros help substantially when we use closures as a representation. \"To\n"
"represent with closures\" is another way of saying \"to compile,\" and since "
"macros\n"
"do their work at compile-time, they are a natural vehicle for this "
"technique.\n"
"After macros have been introduced, Chapters 23 and 24 will present much "
"larger\n"
"programs based on the strategy used here."
msgstr ""
"Макросы могу существенно помочь, когда мы используем замыкания для "
"представления\n"
"данных. \"Представить в виде замыкания\" это еще один способ сказать "
"\"скомпилировать\",\n"
"и так как макросы работают во время компиляции, они являются естественным "
"средством\n"
"для этого. После того, как макросы будут представлены, главы 23 и 24 "
"покажут\n"
"гораздо больше программ, основанных на используемой здесь стратегии."
