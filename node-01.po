#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-01.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-05-15 16:57+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-01.texi:5
msgid ""
"@node 1 Extensible Language , 2 Functions, Preface to this edition, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 1 The Extensible Language\n"
"@cindex 1 The Extensible Language"
msgstr ""
"@node 1 Extensible Language , 2 Functions, Preface to this edition, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 1 Расширяемый язык (The Extensible Language)\n"
"@cindex 1 The Extensible Language"

#: texi/node-01.texi:13
msgid ""
"Not long ago, if you asked what Lisp was for, many people would have "
"answered\n"
"\"for artificial intelligence.\" In fact, the association between Lisp and "
"AI is just an\n"
"accident of history. Lisp was invented by John McCarthy, who also invented "
"the\n"
"term \"artificial intelligence.\" His students and colleagues wrote their "
"programs in\n"
"Lisp, and so it began to be spoken of as an AI language. This line was taken "
"up\n"
"and repeated so often during the brief AI boom in the 1980s that it became "
"almost\n"
"an institution."
msgstr ""
"Не так давно, если бы вы спросили, для чего нужен Лисп, то многие бы\n"
"ответили «для искусственного интеллекта». На самом деле, связь между\n"
"Лисп и ИИ – просто историческая случайность. Лисп был изобретен Джоном\n"
"Маккарти (John McCarthy), который также придумал термин «искусственный\n"
"интеллект». Его студенты и коллеги писали свои программы на Лисп,\n"
"поэтому о Лисп стали говорить как о языке для задач ИИ. Во времена\n"
"бума ИИ в 1980-х эта идея обсуждалась и повторялась настолько часто,\n"
"что стала практически непременным атрибутом."

#: texi/node-01.texi:19
msgid ""
"Fortunately, word has begun to spread that AI is not what Lisp is all "
"about.\n"
"Recent advances in hardware and software have made Lisp commercially "
"viable:\n"
"it is now used in Gnu Emacs, the best Unix text-editor; Autocad, the "
"industry stan-\n"
"dard desktop CAD program; and Interleaf, a leading high-end publishing "
"program.\n"
"The way Lisp is used in these programs has nothing whatever to do with AI."
msgstr ""
"К счастью, стали ходить разговоры о том, что ИИ – это не единственная\n"
"область применения Лисп. Недавние успехи в области аппаратного и\n"
"программного обеспечения сделали Лисп коммерчески жизнеспособным:\n"
"сейчас он используется в Gnu Emacs – лучшем текстовом редакторе для\n"
"Unix; Autocad – индустриальном стандарте среди САПР для настольных\n"
"компьютеров и Interleaf – распространенной профессиональной\n"
"издательской программе. Использование Лисп в этих программах\n"
"совершенно никак не связано с ИИ."

#: texi/node-01.texi:27
msgid ""
"If Lisp is not the language of AI, what is it? Instead of judging Lisp by "
"the\n"
"company it keeps, let's look at the language itself. What can you do in Lisp "
"that\n"
"you can't do in other languages? One of the most distinctive qualities of "
"Lisp is\n"
"the way it can be tailored to suit the program being written in it. Lisp "
"itself is a\n"
"Lisp program, and Lisp programs can be expressed as lists, which are Lisp "
"data\n"
"structures. Together, these two principles mean that any user can add "
"operators to\n"
"Lisp which are indistinguishable from the ones that come built-in."
msgstr ""
"Если Lisp не язык ИИ, тогда что это? Вместо того, чтобы судить о Лисп\n"
"по использующим его компаниям, давайте посмотрим на сам язык. Что вы\n"
"можете сделать в Лисп и не сможете в других языках? Одна из наиболее\n"
"отличительных черт Лисп – гибкость – позволяет ему лучше\n"
"подстраиваться под задачу FIXME. Сам по себе Лисп является программой\n"
"на Лисп, а программы на Лисп могут быть выражены в виде списков,\n"
"которые в свою очередь в Лисп являются структурами данных. Вместе эти\n"
"два принципа означают то, что любой пользователь может добавить\n"
"операторы в Лисп так, что они не будут отличаться от встроенных в\n"
"язык."

#: texi/node-01.texi:35
msgid ""
"@menu\n"
"* 1-1 Design by Evolution::     \n"
"* 1-2 Programming Bottom-Up::   \n"
"* 1-3 Extensible Software::     \n"
"* 1-4 Extending Lisp::          \n"
"* 1-5.Why Lisp (or When)::      \n"
"@end menu"
msgstr ""

#: texi/node-01.texi:40
msgid ""
"@node 1-1 Design by Evolution, 1-2 Programming Bottom-Up, 1 Extensible "
"Language , 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-1 Design by Evolution\n"
"@cindex 1-1 Design by Evolution"
msgstr ""
"@node 1-1 Design by Evolution, 1-2 Programming Bottom-Up, 1 Extensible "
"Language , 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-1 Эволюция дизайна\n"
"@cindex 1-1 Design by Evolution"

#: texi/node-01.texi:48
msgid ""
"Because Lisp gives you the freedom to define your own operators, you can "
"mold\n"
"it into just the language you need. If you're writing a text-editor, you can "
"turn\n"
"Lisp into a language for writing text-editors. If you're writing a CAD "
"program,\n"
"you can turn Lisp into a language for writing CAD programs. And if you're "
"not\n"
"sure yet what kind of program you're writing, it's a safe bet to write it in "
"Lisp.\n"
"Whatever kind of program yours turns out to be, Lisp will, during the "
"writing of\n"
"it, have evolved into a language for writing that kind of program."
msgstr ""
"Поскольку Лисп дает свободу в определении операторов, вы можете\n"
"преобразовать его в тот язык, который вам нужен. Если вы пишете\n"
"текстовый редактор, вы можете переделать Лисп в язык для написания\n"
"текстовых редакторов. Если вы пишете САПР, то можете превратить Лисп в\n"
"язык для написания САПР. И даже если вы пока не уверены насчет того,\n"
"какую программу вы пишете, то беспроигрышный вариант – написать ее на\n"
"Лисп. В какой бы вид программы она ни превратилась, Лисп в процессе ее\n"
"написания будет эволюционировать в язык, предназначенный для написания\n"
"такого вида программ."

#: texi/node-01.texi:55
msgid ""
"If you're not sure yet what kind of program you're writing? To some ears\n"
"that sentence has an odd ring to it. It is in jarring contrast with a "
"certain model\n"
"of doing things wherein you (1) carefully plan what you're going to do, and "
"then\n"
"(2) do it. According to this model, if Lisp encourages you to start writing "
"your\n"
"program before you've decided how it should work, it merely encourages "
"sloppy\n"
"thinking."
msgstr ""
"Вы все еще не уверены, какого рода программу пишете? Для кого-то этот\n"
"вопрос прозвучит странно. Такой разительный контраст с известной\n"
"моделью разработки, где вы (1) тщательно планируете то, что\n"
"собираетесь делать, а затем (2) делаете это. Если Лисп вдохновляет вас\n"
"на написание программы до того, как вы определите способ ее работы, то\n"
"согласно этой модели, такой подход лишь порождает хаотичное мышление.\n"

#: texi/node-01.texi:64
msgid ""
"Well, it just ain't so. The plan-and-implement method may have been a good\n"
"way of building dams or launching invasions, but experience has not shown it "
"to\n"
"be as good a way of writing programs. Why? Perhaps it's because computers\n"
"are so exacting. Perhaps there is more variation between programs than "
"there\n"
"is between dams or invasions. Or perhaps the old methods don't work because\n"
"old concepts of redundancy have no analogue in software development: if a "
"dam\n"
"contains 30% too much concrete, that's a margin for error, but if a program "
"does\n"
"30% too much work, that is an error."
msgstr ""
"Ну, это совсем не так. Метод «спланируй и реализуй», возможно, был\n"
"хорош для строительства плотин или совершения военных вторжений, но\n"
"опыт не показал, что это хороший способ написания программ. Почему?\n"
"Возможно, потому что он слишком точный. Может быть, между программами\n"
"больше различий, чем между дамбами или вторжениями. Или, наверное,\n"
"старые методы не работают, поскольку старая идея избыточности не имеет\n"
"аналогов в области разработки программного обеспечения: если дамба\n"
"содержит бетона на 30% выше нормы, то это граница допустимого предела,\n"
"но если программа делает на 30% больше работы, чем нужно, то это недопустимо."

#: texi/node-01.texi:76
msgid ""
"It may be difficult to say why the old method fails, but that it does fail, "
"anyone\n"
"can see. When is software delivered on time? Experienced programmers know\n"
"that no matter how carefully you plan a program, when you write it the plans "
"will\n"
"turn out to be imperfect in some way. Sometimes the plans will be "
"hopelessly\n"
"wrong. Yet few of the victims of the plan-and-implement method question its\n"
"basic soundness. Instead they blame human failings: if only the plans had "
"been\n"
"made with more foresight, all this trouble could have been avoided. Since "
"even\n"
"the very best programmers run into problems when they turn to "
"implementation,\n"
"perhaps it's too much to hope that people will ever have that much "
"foresight.\n"
"Perhaps the plan-and-implement method could be replaced with another "
"approach\n"
"which better suits our limitations."
msgstr ""
"Сложно сказать наверняка, почему старые методы не работают, но любой\n"
"может видеть, что именно это и происходит. Когда программы сдавались\n"
"вовремя? Опытные программисты знают, что вне зависимости от того,\n"
"насколько тщательно вы планировали программу, в процессе ее написания\n"
"планы в какой-то степени нарушатся. Иногда планы становятся безнадежно\n"
"неверными. Но лишь немногие жертвы метода «спланируй и реализуй»\n"
"ставят под сомнение его обоснованность. Вместо этого они начинают\n"
"винить человеческие недостатки: если бы планы были более\n"
"дальновидными, то всех этих неприятностей можно было бы\n"
"избежать. Поскольку даже лучшие программисты, переходя к реализации,\n"
"сталкиваются с проблемами, возможно, было бы слишком надеяться на то,\n"
"что люди когда-нибудь станут такими прозорливыми. Вероятно, метод\n"
"«спланируй и реализуй» может быть заменен другим подходом, более\n"
"подходящим нашим критериям."

#: texi/node-01.texi:83
msgid ""
"We can approach programming in a different way, if we have the right tools.\n"
"Why do we plan before implementing? The big danger in plunging right into\n"
"a project is the possibility that we will paint ourselves into a corner. If "
"we had\n"
"a more flexible language, could this worry be lessened? We do, and it is. "
"The\n"
"flexibility of Lisp has spawned a whole new style of programming. In Lisp, "
"you\n"
"can do much of your planning as you write the program."
msgstr ""
"Если у нас есть правильные инструменты, то мы можем подойти к\n"
"программированию по-другому. Для чего планировать перед реализацией?\n"
"Большая опасность в чрезмерном планировании состоит в возможности быть\n"
"загнанным в угол. Мы делаем, вот и все. Гибкость Лисп породила\n"
"полностью новый стиль программирования. В Лисп многое можно\n"
"спланировать в процессе написания программы."

#: texi/node-01.texi:95
msgid ""
"Why wait for hindsight? As Montaigne found, nothing clarifies your ideas\n"
"like trying to write them down. Once you're freed from the worry that you'll "
"paint\n"
"yourself into a corner, you can take full advantage of this possibility. The "
"ability\n"
"to plan programs as you write them has two momentous consequences: programs\n"
"take less time to write, because when you plan and write at the same time, "
"you\n"
"have a real program to focus your attention; and they turn out better, "
"because the\n"
"final design is always a product of evolution. So long as you maintain a "
"certain\n"
"discipline while searching for your program's destiny-so long as you always\n"
"rewrite mistaken parts as soon as it becomes clear that they're mistaken-the "
"final\n"
"product will be a program more elegant than if you had spent weeks planning "
"it\n"
"beforehand."
msgstr ""
"Зачем ждать оценок прошлого? Как заметил Монтень, ничто так не\n"
"проясняет наши идеи, как попытка записать их. Однажды вы освободитесь\n"
"от беспокойства, которе загоняет вас в угол; вы сможете извлечь всю\n"
"выгоду из этой возможности. Способность планировать программы по мере\n"
"их написания имеет два важных последствия: на написание программ\n"
"уходит меньше времени, потому что, когда вы пишете и планируете\n"
"одновременно, у вас есть настоящая программа, чтобы сосредоточить на\n"
"ней свое внимание; они становятся лучше, потому что окончательная\n"
"разработка – это всегда продукт эволюции. Таким образом в процессе\n"
"написания программы вы постоянно переписываете ошибочные части, как\n"
"только становится очевидна их несостоятельность, в итоге конечный\n"
"продукт будет более элегантным решением, чем если бы вы потратили\n"
"недели, планируя его заранее."

#: texi/node-01.texi:101
msgid ""
"Lisp's versatility makes this kind of programming a practical alternative.\n"
"Indeed, the greatest danger of Lisp is that it may spoil you. Once you've "
"used\n"
"Lisp for a while, you may become so sensitive to the fit between language "
"and\n"
"application that you won't be able to go back to another language without "
"always\n"
"feeling that it doesn't give you quite the flexibility you need."
msgstr ""
"Приспособляемость Лисп делает этот вид программирования практической\n"
"альтернативой. Действительно, самая большая опасность Лисп состоит в\n"
"том, что он может избаловать вас. Один раз попробовав Лисп, вы можете\n"
"стать настолько чувствительным к соответствию между языком и\n"
"приложением, что будете не в состоянии вернуться назад к другому языку\n"
"без постоянного ощущения того, что он не дает в полной мере ту\n"
"гибкость, которая вам необходима."

#: texi/node-01.texi:106
msgid ""
"@node 1-2 Programming Bottom-Up, 1-3 Extensible Software, 1-1 Design by "
"Evolution, 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-2 Programming Bottom-Up\n"
"@cindex 1-2 Programming Bottom-Up"
msgstr ""
"@node 1-2 Programming Bottom-Up, 1-3 Extensible Software, 1-1 Design by "
"Evolution, 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-2 Программирование снизу-вверх\n"
"@cindex 1-2 Programming Bottom-Up"

#: texi/node-01.texi:112
msgid ""
"It's a long-standing principle of programming style that the functional "
"elements of\n"
"a program should not be too large. If some component of a program grows "
"beyond\n"
"the stage where it's readily comprehensible, it becomes a mass of "
"complexity\n"
"which conceals errors as easily as a big city conceals fugitives. Such "
"software\n"
"will be hard to read, hard to test, and hard to debug."
msgstr ""
"Давно известное правило методологии программирования состоит в том,\n"
"что функциональные элементы программы не должны быть слишком\n"
"большими. Если какой-то из элементов программы вырастает настолько,\n"
"что перестает быть легким для понимания, то он превращается в\n"
"запутанный клубок, скрывающий ошибки так же легко, как большой город\n"
"скрывает беглецов. Такое программное обеспечение будет трудно читать,\n"
"трудно проверять и трудно отлаживать."

#: texi/node-01.texi:121
msgid ""
"In accordance with this principle, a large program must be divided into "
"pieces,\n"
"and the larger the program, the more it must be divided. How do you divide\n"
"a program? The traditional approach is called top-down design: you say "
"\"the\n"
"purpose of the program is to do these seven things, so I divide it into "
"seven major\n"
"subroutines. The first subroutine has to do these four things, so it in turn "
"will\n"
"have four of its own subroutines,\" and so on. This process continues until "
"the\n"
"whole program has the right level of granularity-each part large enough to "
"do\n"
"something substantial, but small enough to be understood as a single unit."
msgstr ""
"В соответствии с этим правилом большая программа должна быть разбита\n"
"на части, и чем больше программа, тем больше частей должно быть. Как\n"
"же разбить программу? Традиционный подход называется нисходящим\n"
"проектированием. Вы скажете: \"Цель программы состоит в том, чтобы\n"
"сделать семь таких-то вещей, значит, я разбиваю программу на семь\n"
"главных подпрограмм. Первая подпрограмма должна сделать четыре\n"
"таких-то вещи, поэтому у нее, в свою очередь, будет четыре собственные\n"
"подпрограммы, и так далее”. Этот процесс продолжается до тех пор, пока\n"
"вся программа не достигнет надлежащего уровня модульности – каждая\n"
"часть достаточно велика, чтобы сделать что-то важное, но и достаточно\n"
"мала для того, чтобы представлять собой отдельный модуль.\n"

#: texi/node-01.texi:135
msgid ""
"Experienced Lisp programmers divide up their programs differently. As well\n"
"as top-down design, they follow a principle which could be called bottom-up\n"
"design-changing the language to suit the problem. In Lisp, you don't just "
"write\n"
"your program down toward the language, you also build the language up "
"toward\n"
"your program. As you're writing a program you may think \"I wish Lisp had "
"such-\n"
"and-such an operator.\" So you go and write it. Afterward you realize that "
"using\n"
"the new operator would simplify the design of another part of the program, "
"and so\n"
"on. Language and program evolve together. Like the border between two "
"warring\n"
"states, the boundary between language and program is drawn and redrawn, "
"until\n"
"eventually it comes to rest along the mountains and rivers, the natural "
"frontiers\n"
"of your problem. In the end your program will look as if the language had "
"been\n"
"designed for it. And when language and program fit one another well, you end "
"up\n"
"with code which is clear, small, and efficient."
msgstr ""
"Опытные Лисп-программисты разбивают свои программы по-другому. Так же,\n"
"как и в нисходящем проектировании, они следуют принципу, который можно\n"
"было бы назвать восходящим проектированием – изменением языка для\n"
"решения задачи. В Лисп вы не просто подгоняете свою программу к языку,\n"
"вы также создаете язык для нее. По мере написания программы вам может\n"
"прийти в голову: \"Мне бы хотелось, чтобы в Лисп был такой-то\n"
"оператор”. Тогда вы идете и пишете его. Позже вы понимаете, что\n"
"использование нового оператора упростило бы разработку другой части\n"
"программы и так далее. Язык и программа развиваются вместе. Как\n"
"граница между двумя враждующими государствами, граница между языком и\n"
"программой чертится и перечерчивается, пока в конечном счете черта не\n"
"остается вдоль гор и рек – естественных границ вашей задачи. В итоге\n"
"ваша программа будет выглядеть так, как будто язык был разработан\n"
"специально для нее. И когда язык и программа будут хорошо\n"
"соответствовать друг другу, вы получите ясный, маленький и эффективный\n"
"код."

#: texi/node-01.texi:141
msgid ""
"It's worth emphasizing that bottom-up design doesn't mean just writing the\n"
"same program in a different order. When you work bottom-up, you usually end\n"
"up with a different program. Instead of a single, monolithic program, you "
"will get\n"
"a larger language with more abstract operators, and a smaller program "
"written in\n"
"it. Instead of a lintel, you'll get an arch."
msgstr ""
"Стоит подчеркнуть, что восходящее проектирование не означает всего\n"
"лишь написание той же программы в другом порядке. Когда вы работаете в\n"
"восходящем стиле, то в итоге, как правило, получите другую\n"
"программу. Вместо единственной, монолитной программы вы получите более\n"
"объемный язык с более абстрактными операторами и более короткую\n"
"программу, написанную на нем. Вместо перемычки у вас будет арка.\n"

#: texi/node-01.texi:145
msgid ""
"In typical code, once you abstract out the parts which are merely "
"bookkeeping,\n"
"what's left is much shorter; the higher you build up the language, the less "
"distance\n"
"you will have to travel from the top down to it. This brings several "
"advantages:"
msgstr ""
"В типичном коде, как только вы обобщаете части, являющиеся просто\n"
"бухгалтерией, то что остается намного короче FIXME; чем выше вы\n"
"создаете язык, тем меньше расстояния вы должны будете проходить сверху\n"
"вниз. Это дает несколько преимуществ:"

#: texi/node-01.texi:156
msgid ""
"@enumerate\n"
"@item\n"
"By making the language do more of the work, bottom-up design yields "
"programs\n"
"which are smaller and more agile. A shorter program doesn't have to be "
"divided\n"
"into so many components, and fewer components means programs which are "
"easier\n"
"to read or modify. Fewer components also means fewer connections between\n"
"components, and thus less chance for errors there. As industrial designers\n"
"strive to reduce the number of moving parts in a machine, experienced Lisp\n"
"programmers use bottom-up design to reduce the size and complexity of their\n"
"programs."
msgstr ""
"@enumerate\n"
"@item\n"
"Заставляя язык быть производительнее, восходящее проектирование\n"
"помогает создать более шустрые и менее объемные программы. Небольшую\n"
"программу ни к чему разбивать на слишком большое число компонент, ведь\n"
"меньшее число компонент означает, что программы легче прочитать или\n"
"изменить. Также, чем меньше число компонент, тем меньше связей между\n"
"ними и, таким образом, меньше шанс на ошибки в этих местах. Как\n"
"промышленные проектировщики стремятся сократить количество движущихся\n"
"частей в машине,так и опытные программисты Лисп используют восходящее\n"
"проектирование с целью уменьшения размера и сложности своих программ."

#: texi/node-01.texi:163
msgid ""
"@item \n"
"Bottom-up design promotes code re-use. When you write two or more programs,\n"
"many of the utilities you wrote for the first program will also be useful "
"in\n"
"the succeeding ones. Once you've acquired a large substrate of utilities,\n"
"writing a new program can take only a fraction of the effort it would "
"require\n"
"if you had to start with raw Lisp."
msgstr ""
"@item \n"
"Восходящая разработка способствует многократному использованию\n"
"кода. Когда вы пишете две или более программы, многие из утилит,\n"
"написанных вами для первой программы, пригодятся и для\n"
"последующих. Собрав однажды большое количество утилит, на создание\n"
"новой программы вы потратите лишь часть тех усилий, которые бы\n"
"потребовались, начни вы писать на Лисп с нуля."

#: texi/node-01.texi:171
msgid ""
"@item\n"
"Bottom-up design makes programs easier to read. An instance of this type of\n"
"abstraction asks the reader to understand a general-purpose operator; an\n"
"instance of functional abstraction asks the reader to understand a special-\n"
"purpose subroutine. @footnote {\"But no one can read the program without\n"
"understanding all your new utilities.\" To see why such statements are "
"usually\n"
"mistaken, see Section 4-8.}"
msgstr ""
"@item\n"
"Восходящая разработка делает программы более легкими для чтения. В\n"
"случае абстракции типа экземпляра требуется, чтобы читатель понял оператор\n"
"общего назначения; в случае функциональной абстракции нужно, чтобы\n"
"читатель понял подпрограмму специального назначения. \n"
"@footnote {\"Но никто не может читать программу без понимания всех ваших "
"новых\n"
"утилит.” Чтобы понять, почему такие утверждения обычно ошибочны,\n"
"см Раздел 4-8.}"

#: texi/node-01.texi:179
msgid ""
"@item \n"
"Because it causes you always to be on the lookout for patterns in your "
"code,\n"
"working bottom-up helps to clarify your ideas about the design of your\n"
"program. If two distant components of a program are similar in form, you'll "
"be\n"
"led to notice the similarity and perhaps to redesign the program in a "
"simpler\n"
"way.\n"
"@end enumerate"
msgstr ""
"@item \n"
"Заставляя вас всегда быть в поисках шаблонов в вашем коде,\n"
"восходящее проектирование помогает прояснить ваши идеи о модели\n"
"программы. Если два отдаленных компонента программы похожи по форме,\n"
"то вы первым заметите сходство и, возможно, перепроектируете программу\n"
"более простым способом.\n"
"@end enumerate"

#: texi/node-01.texi:185
msgid ""
"Bottom-up design is possible to a certain degree in languages other than "
"Lisp.\n"
"Whenever you see library functions, bottom-up design is happening. However,\n"
"Lisp gives you much broader powers in this department, and augmenting the\n"
"language plays a proportionately larger role in Lisp style-so much so that "
"Lisp\n"
"is not just a different language, but a whole different way of programming."
msgstr ""
"Восходящее проектирование на языках, отличных от Лисп, осуществимо\n"
"лишь до определенной степени. Всякий раз, когда вы видите библиотечные\n"
"функции, происходит восходящее проектирование. Однако Лисп дает вам\n"
"намного более широкие возможности в этом случае, и расширяемый язык\n"
"играет соответственно большую роль в технике программирования на Лисп,\n"
"настолько большую, что Лисп – это не просто другой язык, а совершенно\n"
"иной способ программирования."

#: texi/node-01.texi:196
msgid ""
"It's true that this style of development is better suited to programs which "
"can be\n"
"written by small groups. However, at the same time, it extends the limits of "
"what\n"
"can be done by a small group. In The Mythical Man-Month, Frederick Brooks  \n"
"proposed that the productivity of a group of programmers does not grow "
"linearly\n"
"with its size. As the size of the group increases, the productivity of "
"individual\n"
"programmers goes down. The experience of Lisp programming suggests a more\n"
"cheerful way to phrase this law: as the size of the group decreases, the "
"productivity\n"
"of individual programmers goes up. A small group wins, relatively speaking,\n"
"simply because it's smaller. When a small group also takes advantage of the\n"
"techniques that Lisp makes possible, it can win outright."
msgstr ""
"Это правда, что этот способ разработки лучше подходит для программ,\n"
"которые могут быть написаны небольшими группами. Однако, в то же самое\n"
"время, он расширяет пределы того, что может быть сделано небольшой\n"
"группой. В книге \"Мифический человеко-месяц” Фредерик Брукс (Frederick\n"
"Brooks) предположил, что производительность группы программистов не\n"
"растет линейно с ее размером. С увеличением размера группы понижается\n"
"производительность отдельных программистов. Опыт программирования на\n"
"Лисп предлагает более жизнерадостную формулировку этого закона: с\n"
"уменьшением размера группы производительность индивидуальных\n"
"программистов повышается. Небольшая группа побеждает, собственно\n"
"говоря, просто потому, что она меньше. Когда небольшая группа\n"
"воспользуется еще и методиками, которые делает доступными Лисп, то она\n"
"может победить вчистую."

#: texi/node-01.texi:202
msgid ""
"@node 1-3 Extensible Software, 1-4 Extending Lisp, 1-2 Programming Bottom-"
"Up, 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-3 Extensible Software\n"
"@cindex 1-3 Extensible Software"
msgstr ""
"@node 1-3 Extensible Software, 1-4 Extending Lisp, 1-2 Programming Bottom-"
"Up, 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-3 Расширяемое программное обеспечение\n"
"@cindex 1-3 Extensible Software"

#: texi/node-01.texi:210
msgid ""
"The Lisp style of programming is one that has grown in importance as "
"software\n"
"has grown in complexity. Sophisticated users now demand so much from "
"software\n"
"that we can't possibly anticipate all their needs. They themselves can't "
"anticipate\n"
"all their needs. But if we can't give them software which does everything "
"they\n"
"want right out of the box, we can give them software which is extensible. "
"We\n"
"transform our software from a mere program into a programming language, and\n"
"advanced users can build upon it the extra features that they need."
msgstr ""
"Именно техника программирования на Лисп становиться более важной по мере\n"
"роста сложности программного обеспечения. Искушенные пользователи\n"
"теперь требуют так много от ПО, что мы не имеем возможности\n"
"предугадывать все их потребности. Они и сами не могут их\n"
"предугадать. Но если мы не можем дать им софт, который делает всё, что\n"
"они хотят, сразу из коробки, то мы можем дать им расширяемое\n"
"программное обеспечение. Мы преобразуем наше ПО из обычных программ в\n"
"язык программирования, и продвинутые пользователи могут надстраивать\n"
"поверх него необходимые им дополнительные функции."

#: texi/node-01.texi:219
msgid ""
"Bottom-up design leads naturally to extensible programs. The simplest\n"
"bottom-up programs consist of two layers: language and program. Complex\n"
"programs may be written as a series of layers, each one acting as a "
"programming\n"
"language for the one above. If this philosophy is carried all the way up to "
"the\n"
"topmost layer, that layer becomes a programming language for the user. Such\n"
"a program, where extensibility permeates every level, is likely to make a "
"much\n"
"better programming language than a system which was written as a "
"traditional\n"
"black box, and then made extensible as an afterthought."
msgstr ""
"Восходящая разработка естественным образом ведет к расширяемым\n"
"программам. Простейшие восходящие программы состоят из двух уровней:\n"
"язык и программа. Сложные программы могут быть написаны как\n"
"последовательность уровней, каждый из которых выступает в качестве\n"
"языка для уровня лежащего над ним. Если эту философию пронести через весь\n"
"процесс до самого верхнего уровня, то тот уровень и станет программным\n"
"языком для пользователя. Такая программа, где расширяемость проходит\n"
"сквозь каждый уровень, вероятно, создает более хороший язык\n"
"программирования, нежели системы, которые были написаны как\n"
"традиционный черный ящик, и лишь с запозданием сделаны расширяемыми."

#: texi/node-01.texi:221
msgid ""
"X Windows and TEX are early examples of programs based on this principle."
msgstr ""
"X Windows и TEX – примеры первых программ, основанных на этом\n"
"принципе."

#: texi/node-01.texi:228
msgid ""
"In the 1980s better hardware made possible a new generation of programs "
"which\n"
"had Lisp as their extension language. The first was Gnu Emacs, the popular\n"
"Unix text-editor. Later came Autocad, the first large-scale commercial "
"product to\n"
"provide Lisp as an extension language. In 1991 Interleaf released a new "
"version\n"
"of its software that not only had Lisp as an extension language, but was "
"largely\n"
"implemented in Lisp."
msgstr ""
"В 1980-е более хорошее оборудование сделало возможным новое\n"
"поколение программ, которые использовали Лисп в качестве собственного\n"
"языка расширений. Первым был Gnu Emacs – популярный текстовый редактор\n"
"Unix. Позже появился Autocad – первый крупномасштабный коммерческий\n"
"продукт, давший возможность использовать Лисп как расширяемый язык. В\n"
"1991 году Interleaf представила новую версию своего продукта, который\n"
"не только использовал Лисп как расширяемый язык, но и был в\n"
"значительной степени на нем же и реализован."

#: texi/node-01.texi:240
msgid ""
"Lisp is an especially good language for writing extensible programs because\n"
"it is itself an extensible program. If you write your Lisp programs so as to "
"pass\n"
"this extensibility on to the user, you effectively get an extension language "
"for free.\n"
"And the difference between extending a Lisp program in Lisp, and doing the "
"same\n"
"thing in a traditional language, is like the difference between meeting "
"someone in\n"
"person and conversing by letters. In a program which is made extensible "
"simply\n"
"by providing access to outside programs, the best we can hope for is two "
"black\n"
"boxes communicating with one another through some predefined channel. In\n"
"Lisp, extensions can have direct access to the entire underlying program. "
"This is\n"
"not to say that you have to give users access to every part of your program-"
"just\n"
"that you now have a choice about whether to give them access or not."
msgstr ""
"Лисп – особенно хороший язык для написания расширяемых программ,\n"
"потому что он сам расширяем. Если вы напишете свою программу на Лисп\n"
"так, чтобы передать эту расширяемость пользователю, вы фактически\n"
"получите расширяемый язык бесплатно. Различие между расширением\n"
"Лисп-программы в Лисп и тем же самым, но на традиционном языке,\n"
"равносильно различию между личной встречей с кем-нибудь и почтовой\n"
"перепиской. В программе, которая сделана расширяемой просто за счет\n"
"предоставления доступа к внешним программам, лучшее, на что мы можем\n"
"рассчитывать – это два черных ящика, соединенных один с другим при\n"
"помощи какого-нибудь заранее определенного протокола. В Лисп же\n"
"расширения могут иметь прямой доступ ко всем подпрограммам. Это не\n"
"означает, что вы должны предоставить пользователям доступ к каждой\n"
"части своей программы – просто теперь у вас есть выбор, давать ли им\n"
"доступ или нет."

#: texi/node-01.texi:251
msgid ""
"When this degree of access is combined with an interactive environment, you\n"
"have extensibility at its best. Any program that you might use as a "
"foundation for\n"
"extensions of your own is likely to be fairly big-too big, probably, for you "
"to have\n"
"a complete mental picture of it. What happens when you're unsure of "
"something?\n"
"If the original program is written in Lisp, you can probe it interactively: "
"you can\n"
"inspect its data structures; you can call its functions; you may even be "
"able to look\n"
"at the original source code. This kind of feedback allows you to program "
"with\n"
"a high degree of confidence-to write more ambitious extensions, and to "
"write\n"
"them faster. An interactive environment always makes programming easier, but "
"it\n"
"is nowhere more valuable than when one is writing extensions."
msgstr ""
"Когда такой уровень доступа встречается с интерактивным окружением,\n"
"достигается наилучшая расширяемость. Любая программа, которую можно\n"
"использовать как основу для собственных расширений – это, вероятно,\n"
"довольно большая программа, возможно, слишком большая для того, чтобы\n"
"вы держали в уме ее полный образ. Что происходит, когда вы в чем-то не\n"
"уверены? Если программа написана на Лисп, вы можете испытать ее в\n"
"диалоговом режиме: вы можете изучить ее структуры данных, можете\n"
"вызвать ее функции, даже можете посмотреть на изначальный исходный\n"
"код. Такой вид обратной связи дает вам возможность программировать с\n"
"большой уверенностью: писать более мощные расширения и писать их\n"
"быстрее. Диалоговое окружение всегда делает программирование проще, но\n"
"оно приобретает имеет особую ценность при написании расширений."

#: texi/node-01.texi:255
msgid ""
"An extensible program is a double-edged sword, but recent experience has\n"
"shown that users prefer a double-edged sword to a blunt one. Extensible "
"programs\n"
"seem to prevail, whatever their inherent dangers."
msgstr ""
"Расширяемая программа – это обоюдоострый меч, тем не менее последний\n"
"опыт показал, что пользователи предпочитают обоюдоострый меч\n"
"тупому. Расширяемые программы, похоже, одерживают верх, несмотря на\n"
"присущие им опасности."

#: texi/node-01.texi:260
msgid ""
"@node 1-4 Extending Lisp, 1-5.Why Lisp (or When), 1-3 Extensible Software, 1 "
"Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-4 Extending Lisp\n"
"@cindex 1-4 Extending Lisp"
msgstr ""
"@node 1-4 Extending Lisp, 1-5.Why Lisp (or When), 1-3 Extensible Software, 1 "
"Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-4 Расширение Лисп\n"
"@cindex 1-4 Extending Lisp"

#: texi/node-01.texi:267
msgid ""
"There are two ways to add new operators to Lisp: functions and macros. In "
"Lisp,\n"
"functions you define have the same status as the built-in ones. If you want "
"a new\n"
"variant of mapcar, you can define one yourself and use it just as you would "
"use\n"
"mapcar. For example, if you want a list of the values returned by some "
"function\n"
"when it is applied to all the integers from 1 to 10, you could create a new "
"list and\n"
"pass it to mapcar:"
msgstr ""
"Существует два способа добавления в Лисп новых операторов: функции и\n"
"макрос. В Лисп определяемые вами функции имеют тот же статус, что и\n"
"встроенные. Если вы хотите новый вариант mapcar, вы можете сами его\n"
"определить и использовать точно так же, как использовали бы\n"
"mapcar. Например, если вам нужен список значений, возвращаемых некой\n"
"функцией, примененной ко всем целым числам от 1 до 10, вы могли бы\n"
"создать новый список и передать его mapcar:"

#: texi/node-01.texi:274
msgid ""
"@lisp\n"
"(mapcar fn\n"
"       (do* ((x 1 (1+ x))\n"
"          (result (list x) (push x result)))\n"
"                   ((= x 10) (nreverse result))))\n"
"@end lisp"
msgstr ""

#: texi/node-01.texi:278
msgid ""
"but this approach is both ugly and inefficient. @footnote {You could write "
"this\n"
"more elegantly with the new Common Lisp series macros, but that only proves "
"the\n"
"same point, because these macros are an extension to Lisp themselves.}"
msgstr ""
"но такой подход и уродливый и неэффективный. @footnote {Вы могли бы "
"написать \n"
"это более красиво при помощи последовательности новых макросов Коммон "
"Лисп, \n"
"но это лишь доказывает ту же точку зрения, так как эти макросы сами по "
"себе \n"
"являются расширением Лисп.}"

#: texi/node-01.texi:281
msgid ""
"Instead you could define a new mapping function map1-n (see page 54), and "
"then\n"
"call it as follows:"
msgstr ""
"вместо этого вы могли  бы определить новую отображающую функцию map1-n (см. "
"страницу 54)\n"
"и затем ее вызвать следующим образом:\n"

#: texi/node-01.texi:285
msgid ""
"@lisp\n"
"(map1-n fn 10)\n"
"@end lisp"
msgstr ""

#: texi/node-01.texi:290
msgid ""
"Defining functions is comparatively straightforward. Macros provide a more\n"
"general, but less well-understood, means of defining new operators. Macros "
"are\n"
"programs that write programs. This statement has far-reaching implications, "
"and\n"
"exploring them is one of the main purposes of this book."
msgstr ""
"Функции определяются относительно просто. Макросы предоставляют более\n"
"широкое, но и менее понятное средство определения новых\n"
"операторов. Макросы – это программы, которые пишут программы. Это\n"
"утверждение имеет глубокий смысл, и его раскрытие – одна из основных\n"
"целей книги."

#: texi/node-01.texi:302
msgid ""
"The thoughtful use of macros leads to programs which are marvels of clarity\n"
"and elegance. These gems are not to be had for nothing. Eventually macros "
"will\n"
"seem the most natural thing in the world, but they can be hard to understand "
"at first.\n"
"Partly this is because they are more general than functions, so there is "
"more to keep\n"
"in mind when writing them. But the main reason macros are hard to "
"understand\n"
"is that they're foreign. No other language has anything like Lisp macros. "
"Thus\n"
"learning about macros may entail unlearning preconceptions inadvertently "
"picked\n"
"up from other languages. Foremost among these is the notion of a program as\n"
"something afflicted by rigor mortis. Why should data structures be fluid "
"and\n"
"changeable, but programs not? In Lisp, programs are data, but the "
"implications\n"
"of this fact take a while to sink in."
msgstr ""
"Осмысленное использование макросов ведет к программам, удивляющим\n"
"ясностью и изящностью. Эти сокровища не даются просто так. В итоге\n"
"макросы, наверное, самая естественная в мире вещь, но вначале они\n"
"могут быть трудными для понимания. Частично это из-за того, что они\n"
"имеют больше возможностей, чем функции, поэтому, когда их пишешь,\n"
"больше приходится держать в голове. Но основная причина, почему\n"
"макросы трудны для понимания, это потому, что они незнакомы. Никакой\n"
"другой язык не имеет ничего, подобного Лисп-макросам. Таким образом,\n"
"изучение макросов позволит рассеять предрассудки, неосторожно\n"
"приобретенные от других языков. Самый главный из которых – это\n"
"представление программы в виде чего-то, подверженного трупному\n"
"окоченению. Почему структуры данных должны быть гибкими и изменяемыми,\n"
"а программы нет? В Лисп программы – это данные, но требуется время,\n"
"чтобы вникнуть в смысл этого факта."

#: texi/node-01.texi:308
msgid ""
"If it takes some time to get used to macros, it is well worth the effort. "
"Even in\n"
"such mundane uses as iteration, macros can make programs significantly "
"smaller\n"
"and cleaner. Suppose a program must iterate over some body of code for x "
"from\n"
"a to b. The built-in Lisp do is meant for more general cases. For simple "
"iteration\n"
"it does not yield the most readable code:"
msgstr ""
"Если привыкание к макросам и займет некоторое время, то оно стоит\n"
"затраченных усилий. Даже в таком простом применении, как итерация,\n"
"макросы могут сделать программы существенно меньше и\n"
"чище. Предположим, что программа должна произвести итерацию с\n"
"некоторым участком кода для x от a до b. Встроенный в Лисп оператор do\n"
"предназначен для более общих случаев. Для простой итерации он не даст\n"
"наиболее читаемый код:"

#: texi/node-01.texi:314
msgid ""
"@lisp\n"
"(do ((x a (+ 1 x)))\n"
"        ((> x b))\n"
"  (print x))\n"
"@end lisp"
msgstr ""

#: texi/node-01.texi:316
msgid "Instead, suppose we could just say:"
msgstr "Вместо этого, допустим, мы могли бы сказать всего лишь:"

#: texi/node-01.texi:321
msgid ""
"@lisp\n"
"(for (x a b)\n"
"  (print x))\n"
"@end lisp"
msgstr ""

#: texi/node-01.texi:325
msgid ""
"Macros make this possible. With six lines of code (see page 154) we can add "
"for\n"
"to the language, just as if it had been there from the start. And as later "
"chapters\n"
"will show, writing for is only the beginning of what you can do with macros."
msgstr ""
"Макросы делают это возможным. При помощи шести строчек кода\n"
"(см. стр. 154) мы можем добавить к языку for, как будто бы он там был\n"
"с самого начала. И, как покажут последующие главы, написание for\n"
"только начало того, что вы можете делать с макросами.\n"

#: texi/node-01.texi:335
msgid ""
"You're not limited to extending Lisp one function or macro at a time. If "
"you\n"
"need to, you can build a whole language on top of Lisp, and write your "
"programs\n"
"in that. Lisp is an excellent language for writing compilers and "
"interpreters, but\n"
"it offers another way of defining a new language which is often more elegant "
"and\n"
"certainly much less work: to define the new language as a modification of "
"Lisp.\n"
"Then the parts of Lisp which can appear unchanged in the new language (e.g.\n"
"arithmetic or I/O) can be used as is, and you only have to implement the "
"parts\n"
"which are different (e.g. control structure). A language implemented in this "
"way\n"
"is called an embedded language."
msgstr ""
"Вы не ограничены расширять Лисп за раз только одной функцией или\n"
"макросом. Если потребуется, вы можете создать целый язык поверх Лисп и\n"
"писать на нем свои программы. Лисп – это превосходный язык для\n"
"написания компиляторов и интерпретаторов, но он предлагает иной способ\n"
"описания нового языка, который зачастую более изящен и, несомненно,\n"
"менее трудоемок – описать новый язык как модификацию Лисп. В таком\n"
"случае части Лисп, которые могут появиться в новом языке без изменений\n"
"(например, арифметика или ввод/вывод), могут быть использованы как\n"
"есть, и вам нужно реализовать компоненты, которые отличаются\n"
"(например, управляющую структуру). Язык, реализованный таким образом,\n"
"называется встраиваемым языком."

#: texi/node-01.texi:341
msgid ""
"Embedded languages are a natural outgrowth of bottom-up programming.\n"
"Common Lisp includes several already. The most famous of them, CLOS,is\n"
"discussed in the last chapter. But you can define embedded languages of "
"your\n"
"own, too. You can have the language which suits your program, even if it "
"ends up\n"
"looking quite different from Lisp."
msgstr ""
"Встраиваемые языки – естественный результат восходящего\n"
"программирования. Коммон Лисп уже включает в себя несколько. Наиболее\n"
"известный из них – CLOS – рассматривается в последней главе. Но вы\n"
"также можете описать и свои собственные встраиваемые языки. Вы можете\n"
"получить язык, который подходит к программе, даже если он станет\n"
"выглядеть совершенно отличным от Лисп.\n"

#: texi/node-01.texi:346
msgid ""
"@node 1-5.Why Lisp (or When),  , 1-4 Extending Lisp, 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-5 Why Lisp (or When)\n"
"@cindex 1-5 Why Lisp (or When)"
msgstr ""
"@node 1-5.Why Lisp (or When),  , 1-4 Extending Lisp, 1 Extensible Language\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 1-5 Почему Lisp (или Когда)\n"
"@cindex 1-5 Why Lisp (or When)"

#: texi/node-01.texi:356
msgid ""
"These new possibilities do not stem from a single magic ingredient. In this "
"respect,\n"
"Lisp is like an arch. Which of the wedge-shaped stones (voussoirs) is the "
"one\n"
"that holds up the arch? The question itself is mistaken; they all do. Like "
"an arch,\n"
"Lisp is a collection of interlocking features. We can list some of these "
"features-\n"
"dynamic storage allocation and garbage collection, runtime typing, functions "
"as\n"
"objects, a built-in parser which generates lists, a compiler which accepts "
"programs\n"
"expressed as lists, an interactive environment, and so on-but the power of "
"Lisp\n"
"cannot be traced to any single one of them. It is the combination which "
"makes\n"
"Lisp programming what it is."
msgstr ""
"Эти новые возможности не происходят от единственного волшебного ингридиента. "
"В этом \n"
"отношении Lisp как арка. Какой из клинообразных камней (voussoirs) является "
"тем, что \n"
"поддерживает арку? Вопрос неверен сам по себе: они все ими и являются. Как и "
"арка, Лисп\n"
"– это набор взаимосвязанных функций(возможностей). Мы можем перечислить "
"некоторые из этих\n"
"функций: динамическое распределение памяти и сборка мусора,\n"
"динамическая типизация, функции как объекты, встроенный систаксический\n"
"анализатор, генерирующий списки, компилятор, принимающий программы,\n"
"представленные в виде списков, диалоговое окружение, и так далее, но\n"
"ни в одной из них нельзя усмотреть способности Лисп. Это сочетание,\n"
"делающее программирование на Лисп таким, какое есть."

#: texi/node-01.texi:362
msgid ""
"Over the past twenty years, the way people program has changed. Many of\n"
"these changes-interactive environments, dynamic linking, even object-"
"oriented\n"
"programming-have been piecemeal attempts to give other languages some of\n"
"the flexibility of Lisp. The metaphor of the arch suggests how well they "
"have\n"
"succeeded."
msgstr ""
"На протяжении двадцати последних лет подход к программированию\n"
"изменился. Многие из этих изменений: диалоговые окружения,\n"
"динамическое связывание, даже объектно-ориентированное\n"
"программирование – были частичными попытками передать другим языкам\n"
"немного гибкости Лисп. Метафора арки как бы намекает, насколько хорошо\n"
"они преуспели."

#: texi/node-01.texi:372
msgid ""
"It is widely known that Lisp and Fortran are the two oldest languages still "
"in\n"
"use. What is perhaps more significant is that they represent opposite poles "
"in the\n"
"philosophy of language design. Fortran was invented as a step up from "
"assembly\n"
"language. Lisp was invented as a language for expressing algorithms. Such\n"
"different intentions yielded vastly different languages. Fortran makes life "
"easy for\n"
"the compiler writer; Lisp makes life easy for the programmer. Most "
"programming\n"
"languages since have fallen somewhere between the two poles. Fortran and "
"Lisp\n"
"have themselves moved closer to the center. Fortran now looks more like "
"Algol,\n"
"and Lisp has given up some of the wasteful habits of its youth."
msgstr ""
"Широко известно, что Лисп и Фортран – два, пока еще используемых,\n"
"старейших языка. Что, наверное, наиболее важно, так это то, что они\n"
"представляют противоположные стороны философии дизайна языков\n"
"программирования. Фортран был изобретен как расширение\n"
"ассемблера. Лисп был изобретен как язык для выражения\n"
"алгоритмов. Такие разные стремления привели к совершенно разным\n"
"языкам. Фортран облегчает жизнь автору компилятора, Лисп облегчает\n"
"жизнь программиста. Большинство языков программирования впоследствии\n"
"распределились где-то между двумя полюсами. Фортран и Лисп\n"
"переместились ближе к центру. Фортран сейчас выглядит больше, как\n"
"Алгол, а Лисп лишился некоторых скверных привычек своей юности."

#: texi/node-01.texi:382
msgid ""
"The original Fortran and Lisp defined a sort of battlefield. On one side "
"the\n"
"battle cry is \"Efficiency! (And besides, it would be too hard to "
"implement.)\" On\n"
"the other side, the battle cry is \"Abstraction! (And anyway, this isn't "
"production\n"
"software.)\" As the gods determined from afar the outcomes of battles among "
"the\n"
"ancient Greeks, the outcome of this battle is being determined by hardware. "
"Every\n"
"year, things look better for Lisp. The arguments against Lisp are now "
"starting to\n"
"sound very much like the arguments that assembly language programmers gave\n"
"against high-level languages in the early 1970s. The question is now "
"becoming\n"
"not Why Lisp?, but When?"
msgstr ""
"Изначально Фортран и Лисп характеризовались как, своего рода, два\n"
"враждующих лагеря. В одном из них кричали: \"Эффективность!” (За\n"
"исключением того, что было бы слишком трудно реализовать). В другом\n"
"лагере кричали: \"Абстракция!” (В любом случае это непромышленное\n"
"ПО). И боги определили из далеких исходов древнегреческих баталий, что\n"
"исход этой битвы будет определен аппаратным обеспечением. С каждым\n"
"годом обстоятельства складываются лучше для Лисп. Аргументы против\n"
"Лисп сейчас стали звучать очень похоже на аргументы программистов на\n"
"ассемблере, направленные против высокоуровневых языков в середине\n"
"1970-х. Вопрос, который сейчас ставится, в том не \"Почему Лисп?”, а\n"
"\"Когда?”."
