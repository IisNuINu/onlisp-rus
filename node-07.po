#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-07.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-07-02 14:30+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-07.texi:5
msgid ""
"@node 7 Macros, 8 When to Use Macros, 6 Functions as Representation, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 7 Macros\n"
"@cindex 7 Macros"
msgstr ""
"@node 7 Macros, 8 When to Use Macros, 6 Functions as Representation, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 7 Макросы\n"
"@cindex 7 Macros"

#: texi/node-07.texi:12
msgid ""
"Lisp's macro facility allows you to define operators that are implemented "
"by\n"
"transformation. The definition of a macro is essentially a function that "
"generates\n"
"Lisp code-a program that writes programs. From these small beginnings arise\n"
"great possibilities, and also unexpected hazards. Chapters 7­10 form a "
"tutorial\n"
"on macros. This chapter explains how macros work, gives techniques for "
"writing\n"
"and testing them, and looks at the issue of macro style."
msgstr ""
"Макросы Lisp позволяют вам определять операторы, которые реализуют "
"преобразования.\n"
"Определение макроса по сутb является функцией, которая генерирует Lisp код, "
"программа\n"
"которая пишет программы/ Из этих небольших начинаний проистекают большие "
"возможности, а \n"
"также неожиданые опасности. Главы 7-­10 составляют учебное пособие о "
"макросах.\n"
"Эта глава объясняет, как работают макросы, дает примемы их написания и "
"тестирования,\n"
"и рассматривает проблемы использования макро стиля."

#: texi/node-07.texi:26
msgid ""
"@menu\n"
"* 7-1 How Macros Work::         \n"
"* 7-2 Backquote::               \n"
"* 7-3 Defining Simple Macros::  \n"
"* 7-4 Testing Macroexpansion::  \n"
"* 7-5 Destructuring in Parameter Lists::  \n"
"* 7-6 A Model of Macros::       \n"
"* 7-7 Macros as Programs::      \n"
"* 7-8 Macro Style::             \n"
"* 7-9 Dependence on Macros::    \n"
"* 7-10 Macros from Functions::  \n"
"* 7-11 Symbol Macros::          \n"
"@end menu"
msgstr ""

#: texi/node-07.texi:31
msgid ""
"@node 7-1 How Macros Work, 7-2 Backquote, 7 Macros, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-1 How Macros Work\n"
"@cindex 7-1 How Macros Work"
msgstr ""
"@node 7-1 How Macros Work, 7-2 Backquote, 7 Macros, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-1 Как работает Макрос\n"
"@cindex 7-1 How Macros Work"

#: texi/node-07.texi:39
msgid ""
"Since macros can be called and return values, they tend to be associated "
"with func-\n"
"tions. Macro definitions sometimes resemble function definitions, and "
"speaking\n"
"informally, people call do, which is actually a macro, a \"built-in function."
"\" But\n"
"pushing the analogy too far can be a source of confusion. Macros work "
"differently\n"
"from normal functions, and knowing how and why macros are different is the\n"
"key to using them correctly. A function produces results, but a macro "
"produces\n"
"expressions-which, when evaluated, produce results."
msgstr ""
"Поскольку макросы могут вызываться и возвращать значения, они, как правило, "
"связаны\n"
"с функциями. Определения макросов иногда напоминают определения функций и "
"неофициально\n"
"люди называют то, что на самом деле является макросом - \"встраиваемой "
"функцией.\" Но это\n"
"слишком далеко идущая аналогия может стать источником путаницы. Макросы "
"работают по\n"
"другому, нежели обычные функции, и знание как и чем макросы отличаются от "
"функций, это\n"
"ключ к их правильному ипользованию. Функция выдает результаы, а макрос "
"выдает(производит)\n"
"выражения, которые при вычислении, дают результаты."

#: texi/node-07.texi:44
msgid ""
"The best way to begin is to move straight into an example. Suppose we want\n"
"to write a macro nil!, which sets its argument to nil. We want (nil! x) to\n"
"have the same effect as (setq x nil). We do it by defining nil! as a macro\n"
"which turns instances of the first form into instances of the second."
msgstr ""
"Лучший способ начать - перейти прямо к примеру. Предположим, мы хотим "
"написать\n"
"макрос nil!, который устанавливает свой аргумент в значение nil. Мы хотим "
"чтобы\n"
"(nil! x) имел тот же эффект что и выражение (setq x nil). Мы сделаем это\n"
"определив nil! как макрос, который превращает экземпляры первой формы в \n"
"в экземпляры второй формы."

#: texi/node-07.texi:50
msgid ""
"@example\n"
"> (defmacro nil! (var)\n"
"      (list 'setq var nil))\n"
"NIL!\n"
"@end example"
msgstr ""

#: texi/node-07.texi:55
msgid ""
"Paraphrased in English,this definition tells Lisp: \"Whenever you see an "
"expression\n"
"of the form (nil! var), turn it into one of the form (setq var nil) before\n"
"evaluating it.\""
msgstr ""
"Перефразируя на русский, это определение говорит Лиспу: \"Всякий раз, когда "
"ты видишь\n"
"выражение вида (nil! var), преврати его в форму вида (setq var nil), прежде "
"чем его\n"
"вычислить.\""

#: texi/node-07.texi:60
msgid ""
"The expression generated by the macro will be evaluated in place of the "
"original\n"
"macro call. A macro call is a list whose first element is the name of a "
"macro.\n"
"What happens when we type the macro call (nil! x) into the toplevel? Lisp\n"
"notices that nil! is the name of a macro, and"
msgstr ""
"Выражение сгенерированное макросом, будет вычислено вместо исходного вызова "
"макроса.\n"
"Вызов макроса это список, первым элементом которого является имя макроса.\n"
"Что происходит, когда мы вводим вызов макроса (nil! x) на верхнем уровне? "
"Лисп\n"
"замечает что nil! это имя макроса, и:"

#: texi/node-07.texi:67
msgid ""
"@enumerate\n"
"@item\n"
"builds the expression specified by the definition above, then\n"
"@item\n"
"evaluates that expression in place of the original macro call.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"строит выражение, указанное в приведенном выше определении, затем\n"
"@item\n"
"вычисляет это выражение, вместо исходного вызова макроса.\n"
"@end enumerate"

#: texi/node-07.texi:74
msgid ""
"The step of building the new expression is called macroexpansion. Lisp "
"looks\n"
"up the definition of nil!, which shows how to construct a replacement for "
"the\n"
"macro call. The definition of nil! is applied like a function to the "
"expressions\n"
"given as arguments in the macro call. It returns a list of three elements: "
"setq,\n"
"the expression given as the argument to the macro, and nil. In this case, "
"the\n"
"argument to nil! is x, and the macroexpansion is (setq x nil)."
msgstr ""
"Шаг построения нового выражения называется расширением "
"макроса(macroexpansion). Лисп\n"
"смотрит на данное выше определение nil!, которое показывает как создать "
"замену для \n"
"вызова макроса. Определение nil! применяется как функция к выражениям "
"приведенным в \n"
"качестве аргументов в вызове макроса. Он(вызов) возвращает список из трех "
"элементов: \n"
"setq, выражение переданное в качестве аргумента макроса и  nil. В нашем "
"случае, аргумент\n"
"переданный в nil! это x, и расшерение макроса равно (setq x nil)."

#: texi/node-07.texi:81
msgid ""
"After macroexpansion comes a second step, evaluation. Lisp evaluates the\n"
"macroexpansion (setq x nil) as if you had typed that in the first place. "
"Evalu-\n"
"ation does not always come immediately after expansion, as it does at the "
"toplevel.\n"
"A macro call occurring in the definition of a function will be expanded when "
"the\n"
"function is compiled, but the expansion-or the object code which results "
"from\n"
"it-won't be evaluated until the function is called."
msgstr ""
"После расширения макроса наступает второй шаг, вычисление. Lisp вычисляет "
"расширение\n"
"макроса - (setq x nil) как если бы вы ввели его, а не вызов макроса. "
"Вычисление \n"
"не всегда происходит сразу после расширения, как это происходит на верхнем "
"уровне.\n"
"Вызов макроса, находящийся в определении функции будет расширен когда "
"функция\n"
"компилируется, но расширение - или объектный код, который получается из него "
"-\n"
"не будет вычисляться, до тех пор, пока функция не будет вызывана."

#: texi/node-07.texi:88
msgid ""
"Many of the difficulties you might encounter with macros can be avoided by\n"
"maintaining a sharp distinction between macroexpansion and evaluation. When\n"
"writing macros, know which computations are performed during "
"macroexpansion,\n"
"and which during evaluation, for the two steps generally operate on objects "
"of\n"
"two different sorts. The macroexpansion step deals with expressions, and "
"the\n"
"evaluation step deals with their values."
msgstr ""
"Многих трудностей связанных с макросами, с которыми вы можете столкнуться, "
"можно\n"
"избежать, поддежкой четкого разделения между расширением макроса и "
"вычислением.\n"
"Когда пишут макросы, знают какие вычисления выполняются во время "
"макрорасширения,\n"
"и какие во время выполнения, эти два шага обычно воздействуют на объекты "
"разных\n"
"сортов. Шаг расширения макроса касается выражений, и шаг вычисления касается "
"их\n"
"значений."

#: texi/node-07.texi:95
msgid ""
"Sometimes macroexpansion can be more complicated than it was in the case of\n"
"nil!. The expansion of nil! was a call to a built-in special form, but "
"sometimes\n"
"the expansion of a macro will be yet another macro call, like a Russian doll "
"which\n"
"contains another doll inside it. In such cases, macroexpansion simply "
"continues\n"
"until it arrives at an expression which is no longer a macro call. The "
"process can\n"
"take arbitrarily many steps, so long as it terminates eventually."
msgstr ""
"Иногда расширение макроса может быть более сложным, чем в случае nil!. "
"Расширение nil!\n"
"было вызовом встроенной специальной формы, но иногда расширение макроса "
"будет еще\n"
"одним вызовом макроса, как русская матрешка, которая содержит в себе еще "
"одну матрешку.\n"
"В таких случаях расширение макроса просто продолжается пока оно не достигнет "
"выражения,\n"
"которое не является вызовом макроса. Процесс может занять сколько угодно "
"шагов, пока \n"
"расширение не закончиться."

#: texi/node-07.texi:106
msgid ""
"Many languages offer some form of macro, but Lisp macros are singularly\n"
"powerful. When a file of Lisp is compiled, a parser reads the source code "
"and sends\n"
"its output to the compiler. Here's the stroke of genius: the output of the "
"parser\n"
"consists of lists of Lisp objects. With macros, we can manipulate the "
"program\n"
"while it's in this intermediate form between parser and compiler. If "
"necessary,\n"
"these manipulations can be very extensive. A macro generating its expansion "
"has\n"
"at its disposition the full power of Lisp. Indeed, a macro is really a Lisp "
"function-\n"
"one which happens to return expressions. The definition of nil! contains a "
"single\n"
"call to list, but another macro might invoke a whole subprogram to generate "
"its\n"
"expansion."
msgstr ""
"Многие языки предлагают некоторые формы макросов, на макросы Лиспа являются "
"необычайно\n"
"мощными. Когда файл Лиспа компилируется, парсер(разборщик синтаксических "
"выражений) читает\n"
"исходный код и отправляет его в компилятор. Вот гениальный штрих: вывод "
"парсера состоит\n"
"из списков объектов Лисп. С помощью макросов, мы можем манипулировать "
"программой, в то\n"
"время как она находиться в промежуточной форме, между парсером и "
"компилятором.\n"
"Если необходимо эти манипуляции могут быть очень обширными. Макрос, "
"генерирующий \n"
"расширение, обладает всеми возможностями Лисп. Действительно, макрос это "
"действительно\n"
"функция Лисп, та, которая возвращает выражения. Определение nil! содержит "
"один вызов\n"
"функции list, но другой макрос, может вызвать целую подпрограммму для "
"генерации\n"
"своего расширения."

#: texi/node-07.texi:110
msgid ""
"Being able to change what the compiler sees is almost like being able to "
"rewrite\n"
"it. We can add any construct to the language that we can define by "
"transformation\n"
"into existing constructs."
msgstr ""
"Возможность изменить то, что видит компилятор, почти как возможность "
"переписать этот\n"
"код. Мы можем добавить любую конструкцию к языку, которую мы можем "
"определить как\n"
"преобразование в существующие конструкции."

#: texi/node-07.texi:115
msgid ""
"@node 7-2 Backquote, 7-3 Defining Simple Macros, 7-1 How Macros Work, 7 "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-2 Backquote\n"
"@cindex 7-2 Backquote"
msgstr ""
"@node 7-2 Backquote, 7-3 Defining Simple Macros, 7-1 How Macros Work, 7 "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-2 Обратная кавычка\n"
"@cindex 7-2 Backquote"

#: texi/node-07.texi:119
msgid ""
"Backquote is a special version of quote which can be used to create "
"templates\n"
"for Lisp expressions. One of the most common uses of backquote is in macro\n"
"definitions."
msgstr ""
"Обратная кавычка(Backquote) это специальная версия кавычки(цитирования), "
"которую\n"
"можно использовать для создания шаблонов выражений Лисп. Одним из наиболее "
"распространенных\n"
"применений обратной кавычки, является определение макросов."

#: texi/node-07.texi:123
msgid ""
"The backquote character, `, is so named because it resembles a regular "
"quote,\n"
"', reversed. When backquote alone is affixed to an expression, it behaves "
"just like\n"
"quote:"
msgstr ""
"Символьный знак обратная кавычка(backquote), `, назван так потому, что он "
"напоминает\n"
"обычную кавычку, ', перевернутую наоброт. Когда к выражению добавляется одна "
"обратная\n"
"кавычка, она ведет себя точно также как и обычная кавычка:"

#: texi/node-07.texi:127
msgid ""
"@lisp\n"
"                         `(abc)is equal to '(abc).\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:132
msgid ""
"Backquote becomes useful only when it appears in combination with comma,\n"
",, and comma-at, ,@. If backquote makes a template, comma makes a slot "
"within\n"
"a template. A backquoted list is equivalent to a call to list with the "
"elements\n"
"quoted. That is,"
msgstr ""
"Обратная кавычка становиться полезной только тогда, когда она появляется в "
"сочетании\n"
"с запятой(,) и запятой с \"собакой\" (,@@). Если обратная кавычка создает "
"шаблон, запятая\n"
"создает слот внутри шаблона. Список с предшествующей обратной кавычке "
"эквивалентен вызову\n"
"команды list с  цитированными элементами(элементами в кавычках). То есть,"

#: texi/node-07.texi:136
msgid ""
"@lisp\n"
"                    `(a b c) is equal to (list 'a 'b 'c).\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:140
msgid ""
"Within the scope of a backquote, a comma tells Lisp: \"turn off the quoting."
"\"\n"
"When a comma appears before one of the elements of the list, it has the "
"effect of\n"
"cancelling out the quote that would have been put there. So"
msgstr ""
"В рамках обратной кавычки, знак запятой говорит Лиспу: \"здесь надо "
"отключить режим цитирования.\"\n"
"Когда перед одним из элементов списка появляется запятая, она имеет эффект "
"отмены его цитирования,\n"
"который был бы к нему применен. Так"

#: texi/node-07.texi:144
msgid ""
"@lisp\n"
"                 `(a ,b c ,d) is equal to (list 'a b 'c d).\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:147
msgid ""
"Instead of the symbol b, its value is inserted into the resulting list. "
"Commas work\n"
"no matter how deeply they appear within a nested list,"
msgstr ""
"Вместо символа b  в результирующий список  вставляется его ЗНАЧЕНИЕ. Запятые "
"работают\n"
"не зависимо от того как глубоко они появляются во вложенном списке,"

#: texi/node-07.texi:155
msgid ""
"@example\n"
"> (setq a1b2c3)\n"
"3> `(a ,b c)\n"
"(A2C)\n"
"> `(a (,b c))\n"
"(A (2 C))\n"
"@end example"
msgstr ""
"@example\n"
"> (setq a 1 b 2 c 3)\n"
"3> `(a ,b c)\n"
"(A 2 C)\n"
"> `(a (,b c))\n"
"(A (2 C))\n"
"@end example"

#: texi/node-07.texi:157
msgid "and they may even appear within quotes, or within quoted sublists:"
msgstr ""
"и они могут даже появляться после кавычки, или внутри цитированного "
"подсписка:"

#: texi/node-07.texi:162
msgid ""
"@example\n"
"> `(a b ,c (',(+ a b c)) (+ a b) 'c '((,a ,b)))\n"
"(A B 3 ('6) (+ A B) 'C '((1 2)))\n"
"@end example"
msgstr ""

#: texi/node-07.texi:172
msgid ""
"One comma counteracts the effect of one backquote, so commas must match\n"
"backquotes. Say that a comma is surrounded by a particular operator if the "
"operator\n"
"is prepended to the comma, or prepended to an expression which contains it. "
"In\n"
"`(,a ,(b `,c))), for example, the last comma is surrounded by one comma\n"
"and two backquotes. The general rule is: a comma surrounded by n commas "
"must\n"
"be surrounded by at least n+1 backquotes. An obvious corollary is that "
"commas\n"
"may not appear outside of a backquoted expression. Backquotes and commas "
"can\n"
"be nested, so long as they obey the rule above. Any of the following "
"expressions\n"
"would generate an error if typed into the toplevel:"
msgstr ""
"Одна запятая противодействует эффекту одной обратной кавычки, поэтому "
"запятые\n"
"должны соответствовать обратным кавычкам. Скажем, что запятая окружена "
"определенным\n"
"оператором, если оператор ставиться перед запятой или перед выражением, "
"которое её\n"
"содержит. Например, в `(,a ,(b `,c))), последняя запятая окружена одной "
"запятой и\n"
"двумя обратными кавычками. Общее правило таково: запятая окруженная n "
"запятыми должна\n"
"быть окружена минимум n+1 обратной кавычкой. Очевидным следствием является "
"то, что запятая\n"
"не может появляться за пределами выражений окруженных обратной кавычкой. "
"Обратные кавычки\n"
"и запятые могут быть вложенными, пока подчиняются правилу указанному выше. "
"Любое из  следующих\n"
"выражений сгенерирует ошибку, если его ввести на верхнем уровне:"

#: texi/node-07.texi:176
msgid ""
"@lisp\n"
"             ,x      `(a ,,b c)        `(a ,(b ,c) d)         `(,,`a)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:179
msgid ""
"Nested backquotes are only likely to be needed in macro-defining macros. "
"Both\n"
"topics are discussed in Chapter 16."
msgstr ""
"Вложенные обратные кавычки, вероятно понадобятся только в макросах, "
"определяющих макросы.\n"
"И то и другое обсуждается в главе 16."

#: texi/node-07.texi:187
msgid ""
"Backquote is usually used for making lists.@footnote{Backquote\n"
"can also be used to create vectors, but this is rarely done in macro\n"
"definitions.} Any list generated by backquote can also be generated by\n"
"using list and regular quotes. The advantage of backquote is just that\n"
"it makes expressions easier to read, because a backquoted expression\n"
"resembles the expression it will produce. In the previous section we\n"
"defined nil! as:"
msgstr ""
"Обратная кавычка используется для создания списков.@footnote{Обратная\n"
"кавычка также может использоваться для создания векторов, но это редко\n"
"делается в определениях макросов.} Любой список, сгенерированный обратной \n"
"кавычкой также  может быть сгенерирован с использвоанием list и обычных "
"кавычек. \n"
"Преимущество обратных кавычек заключается лишь в том, что она облегчает\n"
"чтение выражений, поскольку выражение которое цитирует обратная кавычка,\n"
"напоминает выражение, которое она создает. В предыдущем разделе мы "
"определили\n"
"nil! как:"

#: texi/node-07.texi:192
msgid ""
"@lisp\n"
"(defmacro nil! (var)\n"
"  (list 'setq var nil))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:194
msgid "With backquote the same macro can be defined as:"
msgstr "С помощью обратной кавычки тот же макрос может быть определен как:"

#: texi/node-07.texi:199
msgid ""
"@lisp\n"
"(defmacro nil! (var)\n"
"  `(setq ,var nil))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:204
msgid ""
"which in this case is not all that different. The longer the macro "
"definition,\n"
"however, the more important it is to use backquote. Figure 7-1 contains two\n"
"possible definitions of nif, a macro which does a three-way numeric\n"
"if. @footnote{This macro is defined a little oddly to avoid using gensyms. A "
"better definition is given on page 150.}"
msgstr ""
"которое в этом случае не так уж и отличается от предыдущего. Тем не менее, "
"чем длинне\n"
"определение  макроса, тем более важно использовать обратную кавычку. Рисунок "
"7-1 содержит\n"
"два возможных определения nif, макроса, который выполняет трехстороннее "
"числовое выражение\n"
"if. @footnote{Этот макрос определен немного коряво, чтобы избежать "
"использования gensyms. \n"
"Лучшее определение дано на странице 150.}"

#: texi/node-07.texi:208
msgid ""
"The first argument should evaluate to a number. Then the second, third, or\n"
"fourth argument is evaluated, depending on whether the first was positive, "
"zero,\n"
"or negative:"
msgstr ""
"Первый аргумент должен вычисляться как число. Второй, третий или четверый "
"аргументы\n"
"вычисляются, в зависимости от того, был ли первый аргумент положительным, "
"нулевым или\n"
"отритцательным:"

#: texi/node-07.texi:215
msgid ""
"@example\n"
"> (mapcar #'(lambda (x)\n"
"                     (nif x 'p 'z 'n))\n"
"                '(0 2-5 -8))\n"
"(ZPN)\n"
"@end example"
msgstr ""
"@example\n"
"> (mapcar #'(lambda (x)\n"
"                     (nif x 'p 'z 'n))\n"
"                '(0 2.5 -8))\n"
"(Z P N)\n"
"@end example"

#: texi/node-07.texi:217
msgid "With backquote:"
msgstr ""
"@cartouche\n"
"с использованием обратных кавычек:"

#: texi/node-07.texi:225
msgid ""
"@lisp\n"
" (defmacro nif (expr pos zero neg)\n"
"        `(case (truncate (signum ,expr))\n"
"             (1 ,pos)\n"
"             (0 ,zero)\n"
"             (-1 ,neg)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:227
msgid "Without backquote:"
msgstr "без обратной кавычки:"

#: texi/node-07.texi:236
msgid ""
"@lisp\n"
" (defmacro nif (expr pos zero neg)\n"
"        (list 'case\n"
"                 (list 'truncate (list 'signum expr))\n"
"                 (list 1 pos)\n"
"                 (list 0 zero)\n"
"                 (list -1 neg)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:238
msgid ""
"                 Figure 7-1: A macro defined with and without backquote."
msgstr ""
"                 Рисунок 7-1: Определение макроса с и без обратных кавычек.\n"
"@end cartouche"

#: texi/node-07.texi:243
msgid ""
"The two definitions in Figure 7-1 define the same macro, but the first uses\n"
"backquote, while the second builds its expansion by explicit calls to list. "
"From\n"
"the first definition it's easy to see that (nif x 'p 'z 'n), for example, "
"expands\n"
"into"
msgstr ""
"Два определения на рисунке 7-1 определяют один и тот же макрос, но первое "
"использует\n"
"обратные кавычки, в то время как второе строит свое расширение путем явных\n"
"вызовов команды list. Например, из первого определения легко уведить, что "
"(nif x 'p 'z 'n)\n"
"расширяется в"

#: texi/node-07.texi:250
msgid ""
"@lisp\n"
"(case (truncate (signum x))\n"
"      (1 'p)\n"
"      (0 'z)\n"
"      (-1 'n))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:254
msgid ""
"because the body of the macro definition looks just like the expansion it "
"generates.\n"
"To understand the second version, without backquote, you have to trace in "
"your\n"
"head the building of the expansion."
msgstr ""
"потому что тело определения макроса выглядит так же, как генерируемое им "
"расширение.\n"
"Чтобы понять вторую версию, без обратных кавычек, вы должны проследить в "
"своей голове\n"
"создаваемое расширение."

#: texi/node-07.texi:259
msgid ""
"Comma-at, ,@, is a variant of comma. It behaves like comma, with one\n"
"difference: instead of merely inserting the value of the expression to which "
"it\n"
"is affixed, as comma does, comma-at splices it. Splicing can be thought of "
"as\n"
"inserting while removing the outermost level of parentheses:"
msgstr ""
"Запятая с \"собакой\" - ,@@, это вариант запятой. Он ведет себя как запятая, "
"с одним\n"
"отличием: вместо того, чтобы просто вставить значение выражения, к которому "
"оно\n"
"прикрепляется, как это делает запятая, запятая с \"собакой\" вшивает этот "
"результат. \n"
"Вшивание можно рассматривать как вставку с удалением самого верхнего уровня "
"скобок:"

#: texi/node-07.texi:264
msgid ""
"@example\n"
"> (setq b '(1 2 3))\n"
"(123)\n"
"@end example"
msgstr ""
"@example\n"
"> (setq b '(1 2 3))\n"
"(1 2 3)\n"
"@end example"

#: texi/node-07.texi:268
msgid ""
"@lisp\n"
"> `(a ,b c)\n"
"(A (1 2 3) C)"
msgstr ""

#: texi/node-07.texi:272
msgid ""
"> `(a ,@@b c)\n"
"(A123C)\n"
"@end lisp"
msgstr ""
"> `(a ,@@b c)\n"
"(A 1 2 3 C)\n"
"@end lisp"

#: texi/node-07.texi:276
msgid ""
"The comma causes the list (123)to be inserted in place of b, while the "
"comma-\n"
"at causes the elements of the list to be inserted there. There are some "
"additional\n"
"restrictions on the use of comma-at:"
msgstr ""
"Запятя приводит к тому, что список (1 2 3) вставляется вместо  b, в то время "
"как\n"
"запятая с \"собакой\" вызывает вставку туда элементов списка. Есть некоторые "
"дополнительные\n"
"ограничения на использование запятой с \"собакой\":"

#: texi/node-07.texi:287
msgid ""
"@enumerate\n"
"@item\n"
"In order for its argument to be spliced, comma-at must occur within a\n"
"          sequence. It's an error to say something like @code{`,@@b} because "
"there is nowhere\n"
"          to splice the value of b.\n"
"@item\n"
"The object to be spliced must be a list, unless it occurs last. The "
"expression\n"
"          @code{`(a ,@@1)} will evaluate to @code{(a . 1)}, but attempting "
"to splice an atom into\n"
"          the middle of a list, as in @code{`(a ,@@1 b)}, will cause an "
"error.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Для того чтобы ее аргументы были \"вшиты\", запятая с \"собакой\" должна "
"быть включена в некоторую последовательность.\n"
"          Ошибочно написать, что то вроде @code{`,@@b}, потому, что не с чем "
"склеивать значение b.\n"
"@item\n"
"Объект, который должен быть \"вшит\", должен быть списком, если он не "
"является последним элементом. \n"
"          Выражение @code{`(a ,@@1)} будет вычислено в @code{(a . 1)}, но "
"попытка вшить атом в\n"
"          середину списка, как в @code{`(a ,@@1 b)}, вызовет ошибку.\n"
"@end enumerate"

#: texi/node-07.texi:294
msgid ""
"Comma-at tends to be used in macros which take an indeterminate number of\n"
"arguments and pass them on to functions or macros which also take an "
"indetermi-\n"
"nate number of arguments. This situation commonly arises when implementing\n"
"implicit blocks. Common Lisp has several operators for grouping code into "
"blocks,\n"
"including block, tagbody, and progn. These operators rarely appear directly "
"in\n"
"source code; they are more often implicit-that is, hidden by macros."
msgstr ""
"Запятая с \"собакой\" имеет тенденцию использоваться в макросах, которые "
"принимают\n"
"неопределенное число аргументов и передают их функциям или макросам, которые "
"также\n"
"принимают неопределенное количество аргументов. Такая ситуация обычно "
"возникает при\n"
"реализации неявных блоков. Common Lisp имеет несколько операторов для "
"группировки кода\n"
"в блоки, включая block, tagbody и  progn. Эти операторы редко появляются "
"непосредственно\n"
"в исходном коде; они чаще скрыты, т.е скрыты макросами."

#: texi/node-07.texi:298
msgid ""
"An implicit block occurs in any built-in macro which can have a body of\n"
"expressions. Both let and cond provide implicit progn, for example. The\n"
"simplest built-in macro to do so is probably when:"
msgstr ""
"Неявный block встречается в любом встроенном макросе, который может иметь\n"
"тело выражений. Например, и let, и cond предоставляют неявный progn. \n"
"Простейшим встроенным макросом использующим это вероятно является when:"

#: texi/node-07.texi:305
msgid ""
"@lisp\n"
"(when (eligible obj)\n"
"  (do-this)\n"
"  (do-that)\n"
"  obj)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:309
msgid ""
"If (eligible obj) returns true, the remaining expressions will be evaluated, "
"and\n"
"the when expression as a whole will return the value of the last. As an "
"example of\n"
"the use of comma-at, here is one possible definition for when:"
msgstr ""
"Если (eligible obj) возвращает истину, остальные выражения будут вычислены, "
"и\n"
"выражение when в целом. вернет значение последнего выражения. В качестве "
"примера\n"
"использования запятой с \"собакой\", вот одно из возможных определений для "
"when:"

#: texi/node-07.texi:316
msgid ""
"@lisp\n"
"(defmacro our-when (test &body body)\n"
"  `(if ,test\n"
"             (progn\n"
"                ,@@body)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defmacro our-when (test &body body)\n"
"  `(if ,test\n"
"       (progn\n"
"        ,@@body)))\n"
"@end lisp"

#: texi/node-07.texi:321
msgid ""
"This definition uses an &body parameter (identical to &rest except for its "
"effect\n"
"on pretty-printing) to take in an arbitrary number of arguments, and a comma-"
"at\n"
"to splice them into a progn expression. In the macroexpansion of the call "
"above,\n"
"the three expressions in the body will appear within a single progn:"
msgstr ""
"Это определение использует параметр &body (идентичный &rest за исключением "
"его эффекта\n"
"для красивой печати) чтобы принять произвольное количество аргументов, и "
"запятую с \"собакой\"\n"
"для \"вшивания\" их в выражение progn. При расширении макроса вызванного "
"выше, три выражения\n"
"тела появляются в пределах одного progn:"

#: texi/node-07.texi:328
msgid ""
"@lisp\n"
"(if (eligible obj)\n"
"       (progn (do-this)\n"
"                (do-that)\n"
"                obj))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:330
msgid "Most macros for iteration splice their arguments in a similar way."
msgstr ""
"Большинство макросов для итераций \"вшивают\" свои аргументы аналогичным "
"образом."

#: texi/node-07.texi:335
msgid ""
"The effect of comma-at can be achieved without using backquote. The ex-\n"
"pression @code{`(a ,@@b c)} is equal to (cons 'a (append b (list 'c))), for "
"ex-\n"
"ample. Comma-at exists only to make such expression-generating expressions\n"
"more readable."
msgstr ""
"Эффект запятой с \"собакой\" может быть достигнут без обратных кавычек. "
"Например,\n"
"выражение @code{`(a ,@@b c)} эквивалентно (cons 'a (append b (list 'c))). \n"
"Запятая с \"собакой\" используется только для того, чтобы сделать выражения "
"генерирующие\n"
"выражения более читабельными."

#: texi/node-07.texi:341
msgid ""
"Macro definitions (usually) generate lists. Although macro expansions could\n"
"be built with the function list, backquote list-templates make the task "
"much\n"
"easier. A macro defined with defmacro and backquote will superficially "
"resemble\n"
"a function defined with defun. So long as you are not misled by the "
"similarity,\n"
"backquote makes macro definitions both easier to write and easier to read."
msgstr ""
"Макро определения (обычно) генерируют списки. Хотя расширения макроса могут\n"
"быть построены с использованием функции list, цитированные с помощью "
"обратных\n"
"кавычек шаблоны списков делают эту задачу значительно легче. Определение "
"макросов\n"
"с помощью defmacro и обратных кавычек, будет внешне напоминать функцию "
"определенную\n"
"с помощью defun. Пока вы не введены в заблуждение этим подобием, обратные "
"кавычки\n"
"делают опредление макроса и более легкими для написания и более легкими для "
"чтения."

#: texi/node-07.texi:346
msgid ""
"Backquote is so often used in macro definitions that people sometimes think\n"
"of backquote as part of defmacro. The last thing to remember about backquote "
"is\n"
"that it has a life of its own, separate from its role in macros. You can use "
"backquote\n"
"anywhere sequences need to be built:"
msgstr ""
"Обратные кавычки, так часто используют в определениях макросов, что люди "
"иногда думают,\n"
"что обратные кавычки это часть defmacro. Последнее, что нужно помнить о "
"обратных кавычках,\n"
"это то, что у них есть собственная жизнь, отдельная от её роли в "
"определениях макросов.\n"
"Вы можете использовать обратную кавычку, где угдно, где необходимо строить \n"
"последовательности:"

#: texi/node-07.texi:351
msgid ""
"@lisp\n"
"(defun greet (name)\n"
"      `(hello ,name))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:356
msgid ""
"@node 7-3 Defining Simple Macros, 7-4 Testing Macroexpansion, 7-2 Backquote, "
"7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-3 Defining Simple Macros\n"
"@cindex 7-3 Defining Simple Macros"
msgstr ""
"@node 7-3 Defining Simple Macros, 7-4 Testing Macroexpansion, 7-2 Backquote, "
"7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-3 Определение Простых Макросов\n"
"@cindex 7-3 Defining Simple Macros"

#: texi/node-07.texi:362
msgid ""
"In programming, the best way to learn is often to begin experimenting as "
"soon\n"
"as possible. A full theoretical understanding can come later. Accordingly, "
"this\n"
"section presents a way to start writing macros immediately. It works only "
"for a\n"
"narrow range of cases, but where applicable it can be applied quite "
"mechanically.\n"
"(If you've written macros before, you may want to skip this section.)"
msgstr ""
"В программировании, зачастую, лучший способ научиться - начать "
"экспериментировать.\n"
"Полное теоретическое понимание может прийти позже. Соответственно, в этом "
"разделе\n"
"представлен способ немедленно начать писать макросы. Он работает только для "
"узкого\n"
"круга случаев, но там где он применим, его можно применять довольно "
"механически.\n"
"(Если вы уже писали макросы ранее, вы можете пропустить этот раздел.)"

#: texi/node-07.texi:366
msgid ""
"As an example, we consider how to write a variant of the the built-in "
"Common\n"
"Lisp function member. By default member uses eql to test for equality. If "
"you\n"
"want to test for membership using eq, you have to say so explicitly:"
msgstr ""
"В качестве примера, мы рассмотрим как написать вариант встроенной функции "
"Common\n"
"Lisp - member. По умолчанию функция member использует eql для проверки на "
"равенство.\n"
"Если вы хотите проверять членство используя eq, вы должны прямо сказать:"

#: texi/node-07.texi:370
msgid ""
"@lisp\n"
"(member x choices :test #'eq)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:373
msgid ""
"If we did this a lot, we might want to write a variant of member which "
"always used\n"
"eq. Some earlier dialects of Lisp had such a function, called memq:"
msgstr ""
"Если бы мы делем это много раз, мы могли бы написать вариант member который "
"всегда\n"
"использовал бы eq. В некоторых, более ранних диалектах Lisp быта такая "
"функция,\n"
"которая называлась memq:"

#: texi/node-07.texi:377
msgid ""
"@lisp\n"
"(memq x choices)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:380
msgid ""
"Ordinarily one would define memq as an inline function, but for the sake of "
"example\n"
"we will reincarnate it as a macro."
msgstr ""
"Обычно мы определяем memq как встраиваемую функцию, но для примера мы "
"перевоплотим\n"
"ее как макрос."

#: texi/node-07.texi:384
msgid ""
"@example\n"
"         call:                  (memq x choices)"
msgstr ""
"@cartouche\n"
"@example\n"
"         call:                  (memq x choices)"

#: texi/node-07.texi:387
msgid ""
"         expansion: (member x choices :test #'eq)\n"
"@end example"
msgstr ""

#: texi/node-07.texi:389
msgid "                       Figure 7-2: Diagram used in writing memq."
msgstr ""
"                       Рисунок 7-2: Диаграмма, используемая при написании "
"memq.\n"
"@end cartouche"

#: texi/node-07.texi:397
msgid ""
"The method: Begin with a typical call to the macro you want to define. "
"Write\n"
"it down on a piece of paper, and below it write down the expression into "
"which it\n"
"ought to expand. Figure 7-2 shows two such expressions. From the macro "
"call,\n"
"construct the parameter list for your macro, making up some parameter name "
"for\n"
"each of the arguments. In this case there are two arguments, so we'll have "
"two\n"
"parameters, and call them obj and lst:"
msgstr ""
"Методика написания макросов: Начните с типичного вызова макроса, который вы\n"
"хотите определить. Напишите его на листе бумаги, и ниже него запишите "
"выражение,\n"
"в которое он должен расширяться. Рисунок 7-2 показывает два таких "
"выражения.\n"
"Из вызова макроса, создайте список параметров для вашего макроса, придумав "
"некоторое\n"
"имя параметра для каждого из аргументов. В нашем случае есть два аргумента, "
"поэтому\n"
"у нас будет два параметра, и назовем их obj и lst:"

#: texi/node-07.texi:401
msgid ""
"@lisp\n"
"(defmacro memq (obj lst)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:410
msgid ""
"Now go back to the two expressions you wrote down. For each argument in the\n"
"macro call, draw a line connecting it with the place it appears in the "
"expansion\n"
"below. In Figure 7-2 there are two parallel lines. To write the body of the "
"macro,\n"
"turn your attention to the expansion. Start the body with a backquote. Now, "
"begin\n"
"reading the expansion expression by expression. Wherever you find a "
"parenthesis\n"
"that isn't part of an argument in the macro call, put one in the macro "
"definition.\n"
"So following the backquote will be a left parenthesis. For each expression "
"in the\n"
"expansion"
msgstr ""
"Теперь вернитесь к двум выражениям, которые вы записали ниже. Для каждого "
"аргумента в\n"
"вызове макроса, нарисуйте линию, соединяющую его с местом, где он появляется "
"в \n"
"расширении ниже. На рисунке 7-2 есть две параллельные линии. Чтобы написать "
"тело\n"
"макроса, обратите ваше внимание на расширение. Начните тело с обратной "
"кавычки. \n"
"Теперь, начнем чтение выражения расширения по одному выражению. Где бы вы ни "
"нашли\n"
"скобки, они не являются частью аргумента в вызове макроса, поместите "
"их(скобки) в \n"
"определение макроса, так чтобы за обратной кавычкой была левая скобка. \n"
"Для каждого выражения в расширении"

#: texi/node-07.texi:420
msgid ""
"@enumerate\n"
"@item\n"
"If there is no line connecting it with the macro call, then write down the\n"
"expression itself.\n"
"@item\n"
"If there is a connection to one of the arguments in the macro call, write\n"
"down the symbol which occurs in the corresponding position in the macro\n"
"parameter list, preceded by a comma.\n"
"?@@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Если нет линии соединяющей его с вызовом макроса, запишите это выражение\n"
"@item\n"
"Если есть соединение с одним из аргументов в вызове макроса, напишите далее\n"
"символ, который находитсья в соответствующей позиции списка параметров "
"макроса,\n"
"поставьте перед ним запятую.\n"
"@end enumerate"

#: texi/node-07.texi:422
msgid ""
"There is no connection to the first element, member, so we use member itself:"
msgstr ""
"Здесь нет связи с первым элементом, member, поэтому мы ипользуем само "
"название member:"

#: texi/node-07.texi:427
msgid ""
"@lisp\n"
"(defmacro memq (obj lst)\n"
"  `(member\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:430
msgid ""
"However, x has a line leading to the first argument in the source "
"expression, so we\n"
"use in the macro body the first parameter, with a comma:"
msgstr ""
"Тем не менее, x имеет линию, ведущую к первому аргументу в исходном "
"выражении, поэтому мы\n"
"используем в теле макроса первый параметр, с запятой:"

#: texi/node-07.texi:435
msgid ""
"@lisp\n"
"(defmacro memq (obj lst)\n"
"  `(member ,obj\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:437
msgid "Continuing in this way, the completed macro definition is:"
msgstr "Продолжая таким образом, завершаем определение макроса:"

#: texi/node-07.texi:443
msgid ""
"@lisp\n"
" (while hungry\n"
"       (stare-intently)\n"
"       (meow)\n"
"       (rub-against-legs))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (while hungry\n"
"       (stare-intently)\n"
"       (meow)\n"
"       (rub-against-legs))"

#: texi/node-07.texi:450
msgid ""
" (do ()\n"
"         ((not hungry))\n"
"       (stare-intently)\n"
"       (meow)\n"
"       (rub-against-legs))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:452
msgid "                      Figure 7-3: Diagram used in writing while."
msgstr ""
"                      Рисунок 7-3: Диаграмма используемая в написании "
"макроса while.\n"
"@end cartouche"

#: texi/node-07.texi:458
msgid ""
"@lisp\n"
"(defmacro memq (obj lst)\n"
"      `(member ,obj ,lst :test #'eq))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:464
msgid ""
"So far, we can only write macros which take a fixed number of arguments.\n"
"Now suppose we want to write a macro while, which will take a test "
"expression\n"
"and some body of code, and loop through the code as long as the test "
"expression\n"
"returns true. Figure 7-3 contains an example of a while loop describing the\n"
"behavior of a cat."
msgstr ""
"Пока что мы можем писать макросы, которые принимают фиксированное "
"количество\n"
"аргументов. Теперь предположим, что мы хотим написать макрос while, который "
"принимает\n"
"тестовое выражение и некоторое тело кода, и циклически проходит по "
"коду(выполняет его),\n"
"до тех пор пока тестовое выражение не возвратит истину. Рисунок 7-3 содержит "
"пример\n"
"цикла while описывающего поведение кошки."

#: texi/node-07.texi:469
msgid ""
"To write such a macro, we have to modify our technique slightly. As before,\n"
"begin by writing down a sample macro call. From that, build the parameter "
"list\n"
"of the macro, but where you want to take an indefinite number of arguments,\n"
"conclude with an &rest or &body parameter:"
msgstr ""
"Чтобы написать такой макрос, мы должны немного изменить нашу методику. Как и "
"прежде,\n"
"начнем с записи примера вызова макроса. Из него(вызова) построим список "
"параметров\n"
"макроса, но там где вы хотите принять неопределенное количество аргументов, "
"завершите\n"
"их параметром &rest или &body:"

#: texi/node-07.texi:473
msgid ""
"@lisp\n"
"(defmacro while (test &body body)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:479
msgid ""
"Now write the desired expansion below the macro call, and as before draw "
"lines\n"
"connecting the arguments in the macro call to their position in the "
"expansion.\n"
"However, when you have a sequence of arguments which are going to be sucked\n"
"into a single &rest or &body parameter, treat them as a group, drawing a "
"single\n"
"line for the whole sequence. Figure 7-3 shows the resulting diagram."
msgstr ""
"Теперь напишите нужное расширение под вызовом макроса, и как и раньше, "
"нарисуйте\n"
"линии соединяющие аргументы в вызове макроса с их позицией в расширении.\n"
"Тем не менее, когда у вас есть последовательность аргументов, которые будут "
"собраны\n"
"в один параметр &rest или &body, рассматривайте их как группу, рисуя одну "
"линию для\n"
"всей последовательности. Рисунок 7-3 показывает полученную диаграмму."

#: texi/node-07.texi:482
msgid ""
"To write the body of the macro definition, proceed as before along the "
"expan-\n"
"sion. As well as the two previous rules, we need one more:"
msgstr ""
"Чтобы написать тело определения макроса, продолжайте как и прежде идти вдоль "
"расширения.\n"
"Как и два предыдущих правила, нам нужно еще одно:"

#: texi/node-07.texi:489
msgid ""
"?@@enumerate\n"
"@item\n"
"3. If there is a connection from a series of expressions in the expansion to "
"a\n"
"         series of the arguments in the macro call, write down the "
"corresponding\n"
"         &rest or &body parameter, preceded by a comma-at.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
" Если есть связь из ряда выражений в расширении к ряду аргументов в вызове "
"макроса,\n"
"         запишите соответствующий параметр &rest или &body, поставив перед "
"ним запятую\n"
"         с \"собакой\".\n"
"@end enumerate"

#: texi/node-07.texi:491
msgid "So the resulting macro definition will be:"
msgstr "Таким образом, полученное определение макроса будет:"

#: texi/node-07.texi:498
msgid ""
"@lisp\n"
"(defmacro while (test &body body)\n"
"  `(do ()\n"
"            ((not ,test))\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:502
msgid ""
"To build a macro which can have a body of expressions, some parameter has "
"to\n"
"act as a funnel. Here multiple arguments in the macro call are joined "
"together into\n"
"body, and then broken up again when body is spliced into the expansion."
msgstr ""
"Чтобы построить макрос, который должен иметь тело выражения(body), некоторый "
"параметр\n"
"должен действовать как тунель. Здесь несколько аргументов в вызове макроса \n"
"объединяются в тело(body), а затем снова распадаются, когда тело(body) "
"\"вшивается\" в расширение."

#: texi/node-07.texi:508
msgid ""
"The approach described in this section enables us to write the simplest\n"
"macros-those which merely shuffle their parameters. Macros can do a lot\n"
"more than that. Section 7-7 will present examples where expansions can't be\n"
"represented as simple backquoted lists, and to generate them, macros become\n"
"programs in their own right."
msgstr ""
"Подход описанный в этом разделе, позволяет нам написать простейшие макросы "
"-\n"
"те, которые просто перетасовывают свои параметры. Макросы могут намного "
"больше\n"
"этого. Раздел 7-7 представит примеры, в которых расширения не могут быть "
"представлены\n"
"в виде простых списков с обратными кавычками, и генерирующие их макросы сами "
"по себе\n"
"становяться программами."

#: texi/node-07.texi:513
msgid ""
"@node 7-4 Testing Macroexpansion, 7-5 Destructuring in Parameter Lists, 7-3 "
"Defining Simple Macros, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-4 Testing Macroexpansion\n"
"@cindex 7-4 Testing Macroexpansion"
msgstr ""
"@node 7-4 Testing Macroexpansion, 7-5 Destructuring in Parameter Lists, 7-3 "
"Defining Simple Macros, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-4 Проверка Расширения Макросов\n"
"@cindex 7-4 Testing Macroexpansion"

#: texi/node-07.texi:517
msgid ""
"Having written a macro, how do we test it? A macro like memq is simple "
"enough\n"
"that one can tell just by looking at it what it will do. When writing more "
"compli-\n"
"cated macros, we have to be able to check that they are being expanded "
"correctly."
msgstr ""
"Имея написанный макрос, как мы можем его протестировать? Макрос типа memq "
"достаточно\n"
"прост, так что достаточно просто взглянув на него сказать что он будет "
"делать. При\n"
"написании более сложных макросов, мы должны быть в состоянии проверить, "
"правильно\n"
"ли они расширяются."

#: texi/node-07.texi:525
msgid ""
"Figure 7-4 shows a macro definition and two ways of looking at its "
"expansion.\n"
"The built-in function macroexpand takes an expression and returns its "
"macroex-\n"
"pansion. Sending a macro call to macroexpand shows how the macro call will\n"
"finally be expanded before being evaluated, but a complete expansion is not "
"al-\n"
"ways what you want in order to test a macro. When the macro in question "
"relies\n"
"on other macros, they too will be expanded, so a complete macroexpansion "
"can\n"
"sometimes be difficult to read."
msgstr ""
"На рисунке 7-4 показано определение макроса и два способа увидеть как он\n"
"расширяется. Встроенная функция macroexpand принимает выражение и "
"возвращает\n"
"его макро расширенние. Отправка вызова макроса в macroexpand показывает, "
"как\n"
"вызов макроса будет расширен до конца, перед его вычислением. Но\n"
"полное расширение, это не всегда то что вы хотите, чтобы проверить макрос.\n"
"Когда рассматриваемый макрос основывается на других макросах, они тоже "
"будут\n"
"расширены, поэтому полное расширение иногда может быть трудно прочитать."

#: texi/node-07.texi:532
msgid ""
"From the first expression shown in Figure 7-4, it's hard to tell whether or "
"not\n"
"while is expanding as intended, because the built-in do macro gets expanded, "
"as\n"
"well as the prog macro into which it expands. What we need is a way of "
"seeing\n"
"the result after only one step of expansion. This is the purpose of the "
"built-in\n"
"function macroexpand-1, shown in the second example; macroexpand-1 stops\n"
"after just one step, even if the expansion is still a macro call."
msgstr ""
"По первому выражению, показанному на Рисунке 7-4, трудно сказать, "
"действительно ли\n"
"while расширяется как задумано, потому что встроенный макрос do так же "
"расширяется.\n"
"так же как и макрос prog который тоже расширяется. Что нам нужно, так это "
"способ увидеть\n"
"результат только после одного шага расширения. Это цель встроенной функции "
"macroexpand-1, \n"
"показанной во втором примере; macroexpand-1 останавливается после всего лишь "
"одного шага,\n"
"даже если расширение все еще является результатом вызова макроса."

#: texi/node-07.texi:535
msgid ""
"When we want to look at the expansion of a macro call, it will be a "
"nuisance\n"
"always to have to type"
msgstr ""
"Когда мы хотим посмотреть на расширение вызова макроса, как бы нибыло "
"неприятно,\n"
"всегда нужно набирать"

#: texi/node-07.texi:539
msgid ""
"@lisp\n"
"(pprint (macroexpand-1 '(or x y)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:541
msgid "Figure 7-5 defines a new macro which allows us to say instead:"
msgstr ""
"Рисунок 7-5 определяет новый макрос, который вместо этого позволяет нам "
"сказать:"

#: texi/node-07.texi:545
msgid ""
"@lisp\n"
"(mac (or x y))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:548
msgid ""
"Typically you debug functions by calling them, and macros by expanding\n"
"them. But since a macro call involves two layers of computation, there are "
"two"
msgstr ""
"Обычно вы отлаживаете функции, вызывая их, а макросы - расширяя их. Но так "
"как\n"
"вызов макроса включает в себя два уровня вычислений, существует две"

#: texi/node-07.texi:555
msgid ""
"@example\n"
" > (defmacro while (test &body body)\n"
"          `(do ()\n"
"              ((not ,test))\n"
"            ,@@body))\n"
" WHILE"
msgstr ""
"@cartouche\n"
"@example\n"
" > (defmacro while (test &body body)\n"
"          `(do ()\n"
"              ((not ,test))\n"
"            ,@@body))\n"
" WHILE"

#: texi/node-07.texi:557
msgid " > (pprint (macroexpand '(while (able) (laugh))))"
msgstr ""

#: texi/node-07.texi:572
msgid ""
" (BLOCK NIL\n"
"      (LET NIL\n"
"          (TAGBODY\n"
"           #:G61\n"
"           (IF (NOT (ABLE)) (RETURN NIL))\n"
"           (LAUGH)\n"
"           (GO #:G61))))\n"
" T> (pprint (macroexpand-1 '(while (able) (laugh))))\n"
" (DO NIL\n"
"          ((NOT (ABLE)))\n"
"      (LAUGH))\n"
" T\n"
"@end example\n"
"                  Figure 7-4: A macro and two depths of expansion."
msgstr ""
" (BLOCK NIL\n"
"      (LET NIL\n"
"          (TAGBODY\n"
"           #:G61\n"
"           (IF (NOT (ABLE)) (RETURN NIL))\n"
"           (LAUGH)\n"
"           (GO #:G61))))\n"
" T> (pprint (macroexpand-1 '(while (able) (laugh))))\n"
" (DO NIL\n"
"          ((NOT (ABLE)))\n"
"      (LAUGH))\n"
" T\n"
"@end example\n"
"                  Рисунок 7-4: Макрос и две глубины его расширения.\n"
"@end cartouche"

#: texi/node-07.texi:577
msgid ""
"@lisp\n"
" (defmacro mac (expr)\n"
"      `(pprint (macroexpand-1 ',expr)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro mac (expr)\n"
"      `(pprint (macroexpand-1 ',expr)))\n"
"@end lisp"

#: texi/node-07.texi:579
msgid "                  Figure 7-5: A macro for testing macroexpansion."
msgstr ""
"                  Рисунок 7-5: Макрос для тестирования макрорасширения.\n"
"@end cartouche"

#: texi/node-07.texi:588
msgid ""
"points where things can go wrong. If a macro is misbehaving, most of the "
"time\n"
"you will be able to tell what's wrong just by looking at the expansion. "
"Sometimes,\n"
"though, the expansion will look fine and you'll want to evaluate it to see "
"where\n"
"the problems arise. If the expansion contains free variables, you may want "
"to set\n"
"some variables first. In some systems, you will be able to copy the "
"expansion and\n"
"paste it into the toplevel, or select it and choose eval from a menu. In the "
"worst\n"
"case you can set a variable to the list returned by macroexpand-1, then call "
"eval\n"
"on it:"
msgstr ""
"точки, где все может пойти не так. Если макрос работает не правильно, в "
"большинстве\n"
"случаев вы можете сказать, что что то не так, просто взглянув на расширение. "
"Тем не\n"
"менее, иногда, расширение будет выглядеть хорошо, и вы захотите вычислить "
"его, чтобы\n"
"увидеть, где возникают проблемы.  Если расширение содержит свободные "
"переменные, вы\n"
"можете сначала установить несколько переменных. В некоторых системах вы "
"можете\n"
"скопировать расширение и вставить его на верхний уровень REPL, или выделить "
"его и \n"
"выбрать команду eval из меню. В худшем случае, вы можете установить "
"переменную значением\n"
"списка возвращаемого из macroexpand-1, и затем вызвать eval для него:"

#: texi/node-07.texi:595
msgid ""
"@example\n"
"> (setq exp (macroexpand-1 '(memq 'a '(a b c))))\n"
"(MEMBER (QUOTE A) (QUOTE (A B C)) :TEST (FUNCTION EQ))\n"
"> (eval exp)\n"
"(ABC)\n"
"@end example"
msgstr ""
"@example\n"
"> (setq exp (macroexpand-1 '(memq 'a '(a b c))))\n"
"(MEMBER (QUOTE A) (QUOTE (A B C)) :TEST (FUNCTION EQ))\n"
"> (eval exp)\n"
"(A B C)\n"
"@end example"

#: texi/node-07.texi:600
msgid ""
"Finally, macroexpansion is more than an aid in debugging, it's also a way "
"of\n"
"learning how to write macros. Common Lisp has over a hundred macros built-"
"in,\n"
"some of them quite complex. By looking at the expansions of these macros "
"you\n"
"will often be able to see how they were written."
msgstr ""
"Наконец, расширение макросов это больше чем помощь в отладке, это еще один "
"путь\n"
"научиться писать макросы. Common Lisp имеет более сотни встроенных "
"макросов,\n"
"некоторые из них довольно сложные. Глядя на расширения этих макросов, вы "
"часто\n"
"будете в состоянии увидеть, как они были написаны."

#: texi/node-07.texi:605
msgid ""
"@node 7-5 Destructuring in Parameter Lists, 7-6 A Model of Macros, 7-4 "
"Testing Macroexpansion, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-5 Destructuring in Parameter Lists\n"
"@cindex 7-5 Destructuring in Parameter Lists"
msgstr ""
"@node 7-5 Destructuring in Parameter Lists, 7-6 A Model of Macros, 7-4 "
"Testing Macroexpansion, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-5 Деструктуризация в Списке Параметров\n"
"@cindex 7-5 Destructuring in Parameter Lists"

#: texi/node-07.texi:613
msgid ""
"Destructuring is a generalization of the sort of\n"
"assignment@footnote{Destructuring is usually seen in operators which\n"
"create bindings, rather than do assignments. However, conceptually\n"
"destructuring is a way of assigning values, and would work just as\n"
"well for existing variables as for new ones. That is, there is nothing\n"
"to stop you from writing a destructuring setq.} done by function\n"
"calls.  If you define a function of several arguments"
msgstr ""
"Деструктуризация это обобщенный вид присваивания@footnote{Деструктуризация "
"обычно наблюдается в операторах, которые создают привязки, а не выполняют "
"присваивание. Тем не менее,\n"
"концептуально, деструктуризация это способ присваивания значений, который\n"
"будет также работать как для существующих переменных, так и для новых. \n"
"Т.е ничто не мешает написать нам деструктуризацию setq.} выполняемого "
"вызовами\n"
"функций. Если вы определяете функцию от нескольких аргументов"

#: texi/node-07.texi:618
msgid ""
"@lisp\n"
"(defun foo (x y z)\n"
"   (+ x y z))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:620
msgid "then when the function is called"
msgstr "тогда, когда функция вызывается"

#: texi/node-07.texi:624
msgid ""
"@lisp\n"
"(foo 1 2 3)\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:629
msgid ""
"the parameters of the function are assigned arguments in the call according "
"to their\n"
"position: x to 1, y to 2, and z to 3. Destructuring describes the situation "
"where\n"
"this sort of positional assignment is done for arbitrary list structures, as "
"well as\n"
"flat lists like (xyz)."
msgstr ""
"параметрам функции присваиваются аргументы при вызове в соответствии с их "
"положением:\n"
"x значение 1, y значение 2, и z значение 3. Деструктуризация описывает "
"ситуацию, когда\n"
"такого рода позиционное присваивание выполняется для произвольных списковых "
"структур, а\n"
"также для плоских списков, таких как (x y z)."

#: texi/node-07.texi:634
msgid ""
"The Common Lisp destructuring-bind macro (new in CLTL2) takes a\n"
"pattern, an argument evaluating to a list, and a body of expressions, and "
"evaluates\n"
"the expressions with the parameters in the pattern bound to the "
"corresponding\n"
"elements of the list:"
msgstr ""
"Common Lisp макрос destructuring-bind (новый в CLTL2) принимает "
"образец(шаблон), аргумент\n"
"вычисляющийся в список, и тело выражений, и вычисляет выражения с "
"параметрами связанными\n"
"по образцу с соответствующими элементами списка:"

#: texi/node-07.texi:640
msgid ""
"@example\n"
"> (destructuring-bind (x (y) . z) '(a (b) c d)\n"
"         (list x y z))\n"
"(AB(CD))\n"
"@end example"
msgstr ""
"@example\n"
"> (destructuring-bind (x (y) . z) '(a (b) c d)\n"
"         (list x y z))\n"
"(A B (C D))\n"
"@end example"

#: texi/node-07.texi:642
msgid "This new operator and others like it form the subject of Chapter 18."
msgstr ""
"Этот новый оператор и другие, подобные ему, составляют предмет главы 18."

#: texi/node-07.texi:648
msgid ""
"Destructuring is also possible in macro parameter lists. The Common Lisp\n"
"defmacro allows parameter lists to be arbitrary list structures. When a "
"macro\n"
"call is expanded, components of the call will be assigned to the parameters "
"as if\n"
"by destructuring-bind. The built-in dolist macro takes advantage of such\n"
"parameter list destructuring. In a call like:"
msgstr ""
"Деструктуризация также возможна в списках параметров макроса. В Common Lisp\n"
"defmacro позволяет спискам параметров быть произвольными списковыми "
"структурами.\n"
"Когда вызов макроса расширяется, компоненты вызова будут присвоены "
"параметрам как\n"
"если бы использовался destructuring-bind. Встроенный макрос dolist "
"использует\n"
"преимущества такой деструктуризации списка параметров. В вызове, подобном:"

#: texi/node-07.texi:653
msgid ""
"@lisp\n"
"(dolist (x '(a b c))\n"
"      (print x))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:657
msgid ""
"the expansion function must pluck x and '(abc)from within the list given as\n"
"the first argument. That can be done implicitly by giving dolist the "
"appropriate\n"
"parameter list:@footnote{This version is written in this strange way to "
"avoid using gensyms, which are not introduced till later.}"
msgstr ""
"функция расширения должна \"вырвать\" x и '(a b c) из списка, заданного как "
"первый аргумент.\n"
"Это может быть сделано неявным образом, передавая dolist соответствующий "
"список параметров:\n"
"@footnote{Эта версия написана таким странным образом, чтобы избежать "
"использования gensyms, \n"
"который мы еще не ввели в употребление.}"

#: texi/node-07.texi:666
msgid ""
"@lisp\n"
"(defmacro our-dolist ((var list &optional result) &body body)\n"
"      `(progn\n"
"           (mapc #'(lambda (,var) ,@@body)\n"
"                    ,list)\n"
"           (let ((,var nil))\n"
"              ,result)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:674
msgid ""
"In Common Lisp, macros like dolist usually enclose within a list the "
"arguments\n"
"not part of the body. Because it takes an optional result argument, dolist\n"
"must enclose its first arguments in a distinct list anyway. But even if the "
"extra\n"
"list structure were not necessary, it would make calls to dolist easier to "
"read.\n"
"Suppose we want to define a macro when-bind, like when except that it binds\n"
"some variable to the value returned by the test expression. This macro may "
"be\n"
"best implemented with a nested parameter list:"
msgstr ""
"В Common Lisp, макросы подобные dolist обычно заключают в список "
"аргументы, \n"
"не являющиеся частью тела(вычисляемых выражений). Поскольку он принимает\n"
"не обязательный аргумент result, dolist в любом случае должен заключать "
"свои\n"
"первые аргументы в отдельный список. Но даже если дополнительная списковая "
"структура\n"
"не нужна, она облегчает чтение вызовов dolist.\n"
"Предположим, мы хотим определить макрос when-bind, такой как when за "
"исключением того, \n"
"что он привязывает некоторую переменную к значению возвращаемому тестовым "
"выражением. \n"
"Этот макрос может быть реализован с помощью вложенного списка параметров:"

#: texi/node-07.texi:681
msgid ""
"@lisp\n"
"(defmacro when-bind ((var expr) &body body)\n"
"      `(let ((,var ,expr))\n"
"           (when ,var\n"
"              ,@@body)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:683
msgid "and called as follows:"
msgstr "и вызывается следующим образом:"

#: texi/node-07.texi:688
msgid ""
"@lisp\n"
"(when-bind (input (get-user-input))\n"
"      (process input))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:690
msgid "instead of:"
msgstr "вместо:"

#: texi/node-07.texi:696
msgid ""
"@lisp\n"
"(let ((input (get-user-input)))\n"
"      (when input\n"
"          (process input)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:700
msgid ""
"Used sparingly, parameter list destructuring can result in clearer code. At "
"a\n"
"minimum, it can be used in macros like when-bind and dolist, which take two\n"
"or more arguments followed by a body of expressions."
msgstr ""
"При экономном использовании, деструктуризация списка параметров может "
"привести к\n"
"более ясному коду. Как минимум, ее можно использовать в макросах, таких "
"как \n"
"when-bind и dolist, которые принимают два или более аргументов, "
"сопровождаемых\n"
"телом - последовательностью выражений."

#: texi/node-07.texi:703
msgid ""
"@lisp\n"
" (defmacro our-expander (name) `(get ,name 'expander))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro our-expander (name) `(get ,name 'expander))"

#: texi/node-07.texi:713
msgid ""
" (defmacro our-defmacro (name parms &body body)\n"
"       (let ((g (gensym)))\n"
"          `(progn\n"
"              (setf (our-expander ',name)\n"
"                      #'(lambda (,g)\n"
"                            (block ,name\n"
"                              (destructuring-bind ,parms (cdr ,g)\n"
"                                ,@@body))))\n"
"              ',name)))"
msgstr ""

#: texi/node-07.texi:719
msgid ""
" (defun our-macroexpand-1 (expr)\n"
"       (if (and (consp expr) (our-expander (car expr)))\n"
"            (funcall (our-expander (car expr)) expr)\n"
"            expr))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:721
msgid "                           Figure 7-6: A sketch of defmacro."
msgstr ""
"                           Рисунок 7-6: Эскиз defmacro.\n"
"@end cartouche"

#: texi/node-07.texi:726
msgid ""
"@node 7-6 A Model of Macros, 7-7 Macros as Programs, 7-5 Destructuring in "
"Parameter Lists, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-6 A Model of Macros\n"
"@cindex 7-6 A Model of Macros"
msgstr ""
"@node 7-6 A Model of Macros, 7-7 Macros as Programs, 7-5 Destructuring in "
"Parameter Lists, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-6 Модель Макросов\n"
"@cindex 7-6 A Model of Macros"

#: texi/node-07.texi:731
msgid ""
"A formal description of what macros do would be long and confusing. "
"Experienced\n"
"programmers do not carry such a description in their heads anyway. It's "
"more\n"
"convenient to remember what defmacro does by imagining how it would be\n"
"defined."
msgstr ""
"Формальное описание того, что делают макросы, будет длинным и запутанным. "
"Опытный\n"
"программист все равно не хранит это описание в своей голове. Ему более\n"
"удобно помнить, что делает defmacro представляя как он будет определен."

#: texi/node-07.texi:737
msgid ""
"There is a long tradition of such explanations in Lisp. The Lisp 1.5 Pro-\n"
"grammer's Manual, first published in 1962, gives for reference a definition "
"of  \n"
"eval written in Lisp. Since defmacro is itself a macro, we can give it the "
"same\n"
"treatment, as in Figure 7-6. This definition uses several techniques which "
"haven't\n"
"been covered yet, so some readers may want to refer to it later."
msgstr ""
"В Лиспе существует давняя традиция подобных объяснений. Руководство по "
"программированию\n"
"для Lisp 1.5, впервые опубликованное в 1962 году, дает для справки "
"определение\n"
"eval написанного на Лиспе. Поскольку defmacro сам по себе является макросом, "
"мы можем\n"
"дать ему тоже самое определение как на Рисунке 7-6. Это определение "
"использует несколько\n"
"методов, которые еще не были рассмотрены, поэтому некоторые читатели, если "
"захотят,\n"
"могут обратитсья к нему позже."

#: texi/node-07.texi:746
msgid ""
"The definition in Figure 7-6 gives a fairly accurate impression of what "
"macros\n"
"do, but like any sketch it is incomplete. It wouldn't handle the &whole "
"keyword\n"
"properly. And what defmacro really stores as the macro-function of its "
"first\n"
"argument is a function of two arguments: the macro call, and the lexical "
"envi-\n"
"ronment in which it occurs. However, these features are used only by the "
"most\n"
"esoteric macros. If you worked on the assumption that macros were "
"implemented\n"
"as in Figure 7-6, you would hardly ever go wrong. Every macro defined in "
"this\n"
"book would work, for example."
msgstr ""
"Определение на рисунке 7-6 дает довольно точное представление о том, что "
"делает\n"
"макрос, но, как и любой набросок(эскиз) это представление неполное. Наше "
"определение\n"
"не будет должным образом обрабатывать ключевое слово &whole. И что на самом "
"деле\n"
"defmacro сохранается в как макро-функция своего первого аргумента - это \n"
"функция от двух аргументов: вызова макроса, и лексического окружения в "
"котором\n"
"происходит вызов. Тем не менее,  эти особенности используются в основном\n"
"в эзотерических макросах. Если вы будете работать в предположении, что "
"макросы\n"
"реализуются так как показано на рисунке 7-6, вы вряд ли ошибётесь. "
"Напримепр, \n"
"каждый макрос определенный в этой книге будет работать."

#: texi/node-07.texi:751
msgid ""
"The definition in Figure 7-6 yields an expansion function which is a sharp-\n"
"quoted lambda-expression. That should make it a closure: any free symbols in "
"the\n"
"macro definition should refer to variables in the environment where the "
"defmacro\n"
"occurred. So it should be possible to say this:"
msgstr ""
"Определение на рисунке 7-6 дает функцию расширения, которая является "
"закоментированным\n"
"кавычкой с решеткой('#) лямбда выражением. Это должно сделать ее замыканием: "
"любые \n"
"свободные символы в определении макроса должны ссылаться на переменные в "
"окружении,\n"
"где произошло определение макроса(вызов defmacro). Так что можно сказать "
"следующее:"

#: texi/node-07.texi:757
msgid ""
"@lisp\n"
"(let ((op 'setq))\n"
"      (defmacro our-setq (var val)\n"
"         (list op var val)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:761
msgid ""
"As of CLTL2, it is. But in CLTL1, macro expanders were defined in the null "
"lexical\n"
"environment,@footnote{For an example of macro where this distinction "
"matters, see the note on page 393.} so in some old implementations this "
"definition of our-setq will\n"
"not work."
msgstr ""
"Что касается CLTL2, это так. Но в CLTL1, расширители макросов определяются в "
"нулевом лексическом\n"
"окружении,@footnote{Для примера макроса, где это различие имеет значение, "
"смотри примечание на\n"
"стр. 393.} поэтому в некоторых старых реализациях, определение our-setq не "
"будет работать."

#: texi/node-07.texi:766
msgid ""
"@node 7-7 Macros as Programs, 7-8 Macro Style, 7-6 A Model of Macros, 7 "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-7 Macros as Programs\n"
"@cindex 7-7 Macros as Programs"
msgstr ""
"@node 7-7 Macros as Programs, 7-8 Macro Style, 7-6 A Model of Macros, 7 "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-7 Макросы как Программы\n"
"@cindex 7-7 Macros as Programs"

#: texi/node-07.texi:771
msgid ""
"A macro definition need not be just a backquoted list. A macro is a function "
"which\n"
"transforms one sort of expression into another. This function can call list "
"to\n"
"generate its result, but can just as well invoke a whole subprogram "
"consisting of\n"
"hundreds of lines of code."
msgstr ""
"Определение макроса не обязательно должно быть списком заключенным в "
"обратные кавычки.\n"
"Макрос это функция, которая превращает один вид выражений в другой. Эта "
"функция может\n"
"вызывать функцию list для создания своего результата, но может также "
"вызывать целую\n"
"подпрограмму, состоящую из сотен строк кода."

#: texi/node-07.texi:778
msgid ""
"Section 7-3 gave an easy way of writing macros. Using this technique we can\n"
"write macros whose expansions contain the same subexpressions as appear in "
"the\n"
"macro call. Unfortunately, only the simplest macros meet this condition. As "
"a\n"
"more complicated example, consider the built-in macro do. It isn't possible "
"to\n"
"write do as a macro which simply shuffles its parameters. The expansion has "
"to\n"
"build complex expressions which never appear in the macro call."
msgstr ""
"Раздел 7-3 представил простой способ написания макросов. Используя эту "
"методику, мы можем\n"
"писать макросы, чьи расширения содержат те же подвыражения, что и в вызове "
"макроса. \n"
"К сожалению, только самые простые макросы соответствуют этому условию. Как "
"более\n"
"сложный пример, рассмотрим встроенный макрос do. Невозможно написать do как "
"макрос,\n"
"который просто перетасовывает свои параметры. Расширение должно создавать "
"сложные\n"
"выражения, которые никогда не появляются в вызове макроса."

#: texi/node-07.texi:785
msgid ""
"The more general approach to writing macros is to think about the sort of\n"
"expression you want to be able to use, what you want it to expand into, and "
"then\n"
"write the program that will transform the first form into the second. Try "
"expanding\n"
"an example by hand, then look at what happens when one form is transformed "
"into\n"
"another. By working from examples you can get an idea of what will be "
"required\n"
"of your proposed macro."
msgstr ""
"Более общий подход к написанию макросов - думать о виде выражении, которое "
"вы хотите\n"
"использовать(первая форма), расширренном в то, что вы хотите получить(вторая "
"форма), \n"
"и затем написать программу, которая  преобразует первую форму во вторую. "
"Попробуйте\n"
"расширить пример от руки, а затем посмотрите, что происходит, когда одна "
"форма\n"
"превращается в другую. Работая на примерах, вы сможете получить "
"представление(идеи)\n"
"о том, что потребуется для реализации вашего макроса."

#: texi/node-07.texi:790
msgid ""
"Figure 7-7 shows an instance of do, and the expression into which it should\n"
"expand. Doing expansions by hand is a good way to clarify your ideas about "
"how\n"
"a macro should work. For example, it may not be obvious until one tries "
"writing\n"
"the expansion that the local variables will have to be updated using psetq."
msgstr ""
"На Рисунке 7-7 показан экземпляр do, и выражение в которое его следует "
"расширить.\n"
"Выполнение расширения в ручную - это хороший способ прояснить ваши идеи о "
"том, как\n"
"макрос должен работать. Например, это может быть не очевидно, пока не "
"попробуешь\n"
"написать расширение, что локальные переменные должны быть обновлены с "
"использванием\n"
"psetq."

#: texi/node-07.texi:795
msgid ""
"The built-in macro psetq (named for \"parallel setq\") behaves like setq,\n"
"except that all its (even-numbered) arguments will be evaluated before any "
"of the\n"
"assignments are made. If an ordinary setq has more than two arguments, then\n"
"the new value of the first argument is visible during the evaluation of the "
"fourth:"
msgstr ""
"Встроенный макрос psetq (называемый \"параллельный(parallel) setq\") ведет "
"себя как\n"
"setq, за исключением того, что все его (четные) аргументы будут вычислены до "
"любого\n"
"из выполняемых присвоений. Если обычный setq имеет более двух аргументов, то "
"новое\n"
"значение первого аргумента будет видно во время вычисления "
"последующих(например четвертого):"

#: texi/node-07.texi:805
msgid ""
"@lisp\n"
" (do ((w 3)\n"
"           (x 1 (1+ x))\n"
"           (y 2 (1+ y))\n"
"           (z))\n"
"         ((> x 10) (princ z) y)\n"
"       (princ x)\n"
"       (princ y))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (do ((w 3)\n"
"           (x 1 (1+ x))\n"
"           (y 2 (1+ y))\n"
"           (z))\n"
"         ((> x 10) (princ z) y)\n"
"       (princ x)\n"
"       (princ y))\n"
"@end lisp"

#: texi/node-07.texi:807
msgid "should expand into something like"
msgstr "должно быть расширено в нечто подобное:"

#: texi/node-07.texi:818
msgid ""
"@lisp\n"
" (prog ((w 3) (x 1) (y 2) (z nil))\n"
"        foo\n"
"         (if (> x 10)\n"
"               (return (progn (princ z) y)))\n"
"         (princ x)\n"
"         (princ y)\n"
"         (psetq x (1+ x) y (1+ y))\n"
"        (go foo))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:820
msgid "                         Figure 7-7: Desired expansion of do."
msgstr ""
"                         Рисунок 7-7: Желаемое расширение do.\n"
"@end cartouche"

#: texi/node-07.texi:827
msgid ""
"@example\n"
"> (let ((a 1))\n"
"        (setq a2ba)\n"
"        (list a b))\n"
"(2 2)\n"
"@end example"
msgstr ""
"@example\n"
"> (let ((a 1))\n"
"        (setq a 2 b a)\n"
"        (list a b))\n"
"(2 2)\n"
"@end example"

#: texi/node-07.texi:836
msgid ""
"Here, because a is set first, b gets its new value, 2.Apsetq is supposed to "
"behave\n"
"as if its arguments were assigned in parallel:\n"
"@example\n"
"> (let ((a 1))\n"
"        (psetq a 2 b a)\n"
"        (list a b))\n"
"(2 1)\n"
"@end example"
msgstr ""
"Здесь, поскольку a устанавливается первым, b получает новое значение, 2. "
"Предполагается\n"
"что psetq ведет себя как если бы все его аргументы присваиваются "
"параллельно:\n"
"@example\n"
"> (let ((a 1))\n"
"        (psetq a 2 b a)\n"
"        (list a b))\n"
"(2 1)\n"
"@end example"

#: texi/node-07.texi:840
msgid ""
"So here b gets the old value of a. The psetq macro is provided especially "
"to\n"
"support macros like do, which need to evaluate some of their arguments in "
"parallel.\n"
"(Had we used setq, we would have been defining do* instead.)"
msgstr ""
"Таким образом, здесь b получает старое значение a. Макрос psetq "
"предоставляется специально\n"
"для поддержки макросов, таких как  do, которые должны вычислять некоторые "
"свои аргументы\n"
"параллельно.\n"
"(Если бы мы использовали setq, мы бы в место этого определили do*.)"

#: texi/node-07.texi:846
msgid ""
"On looking at the expansion, it is also clear that we can't really use foo "
"as\n"
"the loop label. What if foo is also used as a loop label within the body of "
"the\n"
"do? Chapter 9 will deal with this problem in detail; for now, suffice it to "
"say that\n"
"instead of using foo, the macroexpansion must use a special anonymous "
"symbol\n"
"returned by the function gensym."
msgstr ""
"Глядя на расширение, также становитсья ясно, что мы не можем использовать "
"foo как\n"
"метку цикла(loop). Что если foo также используется как метка цикла(loop) в "
"теле\n"
"do? Глава 9 подробно рассматривает эту проблему; пока достаточно сказать, "
"что вместо\n"
"использования foo в макросе, расширение макроса должно использовать "
"специальный\n"
"анонимный символ возвращаемый функцией gensym."

#: texi/node-07.texi:857
msgid ""
"@lisp\n"
" (defmacro our-do (bindforms (test &rest result) &body body)\n"
"      (let ((label (gensym)))\n"
"        `(prog ,(make-initforms bindforms)\n"
"            ,label\n"
"            (if ,test\n"
"                 (return (progn ,@@result)))\n"
"            ,@@body\n"
"            (psetq ,@@(make-stepforms bindforms))\n"
"            (go ,label))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro our-do (bindforms (test &rest result) &body body)\n"
"      (let ((label (gensym)))\n"
"        `(prog ,(make-initforms bindforms)\n"
"            ,label\n"
"            (if ,test\n"
"                 (return (progn ,@@result)))\n"
"            ,@@body\n"
"            (psetq ,@@(make-stepforms bindforms))\n"
"            (go ,label))))"

#: texi/node-07.texi:864
msgid ""
" (defun make-initforms (bindforms)\n"
"      (mapcar #'(lambda (b)\n"
"                      (if (consp b)\n"
"                          (list (car b) (cadr b))\n"
"                          (list b nil)))\n"
"                bindforms))"
msgstr ""

#: texi/node-07.texi:872
msgid ""
" (defun make-stepforms (bindforms)\n"
"      (mapcan #'(lambda (b)\n"
"                      (if (and (consp b) (third b))\n"
"                          (list (car b) (third b))\n"
"                          nil))\n"
"                bindforms))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:874
msgid "                           Figure 7-8: Implementing do."
msgstr ""
"                           Рисунок 7-8: Реализация do.\n"
"@end cartouche"

#: texi/node-07.texi:885
msgid ""
"In order to write do, we consider what it would take to transform the first\n"
"expression in Figure 7-7 into the second. To perform such a transformation,\n"
"we need to do more than get the macro parameters into the right positions "
"in\n"
"some backquoted list. The initial prog has to be followed by a list of "
"symbols\n"
"and their initial bindings, which must be extracted from the second "
"argument\n"
"passed to the do. The function make-initforms in Figure 7-8 will return "
"such\n"
"a list. We also have to build a list of arguments for the psetq, but this "
"case is\n"
"more complicated because not all the symbols should be updated. In Figure "
"7-8,\n"
"make-stepforms returns arguments for the psetq. With these two functions,\n"
"the rest of the definition becomes fairly straightforward."
msgstr ""
"Чтобы написать do, мы рассмотрим, что потребуется для преобразования "
"первого\n"
"выражения на Рисунке 7-7 во второе. Чтобы выполнить такое преобразование,\n"
"на нужно сделать больше, чем просто получить и установить параметры макроса\n"
"в правильные позиции какого-то цитированного обратной кавычкой списка. За\n"
"начальным prog должен следовать список символов и их начальные привязки,\n"
"которые должны быть извлечены из второго аргумента переданного do. Функция\n"
"make-initforms на Рисунке 7-8 вернет такой список. Мы также должны "
"построить\n"
"список аргументов для psetq, но этот случай более сложный, потому что не "
"все \n"
"символы должны быть обновлены. На рисунке 7-8, make-stepforms возвращает \n"
"аргументы для psetq. С этими двумя функциями, остальная чать определения\n"
"становиться довольно простой."

#: texi/node-07.texi:890
msgid ""
"The code in Figure 7-8 isn't exactly the way do would be written in a\n"
"real implementation. To emphasize the computation done during expansion,\n"
"make-initforms and make-stepforms have been broken out as separate func-\n"
"tions. In the future, such code will usually be left within the defmacro "
"expression."
msgstr ""
"Код на рисунке 7-8 отличается от того, как написано в официапльной "
"реализации.\n"
"Чтобы подчеркнуть вычисления, сделанные во врмея расширения, make-initforms "
"и \n"
"make-stepforms былил разбиты на отдельные функции. В будущем, такой код "
"обычно\n"
"будет оставться в выражении defmacro."

#: texi/node-07.texi:894
msgid ""
"With the definition of this macro, we begin to see what macros can do. A\n"
"macro has full access to Lisp to build an expansion. The code used to "
"generate\n"
"the expansion may be a program in its own right."
msgstr ""
"С определением этого макроса, мы начинаем видеть, что могут делать "
"макросы. \n"
"Макрос имеет полный доступ к Lisp при построении расширения. Код "
"используемый\n"
"для рарширения может сам по себе быть программой."

#: texi/node-07.texi:899
msgid ""
"@node 7-8 Macro Style, 7-9 Dependence on Macros, 7-7 Macros as Programs, 7 "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-8 Macro Style\n"
"@cindex 7-8 Macro Style"
msgstr ""
"@node 7-8 Macro Style, 7-9 Dependence on Macros, 7-7 Macros as Programs, 7 "
"Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-8 Стиль Макросов\n"
"@cindex 7-8 Macro Style"

#: texi/node-07.texi:903
msgid ""
"Good style means something different for macros. Style matters when code is\n"
"either read by people or evaluated by Lisp. With macros, both of these "
"activities\n"
"take place under slightly unusual circumstances."
msgstr ""
"Хороший стиль означает нечто другое для макросов. Стиль имеет значени, когда "
"код\n"
"либо читается людьми, либо вычисляется Lisp. С макросами, оба эти действия "
"происходят\n"
"при немного необычных обстоятельствах."

#: texi/node-07.texi:911
msgid ""
"There are two different kinds of code associated with a macro definition: "
"ex-\n"
"pander code, the code used by the macro to generate its expansion, and "
"expansion\n"
"code, which appears in the expansion itself. The principles of style are "
"different\n"
"for each. For programs in general, to have good style is to be clear and "
"efficient.\n"
"These principles are bent in opposite directions by the two types of macro "
"code:\n"
"expander code can favor clarity over efficiency, and expansion code can "
"favor\n"
"efficiency over clarity."
msgstr ""
"Существует два различных вида кода, связанных с определением макроса: код \n"
"расширителя - это код используемый макросом для генерации своего расширения, "
"и\n"
"код расширения - это код, который появляется в самом расширении. Для каждого "
"из этих \n"
"типов кода принципы стиля разные. Для программы в целом, иметь хороший стиль "
"- \n"
"значит быть ясной и эффективной. Этот принцип изменяется в противоположных \n"
"направлениях в этих двух типах кода макроса: код расширителя может отдать "
"предпочтение \n"
"ясности над эффективностью, а код расширения может отдать предпочтение "
"эффективности над ясностью."

#: texi/node-07.texi:926
msgid ""
"It's in compiled code that efficiency counts most, and in compiled code the\n"
"macro calls have already been expanded. If the expander code was efficient, "
"it\n"
"made compilation go slightly faster, but it won't make any difference in how "
"well\n"
"the program runs. Since the expansion of macro calls tends to be only a "
"small part\n"
"of the work done by a compiler, macros which expand efficiently can't "
"usually\n"
"make much of a difference even in the compilation speed. So most of the "
"time\n"
"you can safely write expander code the way you would write a quick, first "
"version\n"
"of a program. If the expander code does unnecessary work or conses a lot, "
"so\n"
"what? Your time is better spent improving other parts of the program. "
"Certainly\n"
"if there's a choice between clarity and speed in expander code, clarity "
"should\n"
"prevail. Macro definitions are generally harder to read than function "
"definitions,\n"
"because they contain a mix of expressions evaluated at two different times. "
"If this\n"
"confusion can be reduced at the expense of efficiency in the expander code, "
"it's a\n"
"bargain."
msgstr ""
"Эффективность важнее всего в скомпилированном коде, и в компилированном "
"коде\n"
"вызовы макросов уже расширены. Если код расширителя был эффективен, его "
"компиляция\n"
"прошла бы немного быстрее, но это не повлияет на то, насколько хорошо "
"работает\n"
"программа. Поскольку расширение вызовов макросов, составляет лишь небольшую "
"часть\n"
"из работы, выполняемой компилятором, макросы которые расширяются эффективно, "
"обычно\n"
"не оказывают большого значения даже на скорость компиляции. Вы можете "
"безопасно \n"
"написать код расширителя способом наиболее быстрым, как и первую версию "
"программы.\n"
"Если расширитель кода делает ненужную работу или много тратит, ну и что? \n"
"Ваше время лучше потратить на улучшение других частей программы.  Конечно, "
"если в\n"
"коде расширителя есть выбор между ясностью и скоростью, выбрать ясность "
"предпочтительнее.\n"
"Определения макросов обычно тяжелее читать, чем определения функций, потому "
"что они содержат\n"
"смесь выражений, вычисляемых в различное время. Если эта путаница может быть "
"уменьшена за\n"
"счет уменьшения эффективности кода расширителя, это будет хорошим выбором."

#: texi/node-07.texi:937
msgid ""
"For example, suppose that we wanted to define a version of and as a macro.\n"
"Since (and a b c) is equivalent to (if a (if b c)), we can write and in\n"
"terms of if as in the first definition in Figure 7-9. According to the "
"standards by\n"
"which we judge ordinary code, our-and is badly written. The expander code "
"is\n"
"recursive, and on each recursion finds the length of successive cdrs of the "
"same\n"
"list. If this code were going to be evaluated at runtime, it would be better "
"to define\n"
"this macro as in our-andb, which generates the same expansion with no "
"wasted\n"
"effort. However, as a macro definition our-and is just as good, if not "
"better. It\n"
"may be inefficient in calling length on each recursion, but its organization "
"shows\n"
"more clearly the way in which the expansion depends on the number of "
"conjuncts."
msgstr ""
"Например, предположим, что нам нужна версия and реализованная как макрос.\n"
"Поскольку (and a b c) эквивалентно (if a (if b c)), мы можем написать and в "
"терминах\n"
"if как в первом определении на Рисунке 7-9. Согласно стандартам по которым "
"мы\n"
"судим об обычном коде, our-and написан плохо. Код расширителя рекурсивный, и "
"в\n"
"каждой рекурсии ищет длину последующих cdrs одного и того же списка. Если "
"этот\n"
"код будет вычисляться во время выполнения, было бы лучше определить этот "
"макрос\n"
"как в our-andb, который генерирует такое же расширение не тратя услий в "
"пустую.\n"
"Тем не менее, в качестве определения макроса our-and о очень хорош, если не "
"лучший.\n"
"Он может быть не эффективен по длительности вызова для каждой рекурсии, но "
"его \n"
"организация показывает более ясно, каким образом расширение зависит от "
"числа\n"
"коньюнктов(аргументов and)."

#: texi/node-07.texi:945
msgid ""
"@lisp\n"
" (defmacro our-and (&rest args)\n"
"       (case (length args)\n"
"         (0 t)\n"
"         (1 (car args))\n"
"         (t `(if ,(car args)\n"
"                    (our-and ,@@(cdr args))))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro our-and (&rest args)\n"
"       (case (length args)\n"
"         (0 t)\n"
"         (1 (car args))\n"
"         (t `(if ,(car args)\n"
"                  (our-and ,@@(cdr args))))))"

#: texi/node-07.texi:955
msgid ""
" (defmacro our-andb (&rest args)\n"
"       (if (null args)\n"
"            t(labels ((expander (rest)\n"
"                            (if (cdr rest)\n"
"                                `(if ,(car rest)\n"
"                                      ,(expander (cdr rest)))\n"
"                                (car rest))))\n"
"               (expander args))))\n"
"@end lisp"
msgstr ""
" (defmacro our-andb (&rest args)\n"
"       (if (null args)\n"
"            t\n"
"            (labels ((expander (rest)\n"
"                       (if (cdr rest)\n"
"                           `(if ,(car rest)\n"
"                                ,(expander (cdr rest)))\n"
"                           (car rest))))\n"
"               (expander args))))\n"
"@end lisp"

#: texi/node-07.texi:957
msgid "                      Figure 7-9: Two macros equivalent to and."
msgstr ""
"                      Рисунок 7-9: Два макроса, эквивалентных and.\n"
"@end cartouche"

#: texi/node-07.texi:967
msgid ""
"As always, there are exceptions. In Lisp, the distinction between compile-\n"
"time and runtime is an artificial one, so any rule which depends upon it is "
"likewise\n"
"artificial. In some programs, compile-time is runtime. If you're writing a "
"program\n"
"whose main purpose is transformation and which uses macros to do it, then\n"
"everything changes: the expander code becomes your program, and the "
"expansion\n"
"its output. Of course under such circumstances expander code should be "
"written\n"
"with efficiency in mind. However, it's safe to say that most expander code "
"(a) only\n"
"affects the speed of compilation, and (b) doesn't affect it very much-"
"meaning\n"
"that clarity should nearly always come first."
msgstr ""
"Как всегда, здесь есть исключения. В Лиспе, различие между временем "
"компиляции и\n"
"временем выполнения является искуственным, поэтому любое правило, которое "
"зависит от\n"
"него, также искуственно. В некоторых программах время компиляции является "
"временем\n"
"выполнения. Если вы пишете программу основной целью которой является "
"преобразование\n"
"и для этого используете макросы, все меняется: код расширителя становитсья "
"вашей\n"
"программой и расширение её выводом. Конечно, при таких обстоятельствах код "
"расширителя\n"
"должен быть написан с учетом эффективности. Тем не менее, можно с "
"уверенностью сказать,\n"
"что большинство расширителей кода (a) влияют только на сокрость компиляции, "
"и (b) не\n"
"сильно на него и влияют, т.е ясность почти всегда должна быть на первом "
"месте."

#: texi/node-07.texi:972
msgid ""
"With expansion code, it's just the opposite. Clarity matters less for macro\n"
"expansions because they are rarely looked at, especially by other people. "
"The\n"
"forbidden goto is not entirely forbidden in expansions, and the disparaged "
"setq\n"
"not quite so disparaged."
msgstr ""
"С кодом расширения все наоборот. Ясность менее важна для расширения макроса, "
"потому\n"
"что на нее редко смотрят, особенно другие люди.  Запрещенные goto не "
"полностью\n"
"запрещенн в расширениях, и пренебрегаемый setq не совсем так уж пренебрегаем."

#: texi/node-07.texi:981
msgid ""
"Proponents of structured programming disliked goto for what it did to "
"source\n"
"code. It was not machine language jump instructions that they considered\n"
"harmful-so long as they were hidden by more abstract constructs in source\n"
"code. Gotos are condemned in Lisp precisely because it's so easy to hide "
"them:\n"
"you can use do instead, and if you didn't have do, you could write it. Of "
"course,\n"
"if we're going to build new abstractions on top of goto, the goto is going "
"to have\n"
"to exist somewhere. Thus it is not necessarily bad style to use go in the "
"definition\n"
"of a new macro, if it can't be written in terms of some existing macro."
msgstr ""
"Сторонники структурного программирования не любили goto за то что он делал\n"
"с исходным кодом(а он превращал его в \"лапшу\"). Это были не инструкции "
"jump\n"
"машинного языка, которые они считали вредными - до тех пор пока они были\n"
"скрыты абстрактными конструкциями в исходном коде. Goto осуждены в Lisp "
"именно\n"
"потому, что их так легко спрятать: вместо них вы можете использовать  do, и "
"если\n"
"у вас его нет, вы можете написать его. Конечно, если мы собираемся создавать "
"новые\n"
"абстракции поверх goto, goto будет существовать. Таким образом, это не "
"обязательно\n"
"плохой стиль использовать go в определении нового макроса,  если его нельзя "
"написать\n"
"в терминах какого-либо существующего макроса."

#: texi/node-07.texi:987
msgid ""
"Similarly, setq is frowned upon because it makes it hard to see where a "
"given\n"
"variable gets its value. However, a macroexpansion is not going to be read "
"by\n"
"many people, so there is usually little harm in using setq on variables "
"created\n"
"within the macroexpansion. If you look at expansions of some of the built-"
"in\n"
"macros, you'll see quite a lot of setqs."
msgstr ""
"Точно так же использование setq не одобряется, потому что трудно увидеть, "
"где\n"
"данная переменная получает свое значение. Однако, расширение макроса не "
"будет\n"
"читаться многими людьми, поэтому обычно использование setq для создания "
"переменных\n"
"приносит мало вреда в рамках расширения макроса. Если вы посмотрите на "
"расширения\n"
"некоторых из встроенных макросов, вы можете увидеть довольно много setq."

#: texi/node-07.texi:996
msgid ""
"Several circumstances can make clarity more important in expansion code. If\n"
"you're writing a complicated macro, you may end up reading the expansions "
"after\n"
"all, at least while you're debugging it. Also, in simple macros, only a "
"backquote\n"
"separates expander code from expansion code, so if such macros generate "
"ugly\n"
"expansions, the ugliness will be all too visible in your source code. "
"However,\n"
"even when the clarity of expansion code becomes an issue, efficiency should "
"still\n"
"predominate. Efficiency is important in most runtime code. Two things make "
"it\n"
"especially so for macro expansions: their ubiquity and their invisibility."
msgstr ""
"Несколько обстоятельств могут сделать ясность более предпочтительной в "
"расширенном \n"
"коде генерируемым макросом. Если вы пишете сложный макрос, вы можете читать\n"
"расширение, по крайней мере пока, пока вы отлаживаете макрос. Кроме того, в "
"простых\n"
"макросах, только обратная кавычка разделяет расширяющий код от расширенного "
"кода, \n"
"поэтому если такие макросы генерируют не красивые расширения, его корявость "
"будет\n"
"слишком видна в вашем исходном коде. Тем не менее, даже когда ясность кода "
"расширения\n"
"становиться проблемой, эффективность все еще должна быть в приоритете. "
"Эффективность\n"
"важна в большинстве кода работающем во время выполнения. Две вещи делают это "
"особенно\n"
"важным для макро расширений: их повсеместность и невидимость."

#: texi/node-07.texi:1004
msgid ""
"Macros are often used to implement general-purpose utilities, which are "
"then\n"
"called everywhere in a program. Something used so often can't afford to be\n"
"inefficient. What looks like a harmless little macro could, after the "
"expansion\n"
"of all the calls to it, amount to a significant proportion of your program. "
"Such a\n"
"macro should receive more attention than its length would seem to demand. "
"Avoid\n"
"consing especially. A utility which conses unnecessarily can ruin the "
"performance\n"
"of an otherwise efficient program."
msgstr ""
"Макросы часто используются для реализации утилит общего назначения, которые\n"
"затем вызываются в программах везде. То что используется так часто, не "
"может\n"
"позволить себе быть неэффективным. То что похоже на безобидный маленький "
"макрос,\n"
"может после расширения всех обращений к нему составлять значительную часть "
"вашей\n"
"программы. Такой макрос должен получать больше внимания, чем казалось бы "
"требует\n"
"его длина. Особенно избегайте consing(создани ненужных, промежуточных "
"списков,\n"
"которые создаются но далее не используются). Утилита которая требует "
"ненужных усилий, \n"
"может испортить производительность программы, которя в противном случае была "
"бы\n"
"эффективной."

#: texi/node-07.texi:1010
msgid ""
"The other reason to look to the efficiency of expansion code is its very "
"invis-\n"
"ibility. If a function is badly implemented, it will proclaim this fact to "
"you every\n"
"time you look at its definition. Not so with macros. From a macro "
"definition,\n"
"inefficiency in the expansion code may not be evident, which is all the more "
"reason\n"
"to go looking for it."
msgstr ""
"Другая причина взглянуть на эффективность расширенного кода - это его "
"невидмость.\n"
"Если функция плохо реализована, это будет видно, каждый раз когда вы будет "
"смотреть\n"
"на ее определение. Но это не так с макросами. Из определения макроса, не "
"очевидна \n"
"не эффективность в расширенном коде, что является еще одной причиной "
"смотреть на него."

#: texi/node-07.texi:1015
msgid ""
"@node 7-9 Dependence on Macros, 7-10 Macros from Functions, 7-8 Macro Style, "
"7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-9 Dependence on Macros\n"
"@cindex 7-9 Dependence on Macros"
msgstr ""
"@node 7-9 Dependence on Macros, 7-10 Macros from Functions, 7-8 Macro Style, "
"7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-9 Зависимость от макросов\n"
"@cindex 7-9 Dependence on Macros"

#: texi/node-07.texi:1023
msgid ""
"If you redefine a function, other functions which call it will automatically "
"get the\n"
"new version.@footnote{Except functions compiled inline, which impose the "
"same restrictions on redefinition as macros.} The same doesn't always hold "
"for macros. A macro call which\n"
"occurs in a function definition gets replaced by its expansion when the "
"function\n"
"is compiled. What if we redefine the macro after the calling function has "
"been\n"
"compiled? Since no trace of the original macro call remains, the expansion "
"within\n"
"the function can't be updated. The behavior of the function will continue to "
"reflect\n"
"the old macro definition:"
msgstr ""
"Если вы переопределите функцию, другие функции, вызывающие ее, "
"автоматически\n"
"получат новую версию.@footnote{За исключение встраиваемых функций, которые\n"
"накладывают те же ограничения на переопределение, что и макросы.}  То же "
"самое\n"
"не всегда верно для макросов. Вызов макроса, который происходит в "
"опеделении\n"
"функции заменяется в ней его расширением, когда функция компилируется. Что "
"если \n"
"мы переопределим макрос после вызова компиляции функции? Поскольку не "
"осталось никаких\n"
"следов первоначального вызова макроса, расширени внутри функции не может "
"быть\n"
"обновлено. поведение функции будет отражать старое определние макоса:"

#: texi/node-07.texi:1028
msgid ""
"@example\n"
"> (defmacro mac (x) `(1+ ,x))\n"
"MAC\n"
"@end example"
msgstr ""

#: texi/node-07.texi:1037
msgid ""
"@example\n"
"> (setq fn (compile nil '(lambda (y) (mac y))))\n"
"#<Compiled-Function BF7E7E>\n"
"> (defmacro mac (x) `(+ ,x 100))\n"
"MAC\n"
"> (funcall fn 1)\n"
"2\n"
"@end example"
msgstr ""

#: texi/node-07.texi:1044
msgid ""
"Similar problems occur if code which calls some macro is compiled before\n"
"the macro itself is defined. CLTL2 says that \"a macro definition must be "
"seen\n"
"by the compiler before the first use of the macro.\" Implementations vary in "
"how\n"
"they respond to violations of this rule. Fortunately it's easy to avoid both "
"types\n"
"of problem. If you adhere to the following two principles, you need never "
"worry\n"
"about stale or nonexistent macro definitions:"
msgstr ""
"Подобные проблемы возникают, если код вызывающий некоторый макрос, "
"скомпилирован\n"
"раньше самого определения макроса. CLTL2 говорит, что \"определение макроса "
"должно\n"
"быть видно компилятором перед первым использованием макроса.\" Реализации по "
"разному\n"
"отвечают на нарушение этого правила.К счастью, легко избежать обоих типов "
"проблемы.\n"
"Если вы придерживаетесь следующих двух принципов, вам не нужно беспокоиться "
"о устаревших\n"
"или несуществующих определениях макросов:"

#: texi/node-07.texi:1052
msgid ""
"@enumerate\n"
"@item\n"
"     1. Define macros before functions (or macros) which call them.\n"
"@item\n"
"     2. When a macro is redefined, also recompile all the functions (or "
"macros)\n"
"         which call it-directly or via other macros.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"     Определяйте макросы перед функциями(или макросами), которые их "
"вызывают.\n"
"@item\n"
"     Когда макрос переопределен, также перекомпилируйте все функции(или "
"макросы)\n"
"которые вызывают его, напрямую или через другой макрос.\n"
"@end enumerate"

#: texi/node-07.texi:1058
msgid ""
"It has been suggested that all the macros in a program be put in a separate "
"file,\n"
"to make it easier to ensure that macro definitions are compiled first. "
"That's taking\n"
"things too far. It would be reasonable to put general-purpose macros like "
"while\n"
"into a separate file, but general-purpose utilities ought to be separated "
"from the\n"
"rest of a program anyway, whether they're functions or macros."
msgstr ""
"Было предложено поместить все макросы программы в отдельный файл, чтобы было "
"проще\n"
"убедиться, что определения макросов компилируются первыми. Т.е убрать их "
"подальше.\n"
"Разумно было бы ставить универсальные макросы, такие как  while в отдельный "
"файл, но\n"
"утилиты общего назначения должны быть отделены от остальной части программы "
"в любом\n"
"случае, будь то функции или макросы."

#: texi/node-07.texi:1064
msgid ""
"Some macros are written just for use in one specific part of a program, and\n"
"these should be defined with the code which uses them. So long as the "
"definition\n"
"of each macro appears before any calls to it, your programs will compile "
"fine.\n"
"Collecting together all your macros, simply because they're macros, would "
"do\n"
"nothing but make your code harder to read."
msgstr ""
"Некоторые макросы написаны только для использования в одной определенной "
"части\n"
"программы и они должны быть определены вместе с кодом, который их "
"использует.\n"
"Пока определение каждого макроса появляется перед любыми обращениями к "
"нему,\n"
"ваши программы скомпилируются нормально. Сбор всех ваших макросов, просто "
"потому\n"
"что они макросы, не будет делать ничего, кроме как уложнять чтение вашего "
"кода."

#: texi/node-07.texi:1069
msgid ""
"@node 7-10 Macros from Functions, 7-11 Symbol Macros, 7-9 Dependence on "
"Macros, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-10 Macros from Functions\n"
"@cindex 7-10 Macros from Functions"
msgstr ""
"@node 7-10 Macros from Functions, 7-11 Symbol Macros, 7-9 Dependence on "
"Macros, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-10 Макросы из функций\n"
"@cindex 7-10 Macros from Functions"

#: texi/node-07.texi:1073
msgid ""
"This section describes how to transform functions into macros. The first "
"step in\n"
"translating a function into a macro is to ask yourself if you really need to "
"do it.\n"
"Couldn't you just as well declare the function inline (p. 26)?"
msgstr ""
"В этом разделе описывается, как преобразовать функии в макросы. Первый шаг в "
"переводе\n"
"функции в макрос это спросить себя, нужно ли вам это делать. Не можете ли вы "
"с таким же\n"
"успехом объявить функцию встраиваемой(inline) (стр. 26)?"

#: texi/node-07.texi:1081
msgid ""
"There are some legitimate reasons to consider how to translate functions "
"into\n"
"macros, though. When you begin writing macros, it sometimes helps to think\n"
"as if you were writing a function-an approach that usually yields macros "
"which\n"
"aren't quite right, but which at least give you something to work from. "
"Another\n"
"reason to look at the relationship between macros and functions is to see "
"how they\n"
"differ. Finally, Lisp programmers sometimes actually want to convert "
"functions\n"
"into macros."
msgstr ""
"Однако, есть несколько законных причин для рассмотрения того, как перевести "
"функции в\n"
"макросы. Когда вы начинаете писать макросы, иногда помогает подход, думать "
"так, как если\n"
"бы вы писали функцию, который обычно дает не совсем правильные макросы, но\n"
"которые по крайней мере, дадут вам кое-что для начала работы. Другая причина "
"взглянуть\n"
"на связь между макросами и функциями, чтобы увидеть как они отличаются. "
"Наконец, \n"
"Lisp программисты иногда действительно хотят преобразовать функции в макросы."

#: texi/node-07.texi:1085
msgid ""
"The difficulty of translating a function into a macro depends on a number "
"of\n"
"properties of the function. The easiest class to translate are the functions "
"which"
msgstr ""
"Сложность перевода функции в макрос зависит от ряда свойств функции. Самый "
"простой класс\n"
"для перевода - это функции, которые"

#: texi/node-07.texi:1088
msgid ""
"@enumerate\n"
"@item"
msgstr "@enumerate"

#: texi/node-07.texi:1091
msgid ""
"   1. Have a body consisting of a single expression.\n"
"@item"
msgstr ""
"@item\n"
"   Имеют тело, состоящее из одного выражения"

#: texi/node-07.texi:1094
msgid ""
"   2. Have a parameter list consisting only of parameter names.\n"
"@item"
msgstr ""
"@item\n"
"     Имеют список параметров, состоящий только из имен параметров."

#: texi/node-07.texi:1097
msgid ""
"   3. Create no new variables (except the parameters).\n"
"@item"
msgstr ""
"@item\n"
"     Не создают новых переменных (кроме параметров).\n"

#: texi/node-07.texi:1100
msgid ""
"   4. Are not recursive (nor part of a mutually recursive group).\n"
"@item"
msgstr ""
"@item\n"
"     Не являются рекурсивными (и не являются частью взаимно рекурсивной "
"группы)."

#: texi/node-07.texi:1103
msgid ""
"   5. Have no parameter which occurs more than once in the body.\n"
"@item"
msgstr ""
"@item\n"
"     Не имеют параметров которые встречаются в теле более одного раза."

#: texi/node-07.texi:1107
msgid ""
"   6. Have no parameter whose value is used before that of another "
"parameter\n"
"        occurring before it in the parameter list.\n"
"@item"
msgstr ""
"@item\n"
"     Не имеют параметра, значение которого используется другим параметром\n"
"     стоящим перед ним в списке параметров."

#: texi/node-07.texi:1110
msgid ""
"   7. Contain no free variables.\n"
"@end enumerate"
msgstr ""
"@item\n"
"     Не содержат свободных переменных.\n"
"@end enumerate"

#: texi/node-07.texi:1113
msgid ""
"One function which meets these criteria is the built-in Common Lisp "
"function\n"
"second, which returns the second element of a list. It could be defined:"
msgstr ""
"Одной из функций, которая соответствует всем этим критериям, является "
"встроенная \n"
"функция Common Lisp second, которая возвращает второй элемент списка. Она "
"может быть\n"
"определена:"

#: texi/node-07.texi:1117
msgid ""
"@lisp\n"
"(defun second (x) (cadr x))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:1122
msgid ""
"Where a function definition meets all the conditions above, you\n"
"can easily transform it into an equivalent macro\n"
"definition. Simply put a backquote in front of the body and a\n"
"comma in front of each symbol which occurs in the parameter list:"
msgstr ""
"Если определение функции удовлетворяет всем вышеуказанным условиям,\n"
"вы можете легко преобразовать ее в эквивалентное определение макроса.\n"
"Просто поставьте обратную кавычку перед телом и запятую перед каждым \n"
"символом из списка параметров:"

#: texi/node-07.texi:1126
msgid ""
"@lisp\n"
"(defmacro second (x) `(cadr ,x))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:1132
msgid ""
"Of course, the macro can't be called under all the same conditions. It can't "
"be\n"
"given as the first argument to apply or funcall, and it should not be called "
"in\n"
"environments where the functions it calls have new local bindings. For "
"ordinary\n"
"in-line calls, though, the macro second should do the same thing as the "
"function\n"
"second."
msgstr ""
"Конечно, макрос нельзя вызывать при всех одинаковых обстоятельствах. Он не "
"может\n"
"быть доступен в качестве первого аргумента для apply или funcall, и его не \n"
"следует вызывать в окружении, где вызываемые им функции имеют новые "
"локальные \n"
"привязки. Хотя, для обычных встраиваемых вызовов, макрос second должен "
"выполнять\n"
"тоже самое, что и функция second."

#: texi/node-07.texi:1136
msgid ""
"The technique changes slightly when the body has more than one expression,\n"
"because a macro must expand into a single expression. So if condition 1 "
"doesn't\n"
"hold, you have to add a progn. The function noisy-second:"
msgstr ""
"Техника немного меняетя когда тело имеет более одного выражения, потому что "
"макрос\n"
"должен расширяться в одно выражение, так что если условие 1 не выполняется, "
"вы\n"
"должны добавить команду progn. Функция noisy-second:"

#: texi/node-07.texi:1141
msgid ""
"@lisp\n"
"(defun noisy-second (x)\n"
"  (princ \"Someone is taking a cadr!\")\n"
"  (cadr x))"
msgstr ""

#: texi/node-07.texi:1148
msgid ""
"could be duplicated by the following macro:\n"
"(defmacro noisy-second (x)\n"
"  `(progn\n"
"        (princ \"Someone is taking a cadr!\")\n"
"        (cadr ,x)))\n"
"@end lisp"
msgstr ""
"может быть продублирована следующим макросом:\n"
"(defmacro noisy-second (x)\n"
"  `(progn\n"
"        (princ \"Someone is taking a cadr!\")\n"
"        (cadr ,x)))\n"
"@end lisp"

#: texi/node-07.texi:1152
msgid ""
"When the function doesn't meet condition 2 because it has an &rest or &body\n"
"parameter, the rules are the same, except that the parameter, instead of "
"simply\n"
"having a comma before it, must be spliced into a call to list. Thus"
msgstr ""
"Когда функция не соответствует условию  2 потому что она имеет параметр "
"&rest \n"
"или &body, правила теже, за исключением того, что этот параметр, а не "
"просто\n"
"запятая перед ним, должен быть \"вшит\" в вызов команды list. Таким образом"

#: texi/node-07.texi:1157
msgid ""
"@lisp\n"
"(defun sum (&rest args)\n"
"  (apply #'+ args))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:1159
msgid "becomes"
msgstr "становиться"

#: texi/node-07.texi:1164
msgid ""
"@lisp\n"
"(defmacro sum (&rest args)\n"
"  `(apply #'+ (list ,@@args)))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:1166
msgid "which in this case would be better rewritten:"
msgstr "который в этом случае будет лучше переписать как:"

#: texi/node-07.texi:1171
msgid ""
"@lisp\n"
"(defmacro sum (&rest args)\n"
"  `(+ ,@@args))\n"
"@end lisp"
msgstr ""

#: texi/node-07.texi:1176
msgid ""
"When condition 3 doesn't hold-when new variables are created within the\n"
"function body-the rule about the insertion of commas must be modified. "
"Instead\n"
"of putting commas before all symbols in the parameter list, we only put "
"them\n"
"before those which will refer to the parameters. For example, in:"
msgstr ""
"Когда условие 3 не выполняется - когда новые переменные создаются в  теле "
"функции\n"
"- правило о вставке запятых должно быть изменено. Вместо вставки запятых "
"перед всеми\n"
"символами в списке параметров, мы ставим их до тех пор, пока переменные "
"сслылаются на\n"
"эти параметры. Например, в:"

#: texi/node-07.texi:1182
msgid ""
"@lisp\n"
"(defun foo (x y z)\n"
"  (list x (let ((x y))\n"
"                  (list x z))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun foo (x y z)\n"
"  (list x (let ((x y))\n"
"            (list x z))))\n"
"@end lisp"

#: texi/node-07.texi:1186
msgid ""
"neither of the last two instances of x will refer to the parameter x. The "
"second\n"
"instance is not evaluated at all, and the third instance refers to a new "
"variable\n"
"established by the let. So only the first instance will get a comma:"
msgstr ""
"ни один из последующих двух эземпляров x не ссылается на параметр x. Второй "
"экземпляр x\n"
"не вычисляется вообще(он стоит в let), и третий экземпляр ссылается на новую "
"переменную установленную let. Так что только первый экземпляр x получит "
"запятую:"

#: texi/node-07.texi:1192
msgid ""
"@lisp\n"
"(defmacro foo (x y z)\n"
"  `(list ,x (let ((x ,y))\n"
"                     (list x ,z))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defmacro foo (x y z)\n"
"  `(list ,x (let ((x ,y))\n"
"              (list x ,z))))\n"
"@end lisp"

#: texi/node-07.texi:1197
msgid ""
"Functions can sometimes be transformed into macros when conditions 4, 5 and\n"
"6 don't hold. However, these topics are treated separately in later "
"chapters. The\n"
"issue of recursion in macros is covered in Section 10-4, and the dangers of "
"multiple\n"
"and misordered evaluation in Sections 10-1 and 10-2, respectively."
msgstr ""
"Функции иногда могут быть преобразованы в макросы когда условия 4, 5 и 6 не "
"выполнены. \n"
"Тем не менее, эти темы рассматриваются в последующих главах отдельно. "
"Проблема рекурсии\n"
"в макросах рассматривается в Разделе 10-4, и опасность множественных и "
"неправильных(неупорядоченных)\n"
"вычислений в разделе 10-1  и 10-2, соответственно."

#: texi/node-07.texi:1201
msgid ""
"As for condition 7, it is possible to simulate closures with macros, using "
"a\n"
"technique similar to the error described on page 37. But seeing as this is a "
"low\n"
"hack, not consonant with the genteel tone of this book, we shall not go into "
"details."
msgstr ""
"Что касается условия 7, то можно моделировать замыкания с помощью макросов, "
"используя\n"
"технику похожую на ошибку описанную в (@xref{page-037,,Ошибка изменяющая "
"список внутри функции}). Но учитывая что это низкоуровевый хак, не созвучный "
"с основным тоном этой книги, мы не будем вдаваться в подробности."

#: texi/node-07.texi:1206
msgid ""
"@node 7-11 Symbol Macros,  , 7-10 Macros from Functions, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-11 Symbol Macros\n"
"@cindex 7-11 Symbol Macros"
msgstr ""
"@node 7-11 Symbol Macros,  , 7-10 Macros from Functions, 7 Macros\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 7-11 Макросы Символы\n"
"@cindex 7-11 Symbol Macros"

#: texi/node-07.texi:1210
msgid ""
"CLTL2 introduced a new kind of macro into Common Lisp, the symbol-macro.\n"
"While a normal macro call looks like a function call, a symbol-macro \"call"
"\" looks\n"
"like a symbol."
msgstr ""
"CLTL2 ввел новый тип макросов в Common Lisp, это макрос-символ(symbol-"
"macro).\n"
"В то время как обычный вызов макроса выглядит как вызов функции, \"вызов\" \n"
"макроса-символа выглядит как символ."

#: texi/node-07.texi:1213
msgid ""
"Symbol-macros can only be locally defined. The symbol-macrolet special\n"
"form can, within its body, cause a lone symbol to behave like an expression:"
msgstr ""
"Макрос-символ может быть определен только локально. Специальная форма symbol-"
"macrolet\n"
"внутри своего тела может заставить одиночный символ вести себя как выражение:"

#: texi/node-07.texi:1221
msgid ""
"@example\n"
"> (symbol-macrolet ((hi (progn (print \"Howdy\")\n"
"                                         1)))\n"
"        (+ hi 2))\n"
"\"Howdy\"\n"
"3\n"
"@end example"
msgstr ""

#: texi/node-07.texi:1224
msgid ""
"The body of the symbol-macrolet will be evaluated as if every hi in "
"argument\n"
"position had been replaced with (progn (print \"Howdy\") 1)."
msgstr ""
"Тело symbol-macrolet будет вычисляться так, как будто каждый аргумент в "
"позции hi\n"
"будет заменен на (progn (print \"Howdy\") 1)."

#: texi/node-07.texi:1229
msgid ""
"Conceptually, symbol-macros are like macros that don't take any arguments.\n"
"With no arguments, macros become simply textual abbreviations. This is not "
"to say\n"
"that symbol-macros are useless, however. They are used in Chapter 15 (page "
"205)\n"
"and Chapter 18 (page 237), and in the latter instance they are indispensable."
msgstr ""
"Концептуально, макросы символы похожи на макросы, которые не принимают "
"никаких аргументов.\n"
"Без аргументов, макросы становятся просто текстовыми сокращениями. Однако, "
"это не говорит\n"
"что макросы символы бесполезны. Они используются  (@xref{15-2 Recursion on "
"Cdrs,,Глава 15}) \n"
"и (@xref{18-3 Reference,,Глава 18}), и в последнем случае они не заменимы."
