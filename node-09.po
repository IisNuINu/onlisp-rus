#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-09.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-07-03 12:48+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-09.texi:5
msgid ""
"@node 9 Variable Capture, 10 Other Macro Pitfalls, 8 When to Use Macros, "
"Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 9 Variable Capture\n"
"@cindex 9 Variable Capture"
msgstr ""
"@node 9 Variable Capture, 10 Other Macro Pitfalls, 8 When to Use Macros, "
"Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 9 Захват Переменных\n"
"@cindex 9 Variable Capture"

#: texi/node-09.texi:12
msgid ""
"Macros are vulnerable to a problem called variable capture. Variable "
"capture\n"
"occurs when macroexpansion causes a name clash: when some symbol ends up\n"
"referring to a variable from another context. Inadvertent variable capture "
"can\n"
"cause extremely subtle bugs. This chapter is about how to foresee and avoid\n"
"them. However, intentional variable capture is a useful programming "
"technique,\n"
"and Chapter 14 is full of macros which rely on it."
msgstr ""
"Макрос уязвимы для проблемы, называемой захватом переменных. Захват "
"переменной\n"
"происходит когда расширение макроса вызывает конфликт имен: когда какой то "
"символ\n"
"заканчивается ссылкой на переменную из другого контекста. Случайный захват "
"переменной\n"
"может вызвать трудно уловимые ошибки. Эта глава о том, как предвидеть и "
"избежать их.\n"
"Тем не менее, преднамеренный захват переменных является полезным методом "
"программирования,\n"
"и глава 14 полна макросов, которые полагаются на него."

#: texi/node-09.texi:24
msgid ""
"@menu\n"
"* 9-1 Macro Argument Capture::  \n"
"* 9-2 Free Symbol Capture::     \n"
"* 9-3 When Capture Occurs::     \n"
"* 9-4 Avoiding Capture with Better Names::  \n"
"* 9-5 Avoiding Capture by Prior Evaluation::  \n"
"* 9-6 Avoiding Capture with Gensyms::  \n"
"* 9-7 Avoiding Capture with Packages::  \n"
"* 9-8 Capture in Other Name-Spaces::  \n"
"* 9-9 Why Bother?::             \n"
"@end menu"
msgstr ""

#: texi/node-09.texi:29
msgid ""
"@node 9-1 Macro Argument Capture, 9-2 Free Symbol Capture, 9 Variable "
"Capture, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-1 Macro Argument Capture\n"
"@cindex 9-1 Macro Argument Capture"
msgstr ""
"@node 9-1 Macro Argument Capture, 9-2 Free Symbol Capture, 9 Variable "
"Capture, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-1 Захват Аргумента Макроса\n"
"@cindex 9-1 Macro Argument Capture"

#: texi/node-09.texi:37
msgid ""
"A macro vulnerable to unintended variable capture is a macro with a bug. To "
"avoid\n"
"writing such macros, we must know precisely when capture can occur. "
"Instances\n"
"of variable capture can be traced to one of two situations: macro argument "
"capture\n"
"and free symbol capture. In argument capture, a symbol passed as an argument "
"in\n"
"the macro call inadvertentlyrefers to a variable established by the macro "
"expansion\n"
"itself. Consider the following definition of the macro for, which iterates "
"over a\n"
"body of expressions like a Pascal for loop:"
msgstr ""
"Макрос уязвимый к непреднамеренному захвату переменных, является макросом с "
"ошибкой. \n"
"Чтобы избежать написания такого макроса, мы должны точно знать, когда может "
"произойти\n"
"захват. Отдельные случаи захвата переменной можно отнести к одной из двух "
"ситуаций:\n"
"захват аргумента макроса и захват свободного символа. При захвате аргумента, "
"символ\n"
"передаваемый как аргумент в вызов макроса непреднамеренно ссылается на "
"переменную,\n"
"установленную расширением самого макроса. Рассмотрим следующее определение "
"макроса for,\n"
"который выполняет итерации для выражений body подобно циклу в for в языке "
"Pascal:"

#: texi/node-09.texi:45
msgid ""
"@lisp\n"
"(defmacro for ((var start stop) &body body)                              ; "
"wrong\n"
"  `(do ((,var ,start (1+ ,var))\n"
"          (limit ,stop))\n"
"         ((> ,var limit))\n"
"      ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:47
msgid "This macro looks correct at first sight. It even seems to work fine:"
msgstr ""
"На первый взгляд этот макрос выглядит правильно. Кажеться он работает "
"нормально:"

#: texi/node-09.texi:54
msgid ""
"@example\n"
"> (for (x 1 5)\n"
"        (princ x))\n"
"12345\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-09.texi:57
msgid ""
"Indeed, the error is so subtle that we might use this version of the macro "
"hundreds\n"
"of times and have it always work perfectly. Not if we call it this way, "
"though:"
msgstr ""
"Действительно, ошибка настолько неуловима, что мы можем использовать эту "
"версию\n"
"макроса сотни раз, и он всегда будет работать отлично. Однако если мы "
"вызовем\n"
"этот макрос так:"

#: texi/node-09.texi:62
msgctxt "texi/node-09.texi:62"
msgid ""
"@lisp\n"
"(for (limit 1 5)\n"
"  (princ limit))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:65
msgid ""
"We might expect this expression to have the same effect as the one before. "
"But it\n"
"doesn't print anything; it generates an error. To see why, we look at its "
"expansion:"
msgstr ""
"Мы ожидаем, что это выражение будет иметь тот же эффект, что и раньше. Но "
"оно ничего\n"
"не печатает; оно генерирует ошибку. Чтобы понять почему оно не работает, "
"надо посмотреть\n"
"на его расширение:"

#: texi/node-09.texi:72
msgid ""
"@lisp\n"
"(do ((limit 1 (1+ limit))\n"
"         (limit 5))\n"
"        ((> limit limit))\n"
"  (princ limit))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:77
msgid ""
"Now it's obvious what goes wrong. There is a name clash between a symbol\n"
"local to the macro expansion and a symbol passed as an argument to the "
"macro.\n"
"The macroexpansion captures limit. It ends up occurring twice in the same "
"do,\n"
"which is illegal."
msgstr ""
"Теперь очевидно, что идет не так. Здесь есть конфликт имен между локальным \n"
"символом расширения макроса и символом переданным как аргумент в макрос.\n"
"Расширение макроса захватывает limit. Этот символ возникает дважды в одном\n"
"и том же do, что является ошибкой."

#: texi/node-09.texi:82
msgid ""
"Errors caused by variable capture are rare, but what they lack in frequency "
"they\n"
"make up in viciousness. This capture was comparatively mild-here, at least, "
"we\n"
"got an error. More often than not, a capturing macro would simply yield "
"incorrect\n"
"results with no indication that anything was wrong. In this case,"
msgstr ""
"Ошибки, вызываемые захватом переменных редки, но то чего они не добирают в "
"частоте,\n"
"они берут злобностью. Этот захват был сравнительно мягким - здесь мы, по "
"крайней\n"
"мере, получили ошибку. Чаще всего, захватывающий переменную макрос будет "
"просто\n"
"выдвать не верные результаты без указания того, что пошло не так. В этом "
"случае,"

#: texi/node-09.texi:90
msgid ""
"@example\n"
"> (let ((limit 5))\n"
"        (for (i 1 10)\n"
"           (when (> i limit)\n"
"              (princ i))))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-09.texi:93
msgid ""
"@noindent\n"
"the resulting code quietly does nothing."
msgstr ""
"@noindent\n"
"полученный код тихо ничего не делает."

#: texi/node-09.texi:98
msgid ""
"@node 9-2 Free Symbol Capture, 9-3 When Capture Occurs, 9-1 Macro Argument "
"Capture, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-2 Free Symbol Capture\n"
"@cindex 9-2 Free Symbol Capture"
msgstr ""
"@node 9-2 Free Symbol Capture, 9-3 When Capture Occurs, 9-1 Macro Argument "
"Capture, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-2 Захват Свободного Символа\n"
"@cindex 9-2 Free Symbol Capture"

#: texi/node-09.texi:104
msgid ""
"Less frequently, the macro definition itself contains a symbol which "
"inadvertently\n"
"refers to a binding in the environment where the macro is expanded. Suppose\n"
"some program, instead of printing warnings to the user as they arise, wants "
"to store\n"
"the warnings in a list, to be examined later. One person writes a macro "
"gripe,\n"
"which takes a warning message and adds it to a global list, w:"
msgstr ""
"Менее часто, само определение макроса содержит символ, который "
"непреднамеренно\n"
"ссылается на привязку в окружении, где разворачивается макрос. Предположим, "
"что\n"
"какая то программа, вместо того чтобы печатать предупреждения пользователю "
"по мере\n"
"их возникновения, хочет сохранить предупреждения в списке, чтобы рассмотреть "
"их\n"
"позже. Один человек пишет макрос gripe, который принимает предупреждающее "
"сообщение\n"
"и добавляет его в глобальный список w:"

#: texi/node-09.texi:107
msgid ""
"@lisp\n"
"(defvar w nil)"
msgstr ""

#: texi/node-09.texi:112
msgid ""
"(defmacro gripe (warning)                                                ; "
"wrong\n"
"  `(progn (setq w (nconc w (list ,warning)))\n"
"               nil))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:118
msgid ""
"Someone else then wants to write a function sample-ratio, to return the "
"ratio\n"
"of the lengths of two lists. If either of the lists has less than two "
"elements, the\n"
"function is to return nil instead, also issuing a warning that it was called "
"on a\n"
"statistically insignificant case. (Actual warnings could be more "
"informative, but\n"
"their content isn't relevant to this example.)"
msgstr ""
"Кто-то еще хочет написать функцию sample-ratio, возвращающую соотношени "
"длин\n"
"двух списков. Если любой из списков содержит менее двух элементов, функция "
"должна\n"
"возвращать nil вместо него, таже выдавая предупреждение, что она была "
"вызвана для\n"
"статистически незначимого случая. (Фактические предупреждения могут быть "
"более\n"
"информативными, но их содержание не имеет отношения к этому примеру.)"

#: texi/node-09.texi:126
msgid ""
"@lisp\n"
"(defun sample-ratio (v w)\n"
"  (let ((vn (length v)) (wn (length w)))\n"
"       (if (or (< vn 2) (< wn 2))\n"
"           (gripe \"sample < 2\")\n"
"           (/ vn wn))))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:130
msgid ""
"If sample-ratio is called with w = (b), then it will want to warn that one "
"of its\n"
"arguments, with only one element, is statistically insignificant. But when "
"the call\n"
"to gripe is expanded, it will be as if sample-ratio had been defined:"
msgstr ""
"Если  sample-ratio вызывается с w = (b), то он захочет выдать "
"предупреждение, что один\n"
"из его аргументов, имеет только один элемент, статистически не значим. Но "
"когда вызов\n"
"gripe будет расширен, он создаст код такой, как если бы sample-ratio было "
"определено:"

#: texi/node-09.texi:139
msgid ""
"@lisp\n"
"(defun sample-ratio (v w)\n"
"  (let ((vn (length v)) (wn (length w)))\n"
"       (if (or (< vn 2) (< wn 2))\n"
"           (progn (setq w (nconc w (list \"sample < 2\")))\n"
"                    nil)\n"
"           (/ vn wn))))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:145
msgid ""
"The problem here is that gripe is used in a context where w has its own "
"local\n"
"binding. The warning, instead of being saved in the global warning list, "
"will be\n"
"nconced onto the end of one of the parameters of sample-ratio. Not only is\n"
"the warning lost, but the list (b), which is probably used as data elsewhere "
"in the\n"
"program, will have an extraneous string appended to it:"
msgstr ""
"Проблема здесь в том, что gripe используется в контексте, где w имеет свою "
"собственную\n"
"локальную привязку. Предупреждение, вместо сохранения в глобальном списке "
"предупреждений,\n"
"будет добавлено (nconced) в конец одного из параметров sample-ratio. "
"Предупреждение\n"
"не только будет потеряно, но и список (b), который вероятно используется в "
"качестве данных\n"
"в другом месте программы, будет добавлена посторонняя строка:"

#: texi/node-09.texi:154
msgid ""
"@example\n"
"> (let ((lst '(b)))\n"
"       (sample-ratio nil lst)\n"
"       lst)\n"
"(B \"sample < 2\")\n"
">w\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-09.texi:159
msgid ""
"@node 9-3 When Capture Occurs, 9-4 Avoiding Capture with Better Names, 9-2 "
"Free Symbol Capture, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-3 When Capture Occurs\n"
"@cindex 9-3 When Capture Occurs"
msgstr ""
"@node 9-3 When Capture Occurs, 9-4 Avoiding Capture with Better Names, 9-2 "
"Free Symbol Capture, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-3 Когда Происходит Захват\n"
"@cindex 9-3 When Capture Occurs"

#: texi/node-09.texi:168
msgid ""
"It's asking a lot of the macro writer to be able to look at a macro "
"definition and\n"
"foresee all the possible problems arising from these two types of capture. "
"Variable\n"
"capture is a subtle matter, and it takes some experience to anticipate all "
"the ways\n"
"a capturable symbol could wreak mischief in a program. Fortunately, you can\n"
"detect and eliminate capturable symbols in your macro definitions without "
"having\n"
"to think about how their capture could send your program awry. This section\n"
"provides a straightforward rule for detecting capturable symbols. The "
"remaining\n"
"sections of this chapter explain techniques for eliminating them."
msgstr ""
"Множество авторов макросов просят посмотреть определение макроса и "
"предугадать\n"
"все возможные проблемы, возникающие из этих двух типов захвата. Захват "
"переменной\n"
"является хитрым вопросом, и требуется некоторый опыт, чтобы предвидеть все "
"пути,\n"
"которыми захватываемый символ может нанести вред программе. К счастью, вы "
"можете\n"
"обнаружить и устранять захватываемые символы в ваших определениях макросов "
"без\n"
"размышлений о том, как этот захват может испортить вашу программу. Этот "
"раздел\n"
"предоставляет простое правило для обнаружения захватываемых символов. "
"Остальные\n"
"разделы этой главы объясняют методы их устранения."

#: texi/node-09.texi:171
msgid ""
"The rule for defining a capturable variable depends on some subordinate\n"
"concepts, which must be defined first:"
msgstr ""
"Правило для определения захватываемой переменной зависит от некоторого\n"
"подчиненного понятия, которое должно быть определено в перувую очередь:"

#: texi/node-09.texi:176
msgid ""
"@quotation\n"
"Free: A symbol s occurs free in an expression when it is used as a variable "
"in that\n"
"         expression, but the expression does not create a binding for it.\n"
"@end quotation"
msgstr ""
"@quotation\n"
"Свобода: Символ s появляется в выражении свободным, когда он используется "
"в \n"
"         качестве  перемменной в этом выражении, но выражение не создает \n"
"         привязку для него.\n"
"@end quotation"

#: texi/node-09.texi:178
msgid "In the following expression,"
msgstr "В следующем выражении,"

#: texi/node-09.texi:183
msgid ""
"@lisp\n"
"(let ((x y) (z 10))\n"
"  (list w x z))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:187
msgid ""
"w, x and z all occur free within the list expression, which establishes no "
"bindings.\n"
"However, the enclosing let expression establishes bindings for x and z, so "
"within\n"
"the let as a whole, only y and w occur free. Note that in"
msgstr ""
"w, x и z - все встречаются свободными в выражении list, которое не "
"устанавливает привязок.\n"
"Тем не менее, включающее выражение let устанавливает привязку для x и z, "
"поэтому в целом\n"
"в let только y и w являются свободными. Обратите внимание, что"

#: texi/node-09.texi:192
msgid ""
"@lisp\n"
"(let ((x x))\n"
"  x)\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:195
msgid ""
"the second instance of x is free-it's not within the scope of the new "
"binding being\n"
"established for x."
msgstr ""
"второй экземпляр x является свободным - он не входит в сферу действия новой "
"привязки\n"
"устанавливаемой для x."

#: texi/node-09.texi:200
msgid ""
"@quotation\n"
"Skeleton: The skeleton of a macro expansion is the whole expansion, minus\n"
"         anything which was part of an argument in the macro call.\n"
"@end quotation"
msgstr ""
"@quotation\n"
"Каркас: Каркас расширения макроса - это всё разложение за исключением всего\n"
"        что было частью аргументов в вызове макроса.\n"
"@end quotation"

#: texi/node-09.texi:202
msgid "If foo is defined:"
msgstr "Если foo определено как:"

#: texi/node-09.texi:207
msgid ""
"@lisp\n"
"(defmacro foo (x y)\n"
"  `(/ (+ ,x 1) ,y))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:209
msgid "and called thus:"
msgstr "и вызывается как:"

#: texi/node-09.texi:213
msgid ""
"@lisp\n"
"(foo (- 5 2) 6)\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:215
msgid "then it yields the macro expansion:"
msgstr "тогда этот вызов дает расширение макроса:"

#: texi/node-09.texi:220
msgid ""
"@lisp\n"
"(/ (+ (- 5 2) 1) 6)\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:223
msgid ""
"The skeleton of this expansion is the above expression with holes where the\n"
"parameters x and y got inserted:"
msgstr ""
"Каркас этого расширения представляет собой приведенное выше выражение с "
"\"отверстиями\",\n"
"куда были вставлены параметры x и y:"

#: texi/node-09.texi:227
msgid ""
"@lisp\n"
"(/ (+                  1) )\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(/ (+    ____  1)  ____)\n"
"@end lisp"

#: texi/node-09.texi:230
msgid ""
"With these two concepts defined, it's possible to state a concise rule for\n"
"detecting capturable symbols:"
msgstr ""
"С определением этих двух концепций(свободы и каркаса), становиться возможно\n"
"сформулировать правило для обнаружения захватываемых символов:"

#: texi/node-09.texi:237
msgid ""
"@quotation\n"
"Capturable: A symbol is capturable in some macro expansion if (a) it occurs\n"
"         free in the skeleton of the macro expansion, or (b) it is bound by "
"a part of\n"
"         the skeleton in which arguments passed to the macro are either "
"bound or\n"
"         evaluated.\n"
"@end quotation"
msgstr ""
"@quotation\n"
"Захватываемый: символ может быть захвачен в некотором разложении макроса, "
"если (a) он\n"
"         появляется свободным в каркасе разложения макроса, или (b) он "
"является \n"
"         связанным частью каркаса, в которой аргументы, передаваемые "
"макросу, либо \n"
"         связваются, либо вычисляются.\n"
"@end quotation"

#: texi/node-09.texi:239
msgid ""
"Some examples will show the implications of this rule. In the simplest case:"
msgstr "Несколько примеров прояснят смысл этого правила. В простейшем случае:"

#: texi/node-09.texi:244
msgid ""
"@lisp\n"
"(defmacro cap1 ()\n"
"  '(+ x 1))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:247
msgid ""
"x is capturable because it will occur free in the skeleton. That's what "
"caused the\n"
"bug in gripe. In this macro:"
msgstr ""
"x является захватываемым, поскольку он встречается свободным в каркасе "
"макроса. Это\n"
"то что вызвало ошибку в макросе gripe. В этом макросе:"

#: texi/node-09.texi:254
msgid ""
"@lisp\n"
"(defmacro cap2 (var)\n"
"  `(let ((x ...)\n"
"              (,var ...))\n"
"         ...))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:258
msgid ""
"x is capturable because it is bound in an expression where an argument to "
"the\n"
"macro call will also be bound. (That's what went wrong in for.) Likewise for "
"the\n"
"following two macros"
msgstr ""
"x является захватываемым, поскольку он связывается в выражении, где также "
"связывается\n"
"аргумент  вызова макроса. (Это то, что пошло не так в макросе for.) "
"Аналогично и\n"
"для следующих двух макросов"

#: texi/node-09.texi:264
msgid ""
"@lisp\n"
"(defmacro cap3 (var)\n"
"  `(let ((x ...))\n"
"         (let ((,var ...))\n"
"            ...)))"
msgstr ""

#: texi/node-09.texi:270
msgid ""
"(defmacro cap4 (var)\n"
"  `(let ((,var ...))\n"
"         (let ((x ...))\n"
"            ...)))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:273
msgid ""
"in both of which x is capturable. However, if there is no context in which "
"the\n"
"binding of x and the variable passed as an argument will both be visible, as "
"in"
msgstr ""
"в обоих x является захватываемым. Однако, если нет контекста, в котором "
"привязка x\n"
"и переменная переданная как аргумент будут обе видны, как в"

#: texi/node-09.texi:282
msgid ""
"@lisp\n"
"(defmacro safe1 (var)\n"
"  `(progn (let ((x 1))\n"
"                    (print x))\n"
"                 (let ((,var 1))\n"
"                    (print ,var))))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:286
msgid ""
"then x won't be capturable. Not all variables bound by the skeleton are at "
"risk.\n"
"However, if arguments to the macro call are evaluated within a binding "
"established\n"
"by the skeleton,"
msgstr ""
"здесь x не будет захватываемой. Не все переменные, связанные в каркасе, "
"находятся в\n"
"опсности быть захваченными. Однако, если аргументы в вызове макроса "
"вычисляются в\n"
"установленной привязке в соответствии с каркасом,"

#: texi/node-09.texi:292
msgid ""
"@lisp\n"
"(defmacro cap5 (&body body)\n"
"  `(let ((x ...))\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:295
msgid ""
"then variables so bound are at risk of capture: in cap5, x is capturable. In "
"this\n"
"case, though,"
msgstr ""
"тогда связанные в ней переменные находятся под угрозой захвата: в cap5, x "
"является \n"
"захватываемой. Хотя в это случае,"

#: texi/node-09.texi:301
msgid ""
"@lisp\n"
"(defmacro safe2 (expr)\n"
"  `(let ((x ,expr))\n"
"         (cons x 1)))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:305
msgid ""
"x is not capturable, because when the argument passed to expr is evaluated, "
"the\n"
"new binding of x won't be visible. Note also that it's only the binding of "
"skeletal\n"
"variables we have to worry about. In this macro"
msgstr ""
"x не может быть захвачена, потому что, когда переданный аргумент expr "
"вычисляется, \n"
"новая привязка x не будет видна. Обратите внимание, что это только "
"связывание каркасных\n"
"переменных, о которых мы должны беспокоиться. В этом макросе"

#: texi/node-09.texi:311
msgid ""
"@lisp\n"
"(defmacro safe3 (var &body body)\n"
"  `(let ((,var ...))\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:314
msgid ""
"no symbol is at risk of inadvertent capture (assuming that the user expects "
"that the\n"
"first argument will be bound)."
msgstr ""
"ни один символ не подвергается риску случайного захвата (при условии, что "
"пользователь ожидает,\n"
"что первый аргумент будет связан)."

#: texi/node-09.texi:317
msgid ""
"Now let's look at the original definition of for in light of the new rule "
"for\n"
"identifying capturable symbols:"
msgstr ""
"Теперь давайте посмотрим на исходное определение for в свете нового правила "
"для\n"
"идентификации захватываемых символов:"

#: texi/node-09.texi:325
msgid ""
"@lisp\n"
"(defmacro for ((var start stop) &body body)                               ; "
"wrong\n"
"  `(do ((,var ,start (1+ ,var))\n"
"             (limit ,stop))\n"
"            ((> ,var limit))\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:328
msgid ""
"It turns out now that this definition of for is vulnerable to capture in two "
"ways:\n"
"limit could be passed as the first argument to for, as in the original "
"example:"
msgstr ""
"Теперь выясняется, что это определение уязвимо для захвата двумя способами:\n"
"limit может быть передан в качестве первого аргумента для for, как в "
"исходном\n"
"примере:"

#: texi/node-09.texi:333
msgctxt "texi/node-09.texi:333"
msgid ""
"@lisp\n"
"(for (limit 1 5)\n"
"  (princ limit))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:336
msgid "but it's just as dangerous if limit occurs in the body of the loop:"
msgstr "но столь же опасно, если limit встречается в теле цикла:"

#: texi/node-09.texi:343
msgid ""
"@lisp\n"
"(let ((limit 0))\n"
"  (for (x 1 10)\n"
"        (incf limit x))\n"
"  limit)\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:348
msgid ""
"Someone using for in this way would be expecting his own binding of limit "
"to\n"
"be the one incremented in the loop, and the expression as a whole to return "
"55; in\n"
"fact, only the binding of limit generated by the skeleton of the expansion "
"will\n"
"be incremented:"
msgstr ""
"Кто-либо используя for данным способом, будет ожидать что его собственная "
"привязка\n"
"для limit будет увеличиваться в цикле, и выражение в целом вернет 55; на "
"самом деле,\n"
"полько привязка limit, созданная каркасом расширения будет увеличиваться:"

#: texi/node-09.texi:355
msgid ""
"@lisp\n"
"(do ((x 1 (1+ x))\n"
"         (limit 10))\n"
"        ((> x limit))\n"
"  (incf limit x))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:357
msgid ""
"and since that's the one which controls iteration, the loop won't even "
"terminate."
msgstr ""
"и поскольку именно она контролирует итерации, цикл никогда не прекратиться."

#: texi/node-09.texi:362
msgid ""
"The rules presented in this section should be used with the reservation that "
"they\n"
"are intended only as a guide. They are not even formally stated, let alone "
"formally\n"
"correct. The problem of capture is a vaguely defined one, since it depends "
"on\n"
"expectations. For example, in an expression like"
msgstr ""
"Правила представленные в этом разделе, должны использоваться с оговоркой, "
"что они \n"
"предназначены только как ориентир. Они даже официально не установлены, не "
"говоря уже\n"
"о формальной корректности. Проблема захвата является неопределенной, так как "
"зависит\n"
"от ожиданий. Например, в выражении типа"

#: texi/node-09.texi:366
msgid ""
"@lisp\n"
"(let ((x 1)) (list x))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:371
msgid ""
"we don't regard it as an error that when (list x) is evaluated, x will refer "
"to a\n"
"new variable. That's what let is supposed to do. The rules for detecting "
"capture\n"
"are also imprecise. You could write macros which passed these tests, and "
"which\n"
"still would be vulnerable to unintended capture. For example,"
msgstr ""
"мы не считаем ошибкой то, что когда вычисляется (list x), x будет ссылаться "
"на\n"
"новую переменную. Это то, что let должен делать. Правила обнаружения "
"захвата\n"
"также неточны. Вы можете написать макросы, которые пройдут эти тесты, и "
"которые\n"
"все равно еще будут уязвимы для непреднамеренного захвата. Например,"

#: texi/node-09.texi:381
msgid ""
"@lisp\n"
"(defmacro pathological (&body "
"body)                                          ; wrong\n"
"  (let* ((syms (remove-if (complement #'symbolp)\n"
"                                       (flatten body)))\n"
"               (var (nth (random (length syms))\n"
"                             syms)))\n"
"        `(let ((,var 99))\n"
"            ,@@body)))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:387
msgid ""
"When this macro is called, the expressions in the body will be evaluated as "
"if in\n"
"a progn-but one random variable within the body may have a different value.\n"
"This is clearly capture, but it passes our tests, because the variable does "
"not occur\n"
"in the skeleton. In practice, though, the rules will work nearly all the "
"time: one\n"
"rarely (if ever) wants to write a macro like the example above."
msgstr ""
"Когда вызывается этот макрос, выражения в теле будут вычисляться как если "
"бы\n"
"они были в progn - но одна случайная переменная в теле может иметь другое \n"
"значение. Это явно захват, но он проходит все наши тесты, потому что "
"переменная\n"
"не встречается в каркасе. Однако, на практике, эти правила будут работать "
"почти\n"
"всегда: очень редко(если вообще) кто захочет написать макрос, как в примере\n"
"выше."

#: texi/node-09.texi:389
msgctxt "texi/node-09.texi:389"
msgid "Vulnerable to capture:"
msgstr ""
"@cartouche\n"
"Уявзвимый к захвату вариант:"

#: texi/node-09.texi:396
msgid ""
"@lisp\n"
" (defmacro before (x y seq)\n"
"       `(let ((seq ,seq))\n"
"           (< (position ,x seq)\n"
"               (position ,y seq))))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:398
msgctxt "texi/node-09.texi:398"
msgid " A correct version:"
msgstr "Правильная версия:"

#: texi/node-09.texi:405
msgid ""
"@lisp\n"
" (defmacro before (x y seq)\n"
"       `(let ((xval ,x) (yval ,y) (seq ,seq))\n"
"           (< (position xval seq)\n"
"               (position yval seq))))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:407
msgid "                       Figure 9-1: Avoiding capture with let."
msgstr ""
"                       Рисунок 9-1: Как избежать захвата с помощью let.\n"
"@end cartouche"

#: texi/node-09.texi:412
msgid ""
"@node 9-4 Avoiding Capture with Better Names, 9-5 Avoiding Capture by Prior "
"Evaluation, 9-3 When Capture Occurs, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-4 Avoiding Capture with Better Names\n"
"@cindex 9-4 Avoiding Capture with Better Names"
msgstr ""
"@node 9-4 Avoiding Capture with Better Names, 9-5 Avoiding Capture by Prior "
"Evaluation, 9-3 When Capture Occurs, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-4 Как избежать захвата с помощью Лучших Имен\n"
"@cindex 9-4 Avoiding Capture with Better Names"

#: texi/node-09.texi:422
msgid ""
"The first two sections divided instances of variable capture into two types: "
"ar-\n"
"gument capture, where a symbol used in an argument is caught by a binding\n"
"established by the macro skeleton, and free symbol capture, where a free "
"symbol\n"
"in a macroexpansion is caught by a binding in force where the macro is ex-\n"
"panded. The latter cases are usually dealt with simply by giving global "
"variables\n"
"distinguished names. In Common Lisp, it is traditional to give global "
"variables\n"
"names which begin and end with asterisks. The variable defining the current\n"
"package is called *package*, for example. (Such a name may be pronounced\n"
"\"star-package-star\" to emphasize that it is not an ordinary variable.)"
msgstr ""
"Первые два раздела делят отдельные случаи захвата переменной на два типа:\n"
"захват аргумента, когда символ используемый в аргументе, перехватывается\n"
"привязкой устанавливаемой каркасом макроса и захват свободного символа, "
"когда\n"
"свободный символ в разложении макроса захватывается в силу внешней "
"привязки,\n"
"в месте расширения макроса. Проблема в последнем случае обычно решается "
"путем\n"
"предоставления глобальным переменным отличительных имен. В Common Lisp, "
"имена\n"
"глобальным переменным обычно дают начинающимися и заканчивающимися "
"звездочкой.\n"
"Например, переменная определяющия текущий пакет называется *package*. "
"(Такое \n"
"имя может быть произнесено \"star-package-star\", чтобы подчеркнуть, что "
"это\n"
"не обычная переменная.)"

#: texi/node-09.texi:428
msgid ""
"So really it was the responsibility of the author of gripe to store "
"warnings\n"
"in a variable called something like *warnings*, rather than just w. If the "
"author\n"
"of sample-ratio had used *warnings* as a parameter, then he would deserve\n"
"every bug he got, but he can't be blamed for thinking that it would be safe "
"to call\n"
"a parameter w."
msgstr ""
"Так что на самом деле ответственноть за хранение предупреждений лежит на "
"авторе\n"
"макроса gripe, сохраняя предупреждения в переменной, которому надо было "
"назвать\n"
"переменную для хранения предупреждений, чем-то вроде *warnings*, а не просто "
"w. \n"
"Если автор sample-ratio использовал бы *warnings* как параметр, тогда бы он "
"заслужил\n"
"каждую ошибку, которую он получил, но он не может быть обвинен в том, что не "
"подумал\n"
"о безопасности использоваия вызова с параметром w."

#: texi/node-09.texi:433
msgid ""
"@node 9-5 Avoiding Capture by Prior Evaluation, 9-6 Avoiding Capture with "
"Gensyms, 9-4 Avoiding Capture with Better Names, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-5 Avoiding Capture by Prior Evaluation\n"
"@cindex 9-5 Avoiding Capture by Prior Evaluation"
msgstr ""
"@node 9-5 Avoiding Capture by Prior Evaluation, 9-6 Avoiding Capture with "
"Gensyms, 9-4 Avoiding Capture with Better Names, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-5 Как избежать Захвата с помощью Предварительного Вычисления\n"
"@cindex 9-5 Avoiding Capture by Prior Evaluation"

#: texi/node-09.texi:443
msgid ""
"Sometimes argument capture can be cured simply by evaluating the\n"
"endan- gered arguments outside of any bindings created by the\n"
"macroexpansion. The simplest cases can be handled by beginning the\n"
"macro with a let expression.  Figure 9-1 contains two versions of the\n"
"macro before, which takes two objects and a sequence, and returns true\n"
"iff the first object occurs before the second in the\n"
"sequence.@footnote{This macro is used only as an example. Really it\n"
"should neither be implemented as a macro, nor use the inefficient\n"
"algorithm that it does. For a proper definition, see page 50.}"
msgstr ""
"Иногда захват аргументов можно вылечить, просто вычислив подвергаемые\n"
"опасности аргументы за пределами любых создаваемых расширением макроса\n"
"привязок. Простейшие случаи можно обработать, начав макрос с выражения\n"
"let.  Рисунок 9-1 содержит две версии макроса before, который принимает\n"
"два объекта и последовательность и возвращает истину если первый объект\n"
"встречается в последовательности раньше, чем второй.@footnote{Этот макрос\n"
"используется только как пример. На самом деле это не долно быть реализовано\n"
"как макрос, ни испольовать неэффективный алгоритм, который он показывает. \n"
"Для праильного определения см. стр. 50.}"

#: texi/node-09.texi:447
msgid ""
"The first definition is incorrect. Its initial let ensures that the\n"
"form passed as seq is only evaluated once, but it is not sufficient to\n"
"avoid the following problem:"
msgstr ""
"Первое определение не верно. Его начальный let гарантирует, что\n"
"форма переданная как seq будет вычислена только один раз, но этого\n"
"не достаточно, чтобы избежать следующих проблем:"

#: texi/node-09.texi:454
msgid ""
"@example\n"
"> (before (progn (setq seq '(b a)) 'a)\n"
"                      'b\n"
"                      '(a b))\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-09.texi:458
msgid ""
"This amounts to asking \"Is a before b in (a b)?\" If before were correct, "
"it\n"
"would return true. Macroexpansion shows what really happens: the evaluation "
"of\n"
"the first argument to < rearranges the list to be searched in the second."
msgstr ""
"Это равносильно тому, чтобы спросить \"Стоит ли a перед b в (a b)?\" Если "
"before \n"
"верно, он вернул бы истину. Расширение макроса показывает, что на самом "
"деле \n"
"происходит: вычисление первого аргумента операции < переустанавливает "
"список\n"
"для поиска."

#: texi/node-09.texi:465
msgid ""
"@lisp\n"
"(let ((seq '(a b)))\n"
"        (< (position (progn (setq seq '(b a)) 'a)\n"
"                              seq)\n"
"              (position 'b seq)))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:468
msgid ""
"To avoid this problem, it will suffice to evaluate all the arguments first "
"in one big\n"
"let. The second definition in Figure 9-1 is thus safe from capture."
msgstr ""
"Чтобы избежать этой проблемы, достаточно вначале вычислить все аргументы в "
"одном большом\n"
"let. Таким образом, второе определение на рисунке 9-1 защищено от захвата."

#: texi/node-09.texi:471
msgid ""
"Unfortunately, the let technique works only in a narrow range of cases:\n"
"macros where"
msgstr ""
"К сожалению, метод использования let работает в узком диапазоне случаев:\n"
"макросы где"

#: texi/node-09.texi:475
msgid ""
"@enumerate\n"
"@item\n"
"all the arguments at risk of capture are evaluated exactly once, and"
msgstr ""
"@enumerate\n"
"@item\n"
"все аргументы, подвергаются риску захвата, вычисляются только один раз, и"

#: texi/node-09.texi:480
msgid ""
"@item\n"
"none of the arguments need to be evaluated in the scope of bindings estab-\n"
"lished by the macro skeleton.\n"
"@end enumerate"
msgstr ""
"@item\n"
"ни один из аргументов не должен вычисляться в области охвата привязок "
"установленых\n"
"каркасом макроса.\n"
"@end enumerate"

#: texi/node-09.texi:485
msgid ""
"This rules out a great many macros. The proposed for macro violates both\n"
"conditions. However, we can use a variation of this scheme to make macros "
"like\n"
"for safe from capture: to wrap its body forms within a lambda-expression "
"outside\n"
"of any locally created bindings."
msgstr ""
"Это правило исключает множество макросов. Предлагаемый макрос нарушает оба\n"
"условия. Тем не менее, мы можем использовать вариант этой схемы, чтобы "
"сделать\n"
"макросы подобными защищенным от захвата: обернув его формы тела в лямбда "
"выражение\n"
"снаружи любых локально созданных привязок."

#: texi/node-09.texi:495
msgid ""
"Some macros, including those for iteration, yield expansions where expres-\n"
"sions appearing in the macro call will be evaluated within newly "
"established\n"
"bindings. In the definition of for, for example, the body of the loop must "
"be\n"
"evaluated within a do created by the macro. Variables occurring in the body "
"of\n"
"the loop are thus vulnerable to capture by bindings established by the do.W\n"
"                                                                                                    e\n"
"can protect variables in the body from such capture by wrapping the body in "
"a\n"
"closure, and, within the loop, instead of inserting the expressions "
"themselves,\n"
"simply funcalling the closure."
msgstr ""
"Некоторые макросы, в том числе используемые для итерации, дают расширения,\n"
"где выражение появляющиеся в вызвое макроса будет вычисляться в рамках "
"вновь\n"
"созданных привязок. Например в определении for тело цикла должно "
"вычисляться\n"
"в do созданным макросом. Таким образом, переменные встречающиеся в теле "
"цикла\n"
"также уязвимы к захвату привязками устанавливаемыми в do. Мы можем защитить\n"
"переменные в теле от такого захвата, обернув тело в замыкание, и внутри "
"цикла,\n"
"вместо вставки самих выражений, просто выполнить вызов замыкания."

#: texi/node-09.texi:497
msgid ""
"Figure 9-2 shows a version of for which uses this technique. Since the "
"closure"
msgstr ""
"Рисунок 9-2 показывает версию for которая использует этот метод. После "
"замыкания"

#: texi/node-09.texi:501
msgid " Vulnerable to capture:"
msgstr ""
"@cartouche\n"
"Уязвимая к захвату:"

#: texi/node-09.texi:509
msgid ""
"@lisp\n"
" (defmacro for ((var start stop) &body body)\n"
"       `(do ((,var ,start (1+ ,var))\n"
"               (limit ,stop))\n"
"             ((> ,var limit))\n"
"           ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:511
msgctxt "texi/node-09.texi:511"
msgid " A correct version:"
msgstr "Правильная версия:"

#: texi/node-09.texi:520
msgid ""
"@lisp\n"
" (defmacro for ((var start stop) &body body)\n"
"       `(do ((b #'(lambda (,var) ,@@body))\n"
"               (count ,start (1+ count))\n"
"               (limit ,stop))\n"
"             ((> count limit))\n"
"           (funcall b count)))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:522
msgid "                     Figure 9-2: Avoiding capture with a closure."
msgstr ""
"                     Рисунок 9-2: Избежание захвата с помощью замыкания.\n"
"@end cartouche"

#: texi/node-09.texi:529
msgid ""
"is the first thing made by the expansion of a for, free symbols occurring in "
"the\n"
"body will all refer to variables in the environment of the macro call. Now "
"the do\n"
"communicates with its body through the parameters of the closure. All the "
"closure\n"
"needs to know from the do is the number of the current iteration, so it has "
"only\n"
"one parameter, the symbol specified as the index variable in the macro call."
msgstr ""
"являющимся первым, что создает расширение for, свободные символы "
"встречающиеся\n"
"в теле body будут ссылаться на переменные из окружения вызова макроса. "
"Теперь do\n"
"взаимодействует с телом body через параметры замыкания. Все что нужно знать\n"
"замыканию от do это номер текущей итерации, поэтому оно имеет только один\n"
"параметр, символ указанный как переменная индекса в вызове макроса."

#: texi/node-09.texi:539
msgid ""
"The technique of wrapping expressions in lambdas is not a universal remedy.\n"
"You can use it to protect a body of code, but closures won't be any use "
"when, for\n"
"example, there is a risk of the same variable being bound twice by the same "
"let or\n"
"do (as in our original broken for). Fortunately, in this case, by rewriting "
"for to\n"
"package its body in a closure, we also eliminated the need for the do to "
"establish\n"
"bindings for the var argument. The var argument of the old for became the\n"
"parameter of the closure and could be replaced in the do by an actual "
"symbol,\n"
"count. So the new definition of for is completely immune from capture, as "
"the\n"
"test in Section 9-3 will show."
msgstr ""
"Техника обертывания выражений в лямбда функции не является универсальным "
"средством.\n"
"Вы можете использовать её для защиты кода тела, но замыкания не годяться "
"когда,\n"
"например, существует риск того, что одна и та же переменная будет дважды "
"связана\n"
"одним и тем же let или do (как в нашем исходном не работающем for). К "
"счастью, в\n"
"этом случае,  переписав for и упаковав его тело в замыкание, мы также "
"избавились\n"
"от необходимости устанавливать  привязки для аргумента var. Аргумент var "
"старого\n"
"for стал параметром замыкания и может быть заменен в do на символ count. \n"
"Таким образом, новое определение for полностью невоспримиимчиво к захвату, "
"как\n"
"покажет тест в Разделе 9-3."

#: texi/node-09.texi:544
msgid ""
"The disadvantage of using closures is that they might be less efficient. We\n"
"could be introducing another function call. Potentially worse, if the "
"compiler\n"
"doesn't give the closure dynamic extent, space for it will have to be "
"allocated in\n"
"the heap at runtime."
msgstr ""
"Недостаток использования замыканий состоит в том, что они могут быть менее "
"эффективными.\n"
"Мы можем ввести другой вызов функции. Потенциально хуже, если компилятор не "
"дает замыканию\n"
"динамического пространства, пространство для него должно быть выделено в "
"куче во время\n"
"выполнения."

#: texi/node-09.texi:549
msgid ""
"@node  9-6 Avoiding Capture with Gensyms, 9-7 Avoiding Capture with "
"Packages, 9-5 Avoiding Capture by Prior Evaluation, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-6 Avoiding Capture with Gensyms\n"
"@cindex 9-6 Avoiding Capture with Gensyms"
msgstr ""
"@node  9-6 Avoiding Capture with Gensyms, 9-7 Avoiding Capture with "
"Packages, 9-5 Avoiding Capture by Prior Evaluation, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-6 Как избежать захвата с помощью Gensyms\n"
"@cindex 9-6 Avoiding Capture with Gensyms"

#: texi/node-09.texi:555
msgid ""
"There is one certain way to avoid macro argument capture: replacing "
"capturable\n"
"symbols with gensyms. In the original version of for, problems arise when "
"two\n"
"symbols inadvertently have the same name. If we want to avoid the "
"possibility that\n"
"a macro skeleton will contain a symbol also used by the calling code, we "
"might\n"
"hope to get away with using only strangely named symbols in macro "
"definitions:"
msgstr ""
"Есть один определенный способ избежать захвата аргументов макроса: "
"заменить \n"
"захватываемые символы с помощью gensyms. В исходной версии for, проблемы "
"возникают\n"
"когда два символа имеют одно и тоже имя. Если мы хотим избежать этого, т.е "
"что бы \n"
"каркас макроса содержал символ так же используемый в вызывающем коде, мы "
"могли бы\n"
"уповать на использование в определении макроса символов со странными именами:"

#: texi/node-09.texi:563
msgid ""
"@lisp\n"
"   (defmacro for ((var start stop) &body "
"body)                              ; wrong\n"
"      `(do ((,var ,start (1+ ,var))\n"
"                (xsf2jsh ,stop))\n"
"               ((> ,var xsf2jsh))\n"
"            ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:567
msgid ""
"but this is no solution. It doesn't eliminate the bug, just makes it less "
"likely to\n"
"show. And not so very less likely at that-it's still possible to imagine "
"conflicts\n"
"arising in nested instances of the same macro."
msgstr ""
"но это не решение проблемы. Это не устраняет ошибку, просто снижает "
"вероятность ее \n"
"проявления. И не так уж и менее вероятно, а все еще весьма возможно "
"представить\n"
"конфликты, возникающие во вложенных экземплярах одного и того же макроса."

#: texi/node-09.texi:572
msgid ""
"We need some way to ensure that a symbol is unique. The Common Lisp\n"
"function gensym exists just for this purpose. It returns a symbol, called a "
"gensym,\n"
"which is guaranteed not to be eq to any symbol either typed in or "
"constructed by\n"
"a program."
msgstr ""
"Нам нужен какой-то способ убедится, что символ уникален. Функция Common Lisp "
"gensym\n"
"существует только для этой цели. Вызов  gensym возвращает символ, который\n"
"гарантированно не будет равен любому другому символу, набранному или "
"составленному\n"
"в программе."

#: texi/node-09.texi:579
msgid ""
"How can Lisp promise this? In Common Lisp, each package keeps a list of\n"
"all the symbols known in that package. (For an introduction to packages, "
"see\n"
"page 381.) A symbol which is on the list is said to be interned in the "
"package.\n"
"Each call to gensym returns a unique, uninterned symbol. And since every "
"symbol\n"
"seen by read gets interned, no one could type anything identical to a "
"gensym.\n"
"Thus, if you begin the expression"
msgstr ""
"Как Lisp может обещать это? В Common Lisp, каждый пакет содержит списко "
"всех\n"
"символов известных в этом пакете. (Для ознакомления с пакетами, см. стр. "
"381.) \n"
"Символ, который находиться в списке называется интернированным(внедренным) в "
"пакет.\n"
"Каждый вызов gensym возвращает уникальный, интернированный символ. И так "
"как\n"
"каждый символ при чтении получает интернирование, никто не может напечатать\n"
"что либо идентичное gensym.\n"
"Таким образом, если вы начинаете выражение"

#: texi/node-09.texi:581
msgid "   (eq (gensym) ..."
msgstr ""

#: texi/node-09.texi:583
msgid "there is no way to complete it that will cause it to return true."
msgstr "нет способа завершить его, чтобы оно вернуло истину."

#: texi/node-09.texi:587
msgid ""
"Asking gensym to make you a symbol is like taking the approach of choosing "
"a\n"
"strangely named symbol one step further-gensym will give you a symbol whose\n"
"name isn't even in the phone book. When Lisp has to display a gensym,"
msgstr ""
"Запросить gensym создать нам символ, все равно что, выбрать подход "
"использующий\n"
"символы со странными именами, но на один шаг более продвинутый - gensym даст "
"нам\n"
"символ, чьего имени нет даже в телефонной книге. Когда Lisp должен "
"отобразить gensym,"

#: texi/node-09.texi:592
msgid ""
"@example\n"
"   > (gensym)\n"
"   #:G47\n"
"@end example"
msgstr ""

#: texi/node-09.texi:598
msgid ""
"what it prints is really just Lisp's equivalent of \"John Doe,\" an "
"arbitrary name\n"
"made up for something whose name is irrelevant. And to be sure that we "
"don't\n"
"have any illusions about this, gensyms are displayed preceded by a sharp-"
"colon,\n"
"a special read-macro which exists just to cause an error if we ever try to "
"read the\n"
"gensym in again."
msgstr ""
"то что он печатает, на самом деле просто Lisp эквивалент \"John Doe\", "
"вымышленного\n"
"произвольного имени, чьё имя не имеет значения. И чтобы быть уверенным, что "
"это \n"
"не какие то наши иллюзии, отображаемым символам gensym  предшествует решетка "
"с\n"
"двоеточием, специальный макрос чтения, который существует только для того, "
"чтобы\n"
"вызывать ошибку, если мы когда-нибудь попытаемся прочитать gensym повторно."

#: texi/node-09.texi:601
msgctxt "texi/node-09.texi:601"
msgid "Vulnerable to capture:"
msgstr ""
"@cartouche\n"
"Уязвимый для захвата:"

#: texi/node-09.texi:609
msgid ""
"@lisp\n"
" (defmacro for ((var start stop) &body body)\n"
"       `(do ((,var ,start (1+ ,var))\n"
"               (limit ,stop))\n"
"              ((> ,var limit))\n"
"           ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:611
msgid "A correct version:"
msgstr "Правильная версия:"

#: texi/node-09.texi:613
msgid "@lisp"
msgstr ""

#: texi/node-09.texi:621
msgid ""
" (defmacro for ((var start stop) &body body)\n"
"       (let ((gstop (gensym)))\n"
"          `(do ((,var ,start (1+ ,var))\n"
"                  (,gstop ,stop))\n"
"                ((> ,var ,gstop))\n"
"              ,@@body)))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:623
msgid "                      Figure 9-3: Avoiding capture with gensym."
msgstr ""
"                      Рисунок 9-3: Как избежать захвата с помощью gensym.\n"
"@end cartouche"

#: texi/node-09.texi:628
msgid ""
"In CLTL2 Common Lisp, the number in a gensym's printed representation\n"
"comes from *gensym-counter*, a global variable always bound to an integer.\n"
"By resetting this counter we can cause two gensyms to print the same"
msgstr ""
"В CLTL2 Common Lisp, число в печатном представлении gensym происходит от\n"
"*gensym-counter*, глобальной переменной всегда связанной с целым числом.\n"
"Сбрасывая этот счетчик, мы можем заставить два gensyms печататься одинаково"

#: texi/node-09.texi:637
msgid ""
"@example\n"
"> (setq x (gensym))\n"
"#:G48\n"
"> (setq *gensym-counter* 48 y (gensym))\n"
"#:G48\n"
">(eqxy)\n"
"NIL\n"
"@end example"
msgstr ""
"@example\n"
"> (setq x (gensym))\n"
"#:G48\n"
"> (setq *gensym-counter* 48 y (gensym))\n"
"#:G48\n"
">(eq x y)\n"
"NIL\n"
"@end example"

#: texi/node-09.texi:640
msgid ""
"@noindent\n"
"but they won't be identical."
msgstr ""
"@noindent\n"
"но они не будут идентичными."

#: texi/node-09.texi:645
msgid ""
"Figure 9-3 contains a correct definition of for using gensyms. Now there is "
"no\n"
"limit to clash with symbols in forms passed to the macro. It has been "
"replaced\n"
"by a symbol gensymed on the spot. In each expansion of the macro, the place "
"of\n"
"limit will be taken by a unique symbol created at expansion-time."
msgstr ""
"Рисунок 9-3 содержит правильное определение for использующее gensyms. Там "
"нет\n"
"символа limit, который может совпасть с символами из форм переданных в "
"макрос.\n"
"Он был заменен символом сгенерированным gensym на месте. В каждом "
"расширении\n"
"макроса, вместо limit будет взят уникальный символ, созданый во время "
"расширения."

#: texi/node-09.texi:652
msgid ""
"The correct definition of for is a complicated one to produce on the first "
"try.\n"
"Finished code, like a finished theorem, often covers up a lot of trial and "
"error. So\n"
"don't worry if you have to write several versions of a macro. To begin "
"writing\n"
"macros like for, you may want to write the first version without thinking "
"about\n"
"variable capture, and then to go back and make gensyms for symbols which "
"could\n"
"be involved in captures."
msgstr ""
"Правильное определение for является сложным для получения с первой попытки.\n"
"Законченный код, как и законченая теорема, часто проходят через много проб "
"и \n"
"ошибок. Так что не беспокойтесь , если вам придется написать несколько "
"версий\n"
"макроса. Начиная писать макрос подобный for, вы можете написать первую "
"версию,\n"
"не думая о захвате переменной, а затем вернуться и сделать gensyms для "
"символов,\n"
"которые могут быть вовлечены в захваты."

#: texi/node-09.texi:657
msgid ""
"@node 9-7 Avoiding Capture with Packages, 9-8 Capture in Other Name-Spaces, "
"9-6 Avoiding Capture with Gensyms, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-7 Avoiding Capture with Packages\n"
"@cindex 9-7 Avoiding Capture with Packages"
msgstr ""
"@node 9-7 Avoiding Capture with Packages, 9-8 Capture in Other Name-Spaces, "
"9-6 Avoiding Capture with Gensyms, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-7 Как избежать захвата с помощью пакетов(packages)\n"
"@cindex 9-7 Avoiding Capture with Packages"

#: texi/node-09.texi:661
msgid ""
"To some extent, it is possible to avoid capture by defining macros in their "
"own\n"
"package. If you create a macros package and define for there, you can even "
"use\n"
"the definition given first"
msgstr ""
"В некоторой степени можно избежать захвата, определяя макросы в своих "
"собственных\n"
"пакетах. Если вы создаете макрос в пакете и определяете for в нем, вы можете "
"использовать\n"
"определение данное первым"

#: texi/node-09.texi:669
msgid ""
"@lisp\n"
"(defmacro for ((var start stop) &body body)\n"
"     `(do ((,var ,start (1+ ,var))\n"
"             (limit ,stop))\n"
"            ((> ,var limit))\n"
"         ,@@body))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:674
msgid ""
"and call it safely from any other package. If you call for from another "
"package,\n"
"say mycode, then even if you do use limit as the first argument, it will be\n"
"mycode::limit-a distinct symbol from macros::limit, which occurs in the\n"
"macro skeleton."
msgstr ""
"и безопасно вызывать его из любого другого пакета. Если вы вызываете for из "
"другого\n"
"пакет, скажем mycode, тогда даже если вы будете использовать limit в "
"качестве первого\n"
"аргуемента, это будет mycode::limit - символ отличный от символа macros::"
"limit, \n"
"который встречается в каркасе макроса."

#: texi/node-09.texi:680
msgid ""
"However, packages do not provide a very general solution to the problem of\n"
"capture. In the first place, macros are an integral part of some programs, "
"and it\n"
"would be inconvenient to have to separate them in their own package. "
"Second,\n"
"this approach offers no protection against capture by other code in the "
"macros\n"
"package."
msgstr ""
"Тем не менее, пакеты не дают общего решения проблемы захватов. Во-первых, "
"макросы\n"
"являются неотъемлемой частью некоторых программ, и было бы неудобно "
"разделять их\n"
"на отдельные пакеты. Во-вторых, этот подход не обеспечивает защиты от "
"захвата\n"
"другим кодом в макросах пакета."

#: texi/node-09.texi:685
msgid ""
"@node 9-8 Capture in Other Name-Spaces, 9-9 Why Bother?, 9-7 Avoiding "
"Capture with Packages, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-8 Capture in Other Name-Spaces\n"
"@cindex 9-8 Capture in Other Name-Spaces"
msgstr ""
"@node 9-8 Capture in Other Name-Spaces, 9-9 Why Bother?, 9-7 Avoiding "
"Capture with Packages, 9 Variable Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-8 Захват в Других Пространствах Имен\n"
"@cindex 9-8 Capture in Other Name-Spaces"

#: texi/node-09.texi:689
msgid ""
"The previous sections have spoken of capture as if it were a problem which "
"afflicted\n"
"variables exclusively. Although most capture is variable capture, the "
"problem can\n"
"arise in Common Lisp's other name-spaces as well."
msgstr ""
"В предыдущих разделах говорилось о захвате, как если бы это была проблем "
"свойственная\n"
"исключительно переменным. Хотя большая часть проблем захвата это захват "
"переменных,\n"
"проблема может возникнуть и в других пространствах имен Common Lisp."

#: texi/node-09.texi:692
msgid ""
"Functions may also be locally bound, and function bindings are equally "
"liable\n"
"to inadvertent capture. For example:"
msgstr ""
"Функции так же могут быть локально связаны и привязки функций одинаково "
"ответственны\n"
"за непреднамеренный захват. Например:"

#: texi/node-09.texi:704
msgid ""
"@example\n"
"> (defun fn (x) (+ x 1))\n"
"FN\n"
"> (defmacro mac (x) `(fn ,x))\n"
"MAC\n"
"> (mac 10)\n"
"11\n"
"> (labels ((fn (y) (- y 1)))\n"
"        (mac 10))\n"
"9\n"
"@end example"
msgstr ""

#: texi/node-09.texi:708
msgid ""
"As predicted by the capture rule, the fn which occurs free in the skeleton "
"of mac\n"
"is at risk of capture. When fn is locally rebound, mac returns a different "
"value\n"
"than it does generally."
msgstr ""
"Как и предсказывает правило захвата, fn который встречается свободным в "
"каркасе mac\n"
"подвергается риску захвата. Когда fn локально пересвязывается, mac "
"возвращает другое\n"
"значение, чем ожидалось."

#: texi/node-09.texi:716
msgid ""
"What to do about this case? When the symbol at risk of capture is the name "
"of\n"
"a built-in function or macro, then it's reasonable to do nothing. In CLTL2 "
"(p. 260)  \n"
"if the name of anything built-in is given a local function or macro binding, "
"\"the\n"
"consequences are undefined.\" So it wouldn't matter what your macro did-"
"anyone\n"
"who rebinds built-in functions is going to have problems with more than just "
"your\n"
"macros."
msgstr ""
"Что делать в этом случае? Когда символом подвергающимся риску захвата "
"является\n"
"встроенная функци или макрос, то разумнее ничего не делать! В CLTL2 (стр. "
"260)  \n"
"если имя чего-либо встроенного имеет локальную привязку функции или "
"макроса,\n"
"последствия не определены.\" Так что не имеет значения, что делал ваш "
"марос,\n"
"некто, кто перепривязывает встроенные функции, будет иметь проблемы не "
"только\n"
"с вашим макросом.."

#: texi/node-09.texi:727
msgid ""
"Otherwise, you can protect function names against macro argument capture\n"
"the same way you would protect variable names: by using gensyms as names\n"
"for any functions given local definitions by the macro skeleton. Avoiding "
"free\n"
"symbol capture, as in the case above, is a bit more difficult. The way to "
"protect\n"
"variables against free symbol capture was to give them distinctly global "
"names:\n"
"e.g. *warnings* instead of w. This solution is not practical for functions, "
"because\n"
"there is no convention for distinguishing the names of global functions-"
"most\n"
"functions are global. If you're concerned about a macro being called in an\n"
"environment where a function it needs might be locally redefined, the best "
"solution\n"
"is probably to put your code in a distinct package."
msgstr ""
"В противном случае, вы можете защитить имена функций от захвата аргументами\n"
"макроса так же, как защищали бы имена переменных: используя gensyms как имя\n"
"для любых функций, заданных локальными определениями в каркасе макроса. "
"Избежать\n"
"захвата свободных симолов, как в случае выше, немного сложнее. Способ "
"защитить\n"
"переменные от захвата свободных символов, дать им отчетливые глобальные "
"имена:\n"
"такие как *warnings* вместо w. Это решение не практично для функций, потому "
"что\n"
"не существует соглашения о различении имен глобальных функций - а "
"большинство\n"
"функций являются глобальными. Если вы обеспокоены тем. что макрос вызывается "
"в\n"
"окружении, где функция может быть переопределена, вероятно лучшим решением, "
"будет\n"
"поместить ваш код в отдельный пакет."

#: texi/node-09.texi:731
msgid ""
"Block-names are also liable to capture, as are the tags used by go and "
"throw.\n"
"When your macros need such symbols,you should use gensyms,as in the "
"definition\n"
"of our-do on page 98."
msgstr ""
"Имена блоков также могут быть захвачены, как и теги используемые go и "
"throw.\n"
"Когда вашим макросам нужны такие символы, вы должны использовать gensyms, "
"как\n"
"в определении our-do на стр. 98."

#: texi/node-09.texi:735
msgid ""
"Remember also that operators like do are implicitly enclosed in a block "
"named\n"
"nil. Thus a return or return-from nil within a do returns from the do, not\n"
"the containing expression:"
msgstr ""
"Помните также , что операторы типа do неявно заключены в блок с именем\n"
"nil. Таким образом, возврат(return) или (return-from nil) в пределах\n"
"do возвращает из do, а не из содержащего его выражения:"

#: texi/node-09.texi:747
msgid ""
"@example\n"
"> (block nil\n"
"        (list 'a\n"
"                (do ((x 1 (1+ x)))\n"
"                     (nil)\n"
"                   (if (> x 5)\n"
"                        (return-from nil x)\n"
"                        (princ x)))))\n"
"12345\n"
"(A 6)\n"
"@end example"
msgstr ""

#: texi/node-09.texi:750
msgid ""
"If do didn't create a block named nil, this example would have returned just "
"6,\n"
"rather than (A 6)."
msgstr ""
"Если  бы do не создавалось в блоке с именем nil, этот пример вернул бы "
"просто 6,\n"
"а не (A 6)."

#: texi/node-09.texi:755
msgid ""
"The implicit block in do is not a problem, because do is advertised to "
"behave\n"
"this way. However, you should realize that if you write macros which expand "
"into\n"
"dos, they will capture the block name nil. In a macro like for,areturn or\n"
"return-from nil will return from the for expression, not the enclosing block."
msgstr ""
"Неявный блок(block) в do не является проблемой, потому что do и должен "
"вести \n"
"себя таким образом.  Однако, вы должны понимать, что если вы пишите "
"макросы,\n"
"которые расширяются в do, они захватят имя блока nil. В макросе вроде for, \n"
"return или return-from nil будет возвращать из выражения for, а не из\n"
"вмещающего блока(block)."

#: texi/node-09.texi:760
msgid ""
"@node 9-9 Why Bother?,  , 9-8 Capture in Other Name-Spaces, 9 Variable "
"Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-9 Why Bother?\n"
"@cindex 9-9 Why Bother?"
msgstr ""
"@node 9-9 Why Bother?,  , 9-8 Capture in Other Name-Spaces, 9 Variable "
"Capture\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 9-9 Зачем Беспокоиться?\n"
"@cindex 9-9 Why Bother?"

#: texi/node-09.texi:766
msgid ""
"Some of the preceding examples are pretty pathological. Looking at them, "
"one\n"
"might be tempted to say \"variable capture is so unlikely-why even worry "
"about\n"
"it?\" There are two ways to answer this question. One is with another "
"question:\n"
"why write programs with small bugs when you could write programs with no\n"
"bugs?"
msgstr ""
"Некоторые из предыдущих примеров довольно патологические. Глядя на них, "
"некто \n"
"может сказать \"захват переменных маловероятен - зачем беспокоиться о нём?"
"\". \n"
"Есть два способа ответить на этот вопрос. Один ответ с другим вопросом:\n"
"зачем писать программы с небольшими ошибками, когда вы можете писать "
"программы\n"
"без ошибок?"

#: texi/node-09.texi:773
msgid ""
"The longer answer is to point out that in real applications it's dangerous "
"to\n"
"assume anything about the way your code will be used. Any Lisp program has\n"
"what is now called an \"open architecture.\" If you're writing code other "
"people\n"
"will use, they may use it in ways you'd never anticipate. And it's not just "
"people\n"
"you have to worry about. Programs write programs too. It may be that no "
"human\n"
"would write code like"
msgstr ""
"Более линный ответ состоит в том, чтобы указать, что в реальных приложениях\n"
"опасно, предполагать что-нибудь о том, как будет использоваться ваш код. \n"
"Любая программа на Lisp имеет то, что сейчас называется \"открытой "
"архитектурой.\" \n"
"Если вы пишете код другим людям, они могут использовать его так, как вы "
"никогда\n"
"бы не ожидали. Вы должны беспокоитсья о том, что это просто люди. Программы "
"тоже\n"
"пишут программы. Может быть, что ни один человек не написал бы код так"

#: texi/node-09.texi:779
msgid ""
"@lisp\n"
"(before (progn (setq seq '(b a)) 'a)\n"
"             'b\n"
"             '(a b))\n"
"@end lisp"
msgstr ""

#: texi/node-09.texi:785
msgid ""
"but code generated by programs often looks like this. Even if individual "
"macros\n"
"generate simple and reasonable-looking expansions, once you begin to nest "
"macro\n"
"calls, the expansions can become large programs which look like nothing any\n"
"human would write. Under such circumstances, it is worth defending against\n"
"cases, however contrived, which might make your macros expand incorrectly."
msgstr ""
"но код, сгенерированный программами, часто выглядит подобным образом. Даже "
"если\n"
"отдельные макросы генерируют простые и разумные расширения, как только вы\n"
"начнете вкладывать вызовы макросов, расширения могут стать большими "
"программами,\n"
"которые не похожи ни на что, что написал бы человек.  При таких "
"обстоятельствах\n"
"стоит защищаться от случаев, какими бы надуманными они не были, когда они "
"могут \n"
"привести к неправильному расширению ваших макросов."

#: texi/node-09.texi:789
msgid ""
"In the end, avoiding variable capture is not very difficult anyway. It soon "
"be-\n"
"comes second-nature. The classic Common Lisp defmacro is like a cook's "
"knife:\n"
"an elegant idea which seems dangerous, but which experts use with confidence."
msgstr ""
"В конце концов, избежать захвата переменных не так уж и сложно. Это скоро "
"станет\n"
"вашей второй натурой. Классический Common Lisp defmacro похож на нож "
"повара:\n"
"элегантная идея, которая кажется опасной, но которой эксперты уверенно "
"пользуются.\n"
