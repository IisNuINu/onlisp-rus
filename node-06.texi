@node 6 Functions as Representation, 7 Macros, 5 Returning Functions, Top
@comment  node-name,  next,  previous,  up
@chapter 6 Функции как представление
@cindex 6 Functions as Representation

Как правило, для представления информации используются структуры данных. Массив может
быть использован как представление геометрических преобразований; дерево может
представлять иерархию команд; граф может представлять систему железнодорожной сети.
В Лиспе, иногда мы можем использовать замыкания в роли представления чего-либо.
Внутри замыкания, переменные могут хранить информацию, и могут также играют роль,
которую играют указатели при построении сложных структур данных. Создав группу
замыканий, которые предоставляют доступ к замкнутым переменным, или могут ссылаться
друг на друга, мы можем создавать гибридные объекты, которые объединяют в себе
преимущества структур данных и программ.


На более низком уровне, разделяемые связанные переменные представляют собой указатели.
Замыкания просто предоставляют нам удобства взаимодействия с ними на более высоком
уровне абстракции. Используя замыкания для представления чего-либо, где обычно
используются статические структуры данных, мы можем получить более элегантный и
эффективный код.

@menu
* 6-1 Networks::                
* 6-2 Compiling Networks::      
* 6-3 Looking Forward::         
@end menu

@node 6-1 Networks, 6-2 Compiling Networks, 6 Functions as Representation, 6 Functions as Representation
@comment  node-name,  next,  previous,  up
@section 6-1 Сети
@cindex 6-1 Networks

Замыкания имеют три полезных свойства: они активны, у них есть локальное состояние, и
мы можем создавать много экземпляров при необходимости. Где нам нужно использовать
несколько копий активных объектов с локальным состоянием? В приложениях с сетями,
среди прочего. Во многих случаях мы можем представить узлы в сети как замыкания.
Кроме наличия собственного состояния, замыкания могут ссылаться друг на друга. Таким
образом узел сети ввиде замыкания может знать несколько других узлов (замыканий)
которым он должен посылать свой вывод. Это означает, что у нас будет возможность
переносить некоторые сети непосредственно в код.

@cartouche
@example
 > (run-node 'people)
 Is the person a man?
 >> yes
 Is he living?
 >> no
 Was he American?
 >> yes
 Is he on a coin?
 >> yes
 Is the coin a penny?
 >> yes
 LINCOLN
@end example

                       Рисунок 6.1: Пример игры "20 вопросов".
@end cartouche

В этом и следующем параграфах мы рассмотрим два способа обхода сети. Сначала
мы будем следовать традиционному подходу, где узлы определяются как структуры,
и существует отдельный код для обхода сети. Затем, в следующем разделе мы покажем,
как написать такую же программу на основе одной абстракции.

В качестве примера мы будем использовать самый простой случай: одну из тех
программ, которые играют в "20 вопросов". Наша сеть будет представлена бинарным
деревом. Каждый нетерминальный узел будет содержать вопрос типа "да/нет", и в
зависимости от ответа на вопрос, обход будет продолжаться по левому или правому
поддереву. Терминальные узлы (листья) будут содержать результаты. Когда будет
достигнут конечный узел, его значение будет возвращено в качестве результата обхода.
Взаимодействие с этой программой может выглядеть как на рисунке 6.1.

Традиционный способ начать работу - это определить какую-то структуру данных для
представления узлов сети. Узел должен хранить определенную информацию: если это
лист дерева, то какое значение возвращать, а если нет, то какой вопрос задать, и
куда идти в зависимости от ответа. Удовлетворяющая этим требования структура данных
представлена на рисунке 6.2. Она рассчитана на минимальный размер. Поле contents
будет содержать вопрос или возвращаемое значение. Если узел не терминальный, поля
yes и no скажут, куда идти в зависимости от ответа на вопрос; если узел является
листом, мы узнаем это, т.к. эти поля будут пустыми. Глобальная переменная *nodes*
будет хэш-таблицей, в которой узлы будут индексированы по имени. Наконец, функция
defnode будет создавать новый узел (любого типа) и сохраняет его в *nodes*.
Используя эти составные кирпичики, мы можем определить первый узел нашего дерева:

@lisp
(defnode 'people "Is the person a man?"
               'male 'female)
@end lisp

@cartouche
@lisp
 (defstruct node contents yes no)

 (defvar *nodes* (make-hash-table))

 (defun defnode (name conts &optional yes no)
      (setf (gethash name *nodes*)
               (make-node :contents conts
                            :yes         yes
                            :no          no)))
@end lisp

                 Рисунок 6.2: Представление и определение узлов.
@end cartouche

@cartouche
@lisp
 (defnode 'people "Is the person a man?" 'male 'female)

 (defnode 'male "Is he living?" 'liveman 'deadman)

 (defnode 'deadman "Was he American?" 'us 'them)

 (defnode 'us "Is he on a coin?" 'coin 'cidence)

 (defnode 'coin "Is the coin a penny?" 'penny 'coins)

 (defnode 'penny 'lincoln)
@end lisp

                            Рисунок 6.3: Пример сети.
@end cartouche

Рисунок 6.3 показывает все, что необходимо для примера из рисунка 6.1.

Теперь все, что нужно сделать, это написать функцию для обхода этой сети, вывода
вопросов и следования указанному пути. Эта функция, run-node, показана на
рисунке 6.4. Указывая имя, мы ищем соответствующий узел. Если это не лист,
задается вопрос из поля content, и в зависимости от ответа, мы продолжаем обход
в одном из двух возможных направлений. Если узел терминальный, run-node просто
возвращает значение поля content. При обходе сети с рисунка 6.3, эта функция
производит результат, показанный на рисунке 6.1.

@cartouche
@lisp
 (defun run-node (name)
       (let ((n (gethash name *nodes*)))
          (cond ((node-yes n)
                   (format t "~A~%>> " (node-contents n))
                   (case (read)
                      (yes (run-node (node-yes n)))
                      (t     (run-node (node-no n)))))
                  (t (node-contents n)))))
@end lisp

                     Рисунок 6.4: Функция обхода сети.
@end cartouche

@cartouche
@lisp
 (defvar *nodes* (make-hash-table))

 (defun defnode (name conts &optional yes no)
       (setf (gethash name *nodes*)
               (if yes
                     #'(lambda ()
                            (format t "~A~%>> " conts)
                            (case (read)
                             (yes (funcall (gethash yes *nodes*)))
                             (t     (funcall (gethash no *nodes*)))))
                     #'(lambda () conts))))
@end lisp

                     Рисунок 6.5: Сеть с использованием замыканий.
@end cartouche

@node 6-2 Compiling Networks, 6-3 Looking Forward, 6-1 Networks, 6 Functions as Representation
@comment  node-name,  next,  previous,  up
@section 6.2 Компиляция(Сборка) сетей
@cindex 6-2 Compiling Networks

В предыдущем разделе мы написали программу для работы с сетью так, как она могла бы
быть написана на любом другом языке. Действительно, программа настолько проста, что
кажется странным рассчитывать на то, что ее можно написать по-другому. Но, на самом
деле, мы можем реализовать ее гораздо проще.

Код на рисунке 6.5 показывает такой пример. Это все, что нам действительно нужно,
чтобы запустить нашу программу. Вместо того, чтобы иметь отдельно структуры данных
для узлов, и отдельную функцию для их обхода, мы представляем узлы как замыкания.
Данные, ранее хранимые в структурах, сохраняются в связанных переменных внутри
замыканий. Теперь нет необходимости в функции run-node; эта функциональность
заложена в самих узлах. Для того, чтобы начать обход,

@cartouche
@lisp
 (defvar *nodes* nil)

 (defun defnode (&rest args)
      (push args *nodes*)
      args)

 (defun compile-net (root)
      (let ((node (assoc root *nodes*)))
        (if (null node)
               nil
               (let ((conts (second node))
                         (yes (third node))
                         (no (fourth node)))
                 (if yes
                         (let ((yes-fn (compile-net yes))
                                (no-fn (compile-net no)))
                           #'(lambda ()
                                (format t "~A~%>> " conts)
                                (funcall (if (eq (read) 'yes)
                                                  yes-fn
                                                  no-fn))))
                         #'(lambda () conts))))))
@end lisp

                      Рисунок 6.6: Компиляция со статическими ссылками.
@end cartouche

мы просто делаем вызов(funcall) узла-замыкания, в котором мы хотим перейти:

@lisp
(funcall (gethash 'people *nodes*))
Is the person a man?
>>
@end lisp

После этого, выполнение будет аналогичным предыдущей реализации.

Представляя узлы как замыкания, мы можем превратить нашу сеть целиком в код. Сейчас,
код должен искать узлы по имени во время выполнения. Однако, если мы знаем, что сеть
не будет изменяться во время выполнения, мы можем добавить следующее улучшение: мы
можем делать прямые вызовы функций-замыканий, без необходимости проходить по хэш-таблице.

Рисунок 6.6 содержит новую версию программы. Теперь переменная *nodes* представляет
собой одноразовый список, а не хэш-таблицу. Все узлы определяются в defnode как
и раньше, но в этот раз никаких замыканий не создается. После того как все узлы
определены, мы вызываем compile-net для компиляции всей сети сразу. Эта функция
рекурсивно проходит свой путь вплоть до листьев дерева, и на пути обратно,
возвращает на каждом шаге узел-функцию для каждого из двух поддеревьев.
@footnote{Эта версия предполагает, что сеть представляет собой дерево, которое
должно быть в этом приложении.}  Итак,
теперь каждый узел будет совершать прямой вызов обработчиков обоих направлений,
а не искать их по имени. Когда первоначальный вызов compile-net завершается, он
возвращает функцию, представляющую часть сети, которую мы попросили собрать.

@example
> (setq n (compile-net 'people))
#<Compiled-Function BF3C06>
> (funcall n)
Is the person a man?
>>
@end example

Обратите внимание, что compile-net производит компиляцию в обоих смыслах. Происходит
компиляция в общем смысле, путем трансляции абстрактного представления сети в код.
Более того, если функция compile-net компилируется, она возвращает скомпилированные
функции. (См. стр. 25.)

После компиляции сети, нам больше не нужен список, созданный с помощью defnode. Он
может быть выброшен (например, путем установки *nodes* в nil) и удален сборщиком
мусора.

@node 6-3 Looking Forward,  , 6-2 Compiling Networks, 6 Functions as Representation
@comment  node-name,  next,  previous,  up
@section 6.3 Заглядывая в будущее
@cindex 6-3 Looking Forward

Многие программы, связанные с сетями могут быть реализованы путем компиляции
узлов в замыкания. Замыкания представляют собой данные, и они могут быть
использованы для представления различных вещей так же, как и структуры. Это
требует некоторого нестандартного мышления, но наградой будут более быстрые
и элегантные программы.

Макросы могу существенно помочь, когда мы используем замыкания для представления
данных. "Представить в виде замыкания" это еще один способ сказать "скомпилировать",
и так как макросы работают во время компиляции, они являются естественным средством
для этого. После того, как макросы будут представлены, главы 23 и 24 покажут
гораздо больше программ, основанных на используемой здесь стратегии.