#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-02.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:01+0300\n"
"PO-Revision-Date: 2019-06-25 16:15+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-02.texi:5
msgid ""
"@node 2 Functions, 3 Functional Programming, 1 Extensible Language , Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 2 Functions\n"
"@cindex 2 Functions"
msgstr ""
"@node 2 Functions, 3 Functional Programming, 1 Extensible Language , Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 2 Функции\n"
"@cindex 2 Functions"

#: texi/node-02.texi:11
msgid ""
"Functions are the building-blocks of Lisp programs. They are also the "
"building-\n"
"blocks of Lisp. In most languages the + operator is something quite "
"different\n"
"from user-defined functions. But Lisp has a single model, function "
"application, to\n"
"describe all the computation done by a program. The Lisp + operator is a "
"function,\n"
"just like the ones you can define yourself."
msgstr ""
"Функции - стандартные блоки программ Лисп. Они также и стандартные\n"
"блоки Лисп. В большинстве языков оператор ”+” – это нечто, совершенно\n"
"отличное от определяемых пользователем функций. Но у Лисп есть единая\n"
"модель для описания всех вычислений, сделанных программой – применение\n"
"функций. В Лисп оператор ”+” – это точно такая же функция, какую вы\n"
"можете определить сами."

#: texi/node-02.texi:23
msgid ""
"In fact, except for a small number of operators called special forms, the "
"core\n"
"of Lisp is a collection of Lisp functions. What's to stop you from adding to "
"this\n"
"collection? Nothing at all: if you think of something you wish Lisp could "
"do, you\n"
"can write it yourself, and your new function will be treated just like the "
"built-in\n"
"ones.This fact has important consequences for the programmer. It means that "
"any\n"
"new function could be considered either as an addition to Lisp, or as part "
"of a\n"
"specific application. Typically, an experienced Lisp programmer will write "
"some\n"
"of each, adjusting the boundary between language and application until the "
"two\n"
"fit one another perfectly. This book is about how to achieve a good fit "
"between\n"
"language and application. Since everything we do toward this end ultimately\n"
"depends on functions, functions are the natural place to begin."
msgstr ""
"В действительности, за исключением небольшого количества операторов,\n"
"называемых специальными формами, ядро Лисп – это коллекция функций\n"
"Лисп. Что же остановит вас от пополнения коллекции? Совершенно\n"
"ничего. Если вы думаете о чем-нибудь, что бы вам хотелось, чтобы делал "
"Лисп,\n"
"то можете написать это сами, и ваша новая функция будет работать точно\n"
"так же, как встроенная.\n"
"Этот факт имеет важные следствия для программиста. Это означает, что\n"
"любую новую функцию можно рассматривать или как дополнение к Лисп, или\n"
"как часть определенного приложения. Как правило, опытный программист\n"
"Лисп напишет всего понемногу, корректируя границу между языком и\n"
"приложением, пока они не подойдут друг другу идеально. Эта книга о\n"
"том, как достигнуть хорошей подгонки между языком и приложением. \n"
"Поскольку всё, что мы делаем в этом направлении, в конечном счете, \n"
"зависит от функций, функция – это естественная точка отсчета."

#: texi/node-02.texi:36
msgid ""
"@menu\n"
"* 2-1 Functions as Data::       \n"
"* 2-2 Defining Functions::      \n"
"* 2-3 Functional Arguments::    \n"
"* 2-4 Functions as Properties::  \n"
"* 2-5 Scope::                   \n"
"* 2-6 Closures::                \n"
"* 2-7 Local Functions::         \n"
"* 2-8 Tail-Recursion::          \n"
"* 2-9 Compilation::             \n"
"* 2-10 Functions from Lists::   \n"
"@end menu"
msgstr ""

#: texi/node-02.texi:41
msgid ""
"@node 2-1 Functions as Data, 2-2 Defining Functions, 2 Functions, 2 "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-1 Functions as Data\n"
"@cindex 2-1 Functions as Data"
msgstr ""
"@node 2-1 Functions as Data, 2-2 Defining Functions, 2 Functions, 2 "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-1 Функции в качестве данных\n"
"@cindex 2-1 Functions as Data"

#: texi/node-02.texi:47
msgid ""
"Two things make Lisp functions different. One, mentioned above, is that "
"Lisp\n"
"itself is a collection of functions. This means that we can add to Lisp new "
"operators\n"
"of our own. Another important thing to know about functions is that they are "
"Lisp\n"
"objects."
msgstr ""
"Функции Лисп отличаются двумя вещами. Первая, упомянутая выше, это то,\n"
"что сам Лисп – коллекция функций. Это означает, что мы можем добавить\n"
"к Лисп свои новые операторы. Другая важная вещь, которую нужно знать о\n"
"функциях, это то, что они являются объектами Лисп.\n"

#: texi/node-02.texi:56
msgid ""
"Lisp offers most of the data types one finds in other languages. We get\n"
"integers and floating-point numbers, strings, arrays, structures, and so on. "
"But\n"
"Lisp supports one data type which may at first seem surprising: the "
"function.\n"
"Nearly all programming languages provide some form of function or "
"procedure.\n"
"What does it mean to say that Lisp provides them as a data type? It means "
"that in\n"
"Lisp we can do with functions all the things we expect to do with more "
"familiar\n"
"data types, like integers: create new ones at runtime, store them in "
"variables and in\n"
"structures, pass them as arguments to other functions, and return them as "
"results."
msgstr ""
"В Лисп можно найти большинство типов данных, которые имеются в других\n"
"языках. Такие, как целые числа и числа с плавающей запятой, строки,\n"
"массивы, структуры и так далее. А еще Лисп поддерживает один тип\n"
"данных, который может поначалу вызвать удивление: функция. Почти все\n"
"языки программирования в том или ином виде поддерживают функции или\n"
"процедуры. Что значит, когда говорят, что Лисп представляет функции\n"
"как тип данных? Это значит, что в Лисп мы можем делать с ними то же\n"
"самое, что могли бы делать с известными типами данных, например,\n"
"целыми числами: создавать новые во время выполнения, сохранять их в\n"
"переменных и в структурах, передавать их как параметры другим функциям\n"
"и возвращать их как результаты."

#: texi/node-02.texi:61
msgid ""
"The ability to create and return functions at runtime is particularly "
"useful.\n"
"This might sound at first like a dubious sort of advantage, like the self-"
"modifying\n"
"machine language programs one can run on some computers. But creating new\n"
"functions at runtime turns out to be a routinely used Lisp programming "
"technique."
msgstr ""
"Способность создавать и возвращать функции во время выполнения\n"
"особенно полезна. Сначала кажется, что это сомнительное преимущество,\n"
"подобно такому, как самомодифицирующиеся программы на машинном языке,\n"
"которые могут работать на некоторых компьютерах. Но создание новых\n"
"функций во время выполнения, оказывается, обычная методика\n"
"программирования на Лисп.\n"

#: texi/node-02.texi:66
msgid ""
"@node 2-2 Defining Functions, 2-3 Functional Arguments, 2-1 Functions as "
"Data, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-2 Defining Functions\n"
"@cindex 2-2 Defining Functions"
msgstr ""
"@node 2-2 Defining Functions, 2-3 Functional Arguments, 2-1 Functions as "
"Data, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-2 Определение функций.\n"
"@cindex 2-2 Defining Functions"

#: texi/node-02.texi:69
msgid ""
"Most people first learn how to make functions with defun. The following "
"expression\n"
"defines a function called double which returns twice its argument."
msgstr ""
"Многие люди сначала учатся, как создавать функции при помощи defun. "
"Следующее выражение \n"
"определяет функцию с именем double, которая возвращает удвоение аргумента."

#: texi/node-02.texi:74
msgid ""
"@example\n"
"> (defun double (x) (* x 2))\n"
"DOUBLE\n"
"@end example"
msgstr ""

#: texi/node-02.texi:77
msgid ""
"Having fed this to Lisp, we can call double in other functions, or from the\n"
"toplevel:"
msgstr ""
"Скормив это Lisp, мы можем вызывать double из других функций или из\n"
"верхнего уровня:"

#: texi/node-02.texi:82
msgid ""
"@example\n"
"> (double 1)\n"
"2\n"
"@end example"
msgstr ""

#: texi/node-02.texi:88
msgid ""
"A file of Lisp code usually consists mainly of such defuns, and so resembles "
"a\n"
"file of procedure definitions in a language like C or Pascal. But something "
"quite\n"
"different is going on. Those defuns are not just procedure definitions, "
"they're\n"
"Lisp calls. This distinction will become clearer when we see what's going "
"on\n"
"underneath defun."
msgstr ""
"Файл с исходным кодом Лисп, как правило, состоит из подобных defun и\n"
"этим походит на файл с определением процедур на языке Си или Паскаль. \n"
"Но происходит кое-что совершенно другое. Эти defun – это не\n"
"только определения процедур, но и вызовы Лисп. Это различие станет\n"
"более ясным, когда мы увидим, что же происходит внутри defun."

#: texi/node-02.texi:93
msgid ""
"and store it under the name given as the first argument. So as well as "
"calling\n"
"double, we can get hold of the function which implements it. The usual way "
"to\n"
"do so is by using the @code{#' (sharp-quote)} operator. This operator can be "
"understood\n"
"as mapping names to actual function objects. By affixing it to the name of "
"double"
msgstr ""
"Функции – это полноправные объекты. На самом деле, defun выстраивает\n"
"такой объект и сохраняет его под именем, заданным первым\n"
"аргументом. Помимо этого, по имени double, мы можем выяснить, что за "
"функция\n"
"его реализует. Обычно это делают при помощи оператора #'. Этот\n"
"оператор следует понимать как отображение имен на существующие\n"
"функциональные объекты. Применяя его к имени double,"

#: texi/node-02.texi:98
msgid ""
"@example\n"
"> #'double\n"
"#<Interpreted-Function C66ACE>\n"
"@end example"
msgstr ""

#: texi/node-02.texi:104
msgid ""
"we get the actual object created by the definition above. Though its "
"printed\n"
"representation will vary from implementation to implementation, a Common "
"Lisp\n"
"function is a first-class object, with all the same rights as more familiar "
"objects\n"
"like numbers and strings. So we can pass this function as an argument, "
"return it,\n"
"store it in a data structure, and so on:"
msgstr ""
"мы получим реально существующий объект, созданный определением выше. Хотя "
"это \n"
"напечатанное представление меняется от реализации к реализации, функция "
"Коммон Лисп – \n"
"это объект первого класса с полностью такими же правами, как и более "
"привычные объекты,\n"
"вроде чисел и строк. Так что мы можем передавать эту функцию как аргумент,\n"
"возвращать ее, сохранять в структуре данных и так далее:"

#: texi/node-02.texi:109
msgid ""
"@example\n"
"> (eq #'double (car (list #'double)))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-02.texi:116
msgid ""
"can refer to them literally. When we want to refer to an integer, we just "
"use the\n"
"integer itself. To represent a string, we use a series of characters "
"surrounded by\n"
"double-quotes. To represent a function, we use what's called a lambda-"
"expression.\n"
"A lambda-expression is a list with three parts: the symbol lambda, a "
"parameter\n"
"list, and a body of zero or more expressions. This lambda-expression refers "
"to a\n"
"function equivalent to double:"
msgstr ""
"Нам даже не нужен defun, чтобы создавать функции. Как и на большинство\n"
"объектов Лисп, мы можем прямо на них ссылаться. Когда мы хотим\n"
"сослаться на целое число, мы прямо используем само целое число. Для\n"
"представления строки мы используем последовательность символов,\n"
"окруженных двойными кавычками. Для представления функции мы используем\n"
"так называемое лямбда-выражение. Лямбда-выражение – это список,\n"
"состоящий из трех частей: символа лямбда, списка параметров и тела из\n"
"нуля или более выражений. Лямбда-выражение ссылается на функцию,\n"
"эквивалентную double:"

#: texi/node-02.texi:120
msgid ""
"@lisp\n"
"(lambda (x) (* x 2))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:123
msgid "It describes a function which takes one argument x, and returns 2x."
msgstr "Оно описывает функцию, принимающую один аргумент x и возвращающую 2x."

#: texi/node-02.texi:129
msgid ""
"A lambda-expression can also be considered as the name of a function. If\n"
"double is a proper name, like \"Michelangelo,\" then (lambda (x) (* x 2)) "
"is\n"
"a definite description, like \"the man who painted the ceiling of the "
"Sistine Chapel.\"\n"
"By putting a sharp-quote before a lambda-expression, we get the "
"corresponding\n"
"function:"
msgstr ""
"Лямбда-выражение также может рассматриваться как имя функции. Если\n"
"double – имя собственное, как “Микеланджело”, то (lambda (x) (* x 2))\n"
"– точное определение, как “человек, расписавший свод Сикстинской\n"
"капеллы”. Помещая диез-кавычку перед лямбда-выражением, мы получим\n"
"соответствующую функцию:"

#: texi/node-02.texi:134
msgid ""
"@example\n"
"> #'(lambda (x) (* x 2))\n"
"#<Interpreted-Function C674CE>\n"
"@end example"
msgstr ""
"@example\n"
"> #'(lambda (x) (* x 2))\n"
"#<Interpreted-Function C674CE>\n"
"@end example\n"
"— : After #\\# is #\\RIGHT_SINGLE_QUOTATION_MARK an undefined dispatch\n"
"macro Измените, пожалуйста, апострофы на прямые '. При копировании\n"
"примеров в интерпретатор Lisp ошибки выполнения форм. — lispuser"

#: texi/node-02.texi:136
msgid ""
"This function behaves exactly like double, but the two are distinct objects."
msgstr ""
"Эта функция ведет себя точно так же, как и double, но это два различных "
"объекта."

#: texi/node-02.texi:139
msgid ""
"In a function call, the name of the function appears first, followed by the\n"
"arguments:"
msgstr ""
"При вызове функции имя функции идет в начале, а за ним следуют\n"
"аргументы:\n"

#: texi/node-02.texi:144
msgid ""
"@example\n"
"> (double 3)\n"
"6\n"
"@end example"
msgstr ""

#: texi/node-02.texi:147
msgid ""
"Since lambda-expressions are also names of functions, they can also appear "
"first\n"
"in function calls:"
msgstr ""
"Так как лямбда-выражения – это также имена функций, то при вызове\n"
"функций они также могут появиться в начале:"

#: texi/node-02.texi:152
msgid ""
"@example\n"
"> ((lambda (x) (* x 2)) 3)\n"
"6\n"
"@end example"
msgstr ""

#: texi/node-02.texi:155
msgid ""
"In Common Lisp, we can have a function named double and a variable named\n"
"double at the same time."
msgstr ""
"В Коммон Лисп у нас одновременно может быть функция с именем double и\n"
"переменная с именем double."

#: texi/node-02.texi:161
msgid ""
"@example\n"
"> (setq double 2)\n"
"2> (double double)\n"
"4\n"
"@end example"
msgstr ""

#: texi/node-02.texi:164
msgid ""
"When a name occurs first in a function call, or is preceded by a sharp-"
"quote, it is\n"
"taken to refer to a function. Otherwise it is treated as a variable name."
msgstr ""
"Когда имя встречается первым при вызове функции или ему предшествует\n"
"диез-кавычка, то оно воспринимается как ссылка на функцию. В противном\n"
"случае рассматривается как имя переменной."

#: texi/node-02.texi:170
msgid ""
"It is therefore said that Common Lisp has distinct name-spaces for "
"variables\n"
"and functions. We can have a variable called foo and a function called foo, "
"and\n"
"they need not be identical. This situation can be confusing, and leads to a "
"certain\n"
"amount of ugliness in code, but it is something that Common Lisp "
"programmers\n"
"have to live with."
msgstr ""
"Именно поэтому говорят, что Коммон Лисп имеет различные пространства имен\n"
"для переменных и функций. У нас может быть переменная с именем foo и\n"
"функция с именем foo, и им необязательно быть одинаковыми. Ситуация\n"
"может сбивать с толку и приводить к определенному уродству в коде, но\n"
"это что-то, с чем программисты Common Lisp вынуждены сосуществовать.\n"

#: texi/node-02.texi:174
msgid ""
"If necessary, Common Lisp provides two functions which map symbols to the\n"
"values, or functions, that they represent. The function symbol-value takes "
"a\n"
"symbol and returns the value of the corresponding special variable:"
msgstr ""
"Если необходимо, Коммон Лисп предоставляет две функции, отображающие\n"
"символы в значения или функции, которые они представляют. Функция\n"
"symbol-value принимает символ и возвращает значение соответствующей\n"
"специальной переменной:"

#: texi/node-02.texi:179
msgid ""
"@example\n"
"> (symbol-value 'double)\n"
"2\n"
"@end example"
msgstr ""

#: texi/node-02.texi:182
msgid "while symbol-function does the same for a globally defined function:"
msgstr ""
"в то время как symbol-function делает то же самое для глобально\n"
"определенной функции:"

#: texi/node-02.texi:187
msgid ""
"@example\n"
"> (symbol-function 'double)\n"
"#<Interpreted-Function C66ACE>\n"
"@end example"
msgstr ""

#: texi/node-02.texi:190
msgid ""
"Note that, since functions are ordinary data objects, a variable could have "
"a\n"
"function as its value:"
msgstr ""
"Обратите внимание: так как функции являются обычными объектами данных,\n"
"переменные могут иметь функцию в качестве значения:"

#: texi/node-02.texi:197
msgid ""
"@example\n"
"> (setq x #'append)\n"
"#<Compiled-Function 46B4BE>\n"
"> (eq (symbol-value 'x) (symbol-function 'append))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-02.texi:201
msgid ""
"Beneath the surface, defun is setting the symbol-function of its first "
"argu-\n"
"ment to a function constructed from the remaining arguments. The following "
"two\n"
"expressions do approximately the same thing:"
msgstr ""
"За кулисами defun устанавливает symbol-function от первого аргумента\n"
"на функцию, состоящую из последующих аргументов. Следующие два\n"
"выражения делают примерно то же самое:"

#: texi/node-02.texi:204
msgid ""
"@lisp\n"
"(defun double (x) (* x 2))"
msgstr ""

#: texi/node-02.texi:208
msgid ""
"(setf (symbol-function 'double)\n"
"          #'(lambda (x) (* x 2)))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:217
msgid ""
"So defun has the same effect as procedure definition in other languages-to\n"
"associate a name with a piece of code. But the underlying mechanism is not "
"the\n"
"same. We don't need defun to make functions, and functions don't have to be\n"
"stored away as the value of some symbol. Underlying defun, which resembles\n"
"procedure definition in any other language, is a more general mechanism: "
"building\n"
"a function and associating it with a certain name are two separate "
"operations.\n"
"When we don't need the full generality of Lisp's notion of a function, "
"defun\n"
"makes function definition as simple as in more restrictive languages."
msgstr ""
"Итак, defun делает то же, что и описание процедуры в других языках –\n"
"связывает имя с участком кода. Но лежащий в основе механизм иной. Нам\n"
"не нужен defun для создания функций, и функции не обязаны сохраняться\n"
"как значение некоторого символа. В основе defun, который аналогичен\n"
"описанию процедуры в любом другом языке, лежит более общий механизм:\n"
"создание функции и связывание ее с определенным именем – это две\n"
"различные операции. Когда нам не требуется полная общность\n"
"представления функций в Лисп, defun делает определение функции таким\n"
"же простым, как и в более ограниченных языках."

#: texi/node-02.texi:222
msgid ""
"@node 2-3 Functional Arguments, 2-4 Functions as Properties, 2-2 Defining "
"Functions, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-3 Functional Arguments\n"
"@cindex 2-3 Functional Arguments"
msgstr ""
"@node 2-3 Functional Arguments, 2-4 Functions as Properties, 2-2 Defining "
"Functions, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-3 Функциональные аргументы\n"
"@cindex 2-3 Functional Arguments"

#: texi/node-02.texi:226
msgid ""
"Having functions as data objects means, among other things, that we can "
"pass\n"
"them as arguments to other functions. This possibility is partly responsible "
"for the\n"
"importance of bottom-up programming in Lisp."
msgstr ""
"Представление функций как объектов данных означает, помимо прочего,\n"
"что мы можем передавать их в качестве аргументов другим функциям. Эта\n"
"возможность отчасти отвечает за важность восходящего программирования\n"
"в Лисп."

#: texi/node-02.texi:231
msgid ""
"A language which allows functions as data objects must also provide some\n"
"way of calling them. In Lisp, this function is apply. Generally, we call "
"apply\n"
"with two arguments: a function, and a list of arguments for it. The "
"following four\n"
"expressions all have the same effect:"
msgstr ""
"Язык, допускающий функции в качестве объектов данных, должен также\n"
"предоставить определенные способы их вызова. В Лисп это функция\n"
"apply. Вообще, мы вызываем apply с двумя аргументами: функцией и\n"
"списком ее аргументов. Все последующие четыре выражения выполняют одно\n"
"и то же действие:"

#: texi/node-02.texi:234
msgid ""
"@lisp\n"
"(+ 1 2)"
msgstr ""

#: texi/node-02.texi:236
msgid "(apply #'+ '(1 2))"
msgstr ""

#: texi/node-02.texi:238
msgid "(apply (symbol-function '+) '(1 2))"
msgstr ""

#: texi/node-02.texi:241
msgid ""
"(apply #'(lambda (x y) (+ x y)) '(1 2))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:245
msgid ""
"In Common Lisp, apply can take any number of arguments, and the function\n"
"given first will be applied to the list made by consing the rest of the "
"arguments\n"
"onto the list given last. So the expression"
msgstr ""
"В Коммон Лисп apply может принимать любое число аргументов, и функция,\n"
"заданная первой, будет применена к списку, полученному путем синтеза в\n"
"него оставшихся аргументов, заданному в конце. Так, выражение\n"

#: texi/node-02.texi:249
msgid ""
"@lisp\n"
"(apply #'+ 1 '(2))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:253
msgid ""
"is equivalent to the preceding four. If it is inconvenient to give the "
"arguments as\n"
"a list, we can use funcall, which differs from apply only in this respect. "
"This\n"
"expression"
msgstr ""
"эквивалентно четырем предыдущим. Если задавать аргументы в виде списка\n"
"неудобно, то мы можем использовать funcall, который отличается от\n"
"apply только в этом отношении. Это выражение"

#: texi/node-02.texi:257
msgid ""
"@lisp\n"
"(funcall #'+ 1 2)\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:259
msgid "has the same effect as those above."
msgstr "выполняет то же действие, что и все предыдущие."

#: texi/node-02.texi:264
msgid ""
"Many built-in Common Lisp functions take functional arguments. Among the\n"
"most frequently used are the mapping functions. For example, mapcar takes "
"two\n"
"or more arguments, a function and one or more lists (one for each parameter "
"of\n"
"the function), and applies the function successively to elements of each "
"list:"
msgstr ""
"Множество встроенных в Коммон Лисп функций принимает функциональные\n"
"аргументы. Среди наиболее широко используемых находятся отображающие\n"
"функции. Например, mapcar принимает два или более аргументов, функцию\n"
"и один или более списков (один на каждый параметр функции) и применяет\n"
"функцию последовательно к элементам каждого списка:"

#: texi/node-02.texi:274
msgid ""
"@example\n"
"> (mapcar #'(lambda (x) (+ x 10))\n"
"               '(1 2 3))\n"
"(11 12 13)\n"
"> (mapcar #'+\n"
"               '(1 2 3)\n"
"               '(10 100 1000))\n"
"(11 102 1003)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:285
msgid ""
"Lisp programs frequently want to do something to each element of a list and "
"get\n"
"back a list of results. The first example above illustrates the conventional "
"way to\n"
"do this: make a function which does what you want done, and mapcar it over "
"the\n"
"list.Already we see how convenientit is to be able to treat functions as "
"data. In\n"
"many languages, even if we could pass a function as an argument to something "
"like\n"
"mapcar, it would still have to be a function defined in some source file "
"beforehand.\n"
"If just one piece of code wanted to add 10 to each element of a list, we "
"would have\n"
"to define a function, called plus ten or some such, just for this one use. "
"With\n"
"lambda-expressions, we can refer to functions directly."
msgstr ""
"Программы на Лисп часто испытывают необходимость делать что-то с\n"
"каждым аргументом списка и вернуть назад список результатов. Первый\n"
"пример, приведенный выше, показывает обычный способ это реализовать:\n"
"создать функцию, которая выполняет то, что вам нужно, и при помощи\n"
"mapcar применить ее к списку.\n"
"\n"
"Мы уже видим, насколько удобно иметь возможность обращаться с\n"
"функциями, как с данными. Во многих языках, даже если мы могли бы\n"
"передать функцию в качестве аргумента чему-то, вроде mapcar, она бы,\n"
"тем не менее, была функцией, определенной заранее в каком-нибудь\n"
"исходном файле. Если бы требовался именно цельный код, добавляющий 10\n"
"к каждому элементу списка, мы бы определили функцию с именем plus\n"
"ten или каким-то подобным только для этого единственного применения. С\n"
"помощью лямбда выражений мы можем ссылаться на функции\n"
"непосредственно.\n"

#: texi/node-02.texi:292
msgid ""
"One of the big differences between Common Lisp and the dialects which\n"
"preceded it are the large number of built-in functions that take functional "
"argu-\n"
"ments. Two of the most commonly used, after the ubiquitous mapcar, are sort\n"
"and remove-if. The former is a general-purpose sorting function. It takes a "
"list\n"
"and a predicate, and returns a list sorted by passing each pair of elements "
"to the\n"
"predicate."
msgstr ""
"Одно из существенных отличий между Коммон Лисп и предшествовавшими ему\n"
"диалектами состоит в огромном количестве встроенных функций,\n"
"принимающих функциональные аргументы. Две из наиболее используемых\n"
"после вездесущего mapcar – это sort и remove-if. Первая из них\n"
"является функцией сортировки общего назначения. Она принимает список\n"
"аргументов и предикат, а возвращает список, отсортированный\n"
"пропусканием через предикат каждой пары элементов."

#: texi/node-02.texi:297
msgid ""
"@example\n"
"> (sort '(1 4 2 5 6 7 3) #'<)\n"
"(1234567)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:300
msgid ""
"To remember how sort works, it helps to remember that if you sort a list "
"with no\n"
"duplicates by <, and then apply < to the resulting list, it will return true."
msgstr ""
"Чтобы запомнить, как работает sort, полезно помнить, что если вы\n"
"сортируете список без повторяющихся элементов с помощью <, а затем\n"
"примените < к результирующему списку, он вернет true."

#: texi/node-02.texi:304
msgid ""
"If remove-if weren't included in Common Lisp, it might be the first utility\n"
"you would write. It takes a function and a list, and returns all the "
"elements of the\n"
"list for which the function returns false."
msgstr ""
"Если бы remove-if не был бы включен в Коммон Лисп, то это, возможно,\n"
"была бы первая утилита, которую бы вы написали. Она принимает функцию\n"
"и список, а возвращает все элементы списка, для которых функция\n"
"вернула false."

#: texi/node-02.texi:309
msgid ""
"@example\n"
"> (remove-if #'evenp '(1234567))\n"
"(1357)\n"
"@end example"
msgstr ""
"@example\n"
"> (remove-if #'evenp '(1 2 3 4 5 6 7))\n"
"(1 3 5 7)\n"
"@end example"

#: texi/node-02.texi:312
msgid ""
"As an example of a function which takes functional arguments, here is a\n"
"definition of a limited version of remove-if:"
msgstr ""
"В качестве примера функции, принимающей функциональные аргументы,\n"
"здесь приводится определение ограниченной версии remove-if:\n"

#: texi/node-02.texi:321
msgid ""
"@lisp\n"
"(defun our-remove-if (fn lst)\n"
"  (if (null lst)\n"
"            nil\n"
"            (if (funcall fn (car lst))\n"
"                   (our-remove-if fn (cdr lst))\n"
"                   (cons (car lst) (our-remove-if fn (cdr lst))))))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:326
msgid ""
"Note that within this definition fn is not sharp-quoted. Since functions are "
"data\n"
"objects, a variable can have a function as its regular value. That's what's "
"happening\n"
"here. Sharp-quote is only for referring to the function named by a symbol-"
"usually\n"
"one globally defined as such with defun."
msgstr ""
"Заметим, что в этом определении fn используется без диеза-кавычки. Так\n"
"как функции являются объектами данных, то переменные могут содержать\n"
"функцию в качестве обычного значения. Вот что здесь\n"
"происходит. Диез-кавычка служит только для ссылки на функцию, имеющую\n"
"символьное имя, как правило, глобально определенное с помощью defun.\n"

#: texi/node-02.texi:332
msgid ""
"As Chapter 4 will show, writing new utilities which take functional "
"arguments\n"
"is an important element of bottom-up programming. Common Lisp has so many\n"
"utilities built-in that the one you need may exist already. But whether you "
"use\n"
"built-ins like sort, or write your own utilities, the principle is the same. "
"Instead\n"
"of wiring in functionality, pass a functional argument."
msgstr ""
"Как покажет глава 4, написание новых утилит, принимающих\n"
"функциональные аргументы, является важным элементом программирования\n"
"снизу-вверх. В Коммон Лисп есть так много встроенных утилит, что та,\n"
"которая вам требуется, возможно, уже существует. Но используете ли вы\n"
"встроенные функции, как sort, или пишете собственные утилиты, принцип\n"
"тот же. Вместо того, чтобы вписывать функциональность, передавайте\n"
"функциональный аргумент.\n"

#: texi/node-02.texi:337
msgid ""
"@node 2-4 Functions as Properties, 2-5 Scope, 2-3 Functional Arguments, 2 "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-4 Functions as Properties\n"
"@cindex 2-4 Functions as Properties"
msgstr ""
"@node 2-4 Functions as Properties, 2-5 Scope, 2-3 Functional Arguments, 2 "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-4 Функции в качестве свойств\n"
"@cindex 2-4 Functions as Properties"

#: texi/node-02.texi:343
msgid ""
"The fact that functions are Lisp objects also allows us to write programs "
"which can\n"
"be extended to deal with new cases on the fly. Suppose we want to write a "
"function\n"
"which takes a type of animal and behaves appropriately. In most languages, "
"the\n"
"way to do this would be with a case statement, and we can do it this way in "
"Lisp\n"
"as well:"
msgstr ""
"То обстоятельство, что функции Лисп являются объектами, также\n"
"позволяет нам писать программы, которые могут быть расширены на лету\n"
"для работы в изменившихся условиях. Допустим, мы хотим написать\n"
"функцию, принимающую аргумент – вид животного и ведущую себя\n"
"соответственно. В большинстве языков естественным средством для этого\n"
"будет оператор case, и мы точно так же можем это сделать и в Lisp:"

#: texi/node-02.texi:354
msgid ""
"@lisp\n"
"(defun behave (animal)\n"
"  (case animal\n"
"        (dog (wag-tail)\n"
"               (bark))\n"
"        (rat (scurry)\n"
"               (squeak))\n"
"        (cat (rub-legs)\n"
"               (scratch-carpet))))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:357
msgid ""
"       What if we want to add a new type of animal? If we were planning to "
"add new\n"
"animals, it would have been better to define behave as follows:"
msgstr ""
"       Что, если нам потребуется добавить новый тип животного? Если бы мы\n"
"хотели добавить новых животных, то было бы лучше определить behave\n"
"следующим образом:"

#: texi/node-02.texi:362
msgid ""
"@lisp\n"
"(defun behave (animal)\n"
"  (funcall (get animal 'behavior)))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:365
msgid ""
"and to define the behavior of an individual animal as a function stored, for "
"example,\n"
"on the property list of its name:"
msgstr ""
"и определить поведение отдельного животного как функцию, сохраненную,\n"
"к примеру, в списке свойств его имени:"

#: texi/node-02.texi:372
msgid ""
"@lisp\n"
"(setf (get 'dog 'behavior)\n"
"            #'(lambda ()\n"
"               (wag-tail)\n"
"               (bark)))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:375
msgid ""
"This way, all we need do in order to add a new animal is define a new "
"property.\n"
"No functions have to be rewritten."
msgstr ""
"В таком случае, все, что потребуется сделать для добавления нового\n"
"животного это определить новое свойство. Никаких функций переписывать\n"
"не нужно."

#: texi/node-02.texi:381
msgid ""
"The second approach, though more flexible, looks slower. It is. If speed "
"were\n"
"critical, we would use structures instead of property lists and, especially, "
"compiled\n"
"instead of interpreted functions. (Section 2-9 explains how to make these.) "
"With\n"
"structures and compiled functions, the more flexible type of code can "
"approach or\n"
"exceed the speed of versions using case statements."
msgstr ""
"Другой подход, несмотря на большую гибкость кажется медленным. Так и\n"
"есть. Если скорость была бы критична, то мы использовали бы структуры\n"
"вместо списков свойств и, главным образом, компилированные, вместо\n"
"интерпретируемых функций. (Раздел 2.9 объясняет, как это\n"
"сделать). Более гибкий вид кода, со структурами и компилированными\n"
"функциями , может приблизиться или обогнать по скорости версии,\n"
"использующие оператор case."

#: texi/node-02.texi:387
msgid ""
"This use of functions corresponds to the concept of a method in object-"
"oriented\n"
"programming. Generally speaking, a method is a function which is a property "
"of\n"
"an object, and that's just what we have. If we add inheritance to this "
"model, we'll\n"
"have all the elements of object-oriented programming. Chapter 25 will show "
"that\n"
"this can be done with surprisingly little code."
msgstr ""
"Такое использование функций передаёт концепцию методов в\n"
"объектно-ориентированном программировании. Собственно, метод – это\n"
"функция, являющаяся свойством объекта, и это всё. Если мы добавим\n"
"наследование в эту модель, то получим все элементы\n"
"объектно-ориентированного программирования. Глава 25 покажет, как\n"
"сделать это с удивительно маленьким кодом."

#: texi/node-02.texi:393
msgid ""
"One of the big selling points of object-oriented programming is that it "
"makes\n"
"programs extensible. This prospect excites less wonder in the Lisp world, "
"where\n"
"extensibility has always been taken for granted. If the kind of "
"extensibility we\n"
"need does not depend too much on inheritance, then plain Lisp may already "
"be\n"
"sufficient."
msgstr ""
"Одним из больших преимуществ объектно-ориентированного\n"
"программирования является расширяемость. Такая перспектива не особо\n"
"удивительна в мире Лиспа, где расширяемость всегда была в порядке\n"
"вещей. Если она не очень сильно зависит от наследования, то простоты\n"
"Лиспа уже может хватать."

#: texi/node-02.texi:398
msgid ""
"@node 2-5 Scope, 2-6 Closures, 2-4 Functions as Properties, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-5 Scope\n"
"@cindex 2-5 Scope"
msgstr ""
"@node 2-5 Scope, 2-6 Closures, 2-4 Functions as Properties, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-5 Область видимости(Scope)\n"
"@cindex 2-5 Scope"

#: texi/node-02.texi:402
msgid ""
"Common Lisp is a lexically scoped Lisp. Scheme is the oldest dialect with "
"lexical\n"
"scope; before Scheme, dynamic scope was considered one of the defining "
"features\n"
"of Lisp."
msgstr ""
"Common Lisp — Лисп с лексическим связыванием. Scheme является\n"
"старейшим диалектом с лексическим связыванием; до Scheme динамическое\n"
"связывание считалось одной из особенностей Лиспа."

#: texi/node-02.texi:408
msgid ""
"The difference between lexical and dynamic scope comes down to how an\n"
"implementation deals with free variables. A symbol is bound in an "
"expression\n"
"if it has been established as a variable, either by appearing as a "
"parameter, or by\n"
"variable-binding operators like let and do. Symbols which are not bound are\n"
"said to be free. In this example, scope comes into play:"
msgstr ""
"Разница между лексической и динамической областью действия связываемых "
"переменных\n"
" заключается в том, как реализация поступает со свободными переменными. "
"Символ \n"
"связывается в выражении, если он используется в роли переменной, например "
"как\n"
"аргумент или при помощи операторов связывания таких, как let и\n"
"do. Символы, которые остаются несвязанными, называются свободными. В\n"
"данном примере связывание проявляет себя:"

#: texi/node-02.texi:414
msgid ""
"@lisp\n"
"(let ((y 7))\n"
"      (defun scope-test (x)\n"
"       (list x y)))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:420
msgid ""
"Within the defun expression,x is bound and y is free. Free variables are "
"interesting\n"
"because it's not obvious what their values should be. There's no uncertainty "
"about\n"
"the value of a bound variable-when scope-test is called, the value of x "
"should\n"
"be whatever is passed as the argument. But what should be the value of y? "
"This\n"
"is the question answered by the dialect's scope rules."
msgstr ""
"Внутри defun x является связанной переменной а y - свободной. Интерес\n"
"к свободным переменным появляется потому, что неясно, каким должно\n"
"быть их значение. Нет никакой неопределенности в значении связанной\n"
"переменной -- когда scope-test будет вычисляться значение x будет тем,\n"
"что передадут в качестве аргумента, но каким должно быть значение y?\n"
"На этот вопрос могут ответить правила связывания переменных\n"
"конкретного диалекта."

#: texi/node-02.texi:426
msgid ""
"In a dynamically scoped Lisp, to find the value of a free variable when "
"exe-\n"
"cuting scope-test, we look back through the chain of functions that called "
"it.\n"
"When we find an environment where y was bound, that binding of y will be "
"the\n"
"one used in scope-test. If we find none, we take the global value of y. "
"Thus, in\n"
"a dynamically scoped Lisp, y would have the value it had in the calling "
"expression:"
msgstr ""
"В лиспе с динамической областью видимости для того, чтобы найти\n"
"значение свободной переменной во время выполнения scope-test мы\n"
"смотрим назад по цепочке вызовов функций, когда мы находим окружение,\n"
"в котором y - связана, мы используем эту привязку в scope-test, если\n"
"же такого окружения нет, будет взято значение глобальной переменной\n"
"y. Таким образом в лиспе с динамическим связыванием y будет содержать\n"
"то значение, которое оно содержало в вызывающем выражении:"

#: texi/node-02.texi:432
msgid ""
"@example\n"
"> (let ((y 5))\n"
"        (scope-test 3))\n"
"(3 5)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:436
msgid ""
"With dynamic scope, it means nothing that y was bound to 7 when scope-test\n"
"was defined. All that matters is that y had a value of 5 when scope-test "
"was\n"
"called."
msgstr ""
"При динамическом связывании ничего не значит тот факт, что y было\n"
"связано со значением 7 при объявлении scope-test. Имеет значение\n"
"только то, что y содержало значение 5 когда scope-test была вызвана.\n"

#: texi/node-02.texi:442
msgid ""
"In a lexically scoped Lisp, instead of looking back through the chain of "
"calling\n"
"functions, we look back through the containing environments at the time the\n"
"function was defined. In a lexically scoped Lisp, our example would catch "
"the\n"
"binding of y where scope-test was defined. So this is what would happen in\n"
"Common Lisp:"
msgstr ""
"В лиспе с лексическим связыванием вместо просматривания всей цепочки\n"
"вызовов функций мы смотрим назад, на окружение в тот момент, когда\n"
"функция была объявлена. В лиспе с лексическим связыванием наш пример\n"
"захватит значение y в тот момент, когда scope-test была объявлена. Так\n"
"что в Common Lisp произойдет следующее:\n"

#: texi/node-02.texi:448
msgid ""
"@example\n"
"> (let ((y 5))\n"
"        (scope-test 3))\n"
"(3 7)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:451
msgid ""
"Here the binding of y to 5 at the time of the call has no effect on the "
"returned\n"
"value."
msgstr ""
"Здесь связывание y со значением 5 во время вызова никак не повлияло на\n"
"возвращаемое значение."

#: texi/node-02.texi:458
msgid ""
"Though you can still get dynamic scope by declaring a variable to be "
"special,\n"
"lexical scope is the default in Common Lisp. On the whole, the Lisp "
"community\n"
"seems to view the passing of dynamic scope with little regret. For one "
"thing, it\n"
"used to lead to horribly elusive bugs. But lexical scope is more than a way "
"of\n"
"avoiding bugs. As the next section will show, it also makes possible some "
"new\n"
"programming techniques."
msgstr ""
"Несмотря на то, что вы можете получить динамическое связывание,\n"
"объявляя переменную специальной, лексические связывание являются\n"
"стандартными для Common Lisp. В основном комьюнити относится к\n"
"динамическому связыванию с недоверием. Так, например, оно может быть\n"
"причиной опасных неуловимых ошибок, но лексические замыкания - это\n"
"больше чем просто способ избежать ошибки. В следующем параграфе показано,\n"
"как с его помощью можно использовать некоторые новые техники."

#: texi/node-02.texi:462
msgid ""
"@node 2-6 Closures, 2-7 Local Functions, 2-5 Scope, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-6 Closures"
msgstr ""
"@node 2-6 Closures, 2-7 Local Functions, 2-5 Scope, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-6 Замыкания"

#: texi/node-02.texi:468
msgid ""
"Because Common Lisp is lexically scoped, when we define a function "
"containing\n"
"free variables, the system must save copies of the bindings of those "
"variables at\n"
"the time the function was defined. Such a combination of a function and a "
"set\n"
"of variable bindings is called a closure. Closures turn out to be useful in "
"a wide\n"
"variety of applications."
msgstr ""
"Поскольку Common Lisp является языком с лексическим связыванием, когда\n"
"мы определяем функцию, содержащую свободные переменные, система должна\n"
"сохранить копии привязок к этим переменным, в то время когда функция\n"
"определяется. Такое сочетание функции и набора привязок переменных\n"
"называется - Замыканием. Замыкания оказываются полезными в широком\n"
"спектре приложений."

#: texi/node-02.texi:474
msgid ""
"Closures are so pervasive in Common Lisp programs that it's possible to\n"
"use them without even knowing it. Every time you give mapcar a sharp-quoted\n"
"lambda-expression containing free variables, you're using closures. For\n"
"example, suppose we want to write a function which takes a list of numbers "
"and\n"
"adds a certain amount to each one. The function list+"
msgstr ""
"Замыкания настолько распространены в обычных программах на Lisp, что\n"
"можно использовать их даже не подозревая об этом. Каждый раз, когда вы\n"
"отдаёте mapcar лямбда-выражение с диез-кавычкой, вы используете\n"
"замыкания. Например, предположим, что мы хотим написать функцию,\n"
"которая принимает список номеров и добавляет определённую сумму к\n"
"каждому. Функция list+"

#: texi/node-02.texi:480
msgid ""
"@lisp\n"
"   (defun list+ (lst n)\n"
"         (mapcar #'(lambda (x) (+ x n))\n"
"                    lst))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:482
msgid "will do what we want:"
msgstr "будет делать то, что мы хотим:"

#: texi/node-02.texi:487
msgid ""
"@example\n"
"   > (list+ '(1 2 3) 10)\n"
"   (11 12 13)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:494
msgid ""
"If we look closely at the function which is passed to mapcar within list+, "
"it's\n"
"actually a closure. The instance of n is free, and its binding comes from "
"the\n"
"surrounding environment. Under lexical scope, every such use of a mapping\n"
"function causes the creation of a closure.@footnote{Under dynamic scope the\n"
"same idiom will work for a different reason-so long as neither of mapcar's\n"
"parameter is called x.}"
msgstr ""
"Если мы посмотрим внимательно на функцию, передаваемую в mapcar внутри\n"
"list+, то поймём, что это замыкание. Экземпляр n является свободным и\n"
"будет связан со значением из внешнего окружения. С лексическим\n"
"связыванием, каждое использование присваивающей функции приводит к\n"
"появлению замыкания. @footnote{С динамическим связыванием та же идиома \n"
"будет работать по другой причине и до тех пор, пока ни один из \n"
"параметров mapcar не назван x.}"

#: texi/node-02.texi:500
msgid ""
"Closures play a more conspicuous role in a style of programming\n"
"promoted by Abelson and Sussman's classic Structure and\n"
"Interpretation of Computer Programs. Closures are functions with\n"
"local state. The simplest way to use this state is in a situation\n"
"like the following:"
msgstr ""
"Замыкания играют важную роль в стиле программирования, предлагаемом в\n"
"книге Абельсона и Сассмана структура и интерпретация компьютерных\n"
"программ (SICP). Замыкания - это функции с локальным\n"
"состоянием. Простейший способ применения показан ниже:"

#: texi/node-02.texi:506
msgid ""
"@lisp\n"
"   (let ((counter 0))\n"
"         (defun new-id ()             (incf counter))\n"
"         (defun reset-id () (setq counter 0)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"   (let ((counter 0))\n"
"         (defun new-id ()   (incf counter))\n"
"         (defun reset-id () (setq counter 0)))\n"
"@end lisp"

#: texi/node-02.texi:512
msgid ""
"These two functions share a variable which serves as a\n"
"counter. The first one returns successive values of the counter,\n"
"and the second resets the counter to 0.  The same thing could be\n"
"done by making the counter a global variable, but this way it is\n"
"protected from unintended references."
msgstr ""
"Эти две функции используют одну переменную(разделяют ее меж собой), \n"
"являющуюся счетчиком. Первая возвращает следующее значение, вторая \n"
"обнуляет счетчик. Аналогичный результат можно получить сделав \n"
"счетчик глобальной переменной, но применение замыканий защищает от \n"
"случайных ссылок."

#: texi/node-02.texi:515
msgid ""
"It's also useful to be able to return functions with local\n"
"state. For example, the function make-adder"
msgstr ""
"Замыкания также удобно использовать для создания функций с локальным\n"
"состоянием. Например функция make-adder\n"

#: texi/node-02.texi:520
msgid ""
"@lisp\n"
"   (defun make-adder (n)\n"
"         #'(lambda (x) (+ x n)))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:524
msgid ""
"takes a number, and returns a closure which, when called, adds\n"
"that number to its argument. We can make as many instances of\n"
"adders as we want:"
msgstr ""
"в качестве аргумента принимает число и возвращает замыкание, которое,\n"
"если его вызвать, складывает это число со своим аргументом. Мы может\n"
"создать столько таких замыканий, сколько нам нужно:"

#: texi/node-02.texi:533
msgid ""
"@example\n"
"> (setq add2 (make-adder 2)\n"
"             add10 (make-adder 10))\n"
"#<Interpreted-Function BF162E>\n"
"> (funcall add2 5)\n"
"7> (funcall add10 3)\n"
"13\n"
"@end example"
msgstr ""

#: texi/node-02.texi:536
msgid ""
"In the closures returned by make-adder, the internal state is fixed, but "
"it's also\n"
"possible to make closures which can be asked to change their state."
msgstr ""
"В замыкании возвращаемом функцией make-adder внутреннее состояние "
"фиксированно, \n"
"но можно сделать замыкание, которое можно попросить менять свое состояние"

#: texi/node-02.texi:544
msgid ""
"@lisp\n"
"(defun make-adderb (n)\n"
"     #'(lambda (x &optional change)\n"
"          (if change\n"
"                (setq n x)\n"
"                (+ x n))))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:547
msgid ""
"This new version of make-adder returns closures which, when called with one\n"
"argument, behave just like the old ones."
msgstr ""
"Эта новая версия make-adder возвращает замыкание, которое, при вызове\n"
"его с одним аргументом, действует так же как и его предыдущая версия.\n"

#: texi/node-02.texi:554
msgid ""
"@example\n"
"> (setq addx (make-adderb 1))\n"
"#<Interpreted-Function BF1C66>\n"
"> (funcall addx 3)\n"
"4\n"
"@end example"
msgstr ""

#: texi/node-02.texi:557
msgid ""
"However, when the new type of adder is called with a non-nil second "
"argument,\n"
"its internal copy of n will be reset to the value passed as the first "
"argument:"
msgstr ""
"Тем не менее если новую версию вызвать со вторым аргументом, не равным\n"
"nil, то его внутренняя копия переменной n будет установлена в\n"
"значение, переданное первым аргументом:\n"

#: texi/node-02.texi:564
msgid ""
"@example\n"
"> (funcall addx 100 t)\n"
"100\n"
"> (funcall addx 3)\n"
"103\n"
"@end example"
msgstr ""

#: texi/node-02.texi:569
msgid ""
"It's even possible to return a group of closures which share the same data\n"
"objects. Figure 2-1 contains a function which creates primitive databases. "
"It takes\n"
"an assoc-list (db), and returns a list of three closures which query, add, "
"and delete\n"
"entries, respectively."
msgstr ""
"Более того, можно вернуть набор замыканий, которые разделяют одно\n"
"состояние. Рисунок 2.1 содержит функцию, которая создает примитивную\n"
"базу данных. В качестве аргумента она принимает ассоциативный список\n"
"(база данных) и возвращает список из трех замыканий для выборки,\n"
"добавления и удаления данных соответственно.\n"

#: texi/node-02.texi:572
msgid ""
"Each call to make-dbms makes a new database-a new set of functions closed\n"
"over their own shared copy of an assoc-list."
msgstr ""
"Каждый вызов make-dbms создает новую базу данных - новый набор\n"
"функций, лексически замкнутых относительно разделяемого ими\n"
"ассоциативного списка."

#: texi/node-02.texi:579
msgid ""
"@example\n"
"> (setq cities (make-dbms '((boston . us) (paris . france))))\n"
"(#<Interpreted-Function 8022E7>\n"
"     #<Interpreted-Function 802317>\n"
"     #<Interpreted-Function 802347>)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:592
msgid ""
"@lisp\n"
" (defun make-dbms (db)\n"
"       (list\n"
"         #'(lambda (key)\n"
"                (cdr (assoc key db)))\n"
"         #'(lambda (key val)\n"
"                (push (cons key val) db)\n"
"                key)\n"
"         #'(lambda (key)\n"
"                (setf db (delete key db :key #'car))\n"
"                key)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun make-dbms (db)\n"
"       (list\n"
"         #'(lambda (key)\n"
"                (cdr (assoc key db)))\n"
"         #'(lambda (key val)\n"
"                (push (cons key val) db)\n"
"                key)\n"
"         #'(lambda (key)\n"
"                (setf db (delete key db :key #'car))\n"
"                key)))\n"
"@end lisp"

#: texi/node-02.texi:594
msgid "                          Figure 2-1: Three closures share a list."
msgstr ""
"                          Рисунок 2-1: Три замыкания совместно используют "
"список\n"
"@end cartouche"

#: texi/node-02.texi:599
msgid ""
"The actual assoc-list within the database is invisible from the outside "
"world-we\n"
"can't even tell that it's an assoc-list-but it can be reached through the "
"functions\n"
"which are components of cities:"
msgstr ""
"Настоящий ассоциативный список внутри базы данных невидим для внешнего\n"
"мира, мы даже не можем сказать что это ассоциативный список, но мы\n"
"может взаимодействовать с ним при помощи функций:\n"

#: texi/node-02.texi:608
msgid ""
"@example\n"
"> (funcall (car cities) 'boston)\n"
"US\n"
"> (funcall (second cities) 'london 'england)\n"
"LONDON\n"
"> (funcall (car cities) 'london)\n"
"ENGLAND\n"
"@end example"
msgstr ""

#: texi/node-02.texi:612
msgid ""
"Calling the car of a list is a bit ugly. In real programs, the access "
"functions might\n"
"instead be entries in a structure. Using them could also be cleaner-"
"databases\n"
"could be reached indirectly via functions like:"
msgstr ""
"Вызов (car list) - не самое красивое решение. В настоящих\n"
"программах функции для доступа могут быть, например, элементами\n"
"структуры. Их использование может быть проще - база данных может быть\n"
"доступна не напрямую, через функции, например:"

#: texi/node-02.texi:617
msgid ""
"@lisp\n"
"(defun lookup (key db)\n"
"      (funcall (car db) key))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:619
msgid ""
"However, the basic behavior of closures is independent of such refinements."
msgstr "Тем не менее поведение замыканий не зависит от подобных тонкостей."

#: texi/node-02.texi:623
msgid ""
"In real programs, the closures and data structures would also be more "
"elaborate\n"
"than those we see in make-adderor make-dbms. The single shared variable "
"could\n"
"be any number of variables, each bound to any sort of data structure."
msgstr ""
"В настоящих программах замыкания и структуры данных могут быть гораздо\n"
"сложней тех, что мы видели в make-adder или make-dbms. Вместо одной\n"
"разделяемой переменной может быть любой набор переменных, каждая из\n"
"которых связана с какой-нибудь структурой данных."

#: texi/node-02.texi:630
msgid ""
"Closures are one of the distinct, tangible benefits of Lisp. Some Lisp "
"programs\n"
"could, with effort, be translated into less powerful languages. But just try "
"to\n"
"translate a program which uses closures as above, and it will become evident "
"how\n"
"much work this abstraction is saving us. Later chapters will deal with "
"closures in\n"
"more detail. Chapter 5 shows how to use them to build compound functions, "
"and\n"
"Chapter 6 looks at their use as a substitute for traditional data structures."
msgstr ""
"Замыкания - одно из явных, осязаемых достоинств лиспа. Некоторые\n"
"программы на лиспе могут быть, с некоторыми усилиями, перенесены на\n"
"менее мощный язык, но попробуйте перевести программу, использующую\n"
"замыкания, например, как приведенная выше, и станет очевидно насколько\n"
"меньше работы нам пришлось проделать имея такую абстракцию как\n"
"замыкание. В следующих главах мы рассмотрим замыкания более\n"
"детально. Глава 5 покажет нам, как использовать их для построения еще\n"
"более сложных функций"

#: texi/node-02.texi:635
msgid ""
"@node 2-7 Local Functions, 2-8 Tail-Recursion, 2-6 Closures, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-7 Local Functions\n"
"@cindex 2-7 Local Functions"
msgstr ""
"@node 2-7 Local Functions, 2-8 Tail-Recursion, 2-6 Closures, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-7 Локальные функции\n"
"@cindex 2-7 Local Functions"

#: texi/node-02.texi:640
msgid ""
"When we define functions with lambda-expressions, we face a restriction "
"which\n"
"doesn't arise with defun: a function defined in a lambda-expression doesn't "
"have\n"
"a name and therefore has no way of referring to itself. This means that in "
"Common\n"
"Lisp we can't use lambda to define a recursive "
"function.                                    "
msgstr ""
"Когда мы определяли функции при помощи лямбда-выражений, то\n"
"столкнулись с ограничением, которого нет при использовании defun: у\n"
"функции определенной как лямбда нет имени, так что нет возможности\n"
"ссылаться на себя. Это означает что в Common Lisp мы неможем\n"
"использовать лямбды для определения рекурсивных функций."

#: texi/node-02.texi:643
msgid ""
"If we want to apply some function to all the elements of a list, we use the "
"most\n"
"familiar of Lisp idioms:"
msgstr ""
"Если мы хотим применить некоторую функцию ко всем элементам списка, мы\n"
"используем наиболее привычный для лиспа стиль:"

#: texi/node-02.texi:649
msgid ""
"@example\n"
"> (mapcar #'(lambda (x) (+ 2 x))\n"
"                '(2 5 7 3))\n"
"(4795)\n"
"@end example"
msgstr ""

#: texi/node-02.texi:653
msgid ""
"What about cases where we want to give a recursive function as the first "
"argument\n"
"to mapcar? If the function has been defined with defun, we can simply refer "
"to\n"
"it by name:"
msgstr ""
"Но что поделать, если мы хотим передать первым аргументом mapcar\n"
"рекурсивную функцию? Если бы функция была определена через defun, мы\n"
"могли бы просто сослаться на нее по имени:"

#: texi/node-02.texi:658
msgid ""
"@example\n"
"> (mapcar #'copy-tree '((a b) (c d e)))\n"
"((A B) (C D E))\n"
"@end example"
msgstr ""

#: texi/node-02.texi:661
msgid ""
"But now suppose that the function has to be a closure, taking some bindings "
"from\n"
"the environment in which the mapcar occurs. In our example list+,"
msgstr ""
"Но предположим теперь, что функция должны быть замыканием, содержащим\n"
"некоторые свящанные переменные из окружения в котором будет работать\n"
"mapcar. В нашем примере list+:"

#: texi/node-02.texi:667
msgid ""
"@lisp\n"
"(defun list+ (lst n)\n"
"  (mapcar #'(lambda (x) (+ x n))\n"
"                lst))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:674
msgid ""
"the first argument to mapcar,#'(lambda (x) (+ x n)), must be defined within\n"
"list+ because it needs to catch the binding of n. So far so good, but what "
"if we\n"
"want to give mapcar a function which both needs local bindings and is "
"recursive?\n"
"We can't use a function defined elsewhere with defun, because we need "
"bindings\n"
"from the local environment. And we can't use lambda to define a recursive\n"
"function, because the function will have no way of referring to itself."
msgstr ""
"первый аргумент mapcar, #'(lambda (x) (+ x n)), должен быть определен\n"
"внутри list+, потому что ему нужно связанное значение n. Пока что все\n"
"хорошо, но что поделать, если нам нужно передать в mapcar и локально\n"
"связанную переменную и рекурсивную функцию? Мы не можем использовать\n"
"функцию, определенную где-то при помощи defun, потому что нам нужны\n"
"локально связанные переменные и мы не можем использовать лямбду для\n"
"определения рекурсивной функции, потому что она неможет ссылаться на\n"
"себя.\n"

#: texi/node-02.texi:678
msgid ""
"Common Lisp gives us labels as a way out of this dilemma. With one\n"
"important reservation, labels could be described as a sort of let for "
"functions.\n"
"Each of the binding specifications in a labels expression should have the "
"form"
msgstr ""
"Common Lisp дает нам labels для разрешения этой дилеммы. С одной\n"
"важной оговоркой, labels должны быть описаны в форме похожей на\n"
"let. Каждое описание связывания в выражении должно быть следующего\n"
"вида"

#: texi/node-02.texi:682
msgid ""
"@lisp\n"
"( name  parameters  .  body )\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:684
msgid ""
"Within the labels expression,  name  will refer to a function equivalent to:"
msgstr ""
"Внутри labels выражение <name> ссылается на функцию, эквивалентную\n"
"следующей:"

#: texi/node-02.texi:688
msgid ""
"@lisp\n"
"#'(lambda  parameters  .  body )\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:690
msgid "So for example:"
msgstr "В качестве примера:"

#: texi/node-02.texi:696
msgid ""
"@example\n"
"> (labels ((inc (x) (1+ x)))\n"
"       (inc 3))\n"
"4\n"
"@end example"
msgstr ""

#: texi/node-02.texi:700
msgid ""
"However, there is an important difference between let and labels.\n"
"In a let expression, the value of one variable can't depend on\n"
"another variable made by the same let-that is, you can't say"
msgstr ""
"Тем не менее есть важное различие между let и labels. Внутри let\n"
"выражения значение одной переменной не может зависеть от какой-либо\n"
"другой объявленной внутри одной let формы, это значит что вы НЕ можете\n"
"написать\n"

#: texi/node-02.texi:705
msgid ""
"@lisp\n"
"(let ((x 10) (y x))\n"
"      y)\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:711
msgid ""
"and expect the value of the new y to reflect that of the new\n"
"x. In contrast, the body of a function f defined in a labels\n"
"expression may refer to any other function defined there,\n"
"including f itself, which makes recursive function definitions\n"
"possible."
msgstr ""
"и ожидать что значение новой переменной y будет содержать значение\n"
"новой x. С другой стороны тело функции f определенной внутри выражения\n"
"labels может ссылаться на любую другую функцию, определенную там же,\n"
"влючая саму себя, что делает возможным описание рекурсивных функций.\n"

#: texi/node-02.texi:714
msgid ""
"Using labels we can write a function analogous to list+, but in\n"
"which the first argument to mapcar is a recursive function:"
msgstr ""
"Используя labels мы можем написать функцию, аналогичную list+, но в\n"
"которой первый аргумент mapcar будет рекурсивной функцией:\n"

#: texi/node-02.texi:724
msgid ""
"@lisp\n"
"(defun count-instances (obj lsts)\n"
"      (labels ((instances-in (lst)\n"
"                   (if (consp lst)\n"
"                        (+ (if (eq (car lst) obj) 1 0)\n"
"                            (instances-in (cdr lst)))\n"
"                        0)))\n"
"       (mapcar #'instances-in lsts)))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:727
msgid ""
"This function takes an object and a list, and returns a list of\n"
"the number of occurrences of the object in each element:"
msgstr ""
"Эта функция берет объект и список и возвращает список чисел,\n"
"соответствующих числу вхождений объекта в каждый элемент:\n"

#: texi/node-02.texi:732
msgid ""
"@example\n"
"> (count-instances 'a '((a b c) (darpa)(dar)(aa)))\n"
"(1212)\n"
"@end example"
msgstr ""
"@example\n"
"> (count-instances 'a '((a b c) (d a r p a)(d a r)(a a)))\n"
"(1 2 1 2)\n"
"@end example"

#: texi/node-02.texi:737
msgid ""
"@node 2-8 Tail-Recursion, 2-9 Compilation, 2-7 Local Functions, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-8 Tail-Recursion\n"
"@cindex 2-8 Tail-Recursion"
msgstr ""
"@node 2-8 Tail-Recursion, 2-9 Compilation, 2-7 Local Functions, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-8 Хвостовая Рекурсия\n"
"@cindex 2-8 Tail-Recursion"

#: texi/node-02.texi:741
msgid ""
"A recursive function is one that calls itself. Such a call is\n"
"tail-recursive if no work remains to be done in the calling\n"
"function afterwards. This function is not tail-recursive"
msgstr ""
"Рекурсивными называют функции вызывающие сами себя. Хвостовой\n"
"рекурсией называется рекурсия, если в вызывающей не остается никакой\n"
"работы после вызова себя рекурсивно. Следующая функция НЕ является\n"
"функцией с хвостовой рекурсией\n"

#: texi/node-02.texi:747
msgid ""
"@lisp\n"
"(defun our-length (lst)\n"
"      (if (null lst)\n"
"            0(1+ (our-length (cdr lst)))))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun our-length (lst)\n"
"      (if (null lst)\n"
"         0\n"
"         (1+ (our-length (cdr lst)))))\n"
"@end lisp"

#: texi/node-02.texi:750
msgid ""
"because on returning from the recursive call we have to pass the\n"
"result to 1+. The following function is tail-recursive, though"
msgstr ""
"поскольку, вернувшись из рекурсивыного вызова, мы должны передать\n"
"результат в 1 +. Следующая функция является функцией с хвостовой\n"
"рекурсией"

#: texi/node-02.texi:758
msgid ""
"@lisp\n"
"(defun our-find-if (fn lst)\n"
"   (if (funcall fn (car lst))\n"
"               (car lst)\n"
"               (our-find-if fn (cdr lst))))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:760
msgid "because the value of the recursive call is immediately returned."
msgstr "потому что значение рекурсивного вызова сразу же возвращается."

#: texi/node-02.texi:767
msgid ""
"Tail-recursion is desirable because many Common Lisp compilers\n"
"can transform tail-recursive functions into loops. With such a\n"
"compiler, you can have the elegance of recursion in your source\n"
"code without the overhead of function calls at runtime. The gain\n"
"in speed is usually great enough that programmers go out of their\n"
"way to make functions tail-recursive."
msgstr ""
"Хвостовая рекурсия более эффективна, потому что многие реализации\n"
"Common Lisp могут трасформировать хвостовую рекурсию в цикл. С такими\n"
"компиляторами вы можете получить элегантность рекурсии в исходном коде\n"
"без накладных расходов на вызов функций. Прирост скорости обычно настолько\n"
"высок, что программисты делают многое, чтобы сделать функцию с\n"
"хвостовой рекурсией."

#: texi/node-02.texi:773
msgid ""
"A function which isn't tail-recursive can often be transformed\n"
"into one that is by embedding in it a local function which uses\n"
"an accumulator. In this context, an accumulator is a parameter\n"
"representing the value computed so far. For example, our-length\n"
"could be transformed into"
msgstr ""
"Функция, не обладающая свойством хвостовой рекурсии, часто может быть\n"
"трансформированна в таковую, при помощи включения в нее локальной\n"
"функции, использующей аккумулятор. В нашем контексте аккумулятор - это\n"
"параметр, представляющий значение, которое нужно вычислить в процессе\n"
"рекурсии. Например наша функция our-length может быть трансформирована\n"
"в"

#: texi/node-02.texi:782
msgid ""
"@lisp\n"
"(defun our-length (lst)\n"
"   (labels ((rec (lst acc)\n"
"                     (if (null lst)\n"
"                            acc\n"
"                            (rec (cdr lst) (1+ acc)))))\n"
"         (rec lst 0)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(defun our-length (lst)\n"
"   (labels ((rec (lst acc)\n"
"              (if (null lst)\n"
"                  acc\n"
"                  (rec (cdr lst) (1+ acc)))))\n"
"      (rec lst 0)))\n"
"@end lisp"

#: texi/node-02.texi:788
msgid ""
"where the number of list elements seen so far is contained in a second "
"parameter,\n"
"acc. When the recursion reaches the end of the list, the value of acc will "
"be\n"
"the total length, which can just be returned. By accumulating the value as "
"we go\n"
"down the calling tree instead of constructing it on the way back up, we can "
"make\n"
"rec tail-recursive."
msgstr ""
"где колличество элементов списка, которые будут пройдены содержится во\n"
"втором параметре acc. Когда рекурсивная функция достигнет конца\n"
"списка, значение acc будет его длиной, которое сразу может быть\n"
"возвращено. Аккумулируя значения при спуске по дереву вызовов вместо\n"
"того чтобы конструировать его поднимаясь мы можем сделать rec функцией\n"
"с хвостовой рекурсией.\n"

#: texi/node-02.texi:792
msgid ""
"Many Common Lisp compilers can do tail-recursion optimization, but not all\n"
"of them do it by default. So after writing your functions to be tail-"
"recursive, you\n"
"may also want to put"
msgstr ""
"Многие компиляторы Common Lisp делают оптимизацию хвостовой рекурсии,\n"
"но не все делают это по умолчанию. Так что после написания функции с\n"
"хвостовой рекурсией непомешает так же добавить\n"

#: texi/node-02.texi:796
msgid ""
"@lisp\n"
"(proclaim '(optimize speed))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:800
msgid ""
"at the top of the file, to ensure that the compiler can take advantage of "
"your\n"
"efforts.@footnote {The declaration (optimize speed) ought to be an "
"abbreviation\n"
"for (optimize (speed 3)).}"
msgstr ""
"в начале файла, чтобы компилятор смог извлечь пользу из ваших\n"
"стараний. @footnote {Декларация (optimize speed) является аббревиатурой для "
"(optimize\n"
"(speed 3)). Тем не менее некоторые компиляторы Common Lisp делают\n"
"оптимизацию хвостовой рекурсии при первом варианте но не втором.}"

#: texi/node-02.texi:805
msgid ""
"Given tail-recursion and type declarations, existing Common Lisp compilers\n"
"can generate code that runs as fast as, or faster than, C. Richard Gabriel "
"gives as  \n"
"an example the following function, which returns the sum of the integers "
"from 1\n"
"to n:"
msgstr ""
"Используя хвостовую рекурсию и декларацию типов существующие\n"
"реализации компиляторов Common Lisp могут генерировать код такой же\n"
"бытрый, или даже быстрее кода на C. Ричард Гэбриэл приводит пример\n"
"следующей функции, которая возвращает сумму целых чисел от 1 до n:\n"

#: texi/node-02.texi:808
msgid ""
"However, one Common Lisp implementation does tail-recursion optimization "
"with the former, but not\n"
"the latter."
msgstr " "

#: texi/node-02.texi:819
msgid ""
"@lisp\n"
"  (defun triangle (n)\n"
"        (labels ((tri (c n)\n"
"                     (declare (type fixnum n c))\n"
"                     (if (zerop n)\n"
"                         c(tri (the fixnum (+ n c))\n"
"                                (the fixnum (- n 1))))))\n"
"         (tri 0 n)))\n"
"@end lisp"
msgstr ""
"@lisp\n"
"  (defun triangle (n)\n"
"     (labels ((tri (c n)\n"
"                (declare (type fixnum n c))\n"
"                (if (zerop n)\n"
"                    c\n"
"                    (tri (the fixnum (+ n c))\n"
"                         (the fixnum (- n 1))))))\n"
"        (tri 0 n)))\n"
"@end lisp"

#: texi/node-02.texi:824
msgid ""
"This is what fast Common Lisp code looks like. At first it may not seem "
"natural\n"
"to write functions this way. It's often a good idea to begin by writing a\n"
"function in whatever way seems most natural, and then, if necessary,\n"
"transforming it into a tail-recursive equivalent."
msgstr ""
"Это пример того, как выглядит быстрый код на Common Lisp. С первого\n"
"взгляда не кажется естественным писать код в таком виде. Хорошей идеей\n"
"будет написать функцию в том виде, в котором она выражается на лиспе\n"
"наиболее естественно, и затем, если возникнет необходимость,\n"
"трансформировать ее в вариант с хвостовой рекурсией."

#: texi/node-02.texi:829
msgid ""
"@node 2-9 Compilation, 2-10 Functions from Lists, 2-8 Tail-Recursion, 2 "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-9 Compilation\n"
"@cindex 2-9 Compilation"
msgstr ""
"@node 2-9 Compilation, 2-10 Functions from Lists, 2-8 Tail-Recursion, 2 "
"Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-9 Компиляция\n"
"@cindex 2-9 Compilation"

#: texi/node-02.texi:832
msgid ""
"Lisp functions can be compiled either individually or by the file. If you "
"just type\n"
"a defun expression into the toplevel,"
msgstr ""
"Функции в лиспе могут быть скомпилированы либо индивидуально, либо в\n"
"составе файла. Если вы просто напечатаете выражение defun в toplevel\n"

#: texi/node-02.texi:837
msgid ""
"@example\n"
"  > (defun foo (x) (1+ x))\n"
"  FOO\n"
"@end example"
msgstr ""

#: texi/node-02.texi:840
msgid ""
"many implementations will create an interpreted function. You can check "
"whether\n"
"a given function is compiled by feeding it to compiled-function-p:"
msgstr ""
"то многие реализации создадут интерпретируемую функцию. Вы можете\n"
"проверить, является ли данная функция скомпилированной скормив ее\n"
"compiled-function-p:"

#: texi/node-02.texi:845
msgid ""
"@example\n"
"  > (compiled-function-p #'foo)\n"
"  NIL\n"
"@end example"
msgstr ""

#: texi/node-02.texi:847
msgid "We can have foo compiled by giving its name to compile"
msgstr ""
"Мы можем получить скомпилированную версию, передав ее имя функции\n"
"compile\n"

#: texi/node-02.texi:852
msgid ""
"@example\n"
"  > (compile 'foo)\n"
"  FOO\n"
"@end example"
msgstr ""

#: texi/node-02.texi:855
msgid ""
"which will compile the definition of foo and replace the interpreted version "
"with\n"
"a compiled one."
msgstr ""
"которая скомпилирует определение функции foo и заменит\n"
"интерпретируемую версию на скомпилированную.\n"

#: texi/node-02.texi:860
msgid ""
"@example\n"
"> (compiled-function-p #'foo)\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-02.texi:866
msgid ""
"Compiled and interpreted functions are both Lisp objects, and behave the "
"same,\n"
"except with respect to compiled-function-p. Literal functions can also be\n"
"compiled: compile expects its first argument to be a name, but if you give "
"nil\n"
"as the first argument, it will compile the lambda-expression given as the "
"second\n"
"argument."
msgstr ""
"Скомпилированная и интерпретируемая версии являются объектами в лиспе\n"
"и ведут себя одинаково за исключением функции\n"
"compiled-function-p. Лямбда функции так же могут быть скомпилированы:\n"
"compile ожидает в качестве первого аргумента имя функции, но если\n"
"передать nil, то она скомпилирует лямбда выражение, переданое вторым\n"
"аргументом."

#: texi/node-02.texi:871
msgid ""
"@example\n"
"> (compile nil '(lambda (x) (+ x 2)))\n"
"#<Compiled-Function BF55BE>\n"
"@end example"
msgstr ""

#: texi/node-02.texi:874
msgid ""
"If you give both the name and function arguments, compile becomes a sort of\n"
"compiling defun:"
msgstr ""
"Если передать и имя и лямбда выражение, то compile будет работать как\n"
"компилирующий defun:"

#: texi/node-02.texi:880
msgid ""
"@example\n"
"> (progn (compile 'bar '(lambda (x) (* x 3)))\n"
"                 (compiled-function-p #'bar))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-02.texi:891
msgid ""
"Having compile in the language means that a program could build and\n"
"compile new functions on the fly. However, calling compile explicitly is a\n"
"drastic measure, comparable to calling eval, and should be viewed with the "
"same\n"
"suspicion. @footnote{An explanation of why it is bad to call eval explicitly "
"appears on page 278.} When Section 2-1 @xref{2-1 Functions as Data}, said "
"that creating\n"
"new functions at runtime was a routinely used programming technique, it\n"
"referred to new closures like those made by make-adder, not functions made "
"by\n"
"calling compile on raw lists. Calling compile is not a routinely used\n"
"programming technique-it's an extremely rare one. So beware of doing it\n"
"unnecessarily. Unless you're implementing another language on top of Lisp "
"(and\n"
"much of the time, even then), what you need to do may be possible with "
"macros."
msgstr ""
"Наличие compile в языке означает, что программа может строить и\n"
"компилировать новые функции на лету. Тем не менее вызов compile в\n"
"явном виде является очень сильным средством, сравнимым с eval и должно\n"
"применяться с такой же осторожностью.  @footnote{Объяснение, почему плохо \n"
"вызывать eval в явном виде есть на 278 странице.} Когда в секции 2.1 \n"
"@xref{2-1 Functions as Data} говорилось, что создание новых функций во "
"время\n"
"выполнения является привычной техникой - имелось ввиду создание новых "
"замыканий,\n"
"вроде тех, которые создавались при помощи make-adder, но не функции "
"созданные \n"
"при помощи вызова compile на сыром списке. Вызов compile - не обычная "
"техника,\n"
"это крайне редкий случай. Так что избегайте применения ее без\n"
"необходимости. И все же если вы реализуете другой язык над лиспом (и\n"
"даже в таком случае) то что вам нужно может быть возможно при помощи\n"
"макросов."

#: texi/node-02.texi:896
msgid ""
"There are two sorts of functions which you can't give as an argument to\n"
"compile. According to CLTL2 (p. 677), you can't compile a function "
"\"defined\n"
"interpretively in a non-null lexical environment.\" That is, if at the "
"toplevel you\n"
"define foo within a let"
msgstr ""
"Существует два вида функций, которые вы не можете передать compile в\n"
"качестве аргумента. Согласно CLTL2 (стр. 677), вы не можете\n"
"скомпилировать функцию \"объявленную интерпретируемо в ненулевом\n"
"лексическом окружении\". Тоесть если в toplevel определить foo внутри\n"
"let"

#: texi/node-02.texi:901
msgid ""
"@example\n"
"> (let ((y 2))\n"
"        (defun foo (x) (+ x y)))\n"
"@end example"
msgstr ""

#: texi/node-02.texi:905
msgid ""
"then (compile 'foo) will not necessarily work.@footnote{It's ok to have this "
"code in a file and then compile the file. The restriction is imposed on "
"interpreted code for implementation reasons, not because there's anything "
"wrong with defining functions in distinct lexical environments.} You also "
"can't call compile\n"
"on a function which is already compiled. In this situation, CLTL2 hints "
"darkly that\n"
"\"the consequences...are unspecified.\""
msgstr ""
"то (compile 'foo) необязательно сработает. @footnote{Не страшно держать \n"
"такой код в файле и затем компилировать его. Ограничение распространяется\n"
"на интерпретируемый код по причине реализации, но не из-за того, что что-то\n"
"не так с определением функций в различных окружениях.} Вы так же несможете\n"
"скомпилировать функцию, которая уже была скомпилирована. В этой\n"
"ситуации CLTL2 отвечает туманно \"результат... не определен.\""

#: texi/node-02.texi:911
msgid ""
"The usual way to compile Lisp code is not to compile functions individually\n"
"with compile, but to compile whole files with compile-file. This function\n"
"takes a filename and creates a compiled version of the source file-typically "
"with\n"
"the same base name but a different extension. When the compiled file is "
"loaded,\n"
"compiled-function-p should return true for all the functions defined in the "
"file."
msgstr ""
"Привычный способ копмилирования лисп кода - не компиляция отдельных\n"
"функций, а компиляция всего файла при помощи compile-file. Это функция\n"
"берет имя файла и создает скомпилированную версию исходного файла -\n"
"как правило с таким же именем и другим расширением. Когда\n"
"скомпилированный файл загружен, compile-function-p должен вернуть true\n"
"для всех функций в нем."

#: texi/node-02.texi:916
msgid ""
"Later chapters will depend on another effect of compilation: when one "
"function\n"
"occurs within another function, and the containing function is compiled, the "
"inner\n"
"function will also get compiled. CLTL2 does not seem to say explicitly that "
"this\n"
"will happen, but in a decent implementation you can count on it."
msgstr ""
"В следующих главах будем опираться на еще один эффект компиляции:\n"
"когда одна функция встречается внутри другой, и внешняя функция\n"
"компилируется, то внутренняя функция так же будет\n"
"скомпилирована. CLTL2 явно не оговаривает этот момент, но вы можете\n"
"расчитывать на него в основных реализациях."

#: texi/node-02.texi:920
msgid ""
"The compiling of inner functions becomes evident in functions which return\n"
"functions. When make-adder (page 18) is compiled, it will return compiled\n"
"functions:"
msgstr ""
"Компиляция внутренней функции становится явной в функциях, которые\n"
"возвращают функции. Когда make-adder (стр. 18) будет скомпилирована,\n"
"она вернет скомпилированную фунуцию:"

#: texi/node-02.texi:927
msgid ""
"@example\n"
"> (compile 'make-adder)\n"
"MAKE-ADDER\n"
"> (compiled-function-p (make-adder 2))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-02.texi:933
msgid ""
"As later chapters will show, this fact is of great importance in the "
"implementation\n"
"of embedded languages. If a new language is implemented by transformation,\n"
"and the transformation code is compiled, then it yields compiled output-and\n"
"so becomes in effect a compiler for the new language. (A simple example is\n"
"described on page 81.)"
msgstr ""
"В следующих главах будет показано, что этот факт играет важнейшую роль\n"
"в разработке встроенного языка. Если новый язык реализован как\n"
"трансформация и трансформирующий код скомпилирован, то будет получен\n"
"скомпилированный результат - и таким образом получаем эффективный\n"
"компилятор для нового языка. (Простой пример описан на странице 81.)\n"

#: texi/node-02.texi:937
msgid ""
"If we have a particularly small function, we may want to request that it be\n"
"compiled inline. Otherwise, the machinery of calling it could entail more "
"effort\n"
"than the function itself. If we define a function:"
msgstr ""
"Если у нас есть очень маленькая функция, мы можем попросить компилятор\n"
"сделать ее встроенной. Иначе издержки на вызов функции могут быть\n"
"больше, чем ее полезная работа. Если мы определим функцию:\n"

#: texi/node-02.texi:941
msgid ""
"@lisp\n"
"   (defun 50th (lst) (nth 49 lst))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:943
msgid "and make the declaration:"
msgstr "и добавим декларацию:"

#: texi/node-02.texi:947
msgid ""
"@lisp\n"
"   (proclaim '(inline 50th))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:950
msgid ""
"then a reference to 50th within a compiled function should no longer require "
"a\n"
"real function call. If we define and compile a function which calls 50th,"
msgstr ""
"то ссылка на функцию 50th внутри скомпилированной функции больше не\n"
"должно требовать реального вызова функции. Если мы определим и\n"
"скомпилируем функцию, которая вызывает 50th,"

#: texi/node-02.texi:955
msgid ""
"@lisp\n"
"   (defun foo (lst)\n"
"         (+ (50th lst) 1))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:958
msgid ""
"then when foo is compiled, the code for 50th should be compiled right into "
"it,\n"
"just as if we had written"
msgstr ""
"то когда foo будет скомпилирована, код 50th будет вкомпилирован\n"
"непосредственно в нее, как быдто мы написали\n"

#: texi/node-02.texi:963
msgid ""
"@lisp\n"
"   (defun foo (lst)\n"
"         (+ (nth 49 lst) 1))\n"
"@end lisp"
msgstr ""

#: texi/node-02.texi:967
msgid ""
"in the first place. The drawback is that if we redefine 50th, we also have "
"to\n"
"recompile foo, or it will still reflect the old definition. The restrictions "
"on inline\n"
"functions are basically the same as those on macros (see Section 7-9)."
msgstr ""
"в первом случае. Недостаток в том, что если мы переопределим 50th то\n"
"придется перекомпилировать foo, или она все еще будет работать со\n"
"старым определением. Ограничение на встраиваемые функции то же, что и на\n"
"макросы (см Глава 7.9)."

#: texi/node-02.texi:972
msgid ""
"@node 2-10 Functions from Lists,  , 2-9 Compilation, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-10 Functions from Lists\n"
"@cindex 2-10 Functions from Lists"
msgstr ""
"@node 2-10 Functions from Lists,  , 2-9 Compilation, 2 Functions\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 2-10 Функции из списков\n"
"@cindex 2-10 Functions from Lists"

#: texi/node-02.texi:978
msgid ""
"In some earlier dialects of Lisp, functions were represented as lists. This "
"gave Lisp\n"
"programs the remarkable ability to write and execute their own Lisp "
"programs.\n"
"In Common Lisp, functions are no longer made of lists-good implementations\n"
"compile them into native machine code. But you can still write programs "
"that\n"
"write programs, because lists are the input to the compiler."
msgstr ""
"В некоторых ранних диалектах лиспов функции были представлены как\n"
"списки. Это давало лиспу выдающуюся способность писать и выполнять\n"
"свои собственные программы на лисп. В Common Lisp функции более не\n"
"списки, хорошие реализации сразу компилируют их в машинный код. Но вы\n"
"все еще можете писать программы, которые пишут программы, потому что\n"
"списки можно отдать компилятору."

#: texi/node-02.texi:985
msgid ""
"It cannot be overemphasized how important it is that Lisp programs can\n"
"write Lisp programs, especially since this fact is so often overlooked. "
"Even\n"
"experienced Lisp users rarely realize the advantages they derive from this "
"feature\n"
"of the language. This is why Lisp macros are so powerful, for example. Most\n"
"of the techniques described in this book depend on the ability to write "
"programs\n"
"which manipulate Lisp expressions."
msgstr ""
"Нельзя переоценить насколько важен факт того, что программы на лиспе\n"
"могут писать программы на лиспе, особенно учитывая то как часто эту\n"
"возможность недооценивают. Даже опытные программисты редко осознают\n"
"какой выигрыш они получают от этой возможности языка. Это причина\n"
"того, почему макросы лиспа настолько могущественны. Большинство техник\n"
"в этой книге зависят от возможности писать программы, манипулирующие\n"
"лисп выражениями."
