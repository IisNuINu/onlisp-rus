@node 16 Macro-Defining Macros, 17 Read-Macros, 15 Macros Returning Functions, Top
@comment  node-name,  next,  previous,  up
@chapter 16 Макросы определяющие Макросы.
@cindex 16 Macro-Defining Macros

Шаблоны в коде часто указывают на необходимость в новых абстракциях. Это правило
выполняется так же, как для кода, так и для макросов. Когда несколько макросов имеют
определения подобной формы, мы можем написать макрос для их создания(генерации). 
В этой главе представлены три примера макросов создающих макро-определения: одно
для определения абревиатур, одно для определения макросов доступа, и третье для
определения анафорических макросов, похожих на описанные в Разделе 14-1.

@menu
* 16-1 Abbreviations::          
* 16-2 Properties::             
* Anaphoric Macros::            
@end menu

@node 16-1 Abbreviations, 16-2 Properties, 16 Macro-Defining Macros, 16 Macro-Defining Macros
@comment  node-name,  next,  previous,  up
@section 16-1 Сокращения(Аббревиатуры)
@cindex 16-1 Abbreviations

Самое простое использование макросов - это сокращения. Некоторые операторы
Common Lisp имеют довольно длинные имена. Высокий рейтинг среди них (хотя ни в коем
случе не самое длинное) у destructuring-bind, в котором 18 знаков. Следствие из
принципа Стила(Steele's principle) (стр. 43) заключается в том, что часто используемые
операторы должны иметь более короткие имена. ("Мы думаем, что сложение является
дешевой операцией, отчасти потому, что мы можем записать его одним знаком: `+'.") 
Встроенный макрос destructuring-bind вводит новый уровень абстракции, но фактический
выигрыш в краткости нивелируется его длинным именем:

@lisp
(let ((a (car x)) (b (cdr x))) ...)

(destructuring-bind (a . b) x ...)
@end lisp

Программу, также как и текст, легче всего читать, если она содержит не более 70 знаков
в строке. Мы с самого начала становимся в невыгодное положение, когда длина отдельных
имен составляет четверть этой величины.

@cartouche
@lisp
 (defmacro abbrev (short long)
       `(defmacro ,short (&rest args)
           `(,',long ,@@args)))

 (defmacro abbrevs (&rest names)
       `(progn
           ,@@(mapcar #'(lambda (pair)
                               `(abbrev ,@@pair))
                         (group names 2))))
@end lisp

                  Рисунок 16-1: Автоматическое определение сокращений.
@end cartouche

К счастью, в таком языке как Lisp, вам не нужно жить со всеми этими решениями разработчиков.
Имея определение

@lisp
(defmacro dbind (&rest args)
  `(destructuring-bind ,@@args))
@end lisp

@noindent
вам больше никогда не будет нужно снова использовать длинное имя. Аналогично
для multiple-value-bind, которое длиннее и чаще используется.

@lisp
(defmacro mvbind (&rest args)
  `(multiple-value-bind ,@@args))
@end lisp

Обратите внимание, насколько близки определения dbind и mvbind. 
В самом деле, этой формулы &rest и запятая с собакой(,@@) будет достаточно,
для того чтобы определить макрос сокращения(аббривиатуру) для любой функции,
@footnote{Хотя аббревиатуру нельзя передать в apply или funcall.}, или 
специальной формы. Зачем делать много определений по модели mvbind, когда
у нас есть макросы, которые мы можем использовать?

Чтобы определить макрос определяющий макрос, нам часто нужны вложенные обратные
кавычки. Вложенные обратные кавычки, как известно, трудно понять. В конце концов
с общим случаем мы разберемся, но не стоит ожидать, что мы взглянув на произвольное
выражение в обратных кавычках скажем, что оно выдает. Это не ошибка в Lisp, что это
невозможно, и не ошибка в обозначениях, на которые нельзя просто посмотреть, подобно,
сложному интегралу, и сказать, какое значение он имеет.  Трудность заключается в
самой проблеме, а не в обозначениях.

Однако, как и при поиске интеграла, мы можем разбить анализ обратных кавычек
на маленькие шаги, каждый из которых можно легко проследить. Предположим, мы
хотим написать макрос abbrev, который позволит нам определить mvbind просто
сказав

@lisp
(abbrev mvbind multiple-value-bind)
@end lisp

Рисунок 16-1 содержит определение этого макроса. Как мы его получили? Определение
такого макроса может быть получено из примера расширения. Одним из его
расширений является:

@lisp
(defmacro mvbind (&rest args)
       `(multiple-value-bind ,@@args))
@end lisp

Понять происхождение будет проще, если мы вынем multiple-value-bind из обратных
кавычек, поскольку мы знаем что оно будет аргументом для возможного макроса. Это
дает нам эквивалентное определение

@lisp
(defmacro mvbind (&rest args)
       (let ((name 'multiple-value-bind))
        `(,name ,@@args)))
@end lisp

Теперь мы берем это выражение и превращаем его в шаблон. Мы добавляем к нему
обратную кавычку и заменяем выражения, которые будут изменяться, на переменные.

@lisp
`(defmacro ,short (&rest args)
        (let ((name ',long))
         `(,name ,@@args)))
@end lisp

Последний шаг состоит в том, чтобы упростить это выражение путем замены(подстановки)
вместо name поставить ',long внутри выражения с обратной кавычкой:

@lisp
`(defmacro ,short (&rest args)
        `(,',long ,@@args))
@end lisp

который и даст нам тело макроса определенного на Рисунке 16-1.

Рисунок 16-1 также содержит abbrevs, для случаев, когда мы хотим определить 
несколько сокращений за один раз.

@lisp
(abbrevs dbind destructuring-bind
              mvbind multiple-value-bind
              mvsetq multiple-value-setq)
@end lisp

Пользователь abbrevs не должен вставлять дополнительные скобки, потому что
abbrevs вызывает group (стр. 47) для группировки аргументов по два. Это
вообще хорошая вещь для макросов - избавить пользователей от логически ненужного
ввода скобок и group будет полезна для большинства таких макросов.

@cartouche
@lisp
 (defmacro propmacro (propname)
       `(defmacro ,propname (obj)
           `(get ,obj ',',propname)))

 (defmacro propmacros (&rest props)
       `(progn
           ,@@(mapcar #'(lambda (p) `(propmacro ,p))
                         props)))
@end lisp

                   Рисунок 16-2: Автоматическое определение макросов доступа.
@end cartouche

@node 16-2 Properties, Anaphoric Macros, 16-1 Abbreviations, 16 Macro-Defining Macros
@comment  node-name,  next,  previous,  up
@section 16-2 Свойства
@cindex 16-2 Properties

Lisp предлагает множество способов связать свойства с объектами. Если рассматриваемый
объект может быть представлен как символ, один из самых удобных(хотя и наименее 
эффективных) способов, заключается в использовании списка свойств символа. 
Чтобы описать тот факт, что объект o имеет свойство p, значение которого равно v, 
мы модифицируем список свойств o:

@lisp
(setf (get o p) v)
@end lisp

Итак, чтобы сказать что ball1 имеет красный(red/значение) цвет(color/свойство),
мы говорим:

@lisp
(setf (get 'ball1 'color) 'red)
@end lisp

Если мы будем часто ссылаться на некоторые свойства объектов, мы можем определить
макрос, чтобы получать их:

@lisp
(defmacro color (obj)
   `(get ,obj 'color))
@end lisp

и затем использовать color вместо get:

@example
> (color 'ball1)
RED
@end example

Поскольку вызовы макросов прозрачны для setf (см. Главу 12) мы также можем 
сказать:

@example
> (setf (color 'ball1) 'green)
GREEN
@end example

Такие макросы имеют преимущество в том, что скрывают конкретный способ, которым
программа представляет цвет(color) объекта. Списки свойств медленные: дальнейшие
версии программы могут, для увеличения скорости, представлять свойства, такие как
цвет(color) как поле в структуре, или как запись в хеш-таблице. Когда для получения
данных используется фасад макроса, такого как color, становиться легким, даже в
сравнительно зрелой программе, изменять код самого низкого уровня. Если программа
переключается с использования списков свойств, на использование структур, ничто не
выходит за рамки необходимости изменения макросов доступа; никакой код который
видит только фасад, не должен знать о перестройке, происходящей за ним.

Для свойства weight мы можем определить макрос, аналогичный написанному для
color:

@lisp
(defmacro weight (obj)
  `(get ,obj 'weight))
@end lisp

Подобно сокращениям в предыдущем разделе, определения color и weight почти
одинаковы. Здесь propmacro (Рисунок 16-2) может играть ту же роль, что и
abbrev выше.

Макрос определяющий макросы может быть разработан тем же процессом, что и любой другой
макрос: смотрим на вызов макроса, затем на его предполагаемое расширение, затем выясняем
как превратить первое во второе. Мы хотим

@lisp
(propmacro color)
@end lisp

расширить в

@lisp
(defmacro color (obj)
  `(get ,obj 'color))
@end lisp

Хотя это выражение само по себе является определением макроса defmacro, мы все же
можем создать его из шаблона, заключив его в обратные кавычки и поместив перед
именами параметров запятую вместо экземпляра color. Как и в предыдущем разделе,
мы начинаем с преобразования его таким образом, чтобы вынести все экземпляры
color из под обратных кавычек:

@lisp
(defmacro color (obj)
  (let ((p 'color))
        `(get ,obj ',p)))
@end lisp

Теперь мы идем вперед и делаем шаблон,

@lisp
`(defmacro ,propname (obj)
    (let ((p ',propname))
          `(get ,obj ',p)))
@end lisp

который упрощается до                                                                   

@lisp
`(defmacro ,propname (obj)
       `(get ,obj ',',propname))
@end lisp

Для случаев, когда вся группа  имен свойств должна быть определена как макросы,
есть propmacros (Рисунок 16-2), который расширяется в ряд индивидуальных вызовов
propmacro. Подобно abbrevs, этот скромный кусочек кода на самом деле является
макросом определяющим макросы определяющие макросы(macro-defining-macro-defining).

Хотя в этом разделе рассматриваются списки свойств, техника описанная здесь является
общей. Мы могли бы использовать её для определения макросов доступа к данным, хранящимся
в любой форме.

@node Anaphoric Macros,  , 16-2 Properties, 16 Macro-Defining Macros
@comment  node-name,  next,  previous,  up
@section 16-3 Анафорные Макросы
@cindex 16-3 Anaphoric Macros

Раздел 14-1 дал определения нескольких анафорических макросов. когда вы используете
макрос, подобные  aif или aand, при вычислении некоторых аргументов символ it будет
привязан к значению возвращаемому одним из предыдущих выражений. Так что вместо

@lisp
(let ((res (complicated-query)))
  (if res
           (foo res)))
@end lisp

@noindent
вы можете использовать просто

@lisp
(aif (complicated-query)
         (foo it))
@end lisp

@noindent
и вместо

@lisp
(let ((o (owner x)))
  (and o (let ((a (address o)))
                  (and a (city a)))))
@end lisp

@noindent
просто

@lisp
(aand (owner x) (address it) (city it))
@end lisp

В разделе 14-1 представлены семь анафорических макросов: aif, awhen, awhile, acond,
alambda, ablock, и aand. Эти семь ни в коем случае не являются единственными полезными
анафорическими макросами этого типа. На самом деле, мы можем определить анафорический
вариант любой функции или макроса Common Lisp. Многие из этих макросов будут похожи
на mapcon: редко используемыми, но незаменимыми при необходимости.

Например, мы можем определить a+ так, чтобы и с aand, it всегда был связан со
значением, возвращаемым предыдущим аргументом.  Следующая функция рассчитывает
стоимость обедов в Массачусетсе:

@cartouche
@lisp
 (defmacro a+ (&rest args)
    (a+expand args nil))

 (defun a+expand (args syms)
    (if args
         (let ((sym (gensym)))
            `(let* ((,sym ,(car args))
                         (it ,sym))
                ,(a+expand (cdr args)
                                 (append syms (list sym)))))
         `(+ ,@@syms)))

 (defmacro alist (&rest args)
    (alist-expand args nil))

 (defun alist-expand (args syms)
    (if args
         (let ((sym (gensym)))
            `(let* ((,sym ,(car args))
                         (it ,sym))
                ,(alist-expand (cdr args)
                                 (append syms (list sym)))))
         `(list ,@@syms)))
@end lisp

                   Рисунок 16-3: Определение a+ и alist.
@end cartouche

@lisp
(defun mass-cost (menu-price)
  (a+ menu-price (* it .05) (* it 3)))
@end lisp

Налог на еду в Массачусетсе составляет 5%, и жители часто расчитывают утроенный
налог. По этой формуле, общая стоимость жареных морепродуктов от Dolphin
Seafood будет:

@example
> (mass-cost 7-95)
9-54
@end example

но это включает в себя салат и печный картофель.

Макрос a+, определенный на Рисунке 16-3, основан на рекурсивной функции  a+expand,
генерирующей его расширение. Общая стратегия  a+expand состоит в том, чтобы остаток
списка(cdr) передавался как аргумент в вызов макроса, генерируя последовательность
вложенных выражений let; каждый let оставляет it связанным с другим аргументов, но
также связывает определенный gensym

@cartouche
@lisp
 (defmacro defanaph (name &optional calls)
        (let ((calls (or calls (pop-symbol name))))
         `(defmacro ,name (&rest args)
             (anaphex args (list ',calls)))))

 (defun anaphex (args expr)
       (if args
            (let ((sym (gensym)))
               `(let* ((,sym ,(car args))
                         (it ,sym))
                   ,(anaphex (cdr args)
                                (append expr (list sym)))))
            expr))

 (defun pop-symbol (sym)
       (intern (subseq (symbol-name sym) 1)))
@end lisp

               Рисунок 16-4: Автоматическое определение анафорических макросов.
@end cartouche

с каждым аргументом. Функция расширения накапливает список этих gensyms, и когда он
достигает конца списка аргументов, она возвращает выражение + с gensyms в качестве
аргументов. Итак, выражение

@lisp
(a+ menu-price (* it .05) (* it 3))
@end lisp

дает расширение макроса:

@lisp
(let* ((#:g2 menu-price) (it #:g2))
  (let* ((#:g3 (* it 0-05)) (it #:g3))
        (let* ((#:g4 (* it 3)) (it #:g4))
           (+ #:g2 #:g3 #:g4))))
@end lisp

       Рисунок 16-3 также содержит аналогичное определение alist:

@example
> (alist 1 (+ 2 it) (+ 2 it))
(1 3 5)
@end example

Еща раз, определения a+ и alist почти идентичны. Если мы хотим, определить больше
макросов подобных этим, они также будут в основном дублировать их код. Зачем?
Разве у нас нет программ для их создания? Макрос defanaph на Рисунке 16-4 будет
это делать. С defanaph, определение a+ и alist также просто как

@lisp
(defanaph a+)
(defanaph alist)
@end lisp

Расширения a+ и alist определенные таким образом, будут идентичны расширениям
сделанным с помощью кода на Рисунке 16-3. Макрос defanaph создающий макро 
определение создаст анафорический вариант чего-либо, чьи аргументы вычисляются
в соответствии с обычным правилом вычисления для функций. То есть, defanaph будет
работать на чем угодно, чьи аргументы все вычисляются и вычисляются с лева на 
право. Так что вы не можете использовать эту версию defanaph для определения
aif или awhile, но вы можете использовать ее для определения анафорного варианта
любой функции.

    Как a+ вызывает a+expand для создания своего расширения, defanaph определяет
макрос, который вызовет anaphex что бы сделать тоже самое. Общий расширитель 
anaphex отличается от a+expand только получением как аргумента имени функции,
которое должно появиться в конце расширения. Фактически, a+ теперь можно
определить:

@lisp
(defmacro a+ (&rest args)
  (anaphex args '(+)))
@end lisp

Ни для anaphex, ни для a+expand нет необходимости в определении их как отдельных
функций: anaphex мог быть определен с помощью labels или alambda внутри defanaph.
Генераторы расширения здесь разбиты на отдельные функции только лишь для ясности.

По умолчанию, defanaph определяет, что вызывать при расширении откинув первую
букву (предположительно a(анафор)) из своего первого аргумента. (Эту операцию
выполняет pop-symbol.) Если пользователь предпочитает указать альтернативное
имя, он может быть передан в качестве необязательного аргумента. Хотя defanaph
может может создавать анафорические варианты всех функций и некоторых макросов,
он накладывает некоторые досадные ограничения:

@enumerate
@item
Он работает только для операторов, все аргументы которых вычисляются.
@item
В разложении макроса it всегда связывается с последовательными аргументами. А в
некоторых случаях - например в awhen - мы хотим, чтобы it оставалось связанным
со значением первого аргумента.
@item
Он не будет работать для такого макроса как setf, который ожидает обобщенную
переменную в качестве первого аргумента.
@end enumerate

Давайте рассмотрим, как снять некоторые из этих ограничений. Часть первой проблемы
может быть решена путем решения второй. Чтобы создать расширение для макроса подобного
aif нам нужна модифицированная версяи anaphex, которая заменяет только первый аргумент
в вызове макроса:

@lisp
(defun anaphex2 (op args)
  `(let ((it ,(car args)))
        (,op it ,@@(cdr args))))
@end lisp

Эта не рекурсивная версия anaphex не должна гарантировать, что разложение макроса
будет связывать it с результатами вычисления последовательных аргументов макроса,
чтобы он мог генерировать расширение, которое не обязательно вычисляет все аргументы
указванные в вызове макроса. Только первый аргумент должен быть вычислен, чтобы 
связать it с его значением. Так aif может быть определен как:

@lisp
(defmacro aif (&rest args)
       (anaphex2 'if args))
@end lisp

Это определение будет отличаться от оригинала на странице 191 только в том месте
где оно будет выдавать жалобу, если в aif будет переадано неправильное количество
аргументов; для корректного вызова макроса, эти два определения создают идентичные
расширения.

Третья проблема, которая заключается в том, что defanaph не будет работать с
обобщенными переменными, может быть решена с помощью использования в расширении
функции _f (стр. 173). Операторы, такие как setf, могут быть обработаны
вариантом anaphex2 определяемым следующим образом:

@lisp
(defun anaphex3 (op args)
       `(_f (lambda (it) (,op it ,@@(cdr args))) ,(car args)))
@end lisp

Этот расширитель предполагает, что вызов макроса будет иметь один или несколько
аргументов, первый из которых будет обобщенной переменной. Используя его мы можем
определить asetf таким образом:

@lisp
(defmacro asetf (&rest args)
       (anaphex3 'setf args))
@end lisp

На Рисунке 16-5 показаны все три функции расширители, объединенные под управлением
одного макроса, нового defanaph. Пользователь сообщает тип требуемого расширения 
макроса с помощью необязательного параметра, ключевого слова, котоый указывает
правило вычисления, которое будет использоваться аргументов в вызове макроса. Если
этот параметр является:

:all (по умолчанию) расширение макроса будет идти по модели alist. Все аргументы в
         вызове макроса будут вычислены, причем it всегда будет связан со значением
         предыдущего аргумента.

:first расширение макроса будет происходит по модели aif. Только первый аргумент 
         будет обязательно вычислен и it будет связано с его значением.

:place  разложение будет идти по модели asetf. Первый аргумент будет рассматриваться как
         обобщенная переменная и  it будет связан с её первоначальным значением.

Используя новый defanaph, некоторые из предыдущих примеров будут определены 
следующим образом:

@cartouche
@lisp
 (defmacro defanaph (name &optional &key calls (rule :all))
    (let* ((opname (or calls (pop-symbol name)))
             (body (case rule
                        (:all       `(anaphex1 args '(,opname)))
                        (:first `(anaphex2 ',opname args))
                        (:place `(anaphex3 ',opname args)))))
        `(defmacro ,name (&rest args)
           ,body)))

 (defun anaphex1 (args call)
    (if args
         (let ((sym (gensym)))
            `(let* ((,sym ,(car args))
                       (it ,sym))
                ,(anaphex1 (cdr args)
                                 (append call (list sym)))))
         call))

 (defun anaphex2 (op args)
    `(let ((it ,(car args))) (,op it ,@@(cdr args))))

 (defun anaphex3 (op args)
    `(_f (lambda (it) (,op it ,@@(cdr args))) ,(car args)))
@end lisp

                     Рисунок 16-5: Более общий defanaph.
@end cartouche

@lisp
(defanaph alist)
(defanaph aif :rule :first)
(defanaph asetf :rule :place)
@end lisp

Одним из преимуществ asetf явтяется то, что он позволяет определить большой класс
макросов на обобщенных переменных, не беспокоясь о множественном вычислении.
Например, мы можем определить incf как:

@lisp
(defmacro incf (place &optional (val 1))
  `(asetf ,place (+ it ,val)))
@end lisp

@noindent
и описать pull (стр. 173) как:

@lisp
(defmacro pull (obj place &rest args)
  `(asetf ,place (delete ,obj it ,@@args)))
@end lisp