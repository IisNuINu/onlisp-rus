@node 7 Macros, 8 When to Use Macros, 6 Functions as Representation, Top
@comment  node-name,  next,  previous,  up
@chapter 7 Макросы
@cindex 7 Macros

Макросы Lisp позволяют ввам определять операторы, которые реализуют преобразования.
Определение макроса по суте является функцией, которая генерирует Lisp код, программа
которая пишет программы Из этих небольших начинаний возникают большие возможности, а 
также неожиданые опасности. Главы 7-­10 составляют учебное пособие о макросах.
Эта глава объясняет, как работают макросы, дает примемы их написания и тестирования,
и рассматривает проблемы использования макро стиля.

@menu
* 7-1 How Macros Work::         
* 7-2 Backquote::               
* 7-3 Defining Simple Macros::  
* 7-4 Testing Macroexpansion::  
* 7-5 Destructuring in Parameter Lists::  
* 7-6 A Model of Macros::       
* 7-7 Macros as Programs::      
* 7-8 Macro Style::             
* 7-9 Dependence on Macros::    
* 7-10 Macros from Functions::  
* 7-11 Symbol Macros::          
@end menu

@node 7-1 How Macros Work, 7-2 Backquote, 7 Macros, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-1 Как работает Макрос
@cindex 7-1 How Macros Work

Поскольку макросы могут вызываться и возвращать значения, они, как правило, связаны
с функциями. Определения макросов иногда напоминают определения функций и неофициально
люди называют то что на самом деле является макросом - "встраиваемой функцией." Но эта
слишком далеко идущая аналогия может стать источником путаницы. Макросы работают по
другому, нежели обычные функции, и знание как и чем макросы отличаются от функций, это
ключ к их правильному ипользованию. Функция выдает результаы, а макрос выдает(производит)
выражения, которые при вычислении, дают результаты.

Лучший способ начать - перейти прямо к примеру. Предположим, мы хотим написать
макрос nil!, который устанавливает свой аргумент в значение nil. Мы хотим чтобы
(nil! x) имел тот же эффект что и выражение (setq x nil). Мы сделаем это
определив nil! как макрос, который превращает экземпляры первой формы в 
в экземпляры второй формы.

@example
> (defmacro nil! (var)
      (list 'setq var nil))
NIL!
@end example

Перефразируя на Русский, это определение говорит Лиспу: "Всякий раз, когда ты видишь
выражение вида (nil! var), преврати его в форму вида (setq var nil), прежде чем его
вычислить."

Выражение сгенерированное макросом, будет вычислено вместо исходного вызова макроса.
Вызов макроса это список, первым элементом которого является имя макроса.
Что происходит, когда мы вводим вызов макроса (nil! x) на верхнем уровне? Лисп
замечает что nil! это имя макроса, и:

@enumerate
@item
строит выражение, указанное в приведенном выше определении, затем
@item
вычисляет это выражение вместо исходного вызова макроса.
@end enumerate

Шаг построения нового выражения называется расширением макроса(macroexpansion). Лисп
смотрит на данное выше определение nil!, которое показывает как создать замену для 
вызова макроса. Определение nil! применяется как функция к выражениям приведенным в 
качестве аргументов в вызове макроса. Он(вызов) возвращает список из трех элементов: 
setq, выражение переданное в качестве аргумента макроса и  nil. В нашем случае, аргумент
переданный в nil! это x, и расшерение макроса равно (setq x nil).

После расширения макроса наступает второй шаг, вычисление. Lisp вычисляет расширение
макроса - (setq x nil) как если бы вы ввели его, а не вызов макроса. Вычисление 
не всегда происходит сразу после расширения, как это происходит на верхнем уровне.
Вызов макроса, находящийся в определении функции будет расширен когда функция
компилируется, но расширение - или объектный код, который получается из него -
не будет вычисляться, до тех пор, пока функция не будет вызывана.

Многих трудностей связанных с макросами, с которыми вы может столкнуться, можно
избежать, поддежкой четкого разделения между расширением макроса и вычислением.
Когда пишут макросы, знают какие вычисления выполняются во время макрорасширения,
и какие во время выполнения, эти два шага обычно воздейтсуют на объекты разных
сортов. Шаг расширения макроса касается выражений, и шаг вычисления касается их
значений.

Иногда расширение макроса может быть более сложным, чем в случае nil!. Расширение nil!
было вызовом встроенной специальной формы, но иногда расширение макроса будет еще
одним вызовом макроса, как русская матрешка, которая содержит в себе еще одну матрешку.
В таких случаях расширение макроса просто продолжается пока оно не достигнет выражения,
которое не является вызовом макроса. Процесс может занять сколько угодно шагов, пока 
расширение не закончиться.

Многие языки предлагают некоторые формы макросов, на макросы Лиспа являются единсвенными
мощными. Когда файл Лиспа компилируется, парсер(разборщик синтаксических выражений) читает
исходный код и отправляет его в компилятор. Вот гениальный штрих: вывод парсера состоит
из списков объектов Лисп. С помощью макросов, мы можем манипулировать программой, в то
время как она находиться в промежуточной форме, между парсером и компилятором.
Если необходимо эти манипуляции могут быть очень обширными. Макрос, генерирующий 
расширение, обладает всеми возможностями Лисп. Действительно, макрос это действительно
функция Лисп, та, которая возвращает выражения. Определение nil! содержит один вызов
функции list, но другой макрос, может вызвать целую подпрограммму для генерации
своего расширения.

Возможность изменить то, что видит компилятор, почти как возможность переписать этот
код. Мы можем добавить любую конструкцию к языку, которую мы можем определить как
преобразование в существующие конструкции.

@node 7-2 Backquote, 7-3 Defining Simple Macros, 7-1 How Macros Work, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-2 Обратная кавычка
@cindex 7-2 Backquote

Обратная кавычка(Backquote) это специальная версия кавычки(цитирования), которую
можно использовать для создания шаблонов выражений Лисп. Одним из наиболее распространенных
применений обратной кавычки, является определение макросов.

Символьный знак обратная кавычка(backquote), `, назван так потому, что он напоминает
обычную кавычку, ', перевернутуня наоброт. Когда к выражению добавляется одна обратная
кавычка, она ведет себя точно также как и обычная кавычка:

@lisp
                         `(abc)is equal to '(abc).
@end lisp

Обратная кавычка становиться полезной только тогда, когда она появляется в сочетании
с запятой(,) и запятой с "собакой" (,@@). Если обратная кавычка создает шаблон, запятая
создает слот внутри шаблона. Список с предшествующей обратной кавычкой эквивалентен вызову
команды list с закоментированными элементами. То есть,

@lisp
                    `(a b c) is equal to (list 'a 'b 'c).
@end lisp

В рамках обратной кавычки, знак запятой говорит Лиспу: "здесь надо отключить режим цитирования."
Когда перед одним из элементов списка появляется запятая, она имеет эффект отмены его цитирования,
который был бы к нему применен. Так

@lisp
                 `(a ,b c ,d) is equal to (list 'a b 'c d).
@end lisp

Вместо символа b, его ЗНАЧЕНИЕ вставляется в результирующий список. Запятые работают
не зависимо от того как глубоко они появляются во вложенном списке,

@example
> (setq a 1 b 2 c 3)
3> `(a ,b c)
(A 2 C)
> `(a (,b c))
(A (2 C))
@end example

и они могут даже появляться после кавычки, или внутри квотированного подсписка:

@example
> `(a b ,c (',(+ a b c)) (+ a b) 'c '((,a ,b)))
(A B 3 ('6) (+ A B) 'C '((1 2)))
@end example

Одна запятая противодействует эффекту одной обратной кавычки, поэтому запятые
должны соответствовать обратным кавычкам. Скажем, что запятая окружена определенным
оператором, если оператор ставиться перед запятой или перед выражением, которое её
содержит. Например, в `(,a ,(b `,c))), последняя запятая окружена одной запятой и
двумя обратными кавычками. Общее правило таково: запятая окруженная n запятыми должна
быть окружена минимум n+1 обратной кавычкой. Очевидным следствием является то, что запятая
не может появляться за пределами выражений окруженных обратной кавычкой. Обратные кавычки
и запятые могут быть вложенными, пока подчиняются правилу указанному выше. Любое из  следующих
выражений сгенерирует ошибку, если его ввести на верхнем уровне:

@lisp
             ,x      `(a ,,b c)        `(a ,(b ,c) d)         `(,,`a)
@end lisp

Вложенные обратные кавычки, вероятно понадобятся только в макросах, определяющих макросы.
И то и другое обсуждается в главе 16.

Обратная кавычка используется для создания списков.@footnote{Обратная
кавычка также может использоваться для создания векторов, но это редко
делается в определениях макросов.} Любой список, сгенерированный обратной 
кавычкой также  может быть сгенерирован с использвоанием list и обычных кавычек. 
Преимущество обратных кавычек заключается лишь в том, что она облегчает
чтение выражений, поскольку выражение которое цитирует обратная кавычка,
напоминает выражение, которое она создает. В предыдущем разделе мы определили
nil! как:

@lisp
(defmacro nil! (var)
  (list 'setq var nil))
@end lisp

С помощью обратной кавычки тот же макрос может быть определен как:

@lisp
(defmacro nil! (var)
  `(setq ,var nil))
@end lisp

которое в этом случае не так уж и отличается от предыдущего. Тем не менее, чем длинне
определение  макроса, тем более важно использовать обратную кавычку. Рисунок 7-1 содержит
два возможных определения nif, макроса, который выполняет трехстороннее числовое выражение
if. @footnote{Этот макрос определен немного коряво, чтобы избежать использования gensyms. 
Лучшее определение дано на странице 150.}

Первый аргумент должен вычисляться как число. Второй, третий или четверый аргументы
вычисляются, в зависимости от того, был ли первый аргумент положительным, нулевым или
отритцательным:

@example
> (mapcar #'(lambda (x)
                     (nif x 'p 'z 'n))
                '(0 2-5 -8))
(ZPN)
@end example

@cartouche
с использованием обратных кавычек:

@lisp
 (defmacro nif (expr pos zero neg)
        `(case (truncate (signum ,expr))
             (1 ,pos)
             (0 ,zero)
             (-1 ,neg)))
@end lisp

без обратной кавычки:

@lisp
 (defmacro nif (expr pos zero neg)
        (list 'case
                 (list 'truncate (list 'signum expr))
                 (list 1 pos)
                 (list 0 zero)
                 (list -1 neg)))
@end lisp

                 Рисунок 7-1: Определение макроса с и без обратных кавычек.
@end cartouche

Два определения на рисунке 7-1 определяют один и тот же макрос, но первое использует
обратные кавычки, в то время как второе строит свое расширение путем явных
вызовов команды list. Например, из первого определения легко уведить, что (nif x 'p 'z 'n)
расширяется в

@lisp
(case (truncate (signum x))
      (1 'p)
      (0 'z)
      (-1 'n))
@end lisp

потому что тело определения макроса выглядит так же, как генерируемое им расширение.
Чтобы понять вторую версию, без обратных кавычек, вы должны проследить в своей голове
создаваемое расширение.

Запятая с "собакой", ,@@, это вариант запятой. Он ведет себя как запятая, с одним
отличием: вместо того, чтобы просто вставить значение выражения, к которому оно
прикрепляется, как это делает запятая, запятая с "собакой" вшивает этот результат. 
Вшивание можно рассматривать как вставку с удалением самого верхнего уровня скобок:

@example
> (setq b '(1 2 3))
(1 2 3)
@end example

@lisp
> `(a ,b c)
(A (1 2 3) C)

> `(a ,@@b c)
(A 1 2 3 C)
@end lisp

Запятя приводит к тому, что список (1 2 3) вставляется вместо  b, в то время как
запятая с "собакой" вызывает вставку туда элементов списка. Есть некоторые дополнительные
ограничения на использование запятой с "собакой":

@enumerate
@item
Для объединения аргументов, запятая с "собакой" должны быть заключены в некоторую последовательность.
          Ошибочно написать, что то вроде @code{`,@@b}, потому, что не с чем склеивать значение b.
@item
Объект, который должен быть "вшит", должен быть списком, если он не является последним элементом. 
          Выражение @code{`(a ,@@1)} будет вычислено в @code{(a . 1)}, но попытка вшить атом в
          середину списка, как в @code{`(a ,@@1 b)}, вызовет ошибку.
@end enumerate

Запятая с "собакой" имеет тенденцию использоваться в макросах, которые принимают
неопределенное число аргументов и передают их функциям или макросам, которые также
принимают неопределенное количество аргументов. Такая ситуация обычно возникает при
реализации неявных блоков. Common Lisp имеет несколько операторов для группировки кода
в блоки, включая block, tagbody и  progn. Эти операторы редко появляются непосредственно
в сиходном коде; они чаще скрыты, т.е скрыты макросами.

Неявный block встречается в любом встроенном макросе, который может иметь
тело выражений. Например, и let, и cond предоставляют неявный progn. 
Простейшим встроенным макросом использующим это вероятно является when:

@lisp
(when (eligible obj)
  (do-this)
  (do-that)
  obj)
@end lisp

Если (eligible obj) возвращает истину, остальные выражения будут вычислены, и
выражение when в целом. вернет значение последнего выражения. В качестве примера
использования запятой с "собакой", вот одно из возможных определений для when:

@lisp
(defmacro our-when (test &body body)
  `(if ,test
             (progn
                ,@@body)))
@end lisp

Это определение использует параметр &body (идентичный &rest за исключением его эффекта
для красивой печати) чтобы принять произвольное количество аргументов, и запятую с "собакой"
для "вшивания" их в выражение progn. При расширении макроса вызванного выше, три выражения
тела появляются в пределах одного progn:

@lisp
(if (eligible obj)
       (progn (do-this)
                (do-that)
                obj))
@end lisp

Большинство макросов для итераций "вшивают" свои аргументы аналогичным образом.

Эффект запятой с "собакой" может быть достигнут без обратных кавычек. Например,
выражение @code{`(a ,@@b c)} эквивалентно (cons 'a (append b (list 'c))). 
Запятая с "собакой" используется только для того, чтобы сделать выражения генерирующие
выражения более читабельными.

Макро определения (обычно) генерируют списки. Хотя расширения макроса могут
быть построены с использованием функции list, цитированные с помощью обратных
кавычек шаблоны списков делают эту задачу значительно легче. Определение макросов
с помощью defmacro и обратных кавычек, будет внешне напоминать функцию определенную
с помощью defun. Пока вы не введены в заблуждение этим подобием, обратные кавычки
делают опредление макроса и более легкими для написания и более легкими для чтения.

Обратные кавычки, так часто используют в определениях макросов, что люди иногда думают,
что обратные кавычки это часть defmacro. Последнее, что нужно помнить о обратных кавычках,
это то, что у нее есть собственная жизнь, отдельная от её роли в определениях макросов.
Вы можете использовать обратную кавычку, где угдно, где необходимо строить 
последовательность:

@lisp
(defun greet (name)
      `(hello ,name))
@end lisp

@node 7-3 Defining Simple Macros, 7-4 Testing Macroexpansion, 7-2 Backquote, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-3 Определение Простых Макросов
@cindex 7-3 Defining Simple Macros

В программировании, зачастую, лучший способ научиться - начать экспериментировать.
Полное теоретическое понимание может прийти позже. Соответственно, в этом разделе
представлен способ немедля начать писать макросы. Это работает только для узкого
круга случаев, но там где это применимо, его можно применять довольно механически.
(Если вы уже писали макросы ранее, вы пожете пропустить этот раздел.)

В качестве примера, мы рассмотрим как написать вариант встроенной функции Common
Lisp - member. По умолчанию функция member использует eql для проверки на равенство.
Если вы хотите проверять членство используя eq, вы должны прямо сказать:

@lisp
(member x choices :test #'eq)
@end lisp

Если бы мы делем это много раз, мы могли бы написать вариант member который всегда
использовал бы eq. В некоторых, более ранних диалектах Lisp быта такая функция,
которая называлась memq:

@lisp
(memq x choices)
@end lisp

Обычно мы определяем memq как встраиваемую функцию, но для примера мы перевоплотим
ее как макрос.

@cartouche
@example
         call:                  (memq x choices)

         expansion: (member x choices :test #'eq)
@end example

                       Рисунок 7-2: Диаграмма, используемая при написании memq.
@end cartouche

Методика написания макросов: Начните с типичного вызова макроса, который вы
хотите определить. Напишите его на листе бумаги, и ниже него запишите выражение,
в которое он должен расширяться. Рисунок 7-2 показывает два таких выражения.
Из вызова макроса, создайте список параметров для вашего макроса, сочинив некоторое
имя параметра для каждого из аргументов. В нашем случае есть два аргумента, поэтому
у нас будет два параметра, и назовем их obj и lst:

@lisp
(defmacro memq (obj lst)
@end lisp

Теперь вернитесь к двум выражениям, которые вы записали ниже. Для каждого аргумента в
вызове макроса, нарисуйте линию, соединяющую его с местом, где он появляется в 
расширении ниже. На рисунке 7-2 есть две параллельные линии. Чтобы написать тело
макроса, обратите ваше внимание на расширение. Начните тело с обратной кавычки. 
Теперь, начнем чтение выражения расширения по одному выражению. Где бы вы ни нашли
скобки, они не являются частью аргумента в вызове макроса, поместите их(скобки) в 
определение макроса, так чтобы за обратной кавычкой была левая скобка. 
Для каждого выражения в расширении

@enumerate
@item
Если нет линии соединяющей его с вызовом макроса, запишите это выражение
@item
Если есть соединение с одним из аргументов в вызове макроса, напишите далее
символ, который находитсья в соответствующей позиции списка параметров макроса,
поставьте перед ним запятую.
?@@end enumerate

Здесь нет связи с первым элементом, member, поэтому мы ипользуем само название member:

@lisp
(defmacro memq (obj lst)
  `(member
@end lisp

Тем не менее, x имеет линию, ведущую к первому аргументу в исходном выражении, поэтому мы
используем в теле макроса первый параметр, с запятой:

@lisp
(defmacro memq (obj lst)
  `(member ,obj
@end lisp

Продолжая таким образом, завершаем определение макроса:

@cartouche
@lisp
 (while hungry
       (stare-intently)
       (meow)
       (rub-against-legs))

 (do ()
         ((not hungry))
       (stare-intently)
       (meow)
       (rub-against-legs))
@end lisp

                      Рисунок 7-3: Диаграмма используемая в написании макроса while.
@end cartouche

@lisp
(defmacro memq (obj lst)
      `(member ,obj ,lst :test #'eq))
@end lisp

Пока что мы можем писать макросы, которые принимают фиксированное количество
аргументов. Теперь предположим, что мы хотим написать макрос while, который принимает
тестовое выражение и некоторое тело кода, и циклически проходит по коду(выполняет его),
до тех пор пока тестовое выражение не возвратит истину. Рисунок 7-3 содержит пример
цикла while описывающего поведение кошки.

Чтобы написать такой макрос, мы должны немного изменить нашу методику. Как и прежде,
начнем с записи примера вызова макроса. Из него(вызова) построим список параметров
макроса, но там где вы хотите принять неопределенное количество аргументов, завершите
их параметром &rest или &body:

@lisp
(defmacro while (test &body body)
@end lisp

Теперь напишите нужное расширение под вызовом макроса, и как и раньше, нарисуйте
линии соединяющие аргументы в вызове макроса с их позицией в расширении.
Тем не менее, когда у вас есть последовательность аргументов, которые будут собраны
в один параметр &rest или &body, рассматривайте их как группу, рисуя одну линию для
всей последовательности. Рисунок 7-3 показывает полученную диаграмму.

Чтобы написать тело определения макроса, продолжайте как и прежде идти вдоль расширения.
Как и два предыдущих правила, нам нужно еще одно:

?@@enumerate
@item
3. Если есть связь из ряда выражений в расширении к ряду аргументов в вызове макроса,
         запишите соответствующий параметр &rest или &body, поставив перед ним запятую
         с "собакой".
@end enumerate

Таким образом, полученное определение макроса будет:

@lisp
(defmacro while (test &body body)
  `(do ()
            ((not ,test))
         ,@@body))
@end lisp

Чтобы построить макрос, который должен иметь body выражения, некоторый параметр
должен действовать как воронка. Здесь несколько аргументов в вызове макроса 
объединяются в body, а затем снова распадаются, когда body "вшивается" в расширение.

Подход описанный в этом разделе, позволяет нам написать простейшие макросы -
те, которые просто перетасовывают свои параметры. Макросы могут много больше
этого. Раздел 7-7 представит примеры, где расширения не могут быть представлены
в виде простых списков с обратными кавычками, и генерирующие их программы. Макросы 
становяться программами сами по себе.

@node 7-4 Testing Macroexpansion, 7-5 Destructuring in Parameter Lists, 7-3 Defining Simple Macros, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-4 Проверка Расширения Макросов
@cindex 7-4 Testing Macroexpansion

Имея написанный макрос, как мы можем его протестировать? Макрос типа memq достаточно
прост, так что достаточно просто взглянув на него сказать что он будет делать. При
написании более сложных макросов, мы должны быть в состоянии проверить, правильно
ли они расширяются.

На рисунке 7-4 показано определение макроса и два способа увидеть как он
расширяется. Встроенная функция macroexpand принимает выражение и возвращает
его расширенние макроса. Отправка вызова макроса в macroexpand показывает, как
вызов макроса будет до конца развернут(расширен), перед его вычислением. Но
полное расширение, это не всегда то что вы хотите, чтобы проверить макрос.
Когда рассматриваемый макрос основывается на других макросах, они тоже будут
расширены, поэтому полное расширение иногда может быть трудно прочитать.

По первому выражению, показанному на Рисунке 7-4, трудно сказать, действительно ли
while расширяется как задумано, потому что встроенный макрос do так же расширяется.
так же как и макрос prog который тоже расширяется. Что нам нужно, это способ увидеть
результат только после одного шага расширения. Это цель встроенной функции macroexpand-1, 
показанной во втором примере; macroexpand-1 останавливается после всего лишь одного шага,
даже если расширение все еще является вызовом макроса.

Когда мы хотим посмотреть на расширение вызова макроса, как бы нибыло неприятно,
всегда нужно набирать

@lisp
(pprint (macroexpand-1 '(or x y)))
@end lisp

Рисунок 7-5 определяет новый макрос, который вместо этого позволяет нам сказать:

@lisp
(mac (or x y))
@end lisp

Обычно вы отлаживаете функции, вызывая их, а макросы - расширяя их. Но так как
вызов макроса включает в себя два уровня вычислений, существует два

@cartouche
@example
 > (defmacro while (test &body body)
          `(do ()
              ((not ,test))
            ,@@body))
 WHILE

 > (pprint (macroexpand '(while (able) (laugh))))

 (BLOCK NIL
      (LET NIL
          (TAGBODY
           #:G61
           (IF (NOT (ABLE)) (RETURN NIL))
           (LAUGH)
           (GO #:G61))))
 T> (pprint (macroexpand-1 '(while (able) (laugh))))
 (DO NIL
          ((NOT (ABLE)))
      (LAUGH))
 T
@end example
                  Рисунок 7-4: Макрос и две глубины его расширения.
@end cartouche

@cartouche
@lisp
 (defmacro mac (expr)
      `(pprint (macroexpand-1 ',expr)))
@end lisp

                  Рисунок 7-5: Макрос для тестирования макрорасширения.
@end cartouche

точки, где все может пойти не так. Если макрос работает не правильно, в большинстве
случаев вы можете сказать, что что то не так, просто взглянув на расширение. Тем не
менее, иногда, расширение будет выглядеть хорошо, и вы захотите вычислить его, чтобы
увидеть, где возникают проблемы.  Если расширение содержит свободные переменные, вы
можете сначала установить несколько переменных. В некоторых системах вы можете
скопировать расширение и вставить его на верхний уровень REPL, или выделить его и 
выбрать команду eval из меню. В худшем случае, вы можете установить переменную значением
списка возвращаемого из macroexpand-1, и затем вызвать eval для него:

@example
> (setq exp (macroexpand-1 '(memq 'a '(a b c))))
(MEMBER (QUOTE A) (QUOTE (A B C)) :TEST (FUNCTION EQ))
> (eval exp)
(ABC)
@end example

Наконец, расширение макросов это больше чем помощь в отладке, это еще один путь
научиться писать макросы. Common Lisp имеет более сотни встроенных макросов,
некоторые из них довольно сложные. Глядя на расширения этих макросов, вы часто
будете в состоянии увидеть, как они были написаны.

@node 7-5 Destructuring in Parameter Lists, 7-6 A Model of Macros, 7-4 Testing Macroexpansion, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-5 Деструктуризация в Списке Параметров
@cindex 7-5 Destructuring in Parameter Lists

Деструктуризация это обобщение вида присваивания
assignment@footnote{Деструктуризация обычно наблюдается в операторах,
которые создают привязки, а не выполняют присваивание. Тем не менее,
концептуально, деструктуризация это способ присваивания значений, который
будет также работать как длся существующих переменных, так и для новых. 
Т.е ничто не мешает написать нам деструктуризацию setq.} выполняемого вызовами
функций. Если вы определяете функцию от нескольких аргументов

@lisp
(defun foo (x y z)
   (+ x y z))
@end lisp

тогда, когда функция вызывается

@lisp
(foo 1 2 3)
@end lisp

параметрам функции присваиваются аргументы при вызове в соответствии с их положением:
x значение 1, y значение 2, и z значение 3. Деструктуризация описывает ситуацию, когда
такого рода позиционное присваивание выполняется для произвольных списковых структур, а
также для плоских списков, таких как (x y z).

Common Lisp макрос destructuring-bind (новый в CLTL2) принимает образец(шаблон), аргумент
вычисляющийся в список, и тело выражений, и вычисляет выражения с параметрами связывающимися
по образцу с соответствующими элементами списка:

@example
> (destructuring-bind (x (y) . z) '(a (b) c d)
         (list x y z))
(A B (C D))
@end example

Этот новый оператор и другие, подобные ему, составляют предмет главы 18.

Деструктуризация также возможна в списках параметров макроса. В Common Lisp
defmacro позволяет спискам параметров быть произвольными списковыми структурами.
Когда вызов макроса расширяется, компоненты вызова будут присвоены параметрам как
если бы использовался destructuring-bind. Встроенный макрос dolist использует
преимущества такой деструктуризации списка параметров. В вызове, подобном:

@lisp
(dolist (x '(a b c))
      (print x))
@end lisp

функция расширения должна "вырвать" x и '(a b c) из списка, заданного как первый аргумент.
Это может быть сделано неявным образом, передавая dolist соответствующий список параметров:
@footnote{Эта версия написана таким странным образом, чтобы избежать использования gensyms, 
который мы еще не ввели в употребление.}

@lisp
(defmacro our-dolist ((var list &optional result) &body body)
      `(progn
           (mapc #'(lambda (,var) ,@@body)
                    ,list)
           (let ((,var nil))
              ,result)))
@end lisp

В Common Lisp, макросы подобные dolist обычно заключют с список аргументы, 
не являющиеся частью тела(вычисляемых выражений). Поскольку он принимает
не обязательный аргумент result, dolist в любом случае должен заключать свои
первые аргументы в отдельный список. Но даже если дополнительная списковая структура
не нужна, она облегчает чтение вызовов dolist.
Предположим, мы хотим определить макрос when-bind, такой как when за исключением, что
он привязывает некоторую переменную к значению возвращаемому тестовым выражением. 
Этот макрос может быть реализован с помощью вложенного списка параметров:

@lisp
(defmacro when-bind ((var expr) &body body)
      `(let ((,var ,expr))
           (when ,var
              ,@@body)))
@end lisp

и вызывается следующим образом:

@lisp
(when-bind (input (get-user-input))
      (process input))
@end lisp

вместо:

@lisp
(let ((input (get-user-input)))
      (when input
          (process input)))
@end lisp

При экономном использовании, деструктуризация списка параметров може привести к
более четкому коду. Как минимум, ее можно использовать в макросах, таких как 
when-bind и dolist, которые принимают два или более аргументов, сопровождаемых
телом - последовательностью выражений.

@cartouche
@lisp
 (defmacro our-expander (name) `(get ,name 'expander))

 (defmacro our-defmacro (name parms &body body)
       (let ((g (gensym)))
          `(progn
              (setf (our-expander ',name)
                      #'(lambda (,g)
                            (block ,name
                              (destructuring-bind ,parms (cdr ,g)
                                ,@@body))))
              ',name)))

 (defun our-macroexpand-1 (expr)
       (if (and (consp expr) (our-expander (car expr)))
            (funcall (our-expander (car expr)) expr)
            expr))
@end lisp

                           Рисунок 7-6: Эскиз defmacro.
@end cartouche

@node 7-6 A Model of Macros, 7-7 Macros as Programs, 7-5 Destructuring in Parameter Lists, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-6 Модель Макросов
@cindex 7-6 A Model of Macros

Формальное описание что делают макросы, будет длинным и запутанным. Оптный
программист все равно не хранит это описание в своей голове. Ему более
удобно помнить, что делает defmacro представляя как он будет определен.

В Лиспе существует давняя традиция подобных объяснений. Руководство по программированию
для Lisp 1.5, впервые опубликованное в 1962 году, дает для справки определение
eval написанного на Лиспе. Поскольку defmacro сам по себе является макросом, мы можем
дать ему тоже самое определение как на Рисунке 7-6. Это определение использует несколько
методов, котоыре еще не были рассмотрены, поэтому некоторые читатели, если захотят,
могут обратитсья к нему позже.

Определение на рисунке 7-6 дает довольно точное представление о том, что делает
макрос, но, как и любой набросок это представление неполное. Наше определение
не будет обрабатывать ключевое слово &whole должным образом. И что на самом деле
defmacro сохранается в качестве макро-функции своего первого аргумента - это 
функция от двух аргументов: вызова макроса, и лексического окружения в котором
происходит вызов. Тем не менее,  эти функции(свойства) используются в основном
в эзотерических макросах. Если вы будете работать в предположении, что макросы
реализуются так как показано на рисунке 7-6, вы вряд ли ошибетесь. Каждый макрос
определенный в этой книге будет работать, например.

Определение на рисунке 7-6 дает функцию расширения, которая является закоментированным
кавычкой с решеткой('#) лямбда выражением. Это должно сделать ее замыканием: любые 
свободные символы в определении макроса должны ссылаться на переменные в окружении,
где произошло определение макроса(вызов defmacro). Так что можно сказать следующее:

@lisp
(let ((op 'setq))
      (defmacro our-setq (var val)
         (list op var val)))
@end lisp

Что касается CLTL2, это так. Но в CLTL1, расширители макросов определяются в нулевом лексическом
окружении,@footnote{Для примера макроса, где это различие имеет значение, смотри примечание на
стр. 393.} поэтому в некоторых старых реализациях, определение our-setq не будет работать.

@node 7-7 Macros as Programs, 7-8 Macro Style, 7-6 A Model of Macros, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-7 Макросы как Программы
@cindex 7-7 Macros as Programs

Определение макроса не обязательно должно быть списком заключенным в обратные кавычки.
Макрос это функция, которая превращает один вид выражений в другой. Эта функция может
вызывать функцию list для создания своего результата, но может также вызывать целую
подпрограмму, состоящую из сотен строк кода.

Раздел 7-3 дал простой способ написания макросов. Используя эту методику, мы можем
писать макросы, чьи расширения содержат те же подвыражения, и в вызове макроса. 
К сожалению, только самые простые макросы соответствуют этому условию. Как более
сложный пример, рассмотрим встроенный макрос do. Невозможно написать do как макрос,
который просто перетасовывает свои параметры. Расширение должно создавать сложные
выражения, которые никогда не появляются в вызове макроса.

Более общий подход к написанию макросов - думать о виде выражении, которое вы хотите
использовать(первая форма), расширренном в то что вы хотите получить(вторая форма), 
и затем написать программу, которая  преобразует первую форму во вторую. Попробуйте
расширить премер от руки, а затем посмотрите, что происходит, когда одна форма
превращается в другую. Работая на примерах, вы сможете получить представление(идеи) 
о том, что потребуется для реализации вашего макроса.

На Рисунке 7-7 показан экземпляр do, и выражение в которое его следует расширить.
Выполнение расширения в ручную - это хороший способ прояснить ваши идеи о том, как
макрос должен работать. Например, это может быть не очевидно, пока не попробуешь
написать расширение, что локальные переменные должны быть обновлены с использванием
psetq.

Встроенный макрос psetq (называемый "параллельный(parallel) setq") ведет себя как
setq, за исключением того, что все его (четные) аргументы будут вычислены до любого
из выполняемых присвоений. Если обычный setq имеет более двух аргументов, то новое
значение первого аргумента будет видно во время вычисления последующих(например четвертого):

@cartouche
@lisp
 (do ((w 3)
           (x 1 (1+ x))
           (y 2 (1+ y))
           (z))
         ((> x 10) (princ z) y)
       (princ x)
       (princ y))
@end lisp

должно быть расширено в нечто подобное:

@lisp
 (prog ((w 3) (x 1) (y 2) (z nil))
        foo
         (if (> x 10)
               (return (progn (princ z) y)))
         (princ x)
         (princ y)
         (psetq x (1+ x) y (1+ y))
        (go foo))
@end lisp

                         Рисунок 7-7: Желаемое расширение do.
@end cartouche

@example
> (let ((a 1))
        (setq a 2 b a)
        (list a b))
(2 2)
@end example

Здесь, поскольку a устанавливается первым, b получает новое значение, 2. Предполагается
что psetq ведет себя как если бы все его аргументы присваиваются параллельно:
@example
> (let ((a 1))
        (psetq a 2 b a)
        (list a b))
(2 1)
@end example

Таким образом, здесь b получает старое значение a. Макрос psetq предоставляется специально
для поддержки макросов, таких как  do, которые должны вычислять некоторые свои аргументы
параллельноe.
(Если бы мы использовали setq, мы бы в место этого определили do*.)

Глядя на расширение, также становитсья ясно, что мы не можем использовать foo как
метку цикла(loop). Что если foo также используется как метка цикла(loop) в теле
do? Глава 9 подробно рассматривает эту проблему; пока достаточно сказать, что вместо
использования foo в макросе, расширение макроса должно использовать специальный
анонимный символ возвращаемый функцией gensym.

@cartouche
@lisp
 (defmacro our-do (bindforms (test &rest result) &body body)
      (let ((label (gensym)))
        `(prog ,(make-initforms bindforms)
            ,label
            (if ,test
                 (return (progn ,@@result)))
            ,@@body
            (psetq ,@@(make-stepforms bindforms))
            (go ,label))))

 (defun make-initforms (bindforms)
      (mapcar #'(lambda (b)
                      (if (consp b)
                          (list (car b) (cadr b))
                          (list b nil)))
                bindforms))

 (defun make-stepforms (bindforms)
      (mapcan #'(lambda (b)
                      (if (and (consp b) (third b))
                          (list (car b) (third b))
                          nil))
                bindforms))
@end lisp

                           Рисунок 7-8: Реализация do.
@end cartouche

Чтобы написать do, мы рассмотрим, что потребуется для преобразования первого
выражения на Рисунке 7-7 во второе. Чтобы выполнить такое преобразование,
на нужно сделать больше, чем просто получить и установить параметры макроса
в правильные позиции какого-то цитированного обратной кавычкой списка. За
начальным prog должен следовать список символов и их начальные привязки,
которые должны быть извлечены из второго аргумента переданного do. Функция
make-initforms на Рисунке 7-8 вернет тако список. Мы также должны построить
список аргументов для psetq, но этот случай более сложный, потому что не все 
символы должны быть обновлены. На рисунке 7-8, make-stepforms возвращает 
аргументы для psetq. С этими двумя функциями, остальная чать определения
становиться довольно простой.

Код на рисунке 7-8 отличается от того, как написано в официапльной реализации.
Чтобы подчеркнуть вычисления, сделанные во врмея расширения, make-initforms и 
make-stepforms былил разбиты на отдельные функции. В будущем, такой код обычно
будет оставться в выражении defmacro.

С определением этого макроса, мы начинаем видеть, что могут делать макросы. 
Макрос имеет полный доступ к Lisp при построении расширения. Код используемый
для рарширения может сам по себе быть программой.

@node 7-8 Macro Style, 7-9 Dependence on Macros, 7-7 Macros as Programs, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-8 Стиль Макросов
@cindex 7-8 Macro Style

Хороший стиль означает нечто другое для макросов. Стиль имеет значени, когда код
либо читается людьми либо вычисляется Lisp. С макросами, оба эти действия происходят
при немного необычных обстоятельствах.

Существуепт два различных вида кода, связанный с определением макроса: код 
расширителя, это код используемый макросом для генерации своего расширения, и
код расширения, который появляется в самом расширении. Для каждого из этих типов кода
принципы стиля разные. Для программы в целом, иметь хороший стиль - значит быть ясной
и эффективной. Этот принцип изменяется в противоположных направлениях в этих двух типах
кода макроса: код расширителя может отдать предпочтение ясности над эффективностью, а
код расширения может отдать предпочтение эффективности над ясностью.

Эффективность важнее всего в скомпилированном коде, а в компилированном коде
вызовы макросов уже расширены. Если код расширителя был эффективен, его компиляция
прошла бы немного быстрее, но это не повлияет на то, насколько хорошо работает
программа. Поскольку расширение вызовов макросов, составляет лишь небольшую часть
из работы, выполняемой компилятором, макросы которые расширяются эффективно, обычно
не оказывают большого значения даже на скорость компиляции. Вы можете безопасно 
написать код расширителя способом наиболее быстрым, как и первую версию программы.
Если расширитель кода делает ненужную работу или много тратит, ну и что? 
Ваше время лучше потратить на улучшение других частей программы.  Конечно, если в
коде расширителя есть выбор между ясностью и скоростью, выбрать ясность предпочтительнее.
Определения макросво обычно тяжелее читать, чем определения функций, потому что они содержат
смесь выражений, вычисляемых в различное время. Если эта путаница может быть уменьшена за
счет уменьшения эффективности кода расширителя, это будет хорошим выбором.

Например, предположим, что мы хотели версию and and как макрос.
Поскольку (and a b c) эквивалентно (if a (if b c)), мы може написать and в терминах
if как в первом определении на Рисунке 7-9. Согласно стандартам по которым мы
судим об обычном коде, our-and написан плохо. Код расширителя рекурсивный, и в
каждой рекурсии ищет длину последующих cdrs одного и того же списка. Если этот
код будет вычисляться во время выполнения, было бы лучше определить этот макрос
как в our-andb, который генерирует такое же расширение не тратя услий в пустую.
Тем не менее, в качестве определения макроса our-and о очень хорош, если не лучший.
Он может быть не эффективен по длительности вызова для каждой рекурсии, но его 
организация показывает более ясно, каким образом расширение зависит от числа
коньюнктов(аргументов and).

@cartouche
@lisp
 (defmacro our-and (&rest args)
       (case (length args)
         (0 t)
         (1 (car args))
         (t `(if ,(car args)
                    (our-and ,@@(cdr args))))))

 (defmacro our-andb (&rest args)
       (if (null args)
            t(labels ((expander (rest)
                            (if (cdr rest)
                                `(if ,(car rest)
                                      ,(expander (cdr rest)))
                                (car rest))))
               (expander args))))
@end lisp

                      Рисунок 7-9: Два макроса, эквивалентных and.
@end cartouche

Как всегда, здесь есть исключения. В Лиспе, различие между временем компиляции и
временем выполнения является искуственным, поэтому любое правило, которое зависит от
него, также искуственно. В некоторых программах время компиляции является временем
выполнения. Если вы пишете программу основной целью которой является преобразование
и для этого используете макросы, все меняется: код расширителя становитсья вашей
программой и расширение её выводом. Конечно, при таких обстоятельствах код расширителя
должен быть написан с учетом эффективности. Тем не менее, можно с уверенностью сказать,
что большинство расширителей кода (a) влияют только на сокрость компиляции, и (b) не
сильно на него и влияют, т.е ясность почти всегда должна быть на первом месте.

С кодом расширения все наоборот. Ясность менее важна для расширения макроса, потому
что на нее редко смотрят, особенно другие люди.  Запрещенные goto не полностью
запрещенн в расширениях, и пренебрегаемый setq не совсем так уж пренебрегаем.

Сторонники структурного программирования не любили goto за то что он делал
с исходным кодом(а он превращал его в "лапшу"). Это были не инструкции jump
машинного языка, которые они считали вредными - до тех пор пока они были
скрыты абстрактными конструкциями в исходном коде. Goto осуждены в Lisp именно
потому, что их так легко спрятать: вместо них вы можете использовать  do, и если
у вас его нет, вы можете написать его. Конечно, если мы собираемся создавать новые
абстракции поверх goto, goto будет существовать. Таким образом, это не обязательно
плохой стиль использовать go в определении нового макроса,  если его нельзя написать
в терминах какого-либо существующего макроса.

Точно так же использование setq не одобряется, потому что трудно увидеть, где
данная переменная получает свое значение. Однако, расширение макроса не будет
читаться многими людьми, поэтому обычно использование setq для создания переменных
приносит мало вреда в рамках расширения макроса. Если вы посмотрите на расширения
некоторых из встроенных макросов, вы можете увидеть довольно много setq.

Несколько обстоятельств могут сделать ясность более предпочтительной в расширенном 
коде генерируемым макросом. Если вы пишете сложный макрос, вы можете читать
расширение, по крайней мере пока, пока вы отлаживаете макрос. Кроме того, в простых
макросах, только обратная кавычка разделяет расширяющий код от расширенного кода, 
поэтому если такие макросы генерируют не красивые расширения, его корявость будет
слишком видна в вашем исходном коде. Тем не менее, даже когда ясность кода расширения
становиться проблемой, эффективность все еще должна быть в приоритете. Эффективность
важна в большинстве кода работающем во время выполнения. Две вещи делают это особенно
важным для макро расширений: их повсеместность и невидимость.

Макросы часто используются для реализации утилит общего назначения, которые
затем вызываются в программах везде. То что используется так часто, не может
позволить себе быть неэффективным. То что похоже на безобидный маленький макрос,
может после расширения всех обращений к нему составлять значительную часть вашей
программы. Такой макрос должен получать больше внимания, чем казалось бы требует
его длина. Особенно избегайте consing. Утилита которая требует ненужных усилий, 
может испортить производительность программы, которя в противном случае была бы
эффективной.

Другая причина взглянуть на эффективность расширенного кода - это его невидмость.
Если функция плохо реализована, это будет видно, каждый раз когда вы будет смотреть
на ее определение. Но это не так с макросами. Из определения макроса, не очевидна 
не эффективность в расширенном коде, что является еще одной причиной смотреть на него.

@node 7-9 Dependence on Macros, 7-10 Macros from Functions, 7-8 Macro Style, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-9 Зависимость от макросов
@cindex 7-9 Dependence on Macros

Если вы переопределите функцию, другие функции, вызывающие ее, автоматически
получат новую версию.@footnote{За исключение встраиваемых функций, которые
накладывают те же ограничения на переопределение, что и макросы.}  То же самое
не всегда верно для макросов. Вызов макроса, который происходит в опеделении
функции заменяется в ней его расширением, когда функция компилируется. Что если 
мы переопределим макрос после вызова компиляции функции? Поскольку не осталось никаких
следов первоначального вызова макроса, расширени внутри функции не может быть
обновлено. поведение функции будет отражать старое определние макоса:

@example
> (defmacro mac (x) `(1+ ,x))
MAC
@end example

@example
> (setq fn (compile nil '(lambda (y) (mac y))))
#<Compiled-Function BF7E7E>
> (defmacro mac (x) `(+ ,x 100))
MAC
> (funcall fn 1)
2
@end example

Подобные проблемы возникают, если код вызывающий некоторый макрос, скомпилирован
раньше самого определения макроса. CLTL2 говорит что "определение макроса должно
быть видно компилятором перед первым использованием макроса." Реализации по разному
отвечают на нарушение этого правила.К счастью, легко избежать обоих типов проблемы.
Есил вы придерживаетесь следующих двух принципов, вам не нужно беспокоиться о устаревших
или несуществующих определениях макросов:

@enumerate
@item
     1.Определяйте макросы перед функциями(или макросами) которые вызывают их.
@item
     2. Когда макрос переопределен, также перекомпилируйте все функции(или макросы)
которые вызывают его, напрямую или через другой макрос.
@end enumerate

Было предложено поместить все макросы программы в отдельный файл, чтобы было проще
убедиться, что определения макросов компилируются первыми. Т.е убрать их подальше.
Разумно было бы ставить универсальные макросы, такие как  while в отдельный файл, но
утилиты общего назначения должны быть отделены от остальной части программы в любом
случае, будь то функции или макросы.

Некоторые макросы написаны только для использования в одной определенной части
программы и они должны быть определены вместе с кодом, который их использует.
Пока определение каждого макроса появляется перед любыми обращениями к нему,
ваши программы скомпилируются нормально. Сбор всех ваших макросов, просто потому
что они макросы, не будет делать ничего, кроме как уложнять чтение вашего кода.

@node 7-10 Macros from Functions, 7-11 Symbol Macros, 7-9 Dependence on Macros, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-10 Макросы из функций
@cindex 7-10 Macros from Functions

В этом разделе описывается, как преобразовать функии в макросы. Первый шаг в переводе
функции в макрос это спросить себя, нужно ли вам это делать. Не можете ли вы с таким же
успехом объявить функцию встраиваемой(inline) (стр. 26)?

Однако, есть несколько законных причин для рассмотрения того, как перевести функции в
макросы. Когда вы начинаете писать макросы, иногда это помогает думать так, как если
бы вы пишете функцию - подход, которые обычно дает не совсем правильные макросы, но
которые по крайней мере, дают вам кое - что для начала работы. Другая причина взглянуть
на связь между макросами и функциями, чтобы увидеть как они отличаются. Наконец, 
Lisp программисты иногда хотят преобразовать функции в макросы.

Сложность перевода функции в макрос зависит от ряда свойств функции. Самый простой класс
для перевода - это функции, которые

@enumerate
@item

   1. Имеют тело, состоящее из одного выражения
@item

   2. Имеют список параметров, состоящий только из имен параметров.
@item

   3. Не создают новых переменных (кроме параметров).
@item

   4. Не являются рекурсивными (и не являются частью взаимно рекурсивной группы).
@item

   5. Не имеют параметров которые встречаются в теле более одного раза.
@item

   6. Не имеют параметра, значение которого используется другим параметром
      стоящим перед ним в списке параметров.
@item

   7. Не содержат свободных переменных.
@end enumerate

Одной из функций, которая соответствует всем этим критериям, является встроенная 
функция Common Lisp second, которая возвращает второй элемен списка. Она может быть
определена:

@lisp
(defun second (x) (cadr x))
@end lisp

Если определение функции удовлетворяет всем вышеуказанным условиям,
вы можете легко преобразовать ее в эквивалентное определение макроса.
Просто поставьте обратную кавычку перед телом и запятую перед каждым 
символом из списка параметров:

@lisp
(defmacro second (x) `(cadr ,x))
@end lisp

Конечно, макрос нельзя вызывать при всех одинаковых обстоятельствах. Он не может
быть доступен в качестве первого аргумента для apply или funcall, и его не 
следует вызывать в окружении, где вызываемые им функции имеют новые локальные 
привязки. Хотя, для обычных встраиваемых вызовов, макрос second должен выполнять
тоже самое, что и функция second.

Техника немного меняетя когда тело имеет более одного выражения, потому что макрос
должен расширяться в одно выражение, так что если условие 1 не выполняется, вы
должны добавить команду progn. Функция noisy-second:

@lisp
(defun noisy-second (x)
  (princ "Someone is taking a cadr!")
  (cadr x))

может быть продублирована следующим макросом:
(defmacro noisy-second (x)
  `(progn
        (princ "Someone is taking a cadr!")
        (cadr ,x)))
@end lisp

Когда функция не соответствует условию  2 потому что она имеет параметр &rest 
или &body, правила теже, за исключением того, что этот параметр, а не просто
запятая перед ним, должен быть "вшит" в вызов команды list. Таким образом

@lisp
(defun sum (&rest args)
  (apply #'+ args))
@end lisp

становиться

@lisp
(defmacro sum (&rest args)
  `(apply #'+ (list ,@@args)))
@end lisp

который в этом случае будет лучше переписать как:

@lisp
(defmacro sum (&rest args)
  `(+ ,@@args))
@end lisp

Когда условие 3 не выполняется - когда новые переменные создаются в  теле функции
- правило о вставке запятых должно быть изменено. Вместо вставки запятых перед всеми
символами в списке параметров, мы ставим их до тех пор, пока переменные сслылаются на
эти параметры. Например, в:

@lisp
(defun foo (x y z)
  (list x (let ((x y))
                  (list x z))))
@end lisp

ни один из последующих двух эземпляров x не ссылается на параметр x. Второй экзепляр
не вычисляется вообще, и третий экземпляр ссылается на новую переменную установленную
let. Так что только первый экземпляр x получит запятую:

@lisp
(defmacro foo (x y z)
  `(list ,x (let ((x ,y))
                     (list x ,z))))
@end lisp

Функции иногда могут быть преобразованы в макросы когда условия 4, 5 и 6 не выполнены. 
Тем не менее, эти темы рассматриваются в последующих главах отдельно. Проблема рекурсии
в макросах рассматривается в Разделе 10-4, и опасность множественных и неправильных(неупорядоченных)
вычислений в разделе 10-1  и 10-2, соответственно.

Что касается условия 7, то можно моделировать замыкания с помощью макросов, используя
технику похожую на ошибку(error) описанную на стр. 37. Но учитывая что это низкоуровевый
хак, не созвучный с основным тоном этой книги, мы не будем вдаваться в подробности.

@node 7-11 Symbol Macros,  , 7-10 Macros from Functions, 7 Macros
@comment  node-name,  next,  previous,  up
@section 7-11 Макросы Символы
@cindex 7-11 Symbol Macros

CLTL2 ввел новый тип макросов в Common Lisp, это макрос-символ(symbol-macro).
В то время как обычный вызов макроса выглядит как вызов функции, "вызов" 
макроса-символа выглядит как символ.

Макрос-символ может быть определен только локально. Специальная форма symbol-macrolet
внутри своего тела может заставить одиночный символ вести себя как выражение:

@example
> (symbol-macrolet ((hi (progn (print "Howdy")
                                         1)))
        (+ hi 2))
"Howdy"
3
@end example

Тело symbol-macrolet будет вычисляться так, как будто каждый аргумент в позции hi
будет заменен на (progn (print "Howdy") 1).

Концептуально, макросы символы похожи на макросы, которые не принимают никаких аргументов.
Без аргументов, макросы становятся просто текстовыми сокращениями. Однако, это не говорит
что макросы символы бесполезны. Они используются в главе 15 (стр 205)
и главе 18 (стр 237), и в последнем случае они не заменимы.