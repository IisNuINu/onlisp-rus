@node 10 Other Macro Pitfalls, 11 Classic Macros, 9 Variable Capture, Top
@comment  node-name,  next,  previous,  up
@chapter 10 Другие Ошибки в Макросах
@cindex 10 Other Macro Pitfalls

Написание макросов требует особой осторожности. Функция изолирована в своем собственном
лексическом мире, но макрос. поскольку он расширяется в вызывающем его коде, может
преподнести пользователю неприятный сюрприз, если он не будет написан очень тщательно.
Глава 9 обяснила захват переменных, самый большой подобный сюрприз. В этой главе
рассматриваются больше проблем, чтобы избежать их при определении макросов.
@menu
* 10-1 Number of Evaluations::  
* 10-2 Order of Evaluation::    
* 10-3 Non-functional Expanders::  
* 10-4 Recursion::              
@end menu

@node 10-1 Number of Evaluations, 10-2 Order of Evaluation, 10 Other Macro Pitfalls, 10 Other Macro Pitfalls
@comment  node-name,  next,  previous,  up
@section 10-1 Число Вычислений
@cindex 10-1 Number of Evaluations

Несколько неправильных версий for появились в предыдущей главе. Рисунок 10-1
показывает еще два, в сопровождении правильной версии для сравнения.

Хотя он не уязвим к захвату, второй for содержит ошибку. Он будет создавать
расширение в котором, форма переданная в качестве условия остановки(stop) будет
вычисляться на каждой итерации. В лучшем случае, этот вид макроса не эффективен,
многократно вычислять то, что можно вычислить один раз. Если stop имеет сторонние
эффекты, макрос на самом деле может дать неправильные результаты. Например, этот
цикл никогда не прекратиться, потоу что цель отступает(отодвигается) на каждой 
итерации:

@example
> (let ((x 2))
     (for (i 1 (incf x))
        (princ i)))
12345678910111213...
@end example

При написании макросов подобных for нужно помнить, что аргументы макроса это
формы, а не значения. В зависимости от ого, где они появляются в расширении,
они могут вычислятья более одного раза.

@cartouche
Правильная версия:

@lisp
 (defmacro for ((var start stop) &body body)
       (let ((gstop (gensym)))
         `(do ((,var ,start (1+ ,var))
                 (,gstop ,stop))
                ((> ,var ,gstop))
             ,@@body)))
@end lisp

Подлежит многократному вычислению:

@lisp
 (defmacro for ((var start stop) &body body)
       `(do ((,var ,start (1+ ,var)))
             ((> ,var ,stop))
           ,@@body))
@end lisp

Неверный порядок вычилений:

@lisp
 (defmacro for ((var start stop) &body body)
       (let ((gstop (gensym)))
         `(do ((,gstop ,stop)
                 (,var ,start (1+ ,var)))
                ((> ,var ,gstop))
             ,@@body)))
@end lisp

                    Рисунок 10-1: Управление вычислением аргументов
@end cartouche

В этом случае решение состоит в том, чтобы привязать переменную к значению возвращающему
формой stop, и обращаться к этой переменной во время цикла.

Если они явно не предназначены для итерации, макросы должны гарантировать, что
выражения вычисляются ровно столько раз, сколько они появляются в вызове макроса.
Сущствуют очевидные случаи, когда это правило не применяется: Common Lisp
или будет менее полезным (он станет Pascal или) если все его рагументы будут
всегда вычисляться. Но в таких случаях пользователь точно знает сколько вычислений
ожидать. Это не так для второй версии for: у пользователя нет причин предполагать,
что форма stop вычисляетя более одного раза и на самом деле нет причин, по которым
это должно происходить. Макрос написанный подобно второй версии for вероятнее всего
написан так по ошибке.

Непреднамеренные множественные вычисления являются особенно сложной проблемой для
макросов построенных на setf. Common Lisp предоставляет несколько утилит для упрощения
написания таких макросов. Эта проблема и её решение обсуждаются в Главе 12.

@node 10-2 Order of Evaluation, 10-3 Non-functional Expanders, 10-1 Number of Evaluations, 10 Other Macro Pitfalls
@comment  node-name,  next,  previous,  up
@section 10-2 Порядок вычислений
@cindex 10-2 Order of Evaluation

Порядок в котором вычисления выражений, хотя и не так важен, как количество их
вычислений, но иногда может стать проблемой. В Common Lisp при вызове функции,
аргументы вычисляются слева на право:

@example
> (setq x 10)
10
> (+ (setq x 3) x)
6
@end example

и хорошей практикой, будет, делать то же самое для макросов. Макросы обычно должны обеспечивать
вычисление выражений в том же порядке, в котором они появляются в вызове макроса.

На Рисунке 10-1, третья версия for также содержит хитрую ошибку. Параметр
stop будет вычисляться до параметра start, даже если они отображаются в обратном
порядке при вызове макроса:

@example
> (let ((x 1))
        (for (i x (setq x 13))
         (princ i)))
13
NIL
@end example

Этот макрос дает приводящее в замешательство ощущение о возвращении во времени. Вычисление
формы stop влияет на значение, возвращаемое формой start, даеж если форма start появляется 
в текстовом виде - первой.

Правильная весрия for гарантирует, что его аргументы будут вычисляться в том порядке,
в котором они появляются:

@example
> (let ((x 1))
        (for (i x (setq x 13))
         (princ i)))
12345678910111213
NIL
@end example

Теперь установка x в форме stop не повлияет на значение возвращаемое предыдущими
аргументами.

Хотя предыдущий пример является надуманным, есть случаи, когда подобного рода 
проблемы действительно происходили, и такую ошибку чрезвычайно сложно найти.
Возможно мало кто напишет код, в котором вычисление одного аргумента макроса
влияет на значение возвращаемое другим, но люди могут случайно сделать то, что
никогда бы не сделали нарочно. Утилита не должна маскировать ошибки, если 
используется по назначению. Если кто нибудь написал код, как в предыдущих примерах,
вероятно сделал он это по ошибке, но правильная версия for упростит обнаружение
ошибки.

@node 10-3 Non-functional Expanders, 10-4 Recursion, 10-2 Order of Evaluation, 10 Other Macro Pitfalls
@comment  node-name,  next,  previous,  up
@section 10-3 Не функциональный код Расширителя
@cindex 10-3 Non-functional Expanders

Lisp ожидает, что код, который генерирует расширение макросов, будет чисто функциональным,
в смысле описанным в Главе 3. Расширяющий код должен зависеть только от форм передаваемых
ему в качестве аргументов, и не должен оказвать влияние на мир, кроме как путем возвращения
значений.

Начиная с CLTL2 (стр. 685), можно с уверенностью предположить, что вызовы макросов
в скомпилированном коде не подлежит повторному расширению во время выполнения.
В противном случае, Common Lisp не дает никаких гарантий о том, когда и как часто
будет расширен вызов макроса. Считается ошибкой для расширения макроса варьироваться
в зависимости от того или друго. Например, предположим,  мы хотели посчитать, сколько
раз используется какой либо макрос. Мы не можем просто выполнить поиск по исходным
файлам, потому что макрос может быть вызван в коде, который генерируется самой программой.
Поэтому мы моглибы захотеть определить макрос следующим образом:

@lisp
(defmacro nil! (x)                                                           ; wrong
     (incf *nil!s*)
     `(setf ,x nil))
@end lisp

С этим определением, глобальный *nil!s* будет увеличиваться при каждом вызвове
расширения макроса nil!. Тем не менее, мы ошибаемся, если ожидаем, что значение
этой переменной скажат нам, как часто вызвался nil!. Данный вызов может быть
и частым, если он расширен более одного раза. Например, препроцессору, который
выполняет преобразования в вашем исходном коде, возможно, придется расширить
вызовы макросов в выражения, прежде чем он сможет определить, стоит ли его
преобразовывать.

Основное правило, код расширителя не должен зависеть ни от чего. кроме его 
аргументов. Так что любому макросу, например, который строит свое расширение
из строк, следует быть осторожным, чтобы не предполагать, что пакет от которого
зависит расширение макроса, будет загружен во время расширения. Это краткий, но
довольно патологический пример,

@lisp
(defmacro string-call (opstring &rest args)                                  ; wrong
     `(,(intern opstring) ,@@args))
@end lisp

@noindent
определяет макрос, который принимает печатное имя оператора и расширеят вызов к нему:

@example
> (defun our+ (x y) (+ x y))
OUR+
> (string-call "OUR+" 2 3)
5
@end example

Вызов intern принимает строку и возвращает соответствующий символ. Тем не менее,
если мы опускаем необязательный аргумент package(пакет), он делает это в текущем
пакете. Таким образом, расширение будет зависеть от текущего пакета во время
создания расширения, и если our+ не виден в этом пакете, расширение будет с вызовом
неизвестной функции.

Миллер и Бенсон в книге "Lisp Style and Design"(Лисп Стиль и Дизайн) упоминают
один особенно некрасивый прмер проблем, возникающих из-за побочных эффектов в
коде расширителя. В Common Lisp, начиная с CLTL2 (стр. 78), списки связанные с
параметром &rest не являются гарантированно новыми, свеже сформированными. Они
могут разделять структуру со списками находящимися в другим местах программы.
Следовательно, вы не должны разрушающе изменять параметр &rest,  потому что вы
не знаете, что еще вы измените при этом.

Эта возможность влияет как на функции, так и на макросы. С функциями, проблемы
возникают при использовании apply. В правильной реализаци Common Lisp может произойти
следующее. Предположим, мы определили функцию et-al, которая возвращает список
аргументов с добавлением  et al в конец:

@lisp
(defun et-al (&rest args)
  (nconc args (list 'et 'al)))
@end lisp

Если бы мы вызвавали эту функцию обычным образом, она бы работала нормально:

@example
> (et-al 'smith 'jones)
(SMITH JONES ET AL)
@end example

Однако, если мы вызываем ее через apply, она могла бы изменить существующие структуры
данных:

@example
> (setq greats '(leonardo michelangelo))
(LEONARDO MICHELANGELO)
> (apply #'et-al greats)
(LEONARDO MICHELANGELO ET AL)
> greats
(LEONARDO MICHELANGELO ET AL)
@end example

По крайней мере, правильная реализация Common Lisp могла бы сделать это, хотя,
кажется пока, так не делает никто.

Для макросов, опасность больше. Макрос который изменил параметр &rest тем самым
может изменить вызов макроса. То есть, вы можете случайно создать само-переписывающую
программу. Опасность этого также более реальна - эта на самом деле происходит при
использовании существующих реализаций лиспа. Если мы определим макрос, которые
соединяет(nconcs) нечто с его аргументом &rest @footnote {`',(foo) это эквивалент `(quote ,(foo)).}

@lisp
(defmacro echo (&rest args)
  `',(nconc args (list 'amen)))
@end lisp

и затем определим функцию, которая вызывает его:

@lisp
(defun foo () (echo x))
@end lisp

В одном широко используемом Common Lisp, произойдет следующее:

@example
> (foo)
(X AMEN AMEN)
> (foo)
(X AMEN AMEN AMEN)
@end example

foo не только возвращает неправильный результат, он каждый раз возвращает отличный от предыдущего
результат, потому что после каждого расширения макроса изменяется определение foo.

Этот пример также иллюстрирует высказанную ранее мысль о множественных расширениях
данного вызова макроса. В этой конкретной реализации, первый вызов foo возвращает
списки с двумя amens. По какой то причине эта реализация расширила вызов макроса
когда foo был определен, и также по одному разу в каждом из последующих его вызовов.

Было бы более безопасно определить echo как:

@lisp
(defmacro echo (&rest args)
  `'(,@@args amen))
@end lisp

потому что, запятая с "собакой"(comma-at) эквивалентны дополнению, а не nconc. 
После переопределения этого макроса, функцию foo тоже нужно будет переопределить,
даже если она не скомпилирована, потому что предыдущая версия echo вызвала его
перезапись.

В макросах этой опасности подвержены не только параметр &rest. Любой аргумент
макроса, который является списком, должен быть оставлен в покое. Если мы определим
макрос, который изменяет один из своих аргументов,  функцию которая его вызывает,

@lisp
(defmacro crazy (expr) (nconc expr (list t)))

(defun foo () (crazy (list)))
@end lisp

тогда исходный код вызывающей функции может быть изменен, как это происходит в одной
реализации лиспа. В первый раз мы вызваем ее:

@example
> (foo)
(T T)
@end example

Это происходит как в скомпилированном, так и в интерпретиуемом коде.

Заключение: не пытайтесь избежать конструирования списков путем деструктивного изменения
параметра являющегося списковой структурой. Получающиеся программы будут не переносимы,
если вообще будут работать. Если вам необходмо избежать конструирования списка(cons) в функции
которая принимает переменное количество аргументов,

одним из решений будет использование макроса, и таким образом, смещения конструирования
списка(consing) вперед, с времени выполнения, на время работы компилятора. Для такого
применения макросов, смотри Главу 13.

Также следует избегать разрушающих операций над выражениями возвращаемых расширителем
макроса, если эти выражения содержат заквотированные списки. Это не является ограничением
для макросов как таковых, но является примером принципа, изложенного в разделе 3-3.

@node 10-4 Recursion,  , 10-3 Non-functional Expanders, 10 Other Macro Pitfalls
@comment  node-name,  next,  previous,  up
@section 10-4 Рекурсия
@cindex 10-4 Recursion

Иногда естественно определять функцию рекурсивно. Имеется несколько по сути рекурсивных
функций функций подобных такой:

@lisp
(defun our-length (x)
  (if (null x)
          0(1+ (our-length (cdr x)))))
@end lisp

Это определение, кажется более естественным(хотя вероятно более медленным), чем
его итерационный эквивалент:

@lisp
(defun our-length (x)
  (do ((len 0 (1+ len))
           (y x (cdr y)))
          ((null y) len)))
@end lisp

Функция, которая не является ни рекурсивной, ни частью некоторого взаимнореурсивного
набора функций, может быть преобразована в макрос, с помощью простого метода, 
описанного в разделе 7-10. Однако, простая вставка кавычек и запятых не будет
работать с рекурсивной функцией. Давайте возьмем встроенный nth в качестве примера.
(Для простоты, наша версия nth не будет проверять ошибки.) На рисуноке 10-2 показана
ошибочная попытка определить nth как макрос. Внешне, nthb по видимому эквивалентно
ntha, но программа, содержащая вызов nthb не будет компилироваться, поскольку расширение
вызова никогда не прекратиться.

В целом, для макросов нормально содержать ссылки на другие макросы, если расширение
шаблона где то заканчивается. Проблема с nthb в том, что каждое расширение содержит
ссылку на сам nthb. Функциональная версия ntha завершается, потому что она получает
значение n, которое уменьшается при каждом рекурсивном вызове. Но расширитель макроса
имеет доступ только к формам, но не к их значениям. Когда компилятор пытается разширить
макрос, скажем (nthb x y), первое расширение даст

@lisp
(if (= x 0)
        (car y)
        (nthb (- x 1) (cdr y)))
@end lisp

@cartouche
 Это будет работать:

@lisp
 (defun ntha (n lst)
       (if (= n 0)
            (car lst)
            (ntha (- n 1) (cdr lst))))
@end lisp

 Это не компилируется:

@lisp
 (defmacro nthb (n lst)
       `(if (= ,n 0)
              (car ,lst)
              (nthb (- ,n 1) (cdr ,lst))))
@end lisp

                Рисунок 10-2: Ошибочная аналогия с рекурсивной функцией.
@end cartouche

который в свою очередь расшириться в:

@lisp
(if (= x 0)
        (car y)
        (if (= (- x 1) 0)
             (car (cdr y))
             (nthb (- (- x 1) 1) (cdr (cdr y)))))
@end lisp

и так далее в бесконечный цикл. Это нормально для макроса расширении иметь вызов самого себя,
если такое поведение рано или поздно заканчивается.

Опасная вещь в рекурсивных макросах, таких как nthb, в том, что они обычно хорошо
работают под интерпретатором. Затем, когда у вас наконец-то рабочая программа и
вы пытаетесь ее скомпилировать, она даже не компилируется. Хотя только это, но 
обычно это указывает на то, что проблема связана с рекурсивным макросом; компилятор
просто входит в бесконенчный цикл и оставляет вас в раздумьях, о том, что что-то
пошло не так.

В этом случае, ntha является хвостовой(хорошей) рекурсией. Функция с хвостовой рекурсией
может быть легко превращена в итерационный эквивалент, а затем использована в качестве
модели для макроса. Макрос типа nthb может быть написан

@lisp
(defmacro nthc (n lst)
  `(do ((n2 ,n (1- n2))
             (lst2 ,lst (cdr lst2)))
            ((= n2 0) (car lst2))))
@end lisp

поэтому, в принципе, возможно продублировать рекурсивную функцию с помощью макроса.
Однако, преобразование более сложных рекурсивных функций, может быть затруднено или
даже невозможно.

@cartouche
@lisp
 (defmacro nthd (n lst)
    `(nth-fn ,n ,lst))

 (defun nth-fn (n lst)
    (if (= n 0)
         (car lst)
         (nth-fn (- n 1) (cdr lst))))

 (defmacro nthe (n lst)
    `(labels ((nth-fn (n lst)
                       (if (= n 0)
                          (car lst)
                          (nth-fn (- n 1) (cdr lst)))))
        (nth-fn ,n ,lst)))
@end lisp

                    Рисунок 10-3: Два способа решения проблем.
@end cartouche

В зависимости от того, для чего вам нужен макрос, вы можете найти достаточным
для использование сочетания макроса и функции. Рисунок 10-3 показывает два способа
создать то, что кажеться рекурсивным макросом. Первая стратегия, воплощенная в nthd,
просто заставить расширяться макрос в вызов рекурсивной функции. Например, если
вам нужен макрос для того, чтобы избавить пользвателей от необходимости квотировать
аргументы, тогда такого подхода должно хватить.

Если вам нужен макрос, потому что вы хотите вставить всё его расширение в
лексическое окружение, где происходит вызов макроса, тогда вы, скорее всего,
захотите последовать примеру определяющему nthe. Встроенная метка специальной
формы (Раздел 2-7) создает локальное определение функции. В то время как, каждое
расширение nthc будет вызывать глобально определенную функцию nth-fn, каждое 
расширение nthe будет иметь свою собственную версию такой функции внутри себя.

Хотя вы не можете перевести рекурсивную функцию непосредственно в макрос, вы можете
написать макрос, расширение которого генерируется рекурсивно. Функция расширения
макроса это обычная функция Lisp и, конечно, она может быть рекурсивной. Например,
если бы мы определяли версию встроенного or, мы хотели бы использовать рекурсивную
функцию расширяния.

На рисунке 10-4 показаны два способа определить рекурсивную функцию расширения
для or. Макрос or вызывает рекурсивную функцию or-expand для генерации своего
расширения. Этот макрос будет работать, равно как и эквивалентный orb. Хотя
orb рекурсивный, он рекурсивен по аргументам макроса (которые доступны во
время расширения макроса), а не по их значениям (которые не доступны). Может
показаться, что расширение будет содержать ссылку на само себя orb, но вызов
orb генерируемый одним

@cartouche
@lisp
 (defmacro ora (&rest args)
       (or-expand args))

 (defun or-expand (args)
       (if (null args)
               nil
          (let ((sym (gensym)))
                `(let ((,sym ,(car args)))
                      (if ,sym
                         ,sym
                         ,(or-expand (cdr args)))))))

 (defmacro orb (&rest args)
       (if (null args)
          nil
          (let ((sym (gensym)))
                `(let ((,sym ,(car args)))
                      (if ,sym
                         ,sym
                         (orb ,@@(cdr args)))))))
@end lisp

                       Рисунок 10-4: Функции рекусрсивного расширения.
@end cartouche

шагом расширения макроса, будет заменен на let в следующем шаге, приводя окончательное
расширение, в ничто иное как стек вложенных let; (orb x y) расширяется в код
эквивалентный:

@lisp
(let ((g2 x))
  (if g2
         g2
         (let ((g3 y))
           (if g3 g3 nil))))
@end lisp

На самом деле ora и orb эквивалентны, и какой стиль использовать - это вопрос
личного предпочтения.