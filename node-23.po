#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-23.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 13:05+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-23.texi:5
msgid ""
"@node 23 Parsing with ATNs, 24 Prolog, 22 Nondeterminism, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 23 Parsing with ATNs\n"
"@cindex 23 Parsing with ATNs"
msgstr ""
"@node 23 Parsing with ATNs, 24 Prolog, 22 Nondeterminism, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 23 Разбор с ATN\n"
"@cindex 23 Parsing with ATNs"

#: texi/node-23.texi:11
msgid ""
"This chapter shows how to write a nondeterministic parser as an embedded "
"lan-\n"
"guage. The first part explains what ATN parsers are, and how they represent\n"
"grammar rules. The second part presents an ATN compiler which uses the "
"nonde-\n"
"terministic operators defined in the previous chapter. The final sections "
"present a\n"
"small ATN grammar, and show it in action parsing sample input."
msgstr ""
"В этой главе показано, как писать недетерминированный синтаксический "
"анализатор\n"
"как встроенный язык. Первая часть объясняет, что такое парсеры ATN и как "
"они\n"
"представляют граматические правила. Во второй части представлен компилятор "
"ATN\n"
"который использует недетерминированные операторы определенные в предыдущей "
"главе.\n"
"В заключительных разделах представлена небольшая граматика  ATN и она "
"показана\n"
"в действии при разборе входных данных."

#: texi/node-23.texi:19
msgid ""
"@menu\n"
"* 23-1 Background::             \n"
"* 23-2 The Formalism::          \n"
"* 23-3 Nondeterminism::         \n"
"* 23-4 An ATN Compiler::        \n"
"* 23-5 A Sample ATN::           \n"
"@end menu"
msgstr ""

#: texi/node-23.texi:24
msgid ""
"@node 23-1 Background, 23-2 The Formalism, 23 Parsing with ATNs, 23 Parsing "
"with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-1 Background\n"
"@cindex 23-1 Background"
msgstr ""
"@node 23-1 Background, 23-2 The Formalism, 23 Parsing with ATNs, 23 Parsing "
"with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-1 История Вопроса\n"
"@cindex 23-1 Background"

#: texi/node-23.texi:30
msgid ""
"Augmented Transition Networks, or ATNs, are a form of parser described by\n"
"Bill Woods in 1970. Since then they have become a widely used formalism "
"for  \n"
"parsing natural language. In an hour you can write an ATN grammar which "
"parses\n"
"interesting English sentences. For this reason, people are often held in a "
"sort of\n"
"spell when they first encounter them."
msgstr ""
"Расширенная Сеть Переходов(Augmented Transition Networks), илиr ATNs, "
"является видом\n"
"синтаксического анализатора, описанного  Bill Woods в 1970. С тех пор они "
"стали широко\n"
"используемым формализмом для анализа естественного языка. Через час вы "
"сможете\n"
"написать граматику ATN, которая анализирует интересные предложения на "
"английском\n"
"языке. По этой причине людей часто держат в некоем заклинании, когда они "
"впервые\n"
"сталкиваются с ними."

#: texi/node-23.texi:35
msgid ""
"In the 1970s, some people thought that ATNs might one day be components\n"
"of truly intelligent-seeming programs. Though few hold this position today, "
"ATNs\n"
"have found a niche. They aren't as good as you are at parsing English, but "
"they\n"
"can still parse an impressive variety of sentences."
msgstr ""
"В 1970-х некоторые люди думали, что  ATN смогут однажды стать компонентами \n"
"действительно интеллектуальных программ. Хотя немногие занимают эту "
"позицию \n"
"сегодня, ATN нашли свою нишу. Они не так хороши, как вы при разборе "
"английского,\n"
"но они все же могут анализировать впечатляющее разнообразие предложений."

#: texi/node-23.texi:37
msgid "ATNs are useful if you observe the following four restrictions:"
msgstr "ATN полезны если вы соблюдаете следующие четыре ограничения:"

#: texi/node-23.texi:54
msgid ""
"@enumerate\n"
"@item\n"
"Use them in a semantically limited domain-in a front-end to a particular\n"
"database, for example.\n"
"@item\n"
"Don't feed them very difficult input. Among other things, don't expect\n"
"them to understand wildly ungrammatical sentences the way people can.\n"
"@item\n"
"Only use them for English, or other languages in which word order deter-\n"
"mines grammatical structure. ATNs would not be useful in parsing inflected\n"
"languages like Latin.\n"
"@item\n"
"Don't expect them to work all the time. Use them in applications where it's\n"
"helpful if they work ninety percent of the time, not those where it's "
"critical\n"
"that they work a hundred percent of the time.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Используйте их в семантически ограниченном домене - например, во внешнем\n"
"интерфейсе конкретной базы данных.\n"
"@item\n"
"Не скармливайте им слишком сложный ввод. Помимо прочего, не ожидайте, что \n"
"они поймут дико не грамотные предложения так, как это могут люди.\n"
"@item\n"
"Используйте их только для английского или других языков, в которых порядок\n"
"слов определяет грамматическую структуру. ATN не будут полезны при разборе\n"
"таких языков как латынь.\n"
"@item\n"
"Не ожидайте, что они будут работать все время. Используйте их в "
"предложениях,\n"
"где это полезно, если они работают 90 процентах случаев, а не в тех, где\n"
"важно, чтобы они работали в 100 процентах случаев.\n"
"@end enumerate"

#: texi/node-23.texi:59
msgid ""
"Within these limits there are plenty of useful applications. The canonical "
"example\n"
"is as the front-end of a database. If you attach an ATN-driven interface to "
"such\n"
"a system, then instead of making a formal query, users can ask questions in "
"a\n"
"constrained form of English."
msgstr ""
"В этих пределах есть много полезных приложений. Канонический пример - это "
"внешний\n"
"интерфейс базы данных. Если к такой системе подключить интерфейс, "
"управляемый\n"
"ATN, то вместо формального запроса пользователи могут задавать вопросы в "
"ограниченной\n"
"форме английского языка."

#: texi/node-23.texi:64
msgid ""
"@node 23-2 The Formalism, 23-3 Nondeterminism, 23-1 Background, 23 Parsing "
"with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-2 The Formalism\n"
"@cindex 23-2 The Formalism"
msgstr ""
"@node 23-2 The Formalism, 23-3 Nondeterminism, 23-1 Background, 23 Parsing "
"with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-2 Формализм\n"
"@cindex 23-2 The Formalism"

#: texi/node-23.texi:74
msgid ""
"To understand what ATNs do, we should recall their full name: augmented "
"transi-\n"
"tion networks. A transition network is a set of nodes joined together by "
"directed\n"
"arcs-essentially, a flow-chart. One node is designated the start node, and "
"some\n"
"other nodes are designated terminal nodes. Conditions are attached to each "
"arc,\n"
"which have to be met before the arc can be followed. There will be an input\n"
"sentence, with a pointer to the current word. Following some arcs will cause "
"the\n"
"pointer to be advanced. To parse a sentence on a transition network is to "
"find a\n"
"path from the start node to some terminal node, along which all the "
"conditions\n"
"can be met."
msgstr ""
"Чтобы понять что делалетt ATNs, мы должны вспомнить их полное название: "
"расширенные\n"
"сети переходов. Сеть переходов - это набор узлов, содединенных между собой\n"
"направленными дугами, по сути, диаграмма-потоков. Один узел обозначен как "
"начальный\n"
"узел, а некоторые другие узлы обозначены как конечные узлы(terminal node). К "
"каждой\n"
"дуге прикрепляются условия, которые должны быть выполнены до того, как можно "
"будет\n"
"проследовать по дуге.  Теперь возмем входное предложение, с указателем на "
"текущее\n"
"слово. Следование некоторым дугам приведет к продвижению указателя. "
"Разобрать\n"
"предложение в сети переходов - это найти путь, от начального узла к "
"некоторому\n"
"конечному/терминальному(terminal) узлу, для которого выполнены все условия."

#: texi/node-23.texi:76
msgid "ATNs add two features to this model:"
msgstr "ATN добавляет две функции к этой модели:"

#: texi/node-23.texi:86
msgid ""
"@enumerate\n"
"@item\n"
"ATNs have registers-named slots for storing away information as the parse\n"
"proceeds. As well as performing tests, arcs can modify the contents of the\n"
"registers.\n"
"@item\n"
"ATNs are recursive. Arcs may require that, in order to follow them, the\n"
"parse must successfully make it through some sub-network.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"ATN имеет регистры - именованные слоты для хранения информации в процессе\n"
"анализа. Помимо выполнения тестов, дуги могут изменять содержимое "
"регистров.\n"
"@item\n"
"ATN является рекурсивным. Дуги могут потребовать, чтобы для прохождения по \n"
"ним, анализ(парсер) прошел через некоторую подсеть.\n"
"@end enumerate"

#: texi/node-23.texi:91
msgid ""
"Terminal nodes use the information which has accumulated in the registers "
"to\n"
"build list structures, which they return in much the same way that functions "
"return\n"
"values. In fact, with the exception of being nondeterministic, ATNs behave a "
"lot\n"
"like a functional programming language."
msgstr ""
"Терминальные узлы используют информацию, накопленную в регистрах, для "
"построения\n"
"списковых структур, которые они возвращают почти так же, как функции "
"возвращают\n"
"значения. Фактически, за исключением того, что ATN являются "
"недетерминированными,\n"
"они ведут себя во многом как функциональный язык программирования."

#: texi/node-23.texi:95
msgid ""
"The ATN defined in Figure 23-1 is nearly the simplest possible. It parses "
"noun-\n"
"verb sentences of the form \"Spot runs.\" The network representation of this "
"ATN is\n"
"shown in Figure 23-2."
msgstr ""
" ATN определенный на рисунке 23-1 является почти самым простым из возмжных. "
"Он \n"
"анализирует высказывания существительное-глагол в форме \"Spot(место) "
"runs(беги).\" \n"
"Сетевое представление этого ATN показано на рисунке 23-2."

#: texi/node-23.texi:98
msgid ""
"What does this ATN do when given the input (spot runs)? The first node has\n"
"one outgoing arc, a cat, or category arc, leading to node s2. It says, "
"effectively,"
msgstr ""
"Что делает этот ATN когда получает на вход предложение (spot runs)? Первый "
"узел\n"
"имеет одну отходящую дугу - кошку или дугу категории, ведущую к узлу s2. Он "
"говорит,\n"
"по сути, "

#: texi/node-23.texi:103
msgid ""
"@lisp\n"
" (defnode s\n"
"    (cat noun s2\n"
"        (setr subj *)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defnode s\n"
"    (cat noun s2\n"
"        (setr subj *)))"

#: texi/node-23.texi:107
msgid ""
" (defnode s2\n"
"    (cat verb s3\n"
"        (setr v *)))"
msgstr ""

#: texi/node-23.texi:113
msgid ""
" (defnode s3\n"
"    (up `(sentence\n"
"              (subject ,(getr subj))\n"
"              (verb ,(getr v)))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:115
msgid "                          Figure 23-1: A very small ATN."
msgstr ""
"                          Рисунок 23-1: Очень маленький ATN.\n"
"@end cartouche"

#: texi/node-23.texi:123
msgid "                        Figure 23-2: Graph of a small ATN."
msgstr ""
"@cartouche\n"
"                        Рисунок 23-2: Граф маленькой ATN.\n"
"@end cartouche"

#: texi/node-23.texi:129
msgid ""
"@noindent\n"
"you can follow me if the current word is a noun, and if you do, you must "
"store\n"
"the current word (indicated by *)inthesubj register. So we leave this node "
"with\n"
"spot stored in the subj register."
msgstr ""
"@noindent\n"
"что вы можете следовать за мной, если текущее слово является "
"существительным,\n"
"и если вы  это делаете, вы должны сохранить текущее слово(обозначенное *) в "
"регистре\n"
"subj. Таким образом, мы оставляем этот узел со spot(местом) сохраненным в "
"регистре\n"
"subj."

#: texi/node-23.texi:135
msgid ""
"There is always a pointer to the current word. Initially it points to the "
"first\n"
"word in the sentence. When cat arcs are followed, this pointer is moved "
"forward\n"
"one. So when we get to node s2, the current word is the second, runs. The\n"
"second arc is just like the first, except that it is looking for a verb. It "
"finds runs,\n"
"stores it in register v, and proceeds to s3."
msgstr ""
"Здесь всегда есть указатель на текущее слово. В начале он указывает на "
"первое слово\n"
"в предложении. Когда мы следуем по дуге-категории(кошке), этот указатель "
"перемещается\n"
"вперед на одно слово. Поэтому когда мы добираемся до узлв s2, текущим словом "
"становиться\n"
"второе слов - runs. Вторая дуга, такая же как и первая, за исключением того, "
"что она \n"
"ищет глагол. Она находит runs, сохраняет его в регистре v, и переходит к s3."

#: texi/node-23.texi:139
msgid ""
"The final node, s3, has only a pop, or terminal, arc. (Nodes with pop arcs "
"have\n"
"dashed borders.) Because we arrive at the pop arc just as we run out of "
"input, we\n"
"have a successful parse. The pop arc returns the backquoted expression "
"within it:"
msgstr ""
"Последний узел s3, имеет только входящую или конечную/терминальную дугу. "
"(Узлы\n"
"с терминальным дугами обозначаются пунктирной линией.) Поскольку мы "
"достигаем\n"
"терминальной дуги, когда у нас закончился ввод, мы имеем успешно выполненный "
"анализ.\n"
"Терминальная дуга возвращает выражение в кавычках с ним:"

#: texi/node-23.texi:144
msgid ""
"@lisp\n"
"(sentence (subject spot)\n"
"              (verb runs))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:151
msgid ""
"An ATN corresponds to the grammar of the language it is designed to parse. "
"A\n"
"decent-sized ATN for parsing English will have a main network for parsing\n"
"sentences, and sub-networks for parsing noun-phrases, prepositional "
"phrases,\n"
"modi- fier groups, and so on. The need for recursion is obvious when we "
"consider\n"
"that noun-phrases may contain prepositional phrases which may contain\n"
"noun-phrases, ad infinitum, as in"
msgstr ""
"ATN соответствует граматике языка, который она(сеть) должна анализировать\n"
"Приличный размер ATN для разбора английского языка будет иметь основную "
"сеть\n"
"для разбора предложений, и подсети для разбора именных фраз, предлоговых "
"фраз,\n"
"групп модификаторов, и так далее. Необходимость рекурсии очевидна, если "
"учесть,\n"
"что  именные фразы(noun-phrases) могут содержать предлоговые фразы, "
"которые \n"
"могут содержать именные фразы, и так до бесконечности, как в"

#: texi/node-23.texi:155
msgid ""
"@quotation\n"
"\"the key on the table in the hall of the house on the hill\"\n"
"@end quotation"
msgstr ""
"@quotation\n"
"\"the key on the table in the hall of the house on the hill\"\n"
"\"ключ на столе в холле дома на холме\"\n"
"@end quotation"

#: texi/node-23.texi:160
msgid ""
"@node 23-3 Nondeterminism, 23-4 An ATN Compiler, 23-2 The Formalism, 23 "
"Parsing with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-3 Nondeterminism\n"
"@cindex 23-3 Nondeterminism"
msgstr ""
"@node 23-3 Nondeterminism, 23-4 An ATN Compiler, 23-2 The Formalism, 23 "
"Parsing with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-3 Недетерминизм\n"
"@cindex 23-3 Nondeterminism"

#: texi/node-23.texi:166
msgid ""
"Although we didn't see it in this small example, ATNs are nondeterministic. "
"A\n"
"node can have several outgoing arcs, more than one of which could be "
"followed\n"
"with a given input. For example, a reasonably good ATN should be able to "
"parse\n"
"both imperative and declarative sentences. Thus the first node could have "
"outgoing\n"
"cat arcs for both nouns (in statements) and verbs (in commands)."
msgstr ""
"Хотя мы не видели в этом небольшом примере, ATNs недетерминированы. Узел "
"может\n"
"иметь несколько исходящих дуг, более чем по одной из которых может "
"следовать\n"
"заданный ввод. Например, достаточно хороший ATN должен уметь анализировать "
"как \n"
"императивные, так и декларативные высказывания. Таким образом, первый узел "
"может\n"
"иметь исходящие дуги-категории как для существительных(в операторах), так и "
"для\n"
"глаголов (в командах)."

#: texi/node-23.texi:172
msgid ""
"What if the first word of the sentence is \"time,\" which is both a noun and "
"a\n"
"verb? How does the parser know which arc to follow? When ATNs are described\n"
"as nondeterministic, it means that users can assume that the parser will "
"correctly\n"
"guess which arc to follow. If some arcs lead only to failed parses, they "
"won't be\n"
"followed."
msgstr ""
"Что если первое слово в предложении время(\"time\"), которое в английском "
"является\n"
"и существительным и глаголом?  Как анализатор(парсепр) узнает, какой дуге "
"следовать?\n"
"Когда ATN описывается как недетерминированный, это означает, что "
"пользователи могут\n"
"предполагать, что анализатор будет правильно угадывать, какой дуге "
"следовать. Если\n"
"некоторые дуги приводят только к неудачным анализам, по ним нельзя будет "
"проходить."

#: texi/node-23.texi:177
msgid ""
"In reality the parser cannot look into the future. It simulates correct "
"guessing\n"
"by backtracking when it runs out of arcs, or input. But all the machinery "
"of\n"
"backtracking is inserted automatically into the code generated by the ATN "
"compiler.\n"
"We can write ATNs as if the parser really could guess which arcs to follow."
msgstr ""
"В действительности парсер не может заглядывать в будущее. Он имитирует "
"правильное\n"
"угадывание путем обратного отслеживания, когда у него заканчиваются дуги или "
"ввод.\n"
"Но все механизмы обратного отслеживания автоматически вставляются в код, "
"сгенерированный\n"
"компилятором ATN. Мы можем написать ATN так, как будто парсер действительно "
"может угадать,\n"
"по какой дуге надо следовать."

#: texi/node-23.texi:185
msgid ""
"Like many (perhaps most) programs which use nondeterminism, ATNs use\n"
"the depth-first implementation. Experience parsing English quickly teaches "
"one\n"
"that any given sentence has a slew of legal parsings, most of them junk. On "
"a\n"
"conventional single-processor machine, one is better off trying to get good "
"parses\n"
"quickly. Instead of getting all the parses at once, we get just the most "
"likely. If\n"
"it has a reasonable interpretation, then we have saved the effort of finding "
"other\n"
"parses; if not, we can call fail to get more."
msgstr ""
"Как и многие(возможно большинство) программы, которые используют "
"недетерминизм,\n"
"ATNs использует реализацию в глубину(принцип - сначала в глубь(depth-"
"first)). \n"
"Опыт разбора английского языка быстро учит, что в любом предложении есть "
"множество\n"
"законных разборов(legal parsings), большинство из которых не желательны. На "
"обычной\n"
"однопроцессорной машине, лучеше попытаться быстро получить хороший анализ. "
"Вместо \n"
"того, чтобы получать все разборы одновременно, мы получаем несколько "
"наиболее\n"
"вероятных. Если они имеют разумное толкование, то мы сэкономили усилия на "
"поиске\n"
"других разборов; если нет мы можем вызвать fail, чтобы получить больше "
"анализов."

#: texi/node-23.texi:193
msgid ""
"To control the order in which parses are generated, the programmer needs to\n"
"have some way of controlling the order in which choose tries alternatives. "
"The\n"
"depth-first implementation isn't the only way of controlling the order of "
"the search.\n"
"Any implementation except a randomizing one imposes some kind of order. "
"How-\n"
"ever, ATNs, like Prolog, have the depth-first implementation conceptually "
"built-in.\n"
"In an ATN, the arcs leaving a node are tried in the order in which they were "
"defined.\n"
"This convention allows the programmer to order arcs by priority."
msgstr ""
"Чтобы управлять порядком в котором генерируются синтаксические разборы, "
"программист\n"
"должен иметь какой-то способ управления порядком, в котором choose(выбор) "
"выбирает\n"
"альтернативы. Реализация в глубину не единственный способ управления "
"порядком поиска.\n"
"Любая реализация, за исключением случайной, накладывает какой-то порядок. "
"Тем не менее\n"
"ATN, такие как Prolog, имеют концептуально встроенную реализацию с поиском в "
"глубину.\n"
"В ATN дуги, покидающие узел, проверяются в порядке, в котором они были "
"определены.\n"
"Это соглашение позволяет программисту упорядочивать дуги по приоритету."

#: texi/node-23.texi:198
msgid ""
"@node 23-4 An ATN Compiler, 23-5 A Sample ATN, 23-3 Nondeterminism, 23 "
"Parsing with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-4 An ATN Compiler\n"
"@cindex 23-4 An ATN Compiler"
msgstr ""
"@node 23-4 An ATN Compiler, 23-5 A Sample ATN, 23-3 Nondeterminism, 23 "
"Parsing with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-4 Компилятор ATN\n"
"@cindex 23-4 An ATN Compiler"

#: texi/node-23.texi:206
msgid ""
"Ordinarily, an ATN-based parser needs three components: the ATN itself, an "
"inter-\n"
"preter for traversing it, and a dictionary which can tell it, for example, "
"that \"runs\"\n"
"is a verb. Dictionaries are a separate topic-here we will use a rudimentary "
"hand-\n"
"made one. Nor will we need to deal with a network interpreter, because we "
"will\n"
"translate the ATN directly into Lisp code. The program described here is "
"called an\n"
"ATN compiler because it transforms a whole ATN into code. Nodes are "
"transformed\n"
"into functions, and arcs become blocks of code within them."
msgstr ""
"Обычно синтаксическому анализатору на основе ATN необходимы три компонента: "
"сама ATN,\n"
"интерпретатор для ее обхода, и словарь, который может сказать, например. что "
"\"runs\"\n"
"это глагол(verb). Словари - отдельная тема, здесь мы будем использовать "
"элементарную\n"
"ручную работу. Нам также не нужно иметь дело с интерпретатором сети, потому "
"что мы\n"
"переведем ATN непосредственно в код на Lisp. Описанная здесь программа "
"называется\n"
"компилятором ATN, поскольку она преобразует всю ATN в код. Узлы превращаются "
"в\n"
"функции, а дуги становяться блоками кода внутри них."

#: texi/node-23.texi:212
msgid ""
"Chapter 6 introduced the use of functions as a form of representation. This\n"
"practice usually makes programs faster. Here it means that there will be no\n"
"overhead of interpreting the network at runtime. The disadvantage is that "
"there is\n"
"less to inspect when something goes wrong, especially if you're using a "
"Common\n"
"Lisp implementation which doesn't provide function-lambda-expression."
msgstr ""
"Глава 6 ввела использование функций в качестве формы представления. Эта "
"практика\n"
"обычно делает программы быстрее. Здесь это означает, что не будет никаких "
"затрат\n"
"на интерпретацию сети во время выполнения. Недостатком является то, что "
"происходит\n"
"меньше проверок, когда что то идет не так, особенно если вы используете "
"реализацию\n"
"Common Lisp, которая не предоставляет функцию лямбда-выржения."

#: texi/node-23.texi:218
msgid ""
"Figure 23-3 contains all the code for transforming ATN nodes into Lisp "
"code.\n"
"The macro defnode is used to define nodes. It generates little code itself, "
"just a\n"
"choose over the expressions generated for each of the arcs. The two "
"parameters\n"
"of a node-function get the following values: pos is the current input "
"pointer (an\n"
"integer), and regs is the current set of registers (a list of assoc-lists)."
msgstr ""
"На Рисунке 23-3 показан весь код преобразования узлов ATN в код Lisp.\n"
"Макрос defnode используется для определения узлов. Он сам генерирует "
"небольшой код,\n"
"просто выбирая выражения, сгенерированные для каждой из дуг. Два параметра "
"функции\n"
"node получают следующие значения: pos это текущий указатель ввода (целое "
"число), и \n"
"regs это текущий набор регистров (список ассоциативных списков(assoc-lists))."

#: texi/node-23.texi:224
msgid ""
"The macro defnode defines a macro with the same name as the corresponding\n"
"node. Node s will be defined as macro s. This convention enables arcs to "
"know\n"
"how to refer to their destination nodes-they just call the macro with that "
"name.\n"
"It also means that you shouldn't give nodes the names of existing functions "
"or\n"
"macros, or these will be redefined."
msgstr ""
"Макрос defnode определяет макрос с тем же именем, что и соответствующий "
"узел.\n"
"Узел s будет определен как максрос s. Это соглашение позволяет дугам знать,\n"
"как ссылаться на их узлы назначения - они просто вызывают макрос с этим "
"именем.\n"
"Это также означает, что вы не должны давать узлам имена существующих функций "
"или\n"
"макросов, иначе они будут переопределены."

#: texi/node-23.texi:229
msgid ""
"Debugging ATNs requires some sort of trace facility. Because nodes become\n"
"functions, we don't have to write our own. We can use the built-in Lisp "
"function\n"
"trace. As mentioned on page 266, using =defun to define nodes means that we\n"
"can trace parses going through node mods by saying (trace =mods)."
msgstr ""
"Отладка ATN требует своего рода средства трассировки. Поскольку узылы "
"становятся\n"
"функциями, нам не нужно писать свою собственную трассировку. Мы можем "
"использовать\n"
"встроенную функцию трассировки Lisp trace. Как упомянуто на стр. 266, "
"использование\n"
"=defun для определения узлов означает, что мы можем отслеживать анализ, "
"проходящий\n"
"через узлы mods просто сказав (trace =mods)."

#: texi/node-23.texi:234
msgid ""
"The arcs within the body of a node are simply macro calls,returning code "
"which\n"
"gets embedded in the node function being made by defnode. The parser uses\n"
"nondeterminism at each node by executing a choose over the code "
"representing\n"
"each of the arcs leaving that node. A node with several outgoing arcs, say"
msgstr ""
"Дуги в теле узла - это просто вызовы макросов, возвращающие код, который \n"
"внедряется в функцию узла, создаваемую defnode. Парсер использует\n"
"недетерминизм в каждом узле, выполняя выбор кода, представляющего каждую из\n"
"дуг, покидающих этот узел. Узел с несоклькими исходящими дугами, скажем"

#: texi/node-23.texi:240
msgid ""
"@lisp\n"
"(defnode foo\n"
"  <arc 1>\n"
"  <arc 2>)\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:243
msgid ""
"@noindent\n"
"gets translated into a function definition of the following form:"
msgstr ""
"@noindent\n"
"транслируется в определение функции следующего вида:"

#: texi/node-23.texi:249
msgid ""
"@lisp\n"
"(=defun foo (pos regs)\n"
"  (choose\n"
"        <translation of arc 1>\n"
"        <translation of arc 2>))"
msgstr ""
"@lisp\n"
"(=defun foo (pos regs)\n"
"  (choose\n"
"        <translation of arc 1>\n"
"        <translation of arc 2>))\n"
"@end lisp"

#: texi/node-23.texi:252
msgid ""
" (defmacro defnode (name &rest arcs)\n"
"       `(=defun ,name (pos regs) (choose ,@@arcs)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro defnode (name &rest arcs)\n"
"       `(=defun ,name (pos regs) (choose ,@@arcs)))"

#: texi/node-23.texi:256
msgid ""
" (defmacro down (sub next &rest cmds)\n"
"       `(=bind (* pos regs) (,sub pos (cons nil regs))\n"
"          (,next pos ,(compile-cmds cmds))))"
msgstr ""

#: texi/node-23.texi:264
msgid ""
" (defmacro cat (cat next &rest cmds)\n"
"       `(if (= (length *sent*) pos)\n"
"           (fail)\n"
"           (let ((* (nth pos *sent*)))\n"
"             (if (member ',cat (types *))\n"
"                   (,next (1+ pos) ,(compile-cmds cmds))\n"
"                   (fail)))))"
msgstr ""

#: texi/node-23.texi:267
msgid ""
" (defmacro jump (next &rest cmds)\n"
"       `(,next pos ,(compile-cmds cmds)))"
msgstr ""

#: texi/node-23.texi:272
msgid ""
" (defun compile-cmds (cmds)\n"
"       (if (null cmds)\n"
"          'regs\n"
"          `(,@@(car cmds) ,(compile-cmds (cdr cmds)))))"
msgstr ""

#: texi/node-23.texi:276
msgid ""
" (defmacro up (expr)\n"
"       `(let ((* (nth pos *sent*)))\n"
"          (=values ,expr pos (cdr regs))))"
msgstr ""

#: texi/node-23.texi:280
msgid ""
" (defmacro getr (key &optional (regs 'regs))\n"
"       `(let ((result (cdr (assoc ',key (car ,regs)))))\n"
"          (if (cdr result) result (car result))))"
msgstr ""

#: texi/node-23.texi:284
msgid ""
" (defmacro set-register (key val regs)\n"
"       `(cons (cons (cons ,key ,val) (car ,regs))\n"
"             (cdr ,regs)))"
msgstr ""

#: texi/node-23.texi:287
msgid ""
" (defmacro setr (key val regs)\n"
"       `(set-register ',key (list ,val) ,regs))"
msgstr ""

#: texi/node-23.texi:293
msgid ""
" (defmacro pushr (key val regs)\n"
"       `(set-register ',key\n"
"                        (cons ,val (cdr (assoc ',key (car ,regs))))\n"
"                        ,regs))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:295
msgid "                   Figure 23-3: Compilation of nodes and arcs."
msgstr ""
"                   Рисунок 23-3: Компиляция узлов и дуг.\n"
"@end cartouche"

#: texi/node-23.texi:307
msgid ""
"@lisp\n"
" (defnode s\n"
"    (down np s/subj\n"
"        (setr mood 'decl)\n"
"        (setr subj *))\n"
"    (cat v v\n"
"        (setr mood 'imp)\n"
"        (setr subj '(np (pron you)))\n"
"        (setr aux nil)\n"
"        (setr v *)))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defnode s\n"
"    (down np s/subj\n"
"        (setr mood 'decl)\n"
"        (setr subj *))\n"
"    (cat v v\n"
"        (setr mood 'imp)\n"
"        (setr subj '(np (pron you)))\n"
"        (setr aux nil)\n"
"        (setr v *)))\n"
"@end lisp"

#: texi/node-23.texi:310
msgid ""
"@noindent\n"
"is macroexpanded into:"
msgstr ""
"@noindent\n"
"макро расширяетс в:"

#: texi/node-23.texi:329
msgid ""
"@lisp\n"
" (=defun s (pos regs)\n"
"    (choose\n"
"        (=bind (* pos regs) (np pos (cons nil regs))\n"
"         (s/subj pos\n"
"                    (setr mood 'decl\n"
"                            (setr subj * regs))))\n"
"        (if (= (length *sent*) pos)\n"
"            (fail)\n"
"            (let ((* (nth pos *sent*)))\n"
"               (if (member 'v (types *))\n"
"                    (v (1+ pos)\n"
"                        (setr mood 'imp\n"
"                                (setr subj '(np (pron you))\n"
"                                        (setr aux nil\n"
"                                                   (setr v * regs)))))\n"
"                    (fail))))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:331
msgid "                Figure 23-4: Macroexpansion of a node function."
msgstr ""
"                Рисунок 23-4: Макрорасширение функции узла.\n"
"@end cartouche"

#: texi/node-23.texi:337
msgid ""
"Figure 23-4 shows the macroexpansion of the first node in the sample ATN of\n"
"Figure 23-11. When called at runtime, node functions like s "
"nondeterministically\n"
"choose an arc to follow. The parameter pos will be the current position in "
"the\n"
"input sentence, and regs the current registers."
msgstr ""
"На рисунке 23-4 показано макроразложение первого узла в примере для ATN с \n"
"Рисунка 23-11. При вызове во время выполнения, функция узла, такая как s \n"
"недетерминированно выбирает дуга для следования. Параметр pos будет текущей\n"
"позицией во входящем предложении и  regs текущими регистрами."

#: texi/node-23.texi:341
msgid ""
"Cat arcs, as we saw in our original example, insist that the current word "
"of\n"
"input belong to a certain grammatical category. Within the body of a cat "
"arc, the\n"
"symbol * will be bound to the current word of input."
msgstr ""
"Категориальные дуги, как мы видели в нашем первоначальном примере, "
"настаивают на\n"
"том, что текущее слово входного предложения относиться к определенной "
"граматической\n"
"категории. В теле категориальной дуги, символ * будет связан с текущим "
"входным словом."

#: texi/node-23.texi:352
msgid ""
"Push arcs, defined with down, require successful calls to sub-networks. "
"They\n"
"take two destination nodes, the sub-network destination sub, and the next "
"node\n"
"in the current network, next. Notice that whereas the code generated for a "
"cat\n"
"arc simply calls the next node in the network, the code generated for a "
"push\n"
"arc uses =bind. The push arc must successfully return from the sub-network\n"
"before continuing on to the node which follows it. A clean set of registers "
"(nil)\n"
"gets consed onto the front of regs before they are passed to the sub-"
"network.\n"
"In the bodies of other types of arcs, the symbol * will be bound to the "
"current\n"
"word of input, but in push arcs it will be bound to the expression returned "
"by the\n"
"sub-network."
msgstr ""
"Push дуги, определенные с помощью down, требуют успешных вызовов в подсетях. "
"Они\n"
"принимают два узла назначения, подсеть назначения - sub, и следующий узел "
"в \n"
"текущей сети - next. Обратите внимание, что хотя код сгенерированный для "
"категориальной\n"
"дуги просто вызывает следующий(next) узел в сети, код генерируемый для push\n"
"дуги использует  =bind. push дуга должна успешно вернуться из подсети, "
"прежде\n"
"чем перейдет к узлу следующему за ней. Чистый набор регистров (nil) \n"
"попадает на фронт regs прежде чем они будут переданы в подсеть.\n"
"В телах други типов дуг, символ * будет связан с текущим входным словом, но "
"в \n"
"push дугах он будет связан с выражением возвращаемым подсетью."

#: texi/node-23.texi:355
msgid ""
"Jump arcs are like short-circuits. The parser skips right across to the "
"destination\n"
"node-no tests are required, and the input pointer isn't advanced."
msgstr ""
"Jump дуги похожи на короткое замыкание в схеме. Синтаксический анализатор "
"пропходит\n"
"прямо к узлу назначения, никаких тестов не требуется, и указатель входного "
"слова не \n"
"передвигается."

#: texi/node-23.texi:364
msgid ""
"The final type of arc is the pop arc, defined with up. Pop arcs are unusual "
"in\n"
"that they don't have a destination. Just as a Lisp return leads not to a "
"subroutine\n"
"but the calling function, a pop arc leads not to a new node but back to the "
"\"calling\"\n"
"push arc. The =values in a pop arc \"returns\" a value to the =bind in the "
"most\n"
"recent push arc. But, as Section 20-2 explained, what's happening is not a "
"normal\n"
"Lisp return: the body of the =bind has been wrapped up into a continuation "
"and\n"
"passed down as a parameter through any number of arcs, until the =values of "
"the\n"
"pop arc finally calls it on the \"return\" values."
msgstr ""
"Последний тип дуги это pop дуга, определяемая с помощью up. Pop дуги "
"необычны тем,\n"
"что у них нет места назначения. Точно также как команда return Lisp  не "
"приводит\n"
"к вызову подпорограммы, а к переходу в вызывающую функцию, pop дуга не ведет "
"к\n"
"новому узлу, а ведет обратно к \"вызывающейg\" push дуге. =values в pop "
"дуге \n"
"\"возвращают\" значение  для =bind в самой последней push дуге. Но, как "
"пояснено\n"
"в Разделе 20-2 происходящее не является обычным возвратом Lisp: тело =bind "
"было\n"
"заключено в подолжение и передано в качестве параметра через любое "
"количество\n"
"дуг, пока значения  =values pop дуги, накоенц, не вызовут его для \"возврата"
"\" значений."

#: texi/node-23.texi:372
msgid ""
"Chapter 22 described two versions of nondeterministic choose: a fast choose\n"
"(page 293) that wasn't guaranteed to terminate when there were loops in the "
"search\n"
"space, and a slower true-choose (page 304) which was safe from such loops.\n"
"There can be cycles in an ATN, of course, but as long as at least one arc in "
"each\n"
"cycle advances the input pointer, the parser will eventually run off the end "
"of the\n"
"sentence. The problem arises with cycles which don't advance the input "
"pointer.\n"
"Here we have two alternatives:"
msgstr ""
"В главе 22 описаны две версии недетерминированного выбора: быстрый выбор "
"(стр.293),\n"
"который не гарантированно завершиться при наличии циклов в циклов в "
"пространстве\n"
"поиска, и более медленный истинный выбор(true-choose) (стр. 304), который "
"был более\n"
"безопасен для таких циклов. Конечно, в  ATN могут быть циклы, но пока по "
"крайней мере\n"
"одна дуга в каждом цикле опережает входной указатель, синтаксический "
"анализатор в \n"
"конечном итоге переходит  за конец предложения. Проблема возникает с "
"циклами,\n"
"которые не перемещают указатель ввода.\n"
"Здесь у нас есть две альтернативы:"

#: texi/node-23.texi:381
msgid ""
"@enumerate\n"
"@item\n"
"Use the slower, correct nondeterministic choice operator (the depth-first\n"
"version given on page 396).\n"
"@item\n"
"Use the fast choose, and specify that it is an error to define networks\n"
"containing cycles which could be traversed by following just jump arcs.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"Использовать медленный, правильный недетерминированный оператор выбора(поиск "
"в глубину\n"
"версия данная на стр. 396).\n"
"@item\n"
"Использовать быстрый выбор, и указать, что ошибочно определять сети "
"содержащие циклы,\n"
"которые можно пройти следуюя простым jump дугам (перехода).\n"
"@end enumerate"

#: texi/node-23.texi:383
msgid "The code defined in Figure 23-3 takes the second approach."
msgstr "Код определенныый на рисунке 23-3 использует второй подход."

#: texi/node-23.texi:390
msgid ""
"The last four definitions in Figure 23-3 define the macros used to read and\n"
"set registers within arc bodies. In this program, register sets are "
"represented as\n"
"assoc-lists. An ATN deals not with sets of registers, but sets of sets of "
"registers.\n"
"When the parser moves down to a sub-network, it gets a clean set of "
"registers\n"
"pushed on top of the existing ones. Thus the whole collection of registers, "
"at any\n"
"given time, is a list of assoc-lists."
msgstr ""
"Последние четыре определения на рисунке 23-3 определяют макросы, "
"используемые для\n"
"чтения и установки регистров внутри тела дуги. В этой программе наборы "
"регистров\n"
"представлени в виде ассоциативных списков(assoc-lists). ATN имеет дело не с "
"набором\n"
"регистров, а с наборами наборов регистров. Когда анализатор(парсер) "
"перемещается\n"
"вниз в подсеть, он получает чистый набор регистров, помещенный поверх "
"существующих.\n"
"Таким образом, вся коллекция регистров в любой момент времени представляет "
"собой\n"
"список ассоциативных спиков(assoc-lists)."

#: texi/node-23.texi:394
msgid ""
"The predefined register operators work on the current, or topmost, set of\n"
"registers: getr reads a register; setr sets one; and pushr pushes a value "
"into\n"
"one. Both getr and pushr use the primitive register manipulation macro set-"
"register."
msgstr ""
"Предопределенные операторы регистров работают с текущим или самым верхним "
"набором\n"
"регистров: getr читает регистр; setr устанавливает один; и pushr помещает "
"одно значение.\n"
"Оба getr и pushr используют макрос set-register упавляющий примитивом "
"регистра."

#: texi/node-23.texi:397
msgid ""
"Note that registers don't have to be declared. If set-register is sent a "
"certain\n"
"name, it will create a register with that name."
msgstr ""
"Обратите внимание что регистры не должны объявляться. Если set-register "
"посылает\n"
"определенное имя, оно создает регистр с этим именем."

#: texi/node-23.texi:406
msgid ""
"The register operators are all completely nondestructive. Cons, cons, cons,\n"
"says set-register. This makes them slow and generates a lot of garbage, "
"but,\n"
"as explained on page 261, objects used in a part of a program where "
"continuations\n"
"are made should not be destructively modified. An object in one thread of "
"control\n"
"may be shared by another thread which is currently suspended. In this case, "
"the\n"
"registers found in one parse will share structure with the registers in many "
"of the\n"
"other parses. If speed became an issue, we could store registers in vectors "
"instead\n"
"of assoc-lists, and recycle used vectors into a common pool."
msgstr ""
"Операторы работающие с регистрами все совершенно не разрушающие. Cons, cons, "
"cons,\n"
"говорит set-register. Это замедляет их работу и создает много мусора, но "
"как\n"
"объясняется на стр. 261, объекты используемые в части программы, в которой "
"создаются\n"
"продолжения, не должны подвергаться деструктивному изменению. Объект в одном "
"потоке\n"
"управления может использоваться другим потоком, который в данный момент "
"приостановлен.\n"
"В этом случае регистры, найденные в одном разборе, будут иметь общую "
"структуру с \n"
"регистрами во многих других разборах. Если бы скорость была приемлемой, мы "
"могли бы\n"
"хранить регистры в векторах, вместо ассоциативных списков(assoc-lists), и "
"повторно\n"
"использовать векторы в общем пуле."

#: texi/node-23.texi:410
msgid ""
"Push, cat, and jump arcs can all contain bodies of expressions. Ordinarily\n"
"these will be just setrs. By calling compile-cmds on their bodies, the "
"expansion\n"
"functions of these arc types string a series of setrs into a single "
"expression:"
msgstr ""
"Push, cat, и jump дуги, все могут содержать тела выражений. Обычно это "
"просто\n"
"сеттеры. Вызывая compile-cmds для своих тел, функция расширения этих типов "
"дуг\n"
"объединяет серию сеттеров(setrs) в одно выражение:"

#: texi/node-23.texi:415
msgid ""
"@example\n"
"> (compile-cmds '((setr a b) (setr c d)))\n"
"(SETR A B (SETR C D REGS))\n"
"@end example"
msgstr ""

#: texi/node-23.texi:419
msgid ""
"Each expression has the next expression inserted as its last argument, "
"except the\n"
"last, which gets regs. So a series of expressions in the body of an arc will "
"be\n"
"transformed into a single expression returning the new registers."
msgstr ""
"Каждое выражение имеет следующее выражение, вставленное в качестве "
"последнего аргумента,\n"
"кроме последнего, который получает regs. Таким образом, серия выражений в "
"теле дуги\n"
"будет преобразована в одно выражение возвращающее новые регистры."

#: texi/node-23.texi:422
msgid ""
"This approach allows users to insert arbitrary Lisp code into the bodies of "
"arcs\n"
"by wrapping it in a progn. For example:"
msgstr ""
"Этот подход позволяет пользователям вставлять произвольный код Lisp в тела "
"дуг,\n"
"помещая его в progn. Например:"

#: texi/node-23.texi:429
msgid ""
"@example\n"
"> (compile-cmds '((setr a b)\n"
"                        (progn (princ \"ek!\"))\n"
"                        (setr c d)))\n"
"(SETR A B (PROGN (PRINC \"ek!\") (SETR C D REGS)))\n"
"@end example"
msgstr ""

#: texi/node-23.texi:436
msgid ""
"Certain variables are left visible to code occurring in arc bodies. The "
"sentence\n"
"will be in the global *sent*. Two lexical variables will also be visible: "
"pos,\n"
"containing the current input pointer, and regs, containing the current "
"registers.\n"
"This is another example of intentional variable capture. If it were "
"desirable to\n"
"prevent the user from referring to these variables, they could be replaced "
"with\n"
"gensyms."
msgstr ""
"Некоторые переменные остаются видимыми для кода, встречающегося в телах "
"дуг.\n"
"Предложение(sentence) будет в глобальном *sent*. Также будут видны, две \n"
"лексические переменные: pos, содержащая текущий указатель на входное слово\n"
"и regs, содержащий текущие регистры. Это еще один пример преднамеренного "
"захвата\n"
"переменных. Если было бы желательно, чтобы пользователь не ссылался на эти \n"
"переменные, их можно было бы заменить на gensyms."

#: texi/node-23.texi:445
msgid ""
"The macro with-parses,defined in Figure 23-5,gives us a way of invoking an\n"
"ATN. It should be called with the name of a start node, an expression to be "
"parsed,\n"
"and a body of code describing what to do with the returned parses. The body "
"of\n"
"code within a with-parses expression will be evaluated once for each "
"successful\n"
"parse. Within the body, the symbol parse will be bound to the current "
"parse.\n"
"Superficially with-parses resembles operators like dolist, but underneath "
"it\n"
"uses backtracking search instead of simple iteration. A with-parses "
"expression\n"
"will return @, because that's what fail returns when it runs out of choices."
msgstr ""
"Макрос with-parses, определенный на Рисунке 23-5, дает нам возможность не "
"вызвать\n"
"ATN. Он должен вызываться с именем начального узла, выражением, которое "
"нужно\n"
"проанализировать, и телом кода, описывающим, что делать с возвращенными "
"значениями\n"
"парсера. Тело кода в  выражении with-parses будет вычисляться один раз для "
"каждого\n"
"успешного анализа. Внутри тела, символ parse будет привязан к текущему "
"анализу/парсеру.\n"
"Внешне with-parses напоминает оператор, такой как dolist, но под ним "
"используется\n"
"поиск с возвратом, вместо простой итерации. Выражение with-parses вернет @, "
"потому \n"
"что это то, что возвращает fail когда у него заканчивается выбор."

#: texi/node-23.texi:457
msgid ""
"@lisp\n"
"     (defmacro with-parses (node sent &body body)\n"
"       (with-gensyms (pos regs)\n"
"         `(progn\n"
"              (setq *sent* ,sent)\n"
"              (setq *paths* nil)\n"
"              (=bind (parse ,pos ,regs) (,node 0 '(nil))\n"
"                (if (= ,pos (length *sent*))\n"
"                     (progn ,@@body (fail))\n"
"                     (fail))))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defmacro with-parses (node sent &body body)\n"
"       (with-gensyms (pos regs)\n"
"         `(progn\n"
"              (setq *sent* ,sent)\n"
"              (setq *paths* nil)\n"
"              (=bind (parse ,pos ,regs) (,node 0 '(nil))\n"
"                (if (= ,pos (length *sent*))\n"
"                     (progn ,@@body (fail))\n"
"                     (fail))))))\n"
"@end lisp"

#: texi/node-23.texi:459
msgid "                             Figure 23-5: Toplevel macro."
msgstr ""
"                             Рисунок 23-5: Марос верхнего уровня.\n"
"@end cartouche"

#: texi/node-23.texi:464
msgid ""
"Before going on to look at a more representative ATN, let's look at a "
"parsing\n"
"generated from the tiny ATN defined earlier. The ATN compiler (Figure 23-3)\n"
"generates code which calls types to determine the grammatical roles of a "
"word,\n"
"so first we have to give it some definition:"
msgstr ""
"Прежде чем перейти к рассмотрению более представительного ATN, давайте "
"рассмотрим\n"
"синтаксический анализ, созданный из крошечного ATN, определенного ранее. "
"Компилятор\n"
"ATN (Рисунок 23-3) генерирует код, который вызывает types для определения "
"граматических\n"
"ролей слов, поэтому сначала мы должны дать ему некоторое определение:"

#: texi/node-23.texi:469
msgid ""
"@lisp\n"
"(defun types (w)\n"
"     (cdr (assoc w '((spot noun) (runs verb)))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:472
msgid ""
"Now we just call with-parses with the name of the start node as the first\n"
"argument:"
msgstr ""
"Теперь мыы просто вызываем with-parsesс именем начального узла в качестве \n"
"первого аргумента:"

#: texi/node-23.texi:479
msgid ""
"@example\n"
"> (with-parses s '(spot runs)\n"
"        (format t \"Parsing: ~A~%\" parse))\n"
"Parsing: (SENTENCE (SUBJECT SPOT) (VERB RUNS))\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-23.texi:484
msgid ""
"@node 23-5 A Sample ATN,  , 23-4 An ATN Compiler, 23 Parsing with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-5 A Sample ATN\n"
"@cindex 23-5 A Sample ATN"
msgstr ""
"@node 23-5 A Sample ATN,  , 23-4 An ATN Compiler, 23 Parsing with ATNs\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 23-5 Пример ATN\n"
"@cindex 23-5 A Sample ATN"

#: texi/node-23.texi:490
msgid ""
"Now that the whole ATN compiler has been described, we can go on to try out\n"
"some parses using a sample network. In order to make an ATN parser handle a\n"
"richer variety of sentences, you make the ATNs themselves more complicated, "
"not\n"
"the ATN compiler. The compiler presented here is a toy mainly in the sense "
"that\n"
"it's slow, not in the sense of having limited power."
msgstr ""
"Теперь, когда был описан весь компилятор ATN, мы можем попробовать "
"некоторые \n"
"синатксические разборы, используя примеры сетей. Чтобы синтаксический "
"анализатор\n"
"ATN обрабатывал более разнообразные предложения, вы усложняеете сам ATN, а\n"
"не компилятор ATN. Представленный здесь компилятор, представляет собой "
"игрушку,\n"
"в основом в том смысле, что он медленный, а не в смысле ограниченной "
"мощности."

#: texi/node-23.texi:496
msgid ""
"The power (as distinct from speed) of a parser is in the grammar, and here\n"
"limited space really will force us to use a toy version. Figures 23-8 "
"through 23-11\n"
"define the ATN (or set of ATNs) represented in Figure 23-6. This network is "
"just\n"
"big enough to yield several parsings for the classic parser fodder \"Time "
"flies like\n"
"an arrow.\""
msgstr ""
"Мощь (в отиличие от скорости) синтаксического анализатора заключается в "
"граматике,\n"
"и здесь ограниченное пространство действительно заставляет нас использовать\n"
"игрушечную версию. Рисунки с 23-8 по 23-11 определяют ATN (или набор ATNs) "
"представленную\n"
"на Рисунке 23-6. Эта сеть достаточно велика, чтобы можно было выполнить "
"несколько\n"
"разборов для классического корма парсеров \"Время летит как стрела\"(\"Time "
"flies like an arrow.\")"

#: texi/node-23.texi:520
msgid "                      Figure 23-6: Graph of a larger ATN."
msgstr ""
"@cartouche\n"
"                      Рисунок 23-6: Грав большой ATN.\n"
"@end cartouche"

#: texi/node-23.texi:534
msgid ""
"@lisp\n"
" (defun types (word)\n"
"    (case word\n"
"        ((do does did) '(aux v))\n"
"        ((time times) '(n v))\n"
"        ((fly flies) '(n v))\n"
"        ((like) '(v prep))\n"
"        ((liked likes) '(v))\n"
"        ((a an the) '(det))\n"
"        ((arrow arrows) '(n))\n"
"        ((i you he she him her it) '(pron))))\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defun types (word)\n"
"    (case word\n"
"        ((do does did) '(aux v))\n"
"        ((time times) '(n v))\n"
"        ((fly flies) '(n v))\n"
"        ((like) '(v prep))\n"
"        ((liked likes) '(v))\n"
"        ((a an the) '(det))\n"
"        ((arrow arrows) '(n))\n"
"        ((i you he she him her it) '(pron))))\n"
"@end lisp"

#: texi/node-23.texi:536
msgid "                        Figure 23-7: Nominal dictionary."
msgstr ""
"                        Рисунок 23-7: Номинальный словарь\n"
"@end cartouche"

#: texi/node-23.texi:542
msgid ""
"We need a slightly larger dictionary to parse more complex input. The "
"function\n"
"types (Figure 23-7) provides a dictionary of the most primitive sort. It "
"defines a\n"
"22-word vocabulary, and associates each word with a list of one or more "
"simple\n"
"grammatical roles."
msgstr ""
"Нам нужен немного больший словарь для разбора более сложного ввода. Функция\n"
"types (Рисунок 23-7) предоставляет словарь самого примитивного вида. Он "
"определяет\n"
"словарь из 22-слов, и связывает каждое слово со списком одной или "
"нескольких\n"
"простых граматических ролей."

#: texi/node-23.texi:547
msgid ""
"@lisp\n"
"     (defnode mods\n"
"       (cat n mods/n\n"
"         (setr mods *)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defnode mods\n"
"       (cat n mods/n\n"
"         (setr mods *)))"

#: texi/node-23.texi:553
msgid ""
"     (defnode mods/n\n"
"       (cat n mods/n\n"
"         (pushr mods *))\n"
"       (up `(n-group ,(getr mods))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:555
msgid "                   Figure 23-8: Sub-network for strings of modifiers."
msgstr ""
"                   Рисунок 23-8: Подсеть для модификаторов строк.\n"
"@end cartouche"

#: texi/node-23.texi:561
msgid ""
"The components of an ATN are themselves ATNs. The smallest ATN in our set\n"
"is the one in Figure 23-8. It parses strings of modifiers, which in this "
"case means\n"
"just strings of nouns. The first node, mods, accepts a noun. The second "
"node,\n"
"mods/n, can either look for more nouns, or return a parsing."
msgstr ""
"Компоненты ATN сами являются ATNs. Самый маленький ATN в нашем наборе - тот, "
"что\n"
"на рисунке 23-8. Он анализирует строковые модификаторы, что в данном случае "
"означает\n"
"стороки существительных. Первый узел, mods, принимает существительное. "
"Второй узел,\n"
"mods/n, может либо искать больше существительных, или возвращать разбор."

#: texi/node-23.texi:564
msgid ""
"Section 3-4 explained how writing programs in a functional style makes them\n"
"easier to test:"
msgstr ""
"В разделе 3-4 объясняется как написание программ в функциональном стиле "
"облегчает\n"
"их тестирование:"

#: texi/node-23.texi:571
msgid ""
"@enumerate\n"
"@item\n"
"In a functional program, components can be tested individually.\n"
"@item\n"
"In Lisp, functions can be tested interactively, in the toplevel loop.\n"
"@end enumerate"
msgstr ""
"@enumerate\n"
"@item\n"
"В функциональной программе компоненты можно тестировать индивидуально.\n"
"@item\n"
"В Lisp, функции можно тестировать интерактивно, в цикле верхнего уровня.\n"
"@end enumerate"

#: texi/node-23.texi:574
msgid ""
"Together these two principles allow interactive development: when we write\n"
"functional programs in Lisp, we can test each piece as we write it."
msgstr ""
"Вместе эти два принципа позволяют проводить интерактивную разработку: "
"когда \n"
"мы пишем функциональные программы на Lisp, мы можем тестировать каждый \n"
"фрагмент по мере его написания."

#: texi/node-23.texi:579
msgid ""
"ATNs are so like functional programs-in this implementation, they macroex-\n"
"pand into functional programs-that the possibility of interactive "
"development\n"
"applies to them as well. We can test an ATN starting from any node, simply "
"by\n"
"giving its name as the first argument to with-parses:"
msgstr ""
"ATNs настолько похожи на функциональные программы - в этой реализации они \n"
"макрорасширяются в функциональные прогарммы, так что возможноть "
"интерактивной\n"
"разработки распространяется и на них. Мы можем проверить ATN начиная с "
"любого\n"
"узла, просто указав его имя в качестве первого аргумента with-parses:"

#: texi/node-23.texi:586
msgid ""
"@example\n"
"> (with-parses mods '(time arrow)\n"
"        (format t \"Parsing: ~A~%\" parse))\n"
"Parsing: (N-GROUP (ARROW TIME))\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-23.texi:592
msgid ""
"The next two networks have to be discussed together,because they are "
"mutually\n"
"recursive. The network defined in Figure 23-9, which begins with the node "
"np,\n"
"is used to parse noun phrases. The network defined in Figure 23-10 parses\n"
"prepositional phrases. Noun phrases may contain prepositional phrases and "
"vice\n"
"versa, so the two networks each contain a push arc which calls the other."
msgstr ""
"Следующие два сети должны обсуждаться вместе, потому что они взаимно "
"рекурсивны.\n"
"Сеть определенная на рисунке 23-9, которая начинается с узла np, "
"используется для\n"
"разбора фраз существительных(noun phrases). Сеть определенная на рисунке "
"23-10 анализирует\n"
"предлоги(prepositional phrases). Фразы существительных могут содержать фразы "
"предлоги и\n"
"наоборот, поэтому каждая из двух сетей содержит push дугу, которая вызывает "
"другую сеть."

#: texi/node-23.texi:596
msgid ""
"The noun phrase network contains six nodes. The first node, np has three\n"
"choices. If it reads a pronoun, then it can move to node pron, which pops "
"out of\n"
"the network:"
msgstr ""
"Сеть существительных фраз содержит шесть узлов. Первый узел np имеет три "
"варианта.\n"
"Если он читает метоимение(pronoun), он может перейти к узлу "
"местоимению(pron), \n"
"которое является выходом из сети:"

#: texi/node-23.texi:605
msgid ""
"@lisp\n"
"     (defnode np\n"
"      (cat det np/det\n"
"         (setr det *))\n"
"      (jump np/det\n"
"         (setr det nil))\n"
"      (cat pron pron\n"
"         (setr n *)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defnode np\n"
"      (cat det np/det\n"
"         (setr det *))\n"
"      (jump np/det\n"
"         (setr det nil))\n"
"      (cat pron pron\n"
"         (setr n *)))"

#: texi/node-23.texi:608
msgid ""
"     (defnode pron\n"
"      (up `(np (pronoun ,(getr n)))))"
msgstr ""

#: texi/node-23.texi:614
msgid ""
"     (defnode np/det\n"
"      (down mods np/mods\n"
"         (setr mods *))\n"
"      (jump np/mods\n"
"         (setr mods nil)))"
msgstr ""

#: texi/node-23.texi:618
msgid ""
"     (defnode np/mods\n"
"      (cat n np/n\n"
"         (setr n *)))"
msgstr ""

#: texi/node-23.texi:625
msgid ""
"     (defnode np/n\n"
"      (up `(np (det ,(getr det))\n"
"                (modifiers ,(getr mods))\n"
"                (noun ,(getr n))))\n"
"      (down pp np/pp\n"
"         (setr pp *)))"
msgstr ""

#: texi/node-23.texi:632
msgid ""
"     (defnode np/pp\n"
"      (up `(np (det ,(getr det))\n"
"                (modifiers ,(getr mods))\n"
"                (noun ,(getr n))\n"
"                ,(getr pp))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:634
msgid "                       Figure 23-9: Noun phrase sub-network."
msgstr ""
"                       Рисунок 23-9: Подсеть фраз существительных.\n"
"@end cartouche"

#: texi/node-23.texi:643
msgid ""
"@example\n"
"> (with-parses np '(it)\n"
"        (format t \"Parsing: ~A~%\" parse))\n"
"Parsing: (NP (PRONOUN IT))\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-23.texi:648
msgid ""
"@lisp\n"
"     (defnode pp\n"
"       (cat prep pp/prep\n"
"           (setr prep *)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defnode pp\n"
"       (cat prep pp/prep\n"
"           (setr prep *)))"

#: texi/node-23.texi:652
msgid ""
"     (defnode pp/prep\n"
"       (down np pp/np\n"
"           (setr op *)))"
msgstr ""

#: texi/node-23.texi:657
msgid ""
"     (defnode pp/np\n"
"       (up `(pp (prep ,(getr prep))\n"
"                   (obj ,(getr op)))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:659
msgid "                    Figure 23-10: Prepositional phrase sub-network."
msgstr ""
"                    Рисунок 23-10: подсеть фраз предлогов.\n"
"@end cartouche"

#: texi/node-23.texi:667
msgid ""
"Both the other arcs lead to node np/det: one arc reads a determiner (e.g. "
"\"the\"),\n"
"and the other arc simply jumps, reading no input. At node np/det, both arcs\n"
"lead to np/mods; np/det has the option of pushing to sub-network mods to "
"pick\n"
"up a string of modifiers, or jumping. Node np-mods reads a noun and "
"continues\n"
"to np/n. This node can either pop a result, or push to the prepositional "
"phrase\n"
"network to try to pick up a prepositional phrase. The final node, np/pp, "
"pops a\n"
"result."
msgstr ""
"Обе другие дуги ведут к узлу np/det: одна дуга считывает определитель "
"(например \"the\"),\n"
"и другае дуга просто переходит(jumps), не считывая ввод. В узле np/det, обе "
"дуги\n"
"ведут к np/mods; У np/det есть возможность входа(pushing) в подсеть "
"модификаторво(mods)\n"
"чтобы получить строку модификаторов, или переход. Узел np-mods читает "
"существительное и\n"
"продлжает np/n. Этот узел может либо выдать(pop) результат, либо войти(push) "
"в сеть\n"
"фраз предлогов, чтобы попытаться подобрать фразу предлог. Последний узел, np/"
"pp,\n"
"выдает(pop) результат."

#: texi/node-23.texi:670
msgid ""
"Different types of noun phrases will have different parse paths. Here are "
"two\n"
"parsings on the noun phrase network:"
msgstr ""
"Различные типы существительных фраз буду иметь различные пути "
"синтаксичекского\n"
"анализа. Вот два анализа в сети фраз существительных:"

#: texi/node-23.texi:686
msgid ""
"@example\n"
"> (with-parses np '(arrows)\n"
"        (pprint parse))\n"
"(NP (DET NIL)\n"
"        (MODIFIERS NIL)\n"
"        (NOUN ARROWS))\n"
"@@> (with-parses np '(a time fly like him)\n"
"        (pprint parse))\n"
"(NP (DET A)\n"
"        (MODIFIERS (N-GROUP TIME))\n"
"        (NOUN FLY)\n"
"        (PP (PREP LIKE)\n"
"             (OBJ (NP (PRONOUN HIM)))))\n"
"@\n"
"@end example"
msgstr ""

#: texi/node-23.texi:689
msgid ""
"The first parse succeeds by jumping to np/det, jumping again to np/mods,\n"
"reading a noun, then popping at np/n. The second never jumps, pushing first "
"for"
msgstr ""
"Первый анализ завершается успешно, если перейти к np/det, снова перейти к np/"
"mods,\n"
"прочитать существительнрое, а затем выйти через np/n. Второй никогда не "
"переходит\n"
"(jumps), входя(pushing) вначале для поиска модификаторов строки в сеть mods"

#: texi/node-23.texi:700
msgid ""
"@lisp\n"
" (defnode s\n"
"    (down np s/subj\n"
"        (setr mood 'decl)\n"
"        (setr subj *))\n"
"    (cat v v\n"
"        (setr mood 'imp)\n"
"        (setr subj '(np (pron you)))\n"
"        (setr aux nil)\n"
"        (setr v *)))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defnode s\n"
"    (down np s/subj\n"
"        (setr mood 'decl)\n"
"        (setr subj *))\n"
"    (cat v v\n"
"        (setr mood 'imp)\n"
"        (setr subj '(np (pron you)))\n"
"        (setr aux nil)\n"
"        (setr v *)))"

#: texi/node-23.texi:705
msgid ""
" (defnode s/subj\n"
"    (cat v v\n"
"        (setr aux nil)\n"
"        (setr v *)))"
msgstr ""

#: texi/node-23.texi:713
msgid ""
" (defnode v\n"
"    (up `(s (mood ,(getr mood))\n"
"               (subj ,(getr subj))\n"
"               (vcl (aux ,(getr aux))\n"
"                     (v ,(getr v)))))\n"
"    (down np s/obj\n"
"        (setr obj *)))"
msgstr ""

#: texi/node-23.texi:721
msgid ""
" (defnode s/obj\n"
"    (up `(s (mood ,(getr mood))\n"
"               (subj ,(getr subj))\n"
"               (vcl (aux ,(getr aux))\n"
"                     (v ,(getr v)))\n"
"               (obj ,(getr obj)))))\n"
"@end lisp"
msgstr ""

#: texi/node-23.texi:723
msgid "                        Figure 23-11: Sentence network."
msgstr ""
"                        Рисунок 23-11: Сеть предложений.\n"
"@end cartouche"

#: texi/node-23.texi:730
msgid ""
"@noindent\n"
"a string of modifiers, and again for a prepositional phrase. As is often the "
"case\n"
"with parsers, expressions which are syntactically well-formed are such "
"nonsense\n"
"semantically that it's difficult for humans even to detect the syntactic "
"structure.\n"
"Here the noun phrase \"a time fly like him\" has the same form as \"a Lisp "
"hacker\n"
"like him.\""
msgstr ""
"@noindent\n"
"и возвращаясь снова к фразе предлогов. Как часто случается с "
"синтаксическими\n"
"анаолизаторами, выражение котоыре правильно синтаксически сформированы, \n"
"семантически настолько бессмысленны, что людям даже трудно обнаружить в них\n"
"синтаксическую структуру.\n"
"Здесь фраза существительного \"a time fly like him\" имеет ту же форму, что "
"и\n"
"\"a Lisp hacker like him.\""

#: texi/node-23.texi:734
msgid ""
"Now all we need is a network for recognizing sentence structure. The "
"network\n"
"shown in Figure 23-11 parses both commands and statements. The start node\n"
"is conventionally called s. The first node leaving it pushes for a noun "
"phrase,"
msgstr ""
"Теперь все, что нам нужно, это сеть для распознавания структуры "
"предложений.\n"
"Сеть показанная на Риснуке 23-11 анализирует как команды, так и операторы.\n"
"Начальный узел, покидающий ее, входит в сеть фраз существительных,"

#: texi/node-23.texi:738
msgid ""
"@example\n"
" > (with-parses s '(time flies like an arrow)\n"
"          (pprint parse))"
msgstr ""
"@cartouche\n"
"@example\n"
" > (with-parses s '(time flies like an arrow)\n"
"          (pprint parse))"

#: texi/node-23.texi:748
msgid ""
" (S (MOOD DECL)\n"
"        (SUBJ (NP (DET NIL)\n"
"                      (MODIFIERS (N-GROUP TIME))\n"
"                      (NOUN FLIES)))\n"
"        (VCL (AUX NIL)\n"
"               (V LIKE))\n"
"        (OBJ (NP (DET AN)\n"
"                     (MODIFIERS NIL)\n"
"                     (NOUN ARROW))))"
msgstr ""

#: texi/node-23.texi:762
msgid ""
" (S (MOOD IMP)\n"
"        (SUBJ (NP (PRON YOU)))\n"
"        (VCL (AUX NIL)\n"
"               (V TIME))\n"
"        (OBJ (NP (DET NIL)\n"
"                     (MODIFIERS NIL)\n"
"                     (NOUN FLIES)\n"
"                     (PP (PREP LIKE)\n"
"                          (OBJ (NP (DET AN)\n"
"                                      (MODIFIERS NIL)\n"
"                                      (NOUN ARROW)))))))\n"
" @\n"
"@end example"
msgstr ""

#: texi/node-23.texi:764
msgid "                      Figure 23-12: Two parsings for a sentence."
msgstr ""
"                      Рисунок 23-12: Два анализа для предложения.\n"
"@end cartouche"

#: texi/node-23.texi:773
msgid ""
"@noindent\n"
"which will be the subject of the sentence. The second outgoing arc reads a "
"verb.\n"
"When a sentence is syntactically ambiguous, both arcs could succeed, "
"ultimately\n"
"yielding two or more parsings, as in Figure 23-12. The first parsing is "
"analogous\n"
"to \"Island nations like a navy,\" and the second is analogous to \"Find "
"someone like\n"
"a policeman.\" More complex ATNs are able to find six or more parsings for "
"\"Time\n"
"flies like an arrow.\""
msgstr ""
"@noindent\n"
"которое будет предметом предложения. Вторая исходящая дуга читает глагол.\n"
"Когда предложение синтаксически не однозначно, обе дуги могут быть "
"успешными,\n"
"в конечно итоге приводя к двум разборам, как на Рисунке 23-12. Первый "
"разбор\n"
"аналогичен \"Island nations like a navy,\"(островные нации, подобны флоту) "
"и\n"
"второй аналогичен \"Find someone like a policeman.\"(найти кото-то похожего\n"
"на полицейского). Более сложные ATN могут найти шесть или более разборов "
"для\n"
"\"Time flies like an arrow.\""

#: texi/node-23.texi:779
msgid ""
"The ATN compiler in this chapter is presented more as a distillation of the "
"idea\n"
"of an ATN than as production software. A few obvious changes would make "
"this\n"
"code much more efficient. When speed is important, the whole idea of "
"simulating\n"
"nondeterminism with closures may be too slow. But when it isn't essential, "
"the\n"
"programming techniques described here lead to very concise programs."
msgstr ""
"Компилятор ATN в этой главе представлен скорее как воплощение идеи ATN, чем "
"как\n"
"производственная программа. Несколько очевидных изменений сделают это код "
"намного\n"
"более эффективным. Когда важна скорость, ама идея симуляции недетерминизма "
"с\n"
"помощью замыканий может быть слишком медленной. Но когда это не важно, "
"описанные\n"
"здесь методы программирования приводят к очень кратки программам."
