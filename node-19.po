#
# NuINu <don't@send.my>, 2019.
#
#. extracted from texi/node-19.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-25 08:02+0300\n"
"PO-Revision-Date: 2019-05-16 12:09+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: texi/node-19.texi:5
msgid ""
"@node 19 A Query Compiler, 20 Continuations, 18 Destructuring, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 19 A Query Compiler\n"
"@cindex 19 A Query Compiler"
msgstr ""
"@node 19 A Query Compiler, 20 Continuations, 18 Destructuring, Top\n"
"@comment  node-name,  next,  previous,  up\n"
"@chapter 19 Компилятор Запросов\n"
"@cindex 19 A Query Compiler"

#: texi/node-19.texi:13
msgid ""
"Some of the macros defined in the preceding chapter were large ones. To "
"generate\n"
"its expansion, if-match needed all the code in Figures 18-7 and 18-8, plus\n"
"destruc from Figure 18-1. Macros of this size lead naturally to our last "
"topic,\n"
"embedded languages. If small macros are extensions to Lisp, large macros "
"define\n"
"sub-languages within it-possibly with their own syntax or control structure. "
"We\n"
"saw the beginning of this in if-match, which had its own distinct "
"representation\n"
"for variables."
msgstr ""
"Некоторые из макросов определенных в предыдущей главе, были большими. "
"Чтобы \n"
"сгенерировать рассширение if-match потребовался весь код на Рисунках 18-7 и "
"18-8,\n"
"плюс destruc из Рисунка 18-1. Макросы такого размера естественным образом "
"ведут\n"
"к нашей последней теме - встроенным языкам. Если небольшие макросы являются\n"
"расширениями Lisp, большие макросы определяют внутриязыковые подъязыки, "
"возможно\n"
"со своим собственным синтаксисом или структурой управления. Мы увидели "
"начало \n"
"этого в  if-match, который имел свое собственное отдельное представление "
"для\n"
"переменных."

#: texi/node-19.texi:17
msgid ""
"A language implemented within Lisp is called an embedded language. Like\n"
"\"utility,\" the term is not a precisely defined one; if-match probably "
"still counts\n"
"as a utility, but it is getting close to the borderline."
msgstr ""
"Язык, реализованный внутри Lisp называется встроенным языком. Как и "
"\"полезность(utility)\",\n"
"этот термин не является четко определенным; if-match вероятно, все еще "
"считается\n"
"утилитой, но приближается к границе."

#: texi/node-19.texi:24
msgid ""
"An embedded language is not a like a language implemented by a traditional\n"
"compiler or interpreter. It is implemented within some existing language, "
"usually\n"
"by transformation. There need be no barrier between the base language and "
"the\n"
"extension: it should be possible to intermingle the two freely. For the "
"implementor,\n"
"this can mean a huge saving of effort. You can embed just what you need, and "
"for\n"
"the rest, use the base language."
msgstr ""
"Встроенный язык не похож на язык, реализованный традиционным транслятором "
"или\n"
"интерперетатором. Он реализуется в рамках существующего языка, обычно путем\n"
"преобразования. Не должно былть никакого барьера между базовым языком и\n"
"расширением: должна быть возможность, свободного их смешивания. Для "
"разработчкика\n"
"это может означать огромную экономию усилий. Вы можете встраивать только то, "
"что\n"
"вам нужно, а в остальном использовать базовый язык."

#: texi/node-19.texi:30
msgid ""
"Transformation, in Lisp, suggests macros. To some extent, you could imple-\n"
"ment embedded languages with preprocessors. But preprocessors usually "
"operate\n"
"only on text, while macros take advantage of a unique property of Lisp: "
"between\n"
"the reader and the compiler, your Lisp program is represented as lists of "
"Lisp\n"
"objects. Transformations done at this stage can be much smarter."
msgstr ""
"Преобразование в Lisp, предполагает макросы. В некоторой степени вы можете \n"
"реализовать встроенный языки с препроцессорами. Но препроцессоры обычно "
"работают\n"
"только с текстом, в то время как макросы используют уникальное свойство "
"Lisp: \n"
"между читателем(reader) и компилятором, ваша программа Lisp представляется\n"
"в виде списков объектов Lisp. Преобразования, сделанные на этом этапе,\n"
"могут быть намного умнее."

#: texi/node-19.texi:36
msgid ""
"The best-known example of an embedded language is CLOS, the Common Lisp\n"
"Object System. If you wanted to make an object-oriented version of a "
"conventional\n"
"language, you would have to write a new compiler. Not so in Lisp. Tuning "
"the\n"
"compiler will make CLOS run faster, but in principle the compiler doesn't "
"have to\n"
"be changed at all. The whole thing can be written in Lisp."
msgstr ""
"Наиболее известным примером встроенного языка является CLOS - Common Lisp\n"
"Object System. Если вы хотите создать объектно-ориентированную версию "
"обычного\n"
"языка, вам придется написать новый компилятор. В Lisp это не так. "
"Настройка \n"
"компилятора заставит CLOS работать быстрее, но в принципе компилятор менять\n"
"вообще не нужно. Все это можно написать и на Lisp."

#: texi/node-19.texi:43
msgid ""
"The remaining chapters give examples of embedded languages. This chapter\n"
"describes how to embed in Lisp a program to answer queries on a database. "
"(You\n"
"will notice in this program a certain family resemblance to if-match.) The "
"first\n"
"sections describe how to write a system which interprets queries. This "
"program is\n"
"then reimplemented as a query compiler-in essence, as one big macro-making\n"
"it both more efficient and better integrated with Lisp."
msgstr ""
"В остальных главах приведены примеры встроенных языков. В этой главе "
"описывается,\n"
"как встроить в Lisp программу отвечающую на запросы к базе данных. (В этой "
"программе\n"
"вы заметите семейное сходствов с if-match.) Первые разделы описывают, как "
"написать\n"
"систему, которая интерпретирует запросы. Затем эта программа реализуется как "
"компилятор\n"
"запросов - по сути, как один большой макрос - что делает её более "
"эффективной и лучше\n"
"интегрированной с Lisp."

#: texi/node-19.texi:51
msgid ""
"@menu\n"
"* 19-1 The Database::           \n"
"* 19-2 Pattern-Matching Queries::  \n"
"* 19-3 A Query Interpreter::    \n"
"* 19-4 Restrictions on Binding::  \n"
"* 19-5 A Query Compiler::       \n"
"@end menu"
msgstr ""

#: texi/node-19.texi:56
msgid ""
"@node 19-1 The Database, 19-2 Pattern-Matching Queries, 19 A Query Compiler, "
"19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-1 The Database\n"
"@cindex 19-1 The Database"
msgstr ""
"@node 19-1 The Database, 19-2 Pattern-Matching Queries, 19 A Query Compiler, "
"19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-1 База Данных\n"
"@cindex 19-1 The Database"

#: texi/node-19.texi:61
msgid ""
"For our present purposes, the format of the database doesn't matter very "
"much.\n"
"Here, for the sake of convenience, we will store information in lists. For "
"example,\n"
"we will represent the fact that Joshua Reynolds was an English painter who "
"lived\n"
"from 1723 to 1792 by:"
msgstr ""
"Для наших нынешних целей формат базы данных не имеет большого значения. "
"Здесь для\n"
"удобства мы будем хранить информацию в списках. Например, мы представим тот "
"факт,\n"
"что Joshua Reynolds был английским художником, который жил с 1723 по 1792:"

#: texi/node-19.texi:66
msgid ""
"@lisp\n"
"(painter reynolds joshua english)\n"
"(dates reynolds 1723 1792)\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:69
msgid ""
"There is no canonical way of reducing information to lists. We could just as "
"well\n"
"have used one big list:"
msgstr ""
"Не существует канонического(общепризнанного) способа сведения информации в "
"списки.\n"
"Мы также могли бы использовать один большой список:\n"

#: texi/node-19.texi:73
msgid ""
"@lisp\n"
"(painter reynolds joshua 1723 1792 english)\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:78
msgid ""
"It is up to the user to decide how to organize database entries. The only "
"restriction\n"
"is that the entries (facts) will be indexed under their first element (the "
"predicate).\n"
"Within those bounds, any consistent form will do, although some forms might\n"
"make for faster queries than others."
msgstr ""
"Пользователь должен решить, как организовать записи в базе данных. "
"Единственным ограничением\n"
"является то, что записи(факты) будут проиндексированы в соответствии с их "
"первым элементом\n"
"(передикатом). В этих рамки подойдет любая совместимая форма, хотя некоторые "
"формы могут\n"
"выполнять запросы быстрее, чем другие."

#: texi/node-19.texi:83
msgid ""
"Any database system needs at least two operations: one for modifying the\n"
"database, and one for examining it. The code shown in Figure 19-1 provides "
"these\n"
"operations in a basic form. A database is represented as a hash-table filled "
"with\n"
"lists of facts, hashed according to their predicate."
msgstr ""
"Любой системе баз данных требуются как минимум две операции: одна для "
"изменения\n"
"базы данных и одна для её проверки. Код показанный на Рисунке 19-1 "
"передоставляет\n"
"эти операции в базовой форме. База данных представлена в виде хеш-таблицы, \n"
"заполненной списками фактов, хешированных в соответствии с их "
"пердикатом(первым \n"
"элементом)."

#: texi/node-19.texi:88
msgid ""
"Although the database functions defined in Figure 19-1 support multiple\n"
"databases, they all default to operations on *default-db*. As with packages\n"
"in Common Lisp, programs which don't need multiple databases need not even\n"
"mention them. In this chapter all the examples will just use the *default-"
"db*."
msgstr ""
"Хотя функции базы данных, определенные на Рисунке 19-1 поддерживают "
"несколько\n"
"баз данных, все они по умолчанию работают с  *default-db*.  Как и в случае "
"с \n"
"пакетами в Common Lisp, программы, которым не требуется несколько баз "
"данных,\n"
"даже не должны упоминать их. В этой главе во всех примерах будет "
"использоваться\n"
"*default-db*."

#: texi/node-19.texi:95
msgid ""
"We initialize the system by calling clear-db, which empties the current\n"
"database. We can look up facts with a given predicate with db-query, and "
"insert\n"
"new facts into a database entry with db-push. As explained in Section 12-1, "
"a\n"
"macro which expands into an invertible reference will itself be invertible. "
"Since\n"
"db-query is defined this way, we can simply push new facts onto the db-"
"query\n"
"of their predicates. In Common Lisp, hash-table entries are initialized to "
"nil"
msgstr ""
"Мы инициализируем систему, вызывая clear-db, который очищает текущую базу "
"данных.\n"
"Мы можем искать факты с заданным предикатом с помощью db-query, и вставлять "
"новые\n"
"факты в базу данных с помощью db-push. Как объяснено в Разделе 12-1, макрос "
"который\n"
"расширяется в обратимую ссылку, сам по себе будет обратимым. Так как db-"
"query \n"
"определен таким же образом, мы можем просто вставить новые факты в db-query "
"в виде\n"
"его предикатов. В Common Lisp, записи хеш-таблицы инициализируются как nil"

#: texi/node-19.texi:99
msgid ""
"@lisp\n"
"     (defun make-db (&optional (size 100))\n"
"       (make-hash-table :size size))"
msgstr ""
"@cartouche\n"
"@lisp\n"
"     (defun make-db (&optional (size 100))\n"
"       (make-hash-table :size size))"

#: texi/node-19.texi:101
msgid "     (defvar *default-db* (make-db))"
msgstr ""

#: texi/node-19.texi:104
msgid ""
"     (defun clear-db (&optional (db *default-db*))\n"
"       (clrhash db))"
msgstr ""

#: texi/node-19.texi:107
msgid ""
"     (defmacro db-query (key &optional (db '*default-db*))\n"
"       `(gethash ,key ,db))"
msgstr ""

#: texi/node-19.texi:110
msgid ""
"     (defun db-push (key val &optional (db *default-db*))\n"
"       (push val (db-query key db)))"
msgstr ""

#: texi/node-19.texi:115
msgid ""
"     (defmacro fact (pred &rest args)\n"
"       `(progn (db-push ',pred ',args)\n"
"               ',args))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:117
msgid "                     Figure 19-1: Basic database functions."
msgstr ""
"                     Рисунок 19-1: Базовые функции работы с базой данных.\n"
"@end cartouche"

#: texi/node-19.texi:122
msgid ""
"@noindent\n"
"unless specified otherwise, so any key initially has an empty list "
"associated with\n"
"it. Finally, the macro fact adds a new fact to the database."
msgstr ""
"@noindent\n"
"если не указано иное, поэтому любой ключ изначально имеет пустой список, "
"связанный с\n"
"ним. Наконец, макрос fact добавляет новый факт в базу данных."

#: texi/node-19.texi:133
msgid ""
"@example\n"
"> (fact painter reynolds joshua english)\n"
"(REYNOLDS JOSHUA ENGLISH)\n"
"> (fact painter canale antonio venetian)\n"
"(CANALE ANTONIO VENETIAN)\n"
"> (db-query 'painter)\n"
"((CANALE ANTONIO VENETIAN)\n"
"     (REYNOLDS JOSHUA ENGLISH))\n"
"T\n"
"@end example"
msgstr ""

#: texi/node-19.texi:137
msgid ""
"The t returned as the second value by db-query appears because db-query\n"
"expands into a gethash, which returns as its second value a flag to "
"distinguish\n"
"between finding no entry and finding an entry whose value is nil."
msgstr ""
"Значение t возвращаемое как второе значение db-query появляется потому, что "
"db-query\n"
"расширяется в gethash, который возвращает в качестве второго значения флаг, "
"позволяющий\n"
"различать, не найде на ли запись, или найдена запись, значение которой равно "
"nil."

#: texi/node-19.texi:142
msgid ""
"@node 19-2 Pattern-Matching Queries, 19-3 A Query Interpreter, 19-1 The "
"Database, 19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-2 Pattern-Matching Queries\n"
"@cindex 19-2 Pattern-Matching Queries"
msgstr ""
"@node 19-2 Pattern-Matching Queries, 19-3 A Query Interpreter, 19-1 The "
"Database, 19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-2 Запросы Сопоставление с Образцом(Pattern-Matching Queries)\n"
"@cindex 19-2 Pattern-Matching Queries"

#: texi/node-19.texi:146
msgid ""
"Calling db-query is not a very flexible way of looking at the contents of "
"the\n"
"database. Usually the user wants to ask questions which depend on more than\n"
"just the first element of a fact. A query language is a language for "
"expressing"
msgstr ""
"Вызов db-query не очень гибкий способ просмотра содержимого базы данных. "
"Обычно\n"
"пользователь хочет задать вопросы, которые зависят не только от первого "
"элемента\n"
"факта. Язык запросов - это язык для выражения"

#: texi/node-19.texi:159
msgid ""
"@lisp\n"
"  query         : ( symbol  argument *)\n"
"                : (not  query )\n"
"                : (and  query *)\n"
"                : (or  query *)\n"
"  argument  : ? symbol \n"
"                :  symbol \n"
"                :  number \n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
"  query         : ( symbol  argument *)\n"
"                : (not  query )\n"
"                : (and  query *)\n"
"                : (or  query *)\n"
"  argument  : ? symbol \n"
"                :  symbol \n"
"                :  number \n"
"@end lisp"

#: texi/node-19.texi:161
msgid "                         Figure 19-2: Syntax of queries."
msgstr ""
"                         Рисунок 19-2: Синтаксис запросов.\n"
"@end cartouche"

#: texi/node-19.texi:166
msgid ""
"more complicated questions. In a typical query language, the user can ask "
"for all\n"
"the values which satisfy some combination of restrictions-for example, the "
"last\n"
"names of all the painters born in 1697."
msgstr ""
"более сложных запросов. В типичном языке запросов пользователь может "
"запросить все\n"
"значения, которые удовлетворяют некоторой комбинации ограничений, например, "
"фамилии\n"
"всех художников родившихся в 1697."

#: texi/node-19.texi:174
msgid ""
"Our program will provide a declarative query language. In a declarative "
"query\n"
"language, the user specifies the constraints which answers must satisfy, and "
"leaves\n"
"it to the system to figure out how to generate them. This way of expressing "
"queries\n"
"is close to the form people use in everyday conversation. With our program, "
"we\n"
"will be able to express the sample query by asking for all the x such that "
"there\n"
"is a fact of the form (painter x ...), and a fact of the form (dates x 1697\n"
"...). We will be able to refer to all the painters born in 1697 by writing:"
msgstr ""
"Наша программа предоставляет декларативный язык запросов. В декларативном "
"языке\n"
"запросов пользователь указывает ограничения, которым должны удовлетворять "
"ответы\n"
"и предоставляет системе возможность выяснить, как их сгенерировать. Этот "
"способ\n"
"выражения запросов близок к форме, которую люди используют в повседневной "
"беседе. \n"
"С нашей программой мы можем выразить пример запроса, запросив все x, то "
"есть \n"
"факты формы (painter x ...), и факты формы (dates x 1697 ...). Мы можем "
"сослаться\n"
"на всех художников(painters) родившихся в 1697 году записав:"

#: texi/node-19.texi:179
msgid ""
"@lisp\n"
"(and (painter ?x ?y ?z)\n"
"        (dates ?x 1697 ?w))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:184
msgid ""
"As well as accepting simple queries consisting of a predicate and some "
"arguments,\n"
"our program will be able to answer arbitrarily complex queries joined "
"together by\n"
"logical operators like and and or. The syntax of the query language is shown "
"in\n"
"Figure 19-2."
msgstr ""
"Помимо принятия простых запросов, состоящих из предиката и некоторых "
"аргументов,\n"
"наша программа сможет отвечать на произвольно сложные запросы, объединенные\n"
"логическими операторами, такими как and и or. Синтаксис языка запросов "
"показан\n"
"на рисунке 19-2."

#: texi/node-19.texi:189
msgid ""
"Since facts are indexed under their predicates, variables cannot appear in "
"the\n"
"predicate position. If you were willing to give up the benefits of indexing, "
"you\n"
"could get around this restriction by always using the same predicate, and "
"making\n"
"the first argument the de facto predicate."
msgstr ""
"Поскольку факты индексируются по их предикатам, переменные не могут "
"появлятья в\n"
"позиции предиката. Если вы готовы отказаться от преимуществ индексирования, "
"вы\n"
"можете обойти это ограничение, всегда используя один и тот же предикат и "
"делая\n"
"первый аргумент предикатом де-факто."

#: texi/node-19.texi:194
msgid ""
"Like many such systems, this program has a skeptic's notion of truth: some\n"
"facts are known, and everything else is false. The not operator succeeds if "
"the\n"
"fact in question is not present in the database. To a degree, you could "
"represent\n"
"explicit falsity by the Wayne's World method:"
msgstr ""
"Как и в большинстве подобных систем, в этой программе скептическое "
"представление об\n"
"истинности: некоторые факты известны, а все остальное ложно. Оператор not "
"завершается\n"
"успехом, если рассматриваемый факт отсутствует в базе данных. В некоторой "
"степени\n"
"вы могли бы представить явную ложь методом Мира Уэйна:"

#: texi/node-19.texi:198
msgid ""
"@lisp\n"
"(edible motor-oil not)\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:200
msgid ""
"However, the not operator wouldn't treat these facts differently from any "
"others."
msgstr ""
"Однако оператор not не будет относиться к этим фактам иначе, чем другие."

#: texi/node-19.texi:207
msgid ""
"In programming languages there is a fundamental distinction between inter-\n"
"preted and compiled programs. In this chapter we examine the same question\n"
"with respect to queries. A query interpreter accepts a query and uses it to "
"generate\n"
"answers from the database. A query compiler accepts a query and generates a\n"
"program which, when run, yields the same result. The following sections "
"describe\n"
"a query interpreter and then a query compiler."
msgstr ""
"В языках программирования существует принципиальное различие между "
"интерпретируемыми\n"
"и скомпилированными программами. В этой главе мы рассмотрим тот же вопрос в "
"отношении\n"
"запросов. Интеретатор запросов принимает запрос и использует его для "
"генерации ответов\n"
"из базы данных. Компилятор запросов принимаетт запрос и генерирует "
"программу, которая\n"
"при запуске дает тот же результат. В следующих разделах описывается "
"интерпретатор\n"
"запросов, а затем компилятор запросов."

#: texi/node-19.texi:212
msgid ""
"@node 19-3 A Query Interpreter, 19-4 Restrictions on Binding, 19-2 Pattern-"
"Matching Queries, 19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-3 A Query Interpreter\n"
"@cindex 19-3 A Query Interpreter"
msgstr ""
"@node 19-3 A Query Interpreter, 19-4 Restrictions on Binding, 19-2 Pattern-"
"Matching Queries, 19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-3 Интерпретатор Запросов\n"
"@cindex 19-3 A Query Interpreter"

#: texi/node-19.texi:219
msgid ""
"To implement a declarative query language we will use the pattern-matching\n"
"utilities defined in Section 18-4. The functions shown in Figure 19-3 "
"interpret\n"
"queries of the form shown in Figure 19-2. The central function in this code "
"is\n"
"interpret-query, which recursively works through the structure of a complex\n"
"query, generating bindings in the process. The evaluation of complex "
"queries\n"
"proceeds left-to-right, as in Common Lisp itself."
msgstr ""
"Для реализации декларативного языка запросов мы будем использовать утилиты\n"
"сопоставления с образцом, определенные в разделе 18-4. Функции, показанные "
"на\n"
"рисунке 19-3 интерпретируют запросы представленные в форме показанной на \n"
"рисунке 19-2. Центральной функцией в этом коде является interpret-query, "
"которая\n"
"рекурсивно работает проходя через структуру сложного запроса, генерируя\n"
"в процессе привязки. Вычисление сложных запросов происходит слева на "
"право, \n"
"как и в самом Common Lisp."

#: texi/node-19.texi:227
msgid ""
"When the recursion gets down to patterns for facts, interpret-query calls\n"
"lookup. This is where the pattern-matching occurs. The function lookup "
"takes\n"
"a pattern consisting of a predicate and a list of arguments, and returns a "
"list of all\n"
"the bindings which make the pattern match some fact in the database. It gets "
"all\n"
"the database entries for the predicate, and calls match (page 239) to "
"compare each\n"
"of them against the pattern. Each successful match returns a list of "
"bindings, and\n"
"lookup in turn returns a list of all these lists."
msgstr ""
"Когда рекурсия опускается вниз к образцам для фактов, interpret-query "
"вызывает lookup. \n"
"Здесь происходит сопоставление с образцом. Функция lookup принимает образец "
"состоящий из\n"
"предиката и списка аргументов, и возвращает список всех привязок, которые "
"делают\n"
"соответствующим образец некоторым фактам в базе данных. Он получает все "
"записи базы данных\n"
"для предиката и вызывает match(сопоставление) (стр 239), чтобы сравнить "
"каждую из них с\n"
"образцом. Каждое успешное сравнение возвращает список привязок, а lookup, в "
"свою очередь,i\n"
"возвращает список всех этих списков."

#: texi/node-19.texi:232
msgid ""
"@example\n"
"> (lookup 'painter '(?x ?y english))\n"
"(((?Y . JOSHUA) (?X . REYNOLDS)))\n"
"@end example"
msgstr ""

#: texi/node-19.texi:237
msgid ""
"These results are then filtered or combined depending on the surrounding\n"
"logical operators. The final result is returned as a list of sets of "
"bindings. Given\n"
"the assertions shown in Figure 19-4, here is the example from earlier in "
"this\n"
"chapter:"
msgstr ""
"Эти результаты затем фильтруются или объединяются в зависимости от "
"окружающих\n"
"логических операторов. Окончательный результат возвращается в виде списка\n"
"наборов привязок. Учитывая утверждения показанные на Рисунке 19-4, вот\n"
"пример интерпретации запроса указанного ранее в этой главе:"

#: texi/node-19.texi:244
msgid ""
"@example\n"
"> (interpret-query '(and (painter ?x ?y ?z)\n"
"                                   (dates ?x 1697 ?w)))\n"
"(((?W . 1768) (?Z . VENETIAN) (?Y . ANTONIO) (?X . CANALE))\n"
" ((?W . 1772) (?Z . ENGLISH) (?Y . WILLIAM) (?X . HOGARTH)))\n"
"@end example"
msgstr ""

#: texi/node-19.texi:248
msgid ""
"As a general rule, queries can be combined and nested without restriction. "
"In a\n"
"few cases there are subtle restrictions on the syntax of queries, but these "
"are best\n"
"dealt with after looking at some examples of how this code is used."
msgstr ""
"Как правило, запросы могут быть объединены и вложены без ограничений. В "
"некоторых\n"
"случаях существуют тонкие ограничения на синтаксис запросов, но лучше всего "
"с ними\n"
"разобраться посмотрев некотоыре примеры использования этого кода."

#: texi/node-19.texi:252
msgid ""
"The macro with-answer provides a clean way of using the query interpreter\n"
"within Lisp programs. It takes as its first argument any legal query; the "
"rest\n"
"of the arguments are treated as a body of code. A with-answer expands into"
msgstr ""
"Макрос with-answer обеспечивает понятный способ использования "
"интерпретатора\n"
"запросов в программах Lisp. В качестве первого аргумента он принимает любой\n"
"правильно сформированный запрос; остальные аргументы обрабатываются как "
"тело\n"
"кода. Макрос with-answer расширяется в"

#: texi/node-19.texi:261
msgid ""
"@lisp\n"
" (defmacro with-answer (query &body body)\n"
"   (let ((binds (gensym)))\n"
"        `(dolist (,binds (interpret-query ',query))\n"
"              (let ,(mapcar #'(lambda (v)\n"
"                                  `(,v (binding ',v ,binds)))\n"
"                              (vars-in query #'atom))\n"
"               ,@@body))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-answer (query &body body)\n"
"   (let ((binds (gensym)))\n"
"        `(dolist (,binds (interpret-query ',query))\n"
"              (let ,(mapcar #'(lambda (v)\n"
"                                  `(,v (binding ',v ,binds)))\n"
"                              (vars-in query #'atom))\n"
"               ,@@body))))"

#: texi/node-19.texi:268
msgid ""
" (defun interpret-query (expr &optional binds)\n"
"   (case (car expr)\n"
"        (and (interpret-and (reverse (cdr expr)) binds))\n"
"        (or      (interpret-or (cdr expr) binds))\n"
"        (not (interpret-not (cadr expr) binds))\n"
"        (t       (lookup (car expr) (cdr expr) binds))))"
msgstr ""

#: texi/node-19.texi:275
msgid ""
" (defun interpret-and (clauses binds)\n"
"   (if (null clauses)\n"
"         (list binds)\n"
"         (mapcan #'(lambda (b)\n"
"                        (interpret-query (car clauses) b))\n"
"                    (interpret-and (cdr clauses) binds))))"
msgstr ""

#: texi/node-19.texi:280
msgid ""
" (defun interpret-or (clauses binds)\n"
"   (mapcan #'(lambda (c)\n"
"                    (interpret-query c binds))\n"
"                 clauses))"
msgstr ""

#: texi/node-19.texi:285
msgid ""
" (defun interpret-not (clause binds)\n"
"   (if (interpret-query clause binds)\n"
"         nil\n"
"         (list binds)))"
msgstr ""

#: texi/node-19.texi:291
msgid ""
" (defun lookup (pred args &optional binds)\n"
"   (mapcan #'(lambda (x)\n"
"                    (aif2 (match x args binds) (list it)))\n"
"                 (db-query pred)))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:293
msgid "                        Figure 19-3: Query interpreter."
msgstr ""
"                        Рисунок 19-3: Интерпретатор Запросов.\n"
"@end cartouche"

#: texi/node-19.texi:307
msgid ""
"@lisp\n"
" (clear-db)\n"
" (fact painter hogarth william english)\n"
" (fact painter canale antonio venetian)\n"
" (fact painter reynolds joshua english)\n"
" (fact dates hogarth 1697 1772)\n"
" (fact dates canale 1697 1768)\n"
" (fact dates reynolds 1723 1792)\n"
"@end lisp"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (clear-db)\n"
" (fact painter hogarth william english)\n"
" (fact painter canale antonio venetian)\n"
" (fact painter reynolds joshua english)\n"
" (fact dates hogarth 1697 1772)\n"
" (fact dates canale 1697 1768)\n"
" (fact dates reynolds 1723 1792)\n"
"@end lisp"

#: texi/node-19.texi:309
msgid "                       Figure 19-4: Assertion of sample facts."
msgstr ""
"                       Рисунок 19-4: Утверждение фактов для примера.\n"
"@end cartouche"

#: texi/node-19.texi:317
msgid ""
"@noindent\n"
"code which collects all the sets of bindings generated by the query, then "
"iterates\n"
"through the body with the variables in the query bound as specified by each "
"set of\n"
"bindings. Variables which appear in the query of a with-answer can "
"(usually)\n"
"be used within its body. When the query is successful but contains no "
"variables,\n"
"with-answer evaluates the body of code just once."
msgstr ""
"@noindent\n"
"код, который собирает все наборы привязок, сгенерированных запросом, затем "
"итерирует \n"
"тело выражений с переменными связанными в запросе, которые определены в "
"каждом наборе\n"
"привязок. Переменные, которые появляются в with-answer могут (обычно) "
"использоваться\n"
"внутри его тела. Когда запрос успешен, но не содержит переменных with-answer "
"исполняет\n"
"тело кода только один раз."

#: texi/node-19.texi:321
msgid ""
"With the database as defined in Figure 19-4, Figure 19-5 shows some sample\n"
"queries, accompanied by English translations. Because pattern-matching is "
"done\n"
"with match, it is possible to use the underscore as a wild-card in patterns."
msgstr ""
"С базой данных, определенной на рисунке 19-4, на риснуке 19-5 показаны "
"некоторые\n"
"примеры запросов, сопровождаемые переводами на английский язык. Поскольку "
"сопоставление\n"
"с образцом выполняется с помощью match, можно использовать подчеркивание как "
"безразличное\n"
"поле в образце."

#: texi/node-19.texi:325
msgid ""
"To keep these examples short, the code within the bodies of the queries "
"does\n"
"nothing more than print some result. In general, the body of a with-answer "
"can\n"
"consist of any Lisp expressions."
msgstr ""
"Чтобы эти примеры были короткими, код внутри тел запросов не делает ничего, "
"кроме\n"
"печати нескольких результатов. В общем, тело with-answer может состоять из\n"
"любых выражений Lisp."

#: texi/node-19.texi:330
msgid ""
"@node 19-4 Restrictions on Binding, 19-5 A Query Compiler, 19-3 A Query "
"Interpreter, 19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-4 Restrictions on Binding\n"
"@cindex 19-4 Restrictions on Binding"
msgstr ""
"@node 19-4 Restrictions on Binding, 19-5 A Query Compiler, 19-3 A Query "
"Interpreter, 19 A Query Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-4 Ограничения на связывание\n"
"@cindex 19-4 Restrictions on Binding"

#: texi/node-19.texi:333
msgid ""
"There are some restrictions on which variables will be bound by a query. "
"For\n"
"example, why should the query"
msgstr ""
"Существуеют некоторые ограничения на то, какие переменные будут связаны "
"запросом.\n"
"Например, почему запрос"

#: texi/node-19.texi:337
msgid ""
"@lisp\n"
"(not (painter ?x ?y ?z))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:343
msgid ""
"@noindent\n"
"assign any bindings to ?x and ?y at all? There are an infinite number of "
"combi-\n"
"nations of ?x and ?y which are not the name of some painter. Thus we add "
"the\n"
"following restriction: the not operator will filter out bindings which are "
"already\n"
"generated, as in"
msgstr ""
"@noindent\n"
"должен назначать какие либо привязки ?x и ?y вообще? Существует "
"бесконечное \n"
"количество комбинаций ?x и ?y, которые не являются именем какого либо "
"художника(painter).\n"
"Таким образом, мы добавляем следующее ограничение: оператор not будет "
"отфильтровывать\n"
"привязки, котоыре уже созданы, как в"

#: texi/node-19.texi:347
msgid ""
"@lisp\n"
"(and (painter ?x ?y ?z) (not (dates ?x 1772 ?d)))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:352
msgid ""
"@noindent\n"
"but you cannot expect it to generate bindings all by itself. We have to "
"generate\n"
"sets of bindings by looking for painters before we can screen out the ones "
"not born\n"
"in 1772. If we had put the clauses in the reverse order:"
msgstr ""
"@noindent\n"
"но вы не можете ожидать, что он будет генерировать привязки сам по себе. Мы "
"должны\n"
"создать наборы привязок, при поиске художников(painters), прежде чем мы "
"сможем отобрать\n"
"тех, кто не родился в 1772. Если бы мы поместили предложения в обратном "
"порядке:"

#: texi/node-19.texi:356
msgid ""
"@lisp\n"
"(and (not (dates ?x 1772 ?d)) (painter ?x ?y ?z))                        ; "
"wrong\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:358
msgctxt "texi/node-19.texi:358"
msgid "The first name and nationality of every painter called Hogarth."
msgstr ""
"@cartouche\n"
"Первое имя(имя) и национальность каждого художника называемого Hogarth."

#: texi/node-19.texi:365
msgid ""
"@example\n"
" > (with-answer (painter hogarth ?x ?y)\n"
"         (princ (list ?x ?y)))\n"
" (WILLIAM ENGLISH)\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:367
msgid "The last name of every painter born in 1697. (Our original example.)"
msgstr ""
"Последнее имя(фамилия) каждого художника родившегося в 1697. (Наш "
"оригинальный пример.)"

#: texi/node-19.texi:376
msgid ""
"@example\n"
" > (with-answer (and (painter ?x _ _)\n"
"                            (dates ?x 1697 _))\n"
"         (princ (list ?x)))\n"
" (CANALE)(HOGARTH)\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:378
msgid "The last name and year of birth of everyone who died in 1772 or 1792."
msgstr ""
"Последнее имя(фамилия) и год рождения любого кто умер в  1772 или  1792."

#: texi/node-19.texi:386
msgid ""
"@example\n"
" > (with-answer (or (dates ?x ?y 1772)\n"
"                          (dates ?x ?y 1792))\n"
"         (princ (list ?x ?y)))\n"
" (HOGARTH 1697)(REYNOLDS 1723)\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:389
msgid ""
"The last name of every English painter not born the same year as a Venetian\n"
"one."
msgstr ""
"Последнее имя(фамилия) каждого английского художника, который родился не в "
"тот\n"
"же год, что и Venetian\n"
"one."

#: texi/node-19.texi:399
msgid ""
"@example\n"
" > (with-answer (and (painter ?x _ english)\n"
"                            (dates ?x ?b _)\n"
"                            (not (and (painter ?x2 _ venetian)\n"
"                                         (dates ?x2 ?b _))))\n"
"         (princ ?x))\n"
" REYNOLDS\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:401
msgid "                   Figure 19-5: The query interpreter in use."
msgstr ""
"                   Рисунок 19-5: Использование интерпретатора запросов.\n"
"@end cartouche"

#: texi/node-19.texi:407
msgid ""
"@noindent\n"
"then we would get nil as the result if there were any painters born in 1772. "
"Even\n"
"in the first example, we shouldn't expect to be able to use the value of ?d "
"within\n"
"the body of a with-answer expression."
msgstr ""
"@noindent\n"
"тогда мы получим nil в качестве результата, если в 1772 году рождались "
"художники. Даже\n"
"в первом примере, мы не должны ожидать, что сможем использовать значение ?d "
"в теле выражения\n"
"with-answer."

#: texi/node-19.texi:411
msgid ""
"Also, expressions of the form (or q1 ... qn) are only guaranteed to "
"generate\n"
"real bindings for variables which appear in all of the qi.If a with-answer\n"
"contained the query"
msgstr ""
"Кроме того, выражение вида (or q1 ... qn) гарантировано генерирует реальные\n"
"привязки только для переменных, которые встречаются во всех qi. Если with-"
"answer\n"
"содержал запрос"

#: texi/node-19.texi:415
msgid ""
"@lisp\n"
"(or (painter ?x ?y ?z) (dates ?x ?b ?d))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:420
msgid ""
"you could expect to use the binding of ?x, because no matter which of the\n"
"subqueries succeeds, it will generate a binding for ?x. But neither ?y nor ?"
"b is\n"
"guaranteed to get a binding from the query, though one or the other will. "
"Pattern\n"
"variables not bound by the query will be nil for that iteration."
msgstr ""
"можно ожидать использования привязки ?x, потому что не зависимо от того, "
"какой из\n"
"подзапросов будет успешным, он сгенерирует привязку для ?x. Но ни ?y, ни ?b "
"не\n"
"гарантировано получение привязки  из запроса, хотя тот или другой её "
"получат. \n"
"Переменные образца не связанные с запросом, будут равны nil для этой "
"итерации."

#: texi/node-19.texi:425
msgid ""
"@node 19-5 A Query Compiler,  , 19-4 Restrictions on Binding, 19 A Query "
"Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-5 A Query Compiler\n"
"@cindex 19-5 A Query Compiler"
msgstr ""
"@node 19-5 A Query Compiler,  , 19-4 Restrictions on Binding, 19 A Query "
"Compiler\n"
"@comment  node-name,  next,  previous,  up\n"
"@section 19-5 Компилятор Запросов\n"
"@cindex 19-5 A Query Compiler"

#: texi/node-19.texi:431
msgid ""
"The code in Figure 19-3 does what we want, but inefficiently. It analyzes "
"the\n"
"structure of the query at runtime, though it is known at compile-time. And "
"it\n"
"conses up lists to hold variable bindings, when we could use the variables "
"to hold\n"
"their own values. Both of these problems can be solved by defining with-"
"answer\n"
"in a different way."
msgstr ""
"Код на рисунке 19-3 делает то что мы хотим, но неэффективно. Он анализирует\n"
"структуру запроса во время выполнения, хотя она известна уже во время "
"компиляции.\n"
"И он содержит списки для хранения привязок переменных, когда мы можем "
"использовать\n"
"переменные для хранения своих собственных значений. Обе эти проблемы могут "
"быть\n"
"решены путем определения with-answer другим способом."

#: texi/node-19.texi:440
msgid ""
"Figure 19-6 defines a new version of with-answer. The new version con-\n"
"tinues a trend which began with avg (page 182), and continued with if-match\n"
"(page 242): it does at compile-time much of the work that the old version "
"did\n"
"at runtime. The code in Figure 19-6 bears a superficial resemblance to that "
"in\n"
"Figure 19-3, but none of these functions are called at runtime. Instead of "
"gen-\n"
"erating bindings, they generate code, which becomes part of the expansion "
"of\n"
"with-answer. At runtime this code will generate all the bindings which "
"satisfy\n"
"the query according to the current state of the database."
msgstr ""
"Рисунок 19-6 оеределяет новую версию with-answer. Новая версия продолжает \n"
"тенденцию, которая началась с avg (стр. 182), и продолжилась в if-match\n"
"(стр. 242): она выполняет во время компиляции большую часть работы, которую\n"
"старая версия выполняла во время выполнения. Код на рисунке 19-6 имеет "
"внешнее\n"
"сходство с кодом на рисунке 19-3, но ни одна из этих функций не вызывается "
"во\n"
"время выполнения. Вместо того, чтобы генерировать привязки, они генерируют "
"код,\n"
"который становиться частью расширения with-answer. Во время выполнения этот "
"код\n"
"будет генерировать все привязки, которые удовлетворяют запросу в "
"соответствии с\n"
"текущим состоянием базы данных."

#: texi/node-19.texi:445
msgid ""
"In effect, this program is one big macro. Figure 19-7 shows the macroexpan-\n"
"sion of a with-answer. Most of the work is done by pat-match (page 242),\n"
"which is itself a macro. Now the only new functions needed at runtime are "
"the\n"
"basic database functions shown in Figure 19-1."
msgstr ""
"По сути, эта программа является одним большим макросом. На рисунке 19-7 "
"показано\n"
"расширение макроса with-answer. Большая часть работы выполняется с помощью "
"pat-match \n"
"(стр. 242), который сам является макросом. Теперь единственными новыми "
"функциями,\n"
"необходимыми во время выполнения, являются функции базы данных, показанные "
"на\n"
"Рисунке 19-1."

#: texi/node-19.texi:452
msgid ""
"When with-answer is called from the toplevel, query compilation has little\n"
"advantage. The code representing the query is generated, evaluated, then "
"thrown\n"
"away. But when a with-answer expression appears within a Lisp program, the\n"
"code representing the query becomes part of its macroexpansion. So when the\n"
"containing program is compiled, the code for all the queries will be "
"compiled\n"
"inline in the process."
msgstr ""
"Когда with-answer вызвается на верхнем уровне, компиляция запросов имеет "
"мало\n"
"преимуществ. Код, представляющий запрос, генерируется, выполняется, а затем\n"
"отбрасывается. Но когда в программе на Lisp появляется выражение with-"
"answer,\n"
"код, представляющий запрос, становиться частью расширения этого макроса. "
"Поэтому,\n"
"когда содержащая его программа компилируется, код для всех запросов будет\n"
"скомпилирован и встроен в процесс."

#: texi/node-19.texi:457
msgid ""
"Although the primary advantage of the new approach is speed, it also makes\n"
"with-answer expressions better integrated with the code in which they "
"appear.\n"
"This shows in two specific improvements. First, the arguments within the "
"query\n"
"now get evaluated, so we can say:"
msgstr ""
"Хотя основным преимуществом нового подхода является скорость, он также "
"позволяет\n"
"лучше интегрировать выражения with-answer в код, в котором они появляются.\n"
"Здесь показаны два конкретных улучшения. Во-первых, теперь вычисляются "
"аргументы\n"
"в запросе, поэтому мы можем сказать:"

#: texi/node-19.texi:467
msgid ""
"@example\n"
"   > (setq my-favorite-year 1723)\n"
"   1723\n"
"   > (with-answer (dates ?x my-favorite-year ?d)\n"
"           (format t \"~A was born in my favorite year.~%\" ?x))\n"
"   REYNOLDS was born in my favorite year.\n"
"   NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:472
msgid ""
"@lisp\n"
" (defmacro with-answer (query &body body)\n"
"   `(with-gensyms ,(vars-in query #'simple?)\n"
"         ,(compile-query query `(progn ,@@body))))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (defmacro with-answer (query &body body)\n"
"   `(with-gensyms ,(vars-in query #'simple?)\n"
"         ,(compile-query query `(progn ,@@body))))"

#: texi/node-19.texi:480
msgid ""
" (defun compile-query (q body)\n"
"   (case (car q)\n"
"        (and (compile-and (cdr q) body))\n"
"        (or     (compile-or (cdr q) body))\n"
"        (not (compile-not (cadr q) body))\n"
"        (lisp `(if ,(cadr q) ,body))\n"
"        (t      (compile-simple q body))))"
msgstr ""

#: texi/node-19.texi:485
msgid ""
" (defun compile-simple (q body)\n"
"   (let ((fact (gensym)))\n"
"        `(dolist (,fact (db-query ',(car q)))\n"
"              (pat-match ,(cdr q) ,fact ,body nil))))"
msgstr ""

#: texi/node-19.texi:491
msgid ""
" (defun compile-and (clauses body)\n"
"   (if (null clauses)\n"
"         body\n"
"         (compile-query (car clauses)\n"
"                              (compile-and (cdr clauses) body))))"
msgstr ""

#: texi/node-19.texi:501
msgid ""
" (defun compile-or (clauses body)\n"
"   (if (null clauses)\n"
"         nil\n"
"         (let ((gbod (gensym))\n"
"                  (vars (vars-in body #'simple?)))\n"
"               `(labels ((,gbod ,vars ,body))\n"
"                 ,@@(mapcar #'(lambda (cl)\n"
"                                   (compile-query cl `(,gbod ,@@vars)))\n"
"                              clauses)))))"
msgstr ""

#: texi/node-19.texi:509
msgid ""
" (defun compile-not (q body)\n"
"   (let ((tag (gensym)))\n"
"        `(if (block ,tag\n"
"                 ,(compile-query q `(return-from ,tag nil))\n"
"                 t)\n"
"               ,body)))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:511
msgid "                           Figure 19-6: Query compiler."
msgstr ""
"                           Рисунок 19-6: Компилятор Запросов.\n"
"@end cartouche"

#: texi/node-19.texi:519
msgid ""
"@lisp\n"
" (with-answer (painter ?x ?y ?z)\n"
"       (format t \"~A ~A is a painter.~%\" ?y ?x))"
msgstr ""
"@cartouche\n"
"@lisp\n"
" (with-answer (painter ?x ?y ?z)\n"
"       (format t \"~A ~A is a painter.~%\" ?y ?x))"

#: texi/node-19.texi:521
msgid " is expanded by the query interpreter into:"
msgstr " расширеяется интерпретатором запросов в:"

#: texi/node-19.texi:527
msgid ""
" (dolist (#:g1 (interpret-query '(painter ?x ?y ?z)))\n"
"       (let ((?x (binding '?x #:g1))\n"
"               (?y (binding '?y #:g1))\n"
"               (?z (binding '?z #:g1)))\n"
"         (format t \"~A ~A is a painter.~%\" ?y ?x)))"
msgstr ""

#: texi/node-19.texi:529
msgid " and by the query compiler into:"
msgstr " и компилятором запросов в:"

#: texi/node-19.texi:537
msgid ""
" (with-gensyms (?x ?y ?z)\n"
"       (dolist (#:g1 (db-query 'painter))\n"
"         (pat-match (?x ?y ?z) #:g1\n"
"                (progn\n"
"                   (format t \"~A ~A is a painter.~%\" ?y ?x))\n"
"                nil)))\n"
"@end lisp"
msgstr ""

#: texi/node-19.texi:539
msgid "                   Figure 19-7: Two expansions of the same query."
msgstr ""
"                   Рисунок 19-7: Два расширения одного и того же запроса.\n"
"@end cartouche"

#: texi/node-19.texi:544
msgid ""
"This could have been done in the query interpreter, but only at the cost of "
"calling\n"
"eval explicitly. And even then, it wouldn't have been possible to refer to "
"lexical\n"
"variables in the query arguments."
msgstr ""
"Это можно было бы сделать и в интерпретаторе запросов, но только за счет "
"явного\n"
"вызова eval. И даже тогда не было бы возможности ссылаться на лексические \n"
"переменные в аргументах запроса."

#: texi/node-19.texi:547
msgid ""
"Since arguments within queries are now evaluated, any literal argument (e."
"g.\n"
"english) that doesn't evaluate to itself should now be quoted. (See Figure "
"19-8.)"
msgstr ""
"Посокльку аргументы в запросах теперь вычисляются, любой буквенный "
"аргумент \n"
"(например english), который не вычисляет сам себя, теперь должен "
"заключаться\n"
"в кавычки. (См. Рисунок 19-8.)"

#: texi/node-19.texi:554
msgid ""
"The second advantage of the new approach is that it is now much easier to\n"
"include normal Lisp expressions within queries. The query compiler adds a "
"lisp\n"
"operator, which may be followed by any Lisp expression. Like the not "
"operator,\n"
"it cannot generate bindings by itself, but it will screen out bindings for "
"which\n"
"the expression returns nil. The lisp operator is useful for getting at built-"
"in\n"
"predicates like >:"
msgstr ""
"Второе преимущество нового подхода состоит в том, что теперь гораздо проще \n"
"включать нормальные выражения Lisp в запросы. Компилятор запросов добавляет\n"
"оператор lisp, за которым может следовать любое выражение Lisp. Как и "
"оператор\n"
"not, он не может генерировать привязки сам по себе, но отсеивает привязки, "
"для\n"
"которых выражение возвращает nil. Оператор lisp полезен для получения "
"встроенных\n"
"предикатов, таких как >:"

#: texi/node-19.texi:564
msgid ""
"@example\n"
"> (with-answer (and (dates ?x ?b ?d)\n"
"                             (lisp (> (- ?d ?b) 70)))\n"
"        (format t \"~A lived over 70 years.~%\" ?x))\n"
"CANALE lived over 70 years.\n"
"HOGARTH lived over 70 years.\n"
"NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:566
msgid ""
"A well-implemented embedded language can have a seamless interface with the"
msgstr ""
"Хорошо реализованный встроенный язык может иметь цельный интерфейс с "
"базовым\n"
"языком с обеих сторон."

#: texi/node-19.texi:571
msgctxt "texi/node-19.texi:571"
msgid "The first name and nationality of every painter called Hogarth."
msgstr ""
"@cartouche\n"
"The first name and nationality of every painter called Hogarth."

#: texi/node-19.texi:578
msgid ""
"@example\n"
" > (with-answer (painter 'hogarth ?x ?y)\n"
"        (princ (list ?x ?y)))\n"
" (WILLIAM ENGLISH)\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:581
msgid ""
"The last name of every English painter not born in the same year as a "
"Venetian\n"
"painter."
msgstr ""

#: texi/node-19.texi:591
msgid ""
"@example\n"
" > (with-answer (and (painter ?x _ 'english)\n"
"                           (dates ?x ?b _)\n"
"                           (not (and (painter ?x2 _ 'venetian)\n"
"                                         (dates ?x2 ?b _))))\n"
"        (princ ?x))\n"
" REYNOLDS\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:594
msgid ""
"The last name and year of death of every painter who died between 1770 and\n"
"1800 exclusive."
msgstr ""

#: texi/node-19.texi:604
msgid ""
"@example\n"
" > (with-answer (and (painter ?x _ _)\n"
"                           (dates ?x _ ?d)\n"
"                           (lisp (< 1770 ?d 1800)))\n"
"        (princ (list ?x ?d)))\n"
" (REYNOLDS 1792)(HOGARTH 1772)\n"
" NIL\n"
"@end example"
msgstr ""

#: texi/node-19.texi:606
msgid "                    Figure 19-8: The query compiler in use."
msgstr ""
"                    Рисунок 19-8: Использование компилятора запросов.\n"
"@end cartouche"

#: texi/node-19.texi:610
msgid ""
"@noindent\n"
"base language on both sides."
msgstr "@noindent\n"

#: texi/node-19.texi:615
msgid ""
"Aside from these two additions-the evaluation of arguments and the new\n"
"lisp operator-the query language supported by the query compiler is "
"identical\n"
"to that supported by the interpreter. Figure 19-8 shows examples of the "
"results\n"
"generated by the query compiler with the database as defined in Figure 19-4."
msgstr ""
"Помимо этих двух дополнений - вычисления аргументов и нового оператора lisp "
"-\n"
"язык запросов, поддерживаемый компилятором запросов, идентичен языку, \n"
"поддерживаемому интерпретатором. На рисунке 19-8 показаны примеры "
"результатов,\n"
"полученных кодом сгенерированным компилятором запросов с базой данных "
"определенной \n"
"на рисунке 19-4."

#: texi/node-19.texi:622
msgid ""
"Section 17-2 gave two reasons why it is better to compile an expression\n"
"than feed it, as a list, to eval. The former is faster, and allows the "
"expression\n"
"to be evaluated in the surrounding lexical context. The advantages of query\n"
"compilation are exactly analogous. Work that used to be done at runtime is "
"now\n"
"done at compile-time. And because the queries are compiled as a piece with "
"the\n"
"surrounding Lisp code, they can take advantage of the lexical context."
msgstr ""
"В разделе 17-2 приведены две причины, по которым лучше скомпилировать "
"выражение,\n"
"чем передаавать его в виде списка, для выполнения. Первая из них, быстрота "
"и \n"
"возможность вычислять выражение в окружающем лексическом контексте. "
"Преимущества\n"
"составления запросов в точности аналогичны. Работа, которая раньше "
"выполнялась\n"
"во время выполнения, теперь выполняется во время компиляции. И поскольку "
"запросы\n"
"компилируются как часть окружающего Lisp кода, они могут использовать "
"преимущества\n"
"окружающего лексического контекста."
